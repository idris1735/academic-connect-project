"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@firebase";
exports.ids = ["vendor-chunks/@firebase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@firebase/app/dist/index.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/@firebase/app/dist/index.cjs.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar component = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/index.cjs.js\");\nvar logger$1 = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/index.cjs.js\");\nvar util = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/index.node.cjs.js\");\nvar idb = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass PlatformLoggerServiceImpl {\n    constructor(container) {\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers\n            .map(provider => {\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            }\n            else {\n                return null;\n            }\n        })\n            .filter(logString => logString)\n            .join(' ');\n    }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nconst name$q = \"@firebase/app\";\nconst version$1 = \"0.10.17\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new logger$1.Logger('@firebase/app');\n\nconst name$p = \"@firebase/app-compat\";\n\nconst name$o = \"@firebase/analytics-compat\";\n\nconst name$n = \"@firebase/analytics\";\n\nconst name$m = \"@firebase/app-check-compat\";\n\nconst name$l = \"@firebase/app-check\";\n\nconst name$k = \"@firebase/auth\";\n\nconst name$j = \"@firebase/auth-compat\";\n\nconst name$i = \"@firebase/database\";\n\nconst name$h = \"@firebase/data-connect\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"11.1.0\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default app name\n *\n * @internal\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n    [name$q]: 'fire-core',\n    [name$p]: 'fire-core-compat',\n    [name$n]: 'fire-analytics',\n    [name$o]: 'fire-analytics-compat',\n    [name$l]: 'fire-app-check',\n    [name$m]: 'fire-app-check-compat',\n    [name$k]: 'fire-auth',\n    [name$j]: 'fire-auth-compat',\n    [name$i]: 'fire-rtdb',\n    [name$h]: 'fire-data-connect',\n    [name$g]: 'fire-rtdb-compat',\n    [name$f]: 'fire-fn',\n    [name$e]: 'fire-fn-compat',\n    [name$d]: 'fire-iid',\n    [name$c]: 'fire-iid-compat',\n    [name$b]: 'fire-fcm',\n    [name$a]: 'fire-fcm-compat',\n    [name$9]: 'fire-perf',\n    [name$8]: 'fire-perf-compat',\n    [name$7]: 'fire-rc',\n    [name$6]: 'fire-rc-compat',\n    [name$5]: 'fire-gcs',\n    [name$4]: 'fire-gcs-compat',\n    [name$3]: 'fire-fst',\n    [name$1]: 'fire-fst-compat',\n    [name$2]: 'fire-vertex',\n    'fire-js': 'fire-js', // Platform identifier for JS SDK.\n    [name]: 'fire-js-all'\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nconst _apps = new Map();\n/**\n * @internal\n */\nconst _serverApps = new Map();\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nfunction _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    }\n    catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\n *\n * @internal\n */\nfunction _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nfunction _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()) {\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()) {\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getProvider(app, name) {\n    const heartbeatController = app.container\n        .getProvider('heartbeat')\n        .getImmediate({ optional: true });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\n *\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\n *\n * @returns true if the provide object is of type FirebaseApp.\n *\n * @internal\n */\nfunction _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\n *\n * @param obj - an object of type FirebaseApp.\n *\n * @returns true if the provided object is of type FirebaseServerAppImpl.\n *\n * @internal\n */\nfunction _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\n * Test only\n *\n * @internal\n */\nfunction _clearComponents() {\n    _components.clear();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\n        'call initializeApp() first',\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\n        'Firebase App instance.',\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\n};\nconst ERROR_FACTORY = new util.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseAppImpl {\n    constructor(options, config, container) {\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled =\n            config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new component.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container) {\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\n            ? serverConfig.automaticDataCollectionEnabled\n            : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        }\n        else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== 'undefined') {\n            this._finalizationRegistry = new FinalizationRegistry(() => {\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$q, version$1, 'serverapp');\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The current SDK version.\n *\n * @public\n */\nconst SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== 'object') {\n        const name = rawConfig;\n        rawConfig = { name };\n    }\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\n    const name = config.name;\n    if (typeof name !== 'string' || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n            appName: String(name)\n        });\n    }\n    options || (options = util.getDefaultAppConfig());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if (util.deepEqual(options, existingApp.options) &&\n            util.deepEqual(config, existingApp.config)) {\n            return existingApp;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\n        }\n    }\n    const container = new component.ComponentContainer(name);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if (util.isBrowser() && !util.isWebWorker()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    }\n    else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s) => {\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === 'undefined') {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\n        }\n    }\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new component.ComponentContainer(nameString);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && util.getDefaultAppConfig()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\n    }\n    return app;\n}\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nfunction getApps() {\n    return Array.from(_apps.values());\n}\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nasync function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    }\n    else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container\n            .getProviders()\n            .map(provider => provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nfunction registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push('and');\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(' '));\n        return;\n    }\n    _registerComponent(new component.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nfunction onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== 'function') {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n    }\n    logger$1.setUserLogHandler(logCallback, options);\n}\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nfunction setLogLevel(logLevel) {\n    logger$1.setLogLevel(logLevel);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = idb.openDB(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        }\n                        catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch(e => {\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    }\n    catch (e) {\n        if (e instanceof util.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, 'readwrite');\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    }\n    catch (e) {\n        if (e instanceof util.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container) {\n        this.container = container;\n        /**\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n         * the header string.\n         * Stores one record per date. This will be consolidated into the standard\n         * format of one record per user agent string before being sent as a header.\n         * Populated from indexedDB when the controller is instantiated and should\n         * be kept in sync with indexedDB.\n         * Leave public for easier testing.\n         */\n        this._heartbeatsCache = null;\n        const app = this.container.getProvider('app').getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\n     * Called to report a heartbeat. The function will generate\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n     * to IndexedDB.\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\n     * already logged, subsequent calls to this function in the same day will be ignored.\n     */\n    async triggerHeartbeat() {\n        var _a, _b;\n        try {\n            const platformLogger = this.container\n                .getProvider('platform-logger')\n                .getImmediate();\n            // This is the \"Firebase user agent\" string from the platform logger\n            // service, not the browser user agent.\n            const agent = platformLogger.getPlatformInfoString();\n            const date = getUTCDateString();\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\n                // If we failed to construct a heartbeats cache, then return immediately.\n                if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                    return;\n                }\n            }\n            // Do not store a heartbeat if one is already stored for this day\n            // or if a header has already been sent today.\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\n                return;\n            }\n            else {\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({ date, agent });\n            }\n            // Remove entries older than 30 days.\n            this._heartbeatsCache.heartbeats =\n                this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\n                    const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n                    const now = Date.now();\n                    return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n                });\n            return this._storage.overwrite(this._heartbeatsCache);\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    /**\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n     * It also clears all heartbeats from memory as well as in IndexedDB.\n     *\n     * NOTE: Consuming product SDKs should not send the header if this method\n     * returns an empty string.\n     */\n    async getHeartbeatsHeader() {\n        var _a;\n        try {\n            if (this._heartbeatsCache === null) {\n                await this._heartbeatsCachePromise;\n            }\n            // If it's still null or the array is empty, there is no data to send.\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\n                this._heartbeatsCache.heartbeats.length === 0) {\n                return '';\n            }\n            const date = getUTCDateString();\n            // Extract as many heartbeats from the cache as will fit under the size limit.\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n            const headerString = util.base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n            // Store last sent date to prevent another being logged/sent for the same day.\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\n            if (unsentEntries.length > 0) {\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                await this._storage.overwrite(this._heartbeatsCache);\n            }\n            else {\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n            }\n            return headerString;\n        }\n        catch (e) {\n            logger.warn(e);\n            return '';\n        }\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache) {\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [singleDateHeartbeat.date]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        }\n        else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app) {\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!util.isIndexedDBAvailable()) {\n            return false;\n        }\n        else {\n            return util.validateIndexedDBOpenable()\n                .then(() => true)\n                .catch(() => false);\n        }\n    }\n    /**\n     * Read all heartbeats.\n     */\n    async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return { heartbeats: [] };\n        }\n        else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            }\n            else {\n                return { heartbeats: [] };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nfunction countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return util.base64urlEncodeWithoutPadding(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerCoreComponents(variant) {\n    _registerComponent(new component.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    _registerComponent(new component.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    // Register `app` package.\n    registerVersion(name$q, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    registerVersion(name$q, version$1, 'cjs2017');\n    // Register platform SDK identifier (no version).\n    registerVersion('fire-js', '');\n}\n\n/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\nregisterCoreComponents('node');\n\nObject.defineProperty(exports, \"FirebaseError\", ({\n  enumerable: true,\n  get: function () { return util.FirebaseError; }\n}));\nexports.SDK_VERSION = SDK_VERSION;\nexports._DEFAULT_ENTRY_NAME = DEFAULT_ENTRY_NAME;\nexports._addComponent = _addComponent;\nexports._addOrOverwriteComponent = _addOrOverwriteComponent;\nexports._apps = _apps;\nexports._clearComponents = _clearComponents;\nexports._components = _components;\nexports._getProvider = _getProvider;\nexports._isFirebaseApp = _isFirebaseApp;\nexports._isFirebaseServerApp = _isFirebaseServerApp;\nexports._registerComponent = _registerComponent;\nexports._removeServiceInstance = _removeServiceInstance;\nexports._serverApps = _serverApps;\nexports.deleteApp = deleteApp;\nexports.getApp = getApp;\nexports.getApps = getApps;\nexports.initializeApp = initializeApp;\nexports.initializeServerApp = initializeServerApp;\nexports.onLog = onLog;\nexports.registerVersion = registerVersion;\nexports.setLogLevel = setLogLevel;\n//# sourceMappingURL=index.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELGdCQUFnQixtQkFBTyxDQUFDLHVGQUFxQjtBQUM3QyxlQUFlLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLG9EQUFLOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLHNDQUFzQyxTQUFTO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQSx1RUFBdUUsU0FBUztBQUNoRiwwRUFBMEUsU0FBUztBQUNuRixzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBLGlHQUFpRyxzQkFBc0I7QUFDdkgsb0dBQW9HLHNCQUFzQjtBQUMxSCxvR0FBb0csc0JBQXNCO0FBQzFILDJHQUEyRyxzQkFBc0I7QUFDakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixlQUFlO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsa0JBQWtCLFFBQVE7QUFDN0U7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRLG9CQUFvQixrQkFBa0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTLEdBQUcsa0JBQWtCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxhQUFhO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3RELHFGQUFxRiwwQ0FBMEM7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBZ0Q7QUFDaEQ7QUFDQSxxQkFBcUI7QUFDckIsQ0FBQyxFQUFDO0FBQ0YsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsZ0NBQWdDO0FBQ2hDLGFBQWE7QUFDYix3QkFBd0I7QUFDeEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2QsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9ob21lL3JndGVjaDAwOC9hY2FkZW1pYy1jb25uZWN0LXByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvZGlzdC9pbmRleC5janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29tcG9uZW50ID0gcmVxdWlyZSgnQGZpcmViYXNlL2NvbXBvbmVudCcpO1xudmFyIGxvZ2dlciQxID0gcmVxdWlyZSgnQGZpcmViYXNlL2xvZ2dlcicpO1xudmFyIHV0aWwgPSByZXF1aXJlKCdAZmlyZWJhc2UvdXRpbCcpO1xudmFyIGlkYiA9IHJlcXVpcmUoJ2lkYicpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cbiAgICAvLyBhdXRoIHRva2VuIHJlZnJlc2gsIGFuZCBpbnN0YWxsYXRpb25zIHdpbGwgc2VuZCB0aGlzIHN0cmluZy5cbiAgICBnZXRQbGF0Zm9ybUluZm9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggcHJvdmlkZXJzIGFuZCBnZXQgbGlicmFyeS92ZXJzaW9uIHBhaXJzIGZyb20gYW55IHRoYXQgYXJlXG4gICAgICAgIC8vIHZlcnNpb24gY29tcG9uZW50cy5cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c2VydmljZS5saWJyYXJ5fS8ke3NlcnZpY2UudmVyc2lvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKGxvZ1N0cmluZyA9PiBsb2dTdHJpbmcpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBwcm92aWRlciBjaGVjayBpZiB0aGlzIHByb3ZpZGVyIHByb3ZpZGVzIGEgVmVyc2lvblNlcnZpY2VcbiAqXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcbiAqIHByb3ZpZGVzIFZlcnNpb25TZXJ2aWNlLiBUaGUgcHJvdmlkZXIgaXMgbm90IG5lY2Vzc2FyaWx5IGEgJ2FwcC12ZXJzaW9uJ1xuICogcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHByb3ZpZGVyLmdldENvbXBvbmVudCgpO1xuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XG59XG5cbmNvbnN0IG5hbWUkcSA9IFwiQGZpcmViYXNlL2FwcFwiO1xuY29uc3QgdmVyc2lvbiQxID0gXCIwLjEwLjE3XCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBsb2dnZXIgPSBuZXcgbG9nZ2VyJDEuTG9nZ2VyKCdAZmlyZWJhc2UvYXBwJyk7XG5cbmNvbnN0IG5hbWUkcCA9IFwiQGZpcmViYXNlL2FwcC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG4gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3NcIjtcblxuY29uc3QgbmFtZSRtID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGwgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2tcIjtcblxuY29uc3QgbmFtZSRrID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xuXG5jb25zdCBuYW1lJGogPSBcIkBmaXJlYmFzZS9hdXRoLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGkgPSBcIkBmaXJlYmFzZS9kYXRhYmFzZVwiO1xuXG5jb25zdCBuYW1lJGggPSBcIkBmaXJlYmFzZS9kYXRhLWNvbm5lY3RcIjtcblxuY29uc3QgbmFtZSRnID0gXCJAZmlyZWJhc2UvZGF0YWJhc2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZiA9IFwiQGZpcmViYXNlL2Z1bmN0aW9uc1wiO1xuXG5jb25zdCBuYW1lJGUgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZCA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnNcIjtcblxuY29uc3QgbmFtZSRjID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRiID0gXCJAZmlyZWJhc2UvbWVzc2FnaW5nXCI7XG5cbmNvbnN0IG5hbWUkYSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ5ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2VcIjtcblxuY29uc3QgbmFtZSQ4ID0gXCJAZmlyZWJhc2UvcGVyZm9ybWFuY2UtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNyA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWdcIjtcblxuY29uc3QgbmFtZSQ2ID0gXCJAZmlyZWJhc2UvcmVtb3RlLWNvbmZpZy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQ1ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZVwiO1xuXG5jb25zdCBuYW1lJDQgPSBcIkBmaXJlYmFzZS9zdG9yYWdlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDMgPSBcIkBmaXJlYmFzZS9maXJlc3RvcmVcIjtcblxuY29uc3QgbmFtZSQyID0gXCJAZmlyZWJhc2UvdmVydGV4YWlcIjtcblxuY29uc3QgbmFtZSQxID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lID0gXCJmaXJlYmFzZVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMTEuMS4wXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBkZWZhdWx0IGFwcCBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcbiAgICBbbmFtZSRxXTogJ2ZpcmUtY29yZScsXG4gICAgW25hbWUkcF06ICdmaXJlLWNvcmUtY29tcGF0JyxcbiAgICBbbmFtZSRuXTogJ2ZpcmUtYW5hbHl0aWNzJyxcbiAgICBbbmFtZSRvXTogJ2ZpcmUtYW5hbHl0aWNzLWNvbXBhdCcsXG4gICAgW25hbWUkbF06ICdmaXJlLWFwcC1jaGVjaycsXG4gICAgW25hbWUkbV06ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxuICAgIFtuYW1lJGtdOiAnZmlyZS1hdXRoJyxcbiAgICBbbmFtZSRqXTogJ2ZpcmUtYXV0aC1jb21wYXQnLFxuICAgIFtuYW1lJGldOiAnZmlyZS1ydGRiJyxcbiAgICBbbmFtZSRoXTogJ2ZpcmUtZGF0YS1jb25uZWN0JyxcbiAgICBbbmFtZSRnXTogJ2ZpcmUtcnRkYi1jb21wYXQnLFxuICAgIFtuYW1lJGZdOiAnZmlyZS1mbicsXG4gICAgW25hbWUkZV06ICdmaXJlLWZuLWNvbXBhdCcsXG4gICAgW25hbWUkZF06ICdmaXJlLWlpZCcsXG4gICAgW25hbWUkY106ICdmaXJlLWlpZC1jb21wYXQnLFxuICAgIFtuYW1lJGJdOiAnZmlyZS1mY20nLFxuICAgIFtuYW1lJGFdOiAnZmlyZS1mY20tY29tcGF0JyxcbiAgICBbbmFtZSQ5XTogJ2ZpcmUtcGVyZicsXG4gICAgW25hbWUkOF06ICdmaXJlLXBlcmYtY29tcGF0JyxcbiAgICBbbmFtZSQ3XTogJ2ZpcmUtcmMnLFxuICAgIFtuYW1lJDZdOiAnZmlyZS1yYy1jb21wYXQnLFxuICAgIFtuYW1lJDVdOiAnZmlyZS1nY3MnLFxuICAgIFtuYW1lJDRdOiAnZmlyZS1nY3MtY29tcGF0JyxcbiAgICBbbmFtZSQzXTogJ2ZpcmUtZnN0JyxcbiAgICBbbmFtZSQxXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXG4gICAgW25hbWUkMl06ICdmaXJlLXZlcnRleCcsXG4gICAgJ2ZpcmUtanMnOiAnZmlyZS1qcycsIC8vIFBsYXRmb3JtIGlkZW50aWZpZXIgZm9yIEpTIFNESy5cbiAgICBbbmFtZV06ICdmaXJlLWpzLWFsbCdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBfYXBwcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IF9zZXJ2ZXJBcHBzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBSZWdpc3RlcmVkIGNvbXBvbmVudHMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbi8qKlxuICogQHBhcmFtIGNvbXBvbmVudCAtIHRoZSBjb21wb25lbnQgYmVpbmcgYWRkZWQgdG8gdGhpcyBhcHAncyBjb250YWluZXJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xuICAgIHRyeSB7XG4gICAgICAgIGFwcC5jb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ29tcG9uZW50ICR7Y29tcG9uZW50Lm5hbWV9IGZhaWxlZCB0byByZWdpc3RlciB3aXRoIEZpcmViYXNlQXBwICR7YXBwLm5hbWV9YCwgZSk7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xuICAgIGFwcC5jb250YWluZXIuYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IHRvIHJlZ2lzdGVyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjb25zdCBjb21wb25lbnROYW1lID0gY29tcG9uZW50Lm5hbWU7XG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFRoZXJlIHdlcmUgbXVsdGlwbGUgYXR0ZW1wdHMgdG8gcmVnaXN0ZXIgY29tcG9uZW50ICR7Y29tcG9uZW50TmFtZX0uYCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NvbXBvbmVudHMuc2V0KGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudCk7XG4gICAgLy8gYWRkIHRoZSBjb21wb25lbnQgdG8gZXhpc3RpbmcgYXBwIGluc3RhbmNlc1xuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XG4gICAgICAgIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlcnZlckFwcCBvZiBfc2VydmVyQXBwcy52YWx1ZXMoKSkge1xuICAgICAgICBfYWRkQ29tcG9uZW50KHNlcnZlckFwcCwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKlxuICogQHJldHVybnMgdGhlIHByb3ZpZGVyIGZvciB0aGUgc2VydmljZSB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpIHtcbiAgICBjb25zdCBoZWFydGJlYXRDb250cm9sbGVyID0gYXBwLmNvbnRhaW5lclxuICAgICAgICAuZ2V0UHJvdmlkZXIoJ2hlYXJ0YmVhdCcpXG4gICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcbiAgICBpZiAoaGVhcnRiZWF0Q29udHJvbGxlcikge1xuICAgICAgICB2b2lkIGhlYXJ0YmVhdENvbnRyb2xsZXIudHJpZ2dlckhlYXJ0YmVhdCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXBwLmNvbnRhaW5lci5nZXRQcm92aWRlcihuYW1lKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBhcHAgLSBGaXJlYmFzZUFwcCBpbnN0YW5jZVxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSBpbnN0YW5jZUlkZW50aWZpZXIgLSBzZXJ2aWNlIGluc3RhbmNlIGlkZW50aWZpZXIgaW4gY2FzZSB0aGUgc2VydmljZSBzdXBwb3J0cyBtdWx0aXBsZSBpbnN0YW5jZXNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX3JlbW92ZVNlcnZpY2VJbnN0YW5jZShhcHAsIG5hbWUsIGluc3RhbmNlSWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xuICAgIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpLmNsZWFySW5zdGFuY2UoaW5zdGFuY2VJZGVudGlmaWVyKTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBvYmogLSBhbiBvYmplY3Qgb2YgdHlwZSBGaXJlYmFzZUFwcCBvciBGaXJlYmFzZU9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZSBvYmplY3QgaXMgb2YgdHlwZSBGaXJlYmFzZUFwcC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2lzRmlyZWJhc2VBcHAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5vcHRpb25zICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfaXNGaXJlYmFzZVNlcnZlckFwcChvYmopIHtcbiAgICByZXR1cm4gb2JqLnNldHRpbmdzICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFRlc3Qgb25seVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfY2xlYXJDb21wb25lbnRzKCkge1xuICAgIF9jb21wb25lbnRzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBFUlJPUlMgPSB7XG4gICAgW1wibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovXTogXCJObyBGaXJlYmFzZSBBcHAgJ3skYXBwTmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXG4gICAgICAgICdjYWxsIGluaXRpYWxpemVBcHAoKSBmaXJzdCcsXG4gICAgW1wiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovXTogXCJJbGxlZ2FsIEFwcCBuYW1lOiAneyRhcHBOYW1lfSdcIixcbiAgICBbXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBvcHRpb25zIG9yIGNvbmZpZ1wiLFxuICAgIFtcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXG4gICAgW1wic2VydmVyLWFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuU0VSVkVSX0FQUF9ERUxFVEVEICovXTogJ0ZpcmViYXNlIFNlcnZlciBBcHAgaGFzIGJlZW4gZGVsZXRlZCcsXG4gICAgW1wibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi9dOiAnTmVlZCB0byBwcm92aWRlIG9wdGlvbnMsIHdoZW4gbm90IGJlaW5nIGRlcGxveWVkIHRvIGhvc3RpbmcgdmlhIHNvdXJjZS4nLFxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xuICAgICAgICAnRmlyZWJhc2UgQXBwIGluc3RhbmNlLicsXG4gICAgW1wiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqL106ICdGaXJzdCBhcmd1bWVudCB0byBgb25Mb2dgIG11c3QgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLicsXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gcmVhZGluZyBmcm9tIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqL106ICdFcnJvciB0aHJvd24gd2hlbiB3cml0aW5nIHRvIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi9dOiAnRmlyZWJhc2VTZXJ2ZXJBcHAgZGVsZXRlT25EZXJlZiBmaWVsZCBkZWZpbmVkIGJ1dCB0aGUgSlMgcnVudGltZSBkb2VzIG5vdCBzdXBwb3J0IEZpbmFsaXphdGlvblJlZ2lzdHJ5LicsXG4gICAgW1wiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovXTogJ0ZpcmViYXNlU2VydmVyQXBwIGlzIG5vdCBmb3IgdXNlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLidcbn07XG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IHV0aWwuRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRmlyZWJhc2VBcHBJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9XG4gICAgICAgICAgICBjb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENvbXBvbmVudChuZXcgY29tcG9uZW50LkNvbXBvbmVudCgnYXBwJywgKCkgPT4gdGhpcywgXCJQVUJMSUNcIiAvKiBDb21wb25lbnRUeXBlLlBVQkxJQyAqLykpO1xuICAgIH1cbiAgICBnZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQodmFsKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gdmFsO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVsZXRlZDtcbiAgICB9XG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5faXNEZWxldGVkID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdGhlIEFwcCBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQgLVxuICAgICAqIHVzZSBiZWZvcmUgcGVyZm9ybWluZyBBUEkgYWN0aW9ucyBvbiB0aGUgQXBwLlxuICAgICAqL1xuICAgIGNoZWNrRGVzdHJveWVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsIGV4dGVuZHMgRmlyZWJhc2VBcHBJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBzZXJ2ZXJDb25maWcsIG5hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICAvLyBCdWlsZCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBGaXJlYmFzZUFwcEltcGwgYmFzZSBjbGFzcy5cbiAgICAgICAgY29uc3QgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID0gc2VydmVyQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHNlcnZlckNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWRcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgRmlyZWJhc2VBcHBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBGaXJlYmFzZUFwcEltcCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5hcGlLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBwYXJlbnQgRmlyZWJhc2VBcHBJbXAgb2JqZWN0LlxuICAgICAgICAgICAgc3VwZXIob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBwSW1wbCA9IG9wdGlvbnM7XG4gICAgICAgICAgICBzdXBlcihhcHBJbXBsLm9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY29uc3RydWN0IHRoZSBkYXRhIGZvciB0aGUgRmlyZWJhc2VTZXJ2ZXJBcHBJbXBsLlxuICAgICAgICB0aGlzLl9zZXJ2ZXJDb25maWcgPSBPYmplY3QuYXNzaWduKHsgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkIH0sIHNlcnZlckNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9tYXRpY0NsZWFudXAoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5pbmNSZWZDb3VudCh0aGlzLl9zZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYpO1xuICAgICAgICAvLyBEbyBub3QgcmV0YWluIGEgaGFyZCByZWZlcmVuY2UgdG8gdGhlIGRyZWYgb2JqZWN0LCBvdGhlcndpc2UgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgICAgIC8vIHdpbGwgbmV2ZXIgdHJpZ2dlci5cbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICBzZXJ2ZXJDb25maWcucmVsZWFzZU9uRGVyZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgJ3NlcnZlcmFwcCcpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCByZWZDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZkNvdW50O1xuICAgIH1cbiAgICAvLyBJbmNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGlzIHNlcnZlciBhcHAuIElmIGFuIG9iamVjdCBpcyBwcm92aWRlZCwgcmVnaXN0ZXIgaXRcbiAgICAvLyB3aXRoIHRoZSBmaW5hbGl6YXRpb24gcmVnaXN0cnkuXG4gICAgaW5jUmVmQ291bnQob2JqKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZkNvdW50Kys7XG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkucmVnaXN0ZXIob2JqLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBjb3VudC5cbiAgICBkZWNSZWZDb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLS10aGlzLl9yZWZDb3VudDtcbiAgICB9XG4gICAgLy8gSW52b2tlZCBieSB0aGUgRmluYWxpemF0aW9uUmVnaXN0cnkgY2FsbGJhY2sgdG8gbm90ZSB0aGF0IHRoaXMgYXBwIHNob3VsZCBnbyB0aHJvdWdoIGl0c1xuICAgIC8vIHJlZmVyZW5jZSBjb3VudHMgYW5kIGRlbGV0ZSBpdHNlbGYgaWYgbm8gcmVmZXJlbmNlIGNvdW50IHJlbWFpbi4gVGhlIGNvb3JkaW5hdGluZyBsb2dpYyB0aGF0XG4gICAgLy8gaGFuZGxlcyB0aGlzIGlzIGluIGRlbGV0ZUFwcCguLi4pLlxuICAgIGF1dG9tYXRpY0NsZWFudXAoKSB7XG4gICAgICAgIHZvaWQgZGVsZXRlQXBwKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICAgKi9cbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBjdXJyZW50IFNESyB2ZXJzaW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgU0RLX1ZFUlNJT04gPSB2ZXJzaW9uO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcbiAgICBsZXQgb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIGlmICh0eXBlb2YgcmF3Q29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xuICAgICAgICByYXdDb25maWcgPSB7IG5hbWUgfTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xuICAgIGNvbnN0IG5hbWUgPSBjb25maWcubmFtZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8ICFuYW1lKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XG4gICAgICAgICAgICBhcHBOYW1lOiBTdHJpbmcobmFtZSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB1dGlsLmdldERlZmF1bHRBcHBDb25maWcoKSk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tb3B0aW9uc1wiIC8qIEFwcEVycm9yLk5PX09QVElPTlMgKi8pO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9hcHBzLmdldChuYW1lKTtcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cbiAgICAgICAgaWYgKHV0aWwuZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXG4gICAgICAgICAgICB1dGlsLmRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250YWluZXIgPSBuZXcgY29tcG9uZW50LkNvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgIF9hcHBzLnNldChuYW1lLCBuZXdBcHApO1xuICAgIHJldHVybiBuZXdBcHA7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplU2VydmVyQXBwKF9vcHRpb25zLCBfc2VydmVyQXBwQ29uZmlnKSB7XG4gICAgaWYgKHV0aWwuaXNCcm93c2VyKCkgJiYgIXV0aWwuaXNXZWJXb3JrZXIoKSkge1xuICAgICAgICAvLyBGaXJlYmFzZVNlcnZlckFwcCBpc24ndCBkZXNpZ25lZCB0byBiZSBydW4gaW4gYnJvd3NlcnMuXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1zZXJ2ZXItYXBwLWVudmlyb25tZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9TRVJWRVJfQVBQX0VOVklST05NRU5UICovKTtcbiAgICB9XG4gICAgaWYgKF9zZXJ2ZXJBcHBDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGFwcE9wdGlvbnM7XG4gICAgaWYgKF9pc0ZpcmViYXNlQXBwKF9vcHRpb25zKSkge1xuICAgICAgICBhcHBPcHRpb25zID0gX29wdGlvbnMub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICB9XG4gICAgLy8gQnVpbGQgYW4gYXBwIG5hbWUgYmFzZWQgb24gYSBoYXNoIG9mIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgY29uc3QgbmFtZU9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3NlcnZlckFwcENvbmZpZyksIGFwcE9wdGlvbnMpO1xuICAgIC8vIEhvd2V2ZXIsIERvIG5vdCBtYW5nbGUgdGhlIG5hbWUgYmFzZWQgb24gcmVsZWFzZU9uRGVyZWYsIHNpbmNlIGl0IHdpbGwgdmFyeSBiZXR3ZWVuIHRoZVxuICAgIC8vIGNvbnN0cnVjdGlvbiBvZiBGaXJlYmFzZVNlcnZlckFwcCBpbnN0YW5jZXMuIEZvciBleGFtcGxlLCBpZiB0aGUgb2JqZWN0IGlzIHRoZSByZXF1ZXN0IGhlYWRlcnMuXG4gICAgaWYgKG5hbWVPYmoucmVsZWFzZU9uRGVyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgbmFtZU9iai5yZWxlYXNlT25EZXJlZjtcbiAgICB9XG4gICAgY29uc3QgaGFzaENvZGUgPSAocykgPT4ge1xuICAgICAgICByZXR1cm4gWy4uLnNdLnJlZHVjZSgoaGFzaCwgYykgPT4gKE1hdGguaW11bCgzMSwgaGFzaCkgKyBjLmNoYXJDb2RlQXQoMCkpIHwgMCwgMCk7XG4gICAgfTtcbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImZpbmFsaXphdGlvbi1yZWdpc3RyeS1ub3Qtc3VwcG9ydGVkXCIgLyogQXBwRXJyb3IuRklOQUxJWkFUSU9OX1JFR0lTVFJZX05PVF9TVVBQT1JURUQgKi8sIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuYW1lU3RyaW5nID0gJycgKyBoYXNoQ29kZShKU09OLnN0cmluZ2lmeShuYW1lT2JqKSk7XG4gICAgY29uc3QgZXhpc3RpbmdBcHAgPSBfc2VydmVyQXBwcy5nZXQobmFtZVN0cmluZyk7XG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XG4gICAgICAgIGV4aXN0aW5nQXBwLmluY1JlZkNvdW50KF9zZXJ2ZXJBcHBDb25maWcucmVsZWFzZU9uRGVyZWYpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBjb21wb25lbnQuQ29tcG9uZW50Q29udGFpbmVyKG5hbWVTdHJpbmcpO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIF9jb21wb25lbnRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB9XG4gICAgY29uc3QgbmV3QXBwID0gbmV3IEZpcmViYXNlU2VydmVyQXBwSW1wbChhcHBPcHRpb25zLCBfc2VydmVyQXBwQ29uZmlnLCBuYW1lU3RyaW5nLCBjb250YWluZXIpO1xuICAgIF9zZXJ2ZXJBcHBzLnNldChuYW1lU3RyaW5nLCBuZXdBcHApO1xuICAgIHJldHVybiBuZXdBcHA7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBpbnN0YW5jZS5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50cywgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLiBXaGVuIGFuIGFwcCBuYW1lXG4gKiBpcyBwcm92aWRlZCwgdGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBhcHAgYmVpbmcgcmV0cmlldmVkIGhhcyBub3QgeWV0IGJlZW5cbiAqIGluaXRpYWxpemVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgYXBwXG4gKiBjb25zdCBhcHAgPSBnZXRBcHAoKTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBSZXR1cm4gYSBuYW1lZCBhcHBcbiAqIGNvbnN0IG90aGVyQXBwID0gZ2V0QXBwKFwib3RoZXJBcHBcIik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIGFwcCB0byByZXR1cm4uIElmIG5vIG5hbWUgaXNcbiAqICAgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGlzIGBcIltERUZBVUxUXVwiYC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYXBwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIGFwcCBuYW1lLlxuICogICBJZiBubyBhcHAgbmFtZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgYXBwIGlzIHJldHVybmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QXBwKG5hbWUgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICBjb25zdCBhcHAgPSBfYXBwcy5nZXQobmFtZSk7XG4gICAgaWYgKCFhcHAgJiYgbmFtZSA9PT0gREVGQVVMVF9FTlRSWV9OQU1FICYmIHV0aWwuZ2V0RGVmYXVsdEFwcENvbmZpZygpKSB7XG4gICAgICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XG4gICAgfVxuICAgIGlmICghYXBwKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBhcHA7XG59XG4vKipcbiAqIEEgKHJlYWQtb25seSkgYXJyYXkgb2YgYWxsIGluaXRpYWxpemVkIGFwcHMuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEFwcHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXG4gKiBzZXJ2aWNlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogZGVsZXRlQXBwKGFwcClcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJBcHAgZGVsZXRlZCBzdWNjZXNzZnVsbHlcIik7XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICogICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZGVsZXRpbmcgYXBwOlwiLCBlcnJvcik7XG4gKiAgIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVBcHAoYXBwKSB7XG4gICAgbGV0IGNsZWFudXBQcm92aWRlcnMgPSBmYWxzZTtcbiAgICBjb25zdCBuYW1lID0gYXBwLm5hbWU7XG4gICAgaWYgKF9hcHBzLmhhcyhuYW1lKSkge1xuICAgICAgICBjbGVhbnVwUHJvdmlkZXJzID0gdHJ1ZTtcbiAgICAgICAgX2FwcHMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChfc2VydmVyQXBwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgY29uc3QgZmlyZWJhc2VTZXJ2ZXJBcHAgPSBhcHA7XG4gICAgICAgIGlmIChmaXJlYmFzZVNlcnZlckFwcC5kZWNSZWZDb3VudCgpIDw9IDApIHtcbiAgICAgICAgICAgIF9zZXJ2ZXJBcHBzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbGVhbnVwUHJvdmlkZXJzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGFwcC5jb250YWluZXJcbiAgICAgICAgICAgIC5nZXRQcm92aWRlcnMoKVxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSkpO1xuICAgICAgICBhcHAuaXNEZWxldGVkID0gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGxpYnJhcnkncyBuYW1lIGFuZCB2ZXJzaW9uIGZvciBwbGF0Zm9ybSBsb2dnaW5nIHB1cnBvc2VzLlxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gQ3VycmVudCB2ZXJzaW9uIG9mIHRoYXQgbGlicmFyeS5cbiAqIEBwYXJhbSB2YXJpYW50IC0gQnVuZGxlIHZhcmlhbnQsIGUuZy4sIG5vZGUsIHJuLCBldGMuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZWdpc3RlclZlcnNpb24obGlicmFyeUtleU9yTmFtZSwgdmVyc2lvbiwgdmFyaWFudCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBUT0RPOiBXZSBjYW4gdXNlIHRoaXMgY2hlY2sgdG8gd2hpdGVsaXN0IHN0cmluZ3Mgd2hlbi9pZiB3ZSBzZXQgdXBcbiAgICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cbiAgICBsZXQgbGlicmFyeSA9IChfYSA9IFBMQVRGT1JNX0xPR19TVFJJTkdbbGlicmFyeUtleU9yTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxpYnJhcnlLZXlPck5hbWU7XG4gICAgaWYgKHZhcmlhbnQpIHtcbiAgICAgICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xuICAgIH1cbiAgICBjb25zdCBsaWJyYXJ5TWlzbWF0Y2ggPSBsaWJyYXJ5Lm1hdGNoKC9cXHN8XFwvLyk7XG4gICAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xuICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggfHwgdmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICAgIGNvbnN0IHdhcm5pbmcgPSBbXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCkge1xuICAgICAgICAgICAgd2FybmluZy5wdXNoKGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2ggJiYgdmVyc2lvbk1pc21hdGNoKSB7XG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIud2Fybih3YXJuaW5nLmpvaW4oJyAnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBjb21wb25lbnQuQ29tcG9uZW50KGAke2xpYnJhcnl9LXZlcnNpb25gLCAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLCBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi8pKTtcbn1cbi8qKlxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXG4gKiBAcGFyYW0gbG9nQ2FsbGJhY2sgLSBBbiBvcHRpb25hbCBjdXN0b20gbG9nIGhhbmRsZXIgdGhhdCBleGVjdXRlcyB1c2VyIGNvZGUgd2hlbmV2ZXJcbiAqIHRoZSBGaXJlYmFzZSBTREsgbWFrZXMgYSBsb2dnaW5nIGNhbGwuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvbkxvZyhsb2dDYWxsYmFjaywgb3B0aW9ucykge1xuICAgIGlmIChsb2dDYWxsYmFjayAhPT0gbnVsbCAmJiB0eXBlb2YgbG9nQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLWxvZy1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfTE9HX0FSR1VNRU5UICovKTtcbiAgICB9XG4gICAgbG9nZ2VyJDEuc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBTZXRzIGxvZyBsZXZlbCBmb3IgYWxsIEZpcmViYXNlIFNES3MuXG4gKlxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBpbmZvYCwgZXJyb3JzIGFyZSBsb2dnZWQsIGJ1dCBgZGVidWdgIGFuZFxuICogYHZlcmJvc2VgIGxvZ3MgYXJlIG5vdCkuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgIGxvZ2dlciQxLnNldExvZ0xldmVsKGxvZ0xldmVsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LWRhdGFiYXNlJztcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xubGV0IGRiUHJvbWlzZSA9IG51bGw7XG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XG4gICAgaWYgKCFkYlByb21pc2UpIHtcbiAgICAgICAgZGJQcm9taXNlID0gaWRiLm9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpL2lPUyBicm93c2VycyB0aHJvdyBvY2Nhc2lvbmFsIGV4Y2VwdGlvbnMgb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYi5jcmVhdGVPYmplY3RTdG9yZSgpIHRoYXQgbWF5IGJlIGEgYnVnLiBBdm9pZCBibG9ja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBhcHAgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRiUHJvbWlzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQihhcHApIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFNUT1JFX05BTUUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKS5nZXQoY29tcHV0ZUtleShhcHApKTtcbiAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSB2YWx1ZSBidXQgdHguZG9uZSBjYW4gdGhyb3csXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gYXdhaXQgaXQgaGVyZSB0byBjYXRjaCBlcnJvcnNcbiAgICAgICAgYXdhaXQgdHguZG9uZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiB1dGlsLkZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHV0aWwuRmlyZWJhc2VFcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUtleShhcHApIHtcbiAgICByZXR1cm4gYCR7YXBwLm5hbWV9ISR7YXBwLm9wdGlvbnMuYXBwSWR9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IE1BWF9IRUFERVJfQllURVMgPSAxMDI0O1xuLy8gMzAgZGF5c1xuY29uc3QgU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyA9IDMwICogMjQgKiA2MCAqIDYwICogMTAwMDtcbmNsYXNzIEhlYXJ0YmVhdFNlcnZpY2VJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbi1tZW1vcnkgY2FjaGUgZm9yIGhlYXJ0YmVhdHMsIHVzZWQgYnkgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHRvIGdlbmVyYXRlXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxuICAgICAgICAgKiBTdG9yZXMgb25lIHJlY29yZCBwZXIgZGF0ZS4gVGhpcyB3aWxsIGJlIGNvbnNvbGlkYXRlZCBpbnRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAgKiBmb3JtYXQgb2Ygb25lIHJlY29yZCBwZXIgdXNlciBhZ2VudCBzdHJpbmcgYmVmb3JlIGJlaW5nIHNlbnQgYXMgYSBoZWFkZXIuXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXG4gICAgICAgICAqIGJlIGtlcHQgaW4gc3luYyB3aXRoIGluZGV4ZWREQi5cbiAgICAgICAgICogTGVhdmUgcHVibGljIGZvciBlYXNpZXIgdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlID0gdGhpcy5fc3RvcmFnZS5yZWFkKCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byByZXBvcnQgYSBoZWFydGJlYXQuIFRoZSBmdW5jdGlvbiB3aWxsIGdlbmVyYXRlXG4gICAgICogYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgb2JqZWN0LCB1cGRhdGUgaGVhcnRiZWF0c0NhY2hlLCBhbmQgcGVyc2lzdCBpdFxuICAgICAqIHRvIEluZGV4ZWREQi5cbiAgICAgKiBOb3RlIHRoYXQgd2Ugb25seSBzdG9yZSBvbmUgaGVhcnRiZWF0IHBlciBkYXkuIFNvIGlmIGEgaGVhcnRiZWF0IGZvciB0b2RheSBpc1xuICAgICAqIGFscmVhZHkgbG9nZ2VkLCBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24gaW4gdGhlIHNhbWUgZGF5IHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICBhc3luYyB0cmlnZ2VySGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGxhdGZvcm1Mb2dnZXIgPSB0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5nZXRQcm92aWRlcigncGxhdGZvcm0tbG9nZ2VyJylcbiAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBcIkZpcmViYXNlIHVzZXIgYWdlbnRcIiBzdHJpbmcgZnJvbSB0aGUgcGxhdGZvcm0gbG9nZ2VyXG4gICAgICAgICAgICAvLyBzZXJ2aWNlLCBub3QgdGhlIGJyb3dzZXIgdXNlciBhZ2VudC5cbiAgICAgICAgICAgIGNvbnN0IGFnZW50ID0gcGxhdGZvcm1Mb2dnZXIuZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gY29uc3RydWN0IGEgaGVhcnRiZWF0cyBjYWNoZSwgdGhlbiByZXR1cm4gaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWFydGJlYXRzKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3Qgc3RvcmUgYSBoZWFydGJlYXQgaWYgb25lIGlzIGFscmVhZHkgc3RvcmVkIGZvciB0aGlzIGRheVxuICAgICAgICAgICAgLy8gb3IgaWYgYSBoZWFkZXIgaGFzIGFscmVhZHkgYmVlbiBzZW50IHRvZGF5LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5zb21lKHNpbmdsZURhdGVIZWFydGJlYXQgPT4gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlID09PSBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIGRhdGUuIENyZWF0ZSBvbmUuXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGVudHJpZXMgb2xkZXIgdGhhbiAzMCBkYXlzLlxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPVxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLmZpbHRlcihzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGJUaW1lc3RhbXAgPSBuZXcgRGF0ZShzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGUpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdyAtIGhiVGltZXN0YW1wIDw9IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB3aGljaCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIGhlYXJ0YmVhdC1zcGVjaWZpYyBoZWFkZXIgZGlyZWN0bHkuXG4gICAgICogSXQgYWxzbyBjbGVhcnMgYWxsIGhlYXJ0YmVhdHMgZnJvbSBtZW1vcnkgYXMgd2VsbCBhcyBpbiBJbmRleGVkREIuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDb25zdW1pbmcgcHJvZHVjdCBTREtzIHNob3VsZCBub3Qgc2VuZCB0aGUgaGVhZGVyIGlmIHRoaXMgbWV0aG9kXG4gICAgICogcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SGVhcnRiZWF0c0hlYWRlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHN0aWxsIG51bGwgb3IgdGhlIGFycmF5IGlzIGVtcHR5LCB0aGVyZSBpcyBubyBkYXRhIHRvIHNlbmQuXG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYXJ0YmVhdHMpID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBhcyBtYW55IGhlYXJ0YmVhdHMgZnJvbSB0aGUgY2FjaGUgYXMgd2lsbCBmaXQgdW5kZXIgdGhlIHNpemUgbGltaXQuXG4gICAgICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclN0cmluZyA9IHV0aWwuYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzVG9TZW5kIH0pKTtcbiAgICAgICAgICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmxhc3RTZW50SGVhcnRiZWF0RGF0ZSA9IGRhdGU7XG4gICAgICAgICAgICBpZiAodW5zZW50RW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB1bnNlbnRFbnRyaWVzO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VlbXMgbW9yZSBsaWtlbHkgdGhhbiBlbXB0eWluZyB0aGUgYXJyYXkgKGJlbG93KSB0byBsZWFkIHRvIHNvbWUgb2RkIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNhY2hlIGlzbid0IGVtcHR5IGFuZCB0aGlzIHdpbGwgYmUgY2FsbGVkIGFnYWluIG9uIHRoZSBuZXh0IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgLy8gYW5kIGlzIHByb2JhYmx5IHNhZmVzdCBpZiB3ZSBhd2FpdCBpdC5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhlYWRlclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZSk7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRVVENEYXRlU3RyaW5nKCkge1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAvLyBSZXR1cm5zIGRhdGUgZm9ybWF0ICdZWVlZLU1NLUREJ1xuICAgIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XG59XG5mdW5jdGlvbiBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcihoZWFydGJlYXRzQ2FjaGUsIG1heFNpemUgPSBNQVhfSEVBREVSX0JZVEVTKSB7XG4gICAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXG4gICAgLy8gdGhlIGhlYWRlci5cbiAgICBjb25zdCBoZWFydGJlYXRzVG9TZW5kID0gW107XG4gICAgLy8gU2luZ2xlIGRhdGUgZm9ybWF0IGhlYXJ0YmVhdHMgdGhhdCBhcmUgbm90IHNlbnQuXG4gICAgbGV0IHVuc2VudEVudHJpZXMgPSBoZWFydGJlYXRzQ2FjaGUuc2xpY2UoKTtcbiAgICBmb3IgKGNvbnN0IHNpbmdsZURhdGVIZWFydGJlYXQgb2YgaGVhcnRiZWF0c0NhY2hlKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cbiAgICAgICAgY29uc3QgaGVhcnRiZWF0RW50cnkgPSBoZWFydGJlYXRzVG9TZW5kLmZpbmQoaGIgPT4gaGIuYWdlbnQgPT09IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQpO1xuICAgICAgICBpZiAoIWhlYXJ0YmVhdEVudHJ5KSB7XG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cbiAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucHVzaCh7XG4gICAgICAgICAgICAgICAgYWdlbnQ6IHNpbmdsZURhdGVIZWFydGJlYXQuYWdlbnQsXG4gICAgICAgICAgICAgICAgZGF0ZXM6IFtzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGVdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxuICAgICAgICAgICAgICAgIC8vIGVudHJ5IGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wdXNoKHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHdvdWxkIGV4Y2VlZCBtYXggc2l6ZSwgcmVtb3ZlIHRoZSBhZGRlZCBkYXRlXG4gICAgICAgICAgICAvLyBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cbiAgICAgICAgICAgIGlmIChjb3VudEJ5dGVzKGhlYXJ0YmVhdHNUb1NlbmQpID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBvcCB1bnNlbnQgZW50cnkgZnJvbSBxdWV1ZS4gKFNraXBwZWQgaWYgYWRkaW5nIHRoZSBlbnRyeSBleGNlZWRlZFxuICAgICAgICAvLyBxdW90YSBhbmQgdGhlIGxvb3AgYnJlYWtzIGVhcmx5LilcbiAgICAgICAgdW5zZW50RW50cmllcyA9IHVuc2VudEVudHJpZXMuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYXJ0YmVhdHNUb1NlbmQsXG4gICAgICAgIHVuc2VudEVudHJpZXNcbiAgICB9O1xufVxuY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwcCkge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xuICAgIH1cbiAgICBhc3luYyBydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCkge1xuICAgICAgICBpZiAoIXV0aWwuaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWwudmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYWxsIGhlYXJ0YmVhdHMuXG4gICAgICovXG4gICAgYXN5bmMgcmVhZCgpIHtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJIZWFydGJlYXRPYmplY3QgPSBhd2FpdCByZWFkSGVhcnRiZWF0c0Zyb21JbmRleGVkREIodGhpcy5hcHApO1xuICAgICAgICAgICAgaWYgKGlkYkhlYXJ0YmVhdE9iamVjdCA9PT0gbnVsbCB8fCBpZGJIZWFydGJlYXRPYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlkYkhlYXJ0YmVhdE9iamVjdC5oZWFydGJlYXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkYkhlYXJ0YmVhdE9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYXJ0YmVhdHM6IFtdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3ZlcndyaXRlIHRoZSBzdG9yYWdlIHdpdGggdGhlIHByb3ZpZGVkIGhlYXJ0YmVhdHNcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgaGVhcnRiZWF0c1xuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2FuVXNlSW5kZXhlZERCID0gYXdhaXQgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKHRoaXMuYXBwLCB7XG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzLFxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2FsY3VsYXRlIGJ5dGVzIG9mIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IGFycmF5IGFmdGVyIGJlaW5nIHdyYXBwZWRcbiAqIGluIGEgcGxhdGZvcm0gbG9nZ2luZyBoZWFkZXIgSlNPTiBvYmplY3QsIHN0cmluZ2lmaWVkLCBhbmQgY29udmVydGVkXG4gKiB0byBiYXNlIDY0LlxuICovXG5mdW5jdGlvbiBjb3VudEJ5dGVzKGhlYXJ0YmVhdHNDYWNoZSkge1xuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cbiAgICByZXR1cm4gdXRpbC5iYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcbiAgICAvLyBoZWFydGJlYXRzQ2FjaGUgd3JhcHBlciBwcm9wZXJ0aWVzXG4gICAgSlNPTi5zdHJpbmdpZnkoeyB2ZXJzaW9uOiAyLCBoZWFydGJlYXRzOiBoZWFydGJlYXRzQ2FjaGUgfSkpLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29yZUNvbXBvbmVudHModmFyaWFudCkge1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgY29tcG9uZW50LkNvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgY29tcG9uZW50LkNvbXBvbmVudCgnaGVhcnRiZWF0JywgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgdmFyaWFudCk7XG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtMjAxNywgY2pzMjAxNywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdjanMyMDE3Jyk7XG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxuICAgIHJlZ2lzdGVyVmVyc2lvbignZmlyZS1qcycsICcnKTtcbn1cblxuLyoqXG4gKiBGaXJlYmFzZSBBcHBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCdub2RlJyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRmlyZWJhc2VFcnJvcicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsLkZpcmViYXNlRXJyb3I7IH1cbn0pO1xuZXhwb3J0cy5TREtfVkVSU0lPTiA9IFNES19WRVJTSU9OO1xuZXhwb3J0cy5fREVGQVVMVF9FTlRSWV9OQU1FID0gREVGQVVMVF9FTlRSWV9OQU1FO1xuZXhwb3J0cy5fYWRkQ29tcG9uZW50ID0gX2FkZENvbXBvbmVudDtcbmV4cG9ydHMuX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50ID0gX2FkZE9yT3ZlcndyaXRlQ29tcG9uZW50O1xuZXhwb3J0cy5fYXBwcyA9IF9hcHBzO1xuZXhwb3J0cy5fY2xlYXJDb21wb25lbnRzID0gX2NsZWFyQ29tcG9uZW50cztcbmV4cG9ydHMuX2NvbXBvbmVudHMgPSBfY29tcG9uZW50cztcbmV4cG9ydHMuX2dldFByb3ZpZGVyID0gX2dldFByb3ZpZGVyO1xuZXhwb3J0cy5faXNGaXJlYmFzZUFwcCA9IF9pc0ZpcmViYXNlQXBwO1xuZXhwb3J0cy5faXNGaXJlYmFzZVNlcnZlckFwcCA9IF9pc0ZpcmViYXNlU2VydmVyQXBwO1xuZXhwb3J0cy5fcmVnaXN0ZXJDb21wb25lbnQgPSBfcmVnaXN0ZXJDb21wb25lbnQ7XG5leHBvcnRzLl9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UgPSBfcmVtb3ZlU2VydmljZUluc3RhbmNlO1xuZXhwb3J0cy5fc2VydmVyQXBwcyA9IF9zZXJ2ZXJBcHBzO1xuZXhwb3J0cy5kZWxldGVBcHAgPSBkZWxldGVBcHA7XG5leHBvcnRzLmdldEFwcCA9IGdldEFwcDtcbmV4cG9ydHMuZ2V0QXBwcyA9IGdldEFwcHM7XG5leHBvcnRzLmluaXRpYWxpemVBcHAgPSBpbml0aWFsaXplQXBwO1xuZXhwb3J0cy5pbml0aWFsaXplU2VydmVyQXBwID0gaW5pdGlhbGl6ZVNlcnZlckFwcDtcbmV4cG9ydHMub25Mb2cgPSBvbkxvZztcbmV4cG9ydHMucmVnaXN0ZXJWZXJzaW9uID0gcmVnaXN0ZXJWZXJzaW9uO1xuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IHNldExvZ0xldmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/index.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar totp = __webpack_require__(/*! ./totp-7195c207.js */ \"(ssr)/./node_modules/@firebase/auth/dist/node/totp-7195c207.js\");\n__webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/index.cjs.js\");\n__webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/index.node.cjs.js\");\n__webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n__webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/index.cjs.js\");\n__webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/index.cjs.js\");\n\n\n\nexports.ActionCodeOperation = totp.ActionCodeOperation;\nexports.ActionCodeURL = totp.ActionCodeURL;\nexports.AuthCredential = totp.AuthCredential;\nexports.AuthErrorCodes = totp.AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY;\nexports.EmailAuthCredential = totp.EmailAuthCredential;\nexports.EmailAuthProvider = totp.EmailAuthProvider;\nexports.FacebookAuthProvider = totp.FacebookAuthProvider;\nexports.FactorId = totp.FactorId;\nexports.GithubAuthProvider = totp.GithubAuthProvider;\nexports.GoogleAuthProvider = totp.GoogleAuthProvider;\nexports.OAuthCredential = totp.OAuthCredential;\nexports.OAuthProvider = totp.OAuthProvider;\nexports.OperationType = totp.OperationType;\nexports.PhoneAuthCredential = totp.PhoneAuthCredential;\nexports.PhoneAuthProvider = totp.PhoneAuthProvider;\nexports.PhoneMultiFactorGenerator = totp.PhoneMultiFactorGenerator;\nexports.ProviderId = totp.ProviderId;\nexports.RecaptchaVerifier = totp.RecaptchaVerifier;\nexports.SAMLAuthProvider = totp.SAMLAuthProvider;\nexports.SignInMethod = totp.SignInMethod;\nexports.TotpMultiFactorGenerator = totp.TotpMultiFactorGenerator;\nexports.TotpSecret = totp.TotpSecret;\nexports.TwitterAuthProvider = totp.TwitterAuthProvider;\nexports.applyActionCode = totp.applyActionCode;\nexports.beforeAuthStateChanged = totp.beforeAuthStateChanged;\nexports.browserLocalPersistence = totp.browserLocalPersistence;\nexports.browserPopupRedirectResolver = totp.browserPopupRedirectResolver;\nexports.browserSessionPersistence = totp.browserSessionPersistence;\nexports.checkActionCode = totp.checkActionCode;\nexports.confirmPasswordReset = totp.confirmPasswordReset;\nexports.connectAuthEmulator = totp.connectAuthEmulator;\nexports.createUserWithEmailAndPassword = totp.createUserWithEmailAndPassword;\nexports.debugErrorMap = totp.debugErrorMap;\nexports.deleteUser = totp.deleteUser;\nexports.fetchSignInMethodsForEmail = totp.fetchSignInMethodsForEmail;\nexports.getAdditionalUserInfo = totp.getAdditionalUserInfo;\nexports.getAuth = totp.getAuth;\nexports.getIdToken = totp.getIdToken;\nexports.getIdTokenResult = totp.getIdTokenResult;\nexports.getMultiFactorResolver = totp.getMultiFactorResolver;\nexports.getRedirectResult = totp.getRedirectResult;\nexports.inMemoryPersistence = totp.inMemoryPersistence;\nexports.indexedDBLocalPersistence = totp.indexedDBLocalPersistence;\nexports.initializeAuth = totp.initializeAuth;\nexports.initializeRecaptchaConfig = totp.initializeRecaptchaConfig;\nexports.isSignInWithEmailLink = totp.isSignInWithEmailLink;\nexports.linkWithCredential = totp.linkWithCredential;\nexports.linkWithPhoneNumber = totp.linkWithPhoneNumber;\nexports.linkWithPopup = totp.linkWithPopup;\nexports.linkWithRedirect = totp.linkWithRedirect;\nexports.multiFactor = totp.multiFactor;\nexports.onAuthStateChanged = totp.onAuthStateChanged;\nexports.onIdTokenChanged = totp.onIdTokenChanged;\nexports.parseActionCodeURL = totp.parseActionCodeURL;\nexports.prodErrorMap = totp.prodErrorMap;\nexports.reauthenticateWithCredential = totp.reauthenticateWithCredential;\nexports.reauthenticateWithPhoneNumber = totp.reauthenticateWithPhoneNumber;\nexports.reauthenticateWithPopup = totp.reauthenticateWithPopup;\nexports.reauthenticateWithRedirect = totp.reauthenticateWithRedirect;\nexports.reload = totp.reload;\nexports.revokeAccessToken = totp.revokeAccessToken;\nexports.sendEmailVerification = totp.sendEmailVerification;\nexports.sendPasswordResetEmail = totp.sendPasswordResetEmail;\nexports.sendSignInLinkToEmail = totp.sendSignInLinkToEmail;\nexports.setPersistence = totp.setPersistence;\nexports.signInAnonymously = totp.signInAnonymously;\nexports.signInWithCredential = totp.signInWithCredential;\nexports.signInWithCustomToken = totp.signInWithCustomToken;\nexports.signInWithEmailAndPassword = totp.signInWithEmailAndPassword;\nexports.signInWithEmailLink = totp.signInWithEmailLink;\nexports.signInWithPhoneNumber = totp.signInWithPhoneNumber;\nexports.signInWithPopup = totp.signInWithPopup;\nexports.signInWithRedirect = totp.signInWithRedirect;\nexports.signOut = totp.signOut;\nexports.unlink = totp.unlink;\nexports.updateCurrentUser = totp.updateCurrentUser;\nexports.updateEmail = totp.updateEmail;\nexports.updatePassword = totp.updatePassword;\nexports.updatePhoneNumber = totp.updatePhoneNumber;\nexports.updateProfile = totp.updateProfile;\nexports.useDeviceLanguage = totp.useDeviceLanguage;\nexports.validatePassword = totp.validatePassword;\nexports.verifyBeforeUpdateEmail = totp.verifyBeforeUpdateEmail;\nexports.verifyPasswordResetCode = totp.verifyPasswordResetCode;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLDBGQUFvQjtBQUN2QyxtQkFBTyxDQUFDLDJFQUFlO0FBQ3ZCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hCLG1CQUFPLENBQUMsdURBQU87QUFDZixtQkFBTyxDQUFDLHVGQUFxQjtBQUM3QixtQkFBTyxDQUFDLGlGQUFrQjs7OztBQUkxQiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLGdDQUFnQztBQUNoQyxrQkFBa0I7QUFDbEIsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxpQ0FBaUM7QUFDakMsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0Isc0NBQXNDO0FBQ3RDLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsiL2hvbWUvcmd0ZWNoMDA4L2FjYWRlbWljLWNvbm5lY3QtcHJvamVjdC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRvdHAgPSByZXF1aXJlKCcuL3RvdHAtNzE5NWMyMDcuanMnKTtcbnJlcXVpcmUoJ0BmaXJlYmFzZS9hcHAnKTtcbnJlcXVpcmUoJ0BmaXJlYmFzZS91dGlsJyk7XG5yZXF1aXJlKCd0c2xpYicpO1xucmVxdWlyZSgnQGZpcmViYXNlL2NvbXBvbmVudCcpO1xucmVxdWlyZSgnQGZpcmViYXNlL2xvZ2dlcicpO1xuXG5cblxuZXhwb3J0cy5BY3Rpb25Db2RlT3BlcmF0aW9uID0gdG90cC5BY3Rpb25Db2RlT3BlcmF0aW9uO1xuZXhwb3J0cy5BY3Rpb25Db2RlVVJMID0gdG90cC5BY3Rpb25Db2RlVVJMO1xuZXhwb3J0cy5BdXRoQ3JlZGVudGlhbCA9IHRvdHAuQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLkF1dGhFcnJvckNvZGVzID0gdG90cC5BVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFk7XG5leHBvcnRzLkVtYWlsQXV0aENyZWRlbnRpYWwgPSB0b3RwLkVtYWlsQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLkVtYWlsQXV0aFByb3ZpZGVyID0gdG90cC5FbWFpbEF1dGhQcm92aWRlcjtcbmV4cG9ydHMuRmFjZWJvb2tBdXRoUHJvdmlkZXIgPSB0b3RwLkZhY2Vib29rQXV0aFByb3ZpZGVyO1xuZXhwb3J0cy5GYWN0b3JJZCA9IHRvdHAuRmFjdG9ySWQ7XG5leHBvcnRzLkdpdGh1YkF1dGhQcm92aWRlciA9IHRvdHAuR2l0aHViQXV0aFByb3ZpZGVyO1xuZXhwb3J0cy5Hb29nbGVBdXRoUHJvdmlkZXIgPSB0b3RwLkdvb2dsZUF1dGhQcm92aWRlcjtcbmV4cG9ydHMuT0F1dGhDcmVkZW50aWFsID0gdG90cC5PQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLk9BdXRoUHJvdmlkZXIgPSB0b3RwLk9BdXRoUHJvdmlkZXI7XG5leHBvcnRzLk9wZXJhdGlvblR5cGUgPSB0b3RwLk9wZXJhdGlvblR5cGU7XG5leHBvcnRzLlBob25lQXV0aENyZWRlbnRpYWwgPSB0b3RwLlBob25lQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLlBob25lQXV0aFByb3ZpZGVyID0gdG90cC5QaG9uZUF1dGhQcm92aWRlcjtcbmV4cG9ydHMuUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciA9IHRvdHAuUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvcjtcbmV4cG9ydHMuUHJvdmlkZXJJZCA9IHRvdHAuUHJvdmlkZXJJZDtcbmV4cG9ydHMuUmVjYXB0Y2hhVmVyaWZpZXIgPSB0b3RwLlJlY2FwdGNoYVZlcmlmaWVyO1xuZXhwb3J0cy5TQU1MQXV0aFByb3ZpZGVyID0gdG90cC5TQU1MQXV0aFByb3ZpZGVyO1xuZXhwb3J0cy5TaWduSW5NZXRob2QgPSB0b3RwLlNpZ25Jbk1ldGhvZDtcbmV4cG9ydHMuVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yID0gdG90cC5Ub3RwTXVsdGlGYWN0b3JHZW5lcmF0b3I7XG5leHBvcnRzLlRvdHBTZWNyZXQgPSB0b3RwLlRvdHBTZWNyZXQ7XG5leHBvcnRzLlR3aXR0ZXJBdXRoUHJvdmlkZXIgPSB0b3RwLlR3aXR0ZXJBdXRoUHJvdmlkZXI7XG5leHBvcnRzLmFwcGx5QWN0aW9uQ29kZSA9IHRvdHAuYXBwbHlBY3Rpb25Db2RlO1xuZXhwb3J0cy5iZWZvcmVBdXRoU3RhdGVDaGFuZ2VkID0gdG90cC5iZWZvcmVBdXRoU3RhdGVDaGFuZ2VkO1xuZXhwb3J0cy5icm93c2VyTG9jYWxQZXJzaXN0ZW5jZSA9IHRvdHAuYnJvd3NlckxvY2FsUGVyc2lzdGVuY2U7XG5leHBvcnRzLmJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSB0b3RwLmJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXI7XG5leHBvcnRzLmJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgPSB0b3RwLmJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2U7XG5leHBvcnRzLmNoZWNrQWN0aW9uQ29kZSA9IHRvdHAuY2hlY2tBY3Rpb25Db2RlO1xuZXhwb3J0cy5jb25maXJtUGFzc3dvcmRSZXNldCA9IHRvdHAuY29uZmlybVBhc3N3b3JkUmVzZXQ7XG5leHBvcnRzLmNvbm5lY3RBdXRoRW11bGF0b3IgPSB0b3RwLmNvbm5lY3RBdXRoRW11bGF0b3I7XG5leHBvcnRzLmNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCA9IHRvdHAuY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkO1xuZXhwb3J0cy5kZWJ1Z0Vycm9yTWFwID0gdG90cC5kZWJ1Z0Vycm9yTWFwO1xuZXhwb3J0cy5kZWxldGVVc2VyID0gdG90cC5kZWxldGVVc2VyO1xuZXhwb3J0cy5mZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbCA9IHRvdHAuZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWw7XG5leHBvcnRzLmdldEFkZGl0aW9uYWxVc2VySW5mbyA9IHRvdHAuZ2V0QWRkaXRpb25hbFVzZXJJbmZvO1xuZXhwb3J0cy5nZXRBdXRoID0gdG90cC5nZXRBdXRoO1xuZXhwb3J0cy5nZXRJZFRva2VuID0gdG90cC5nZXRJZFRva2VuO1xuZXhwb3J0cy5nZXRJZFRva2VuUmVzdWx0ID0gdG90cC5nZXRJZFRva2VuUmVzdWx0O1xuZXhwb3J0cy5nZXRNdWx0aUZhY3RvclJlc29sdmVyID0gdG90cC5nZXRNdWx0aUZhY3RvclJlc29sdmVyO1xuZXhwb3J0cy5nZXRSZWRpcmVjdFJlc3VsdCA9IHRvdHAuZ2V0UmVkaXJlY3RSZXN1bHQ7XG5leHBvcnRzLmluTWVtb3J5UGVyc2lzdGVuY2UgPSB0b3RwLmluTWVtb3J5UGVyc2lzdGVuY2U7XG5leHBvcnRzLmluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2UgPSB0b3RwLmluZGV4ZWREQkxvY2FsUGVyc2lzdGVuY2U7XG5leHBvcnRzLmluaXRpYWxpemVBdXRoID0gdG90cC5pbml0aWFsaXplQXV0aDtcbmV4cG9ydHMuaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyA9IHRvdHAuaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZztcbmV4cG9ydHMuaXNTaWduSW5XaXRoRW1haWxMaW5rID0gdG90cC5pc1NpZ25JbldpdGhFbWFpbExpbms7XG5leHBvcnRzLmxpbmtXaXRoQ3JlZGVudGlhbCA9IHRvdHAubGlua1dpdGhDcmVkZW50aWFsO1xuZXhwb3J0cy5saW5rV2l0aFBob25lTnVtYmVyID0gdG90cC5saW5rV2l0aFBob25lTnVtYmVyO1xuZXhwb3J0cy5saW5rV2l0aFBvcHVwID0gdG90cC5saW5rV2l0aFBvcHVwO1xuZXhwb3J0cy5saW5rV2l0aFJlZGlyZWN0ID0gdG90cC5saW5rV2l0aFJlZGlyZWN0O1xuZXhwb3J0cy5tdWx0aUZhY3RvciA9IHRvdHAubXVsdGlGYWN0b3I7XG5leHBvcnRzLm9uQXV0aFN0YXRlQ2hhbmdlZCA9IHRvdHAub25BdXRoU3RhdGVDaGFuZ2VkO1xuZXhwb3J0cy5vbklkVG9rZW5DaGFuZ2VkID0gdG90cC5vbklkVG9rZW5DaGFuZ2VkO1xuZXhwb3J0cy5wYXJzZUFjdGlvbkNvZGVVUkwgPSB0b3RwLnBhcnNlQWN0aW9uQ29kZVVSTDtcbmV4cG9ydHMucHJvZEVycm9yTWFwID0gdG90cC5wcm9kRXJyb3JNYXA7XG5leHBvcnRzLnJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWwgPSB0b3RwLnJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWw7XG5leHBvcnRzLnJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyID0gdG90cC5yZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlcjtcbmV4cG9ydHMucmVhdXRoZW50aWNhdGVXaXRoUG9wdXAgPSB0b3RwLnJlYXV0aGVudGljYXRlV2l0aFBvcHVwO1xuZXhwb3J0cy5yZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCA9IHRvdHAucmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3Q7XG5leHBvcnRzLnJlbG9hZCA9IHRvdHAucmVsb2FkO1xuZXhwb3J0cy5yZXZva2VBY2Nlc3NUb2tlbiA9IHRvdHAucmV2b2tlQWNjZXNzVG9rZW47XG5leHBvcnRzLnNlbmRFbWFpbFZlcmlmaWNhdGlvbiA9IHRvdHAuc2VuZEVtYWlsVmVyaWZpY2F0aW9uO1xuZXhwb3J0cy5zZW5kUGFzc3dvcmRSZXNldEVtYWlsID0gdG90cC5zZW5kUGFzc3dvcmRSZXNldEVtYWlsO1xuZXhwb3J0cy5zZW5kU2lnbkluTGlua1RvRW1haWwgPSB0b3RwLnNlbmRTaWduSW5MaW5rVG9FbWFpbDtcbmV4cG9ydHMuc2V0UGVyc2lzdGVuY2UgPSB0b3RwLnNldFBlcnNpc3RlbmNlO1xuZXhwb3J0cy5zaWduSW5Bbm9ueW1vdXNseSA9IHRvdHAuc2lnbkluQW5vbnltb3VzbHk7XG5leHBvcnRzLnNpZ25JbldpdGhDcmVkZW50aWFsID0gdG90cC5zaWduSW5XaXRoQ3JlZGVudGlhbDtcbmV4cG9ydHMuc2lnbkluV2l0aEN1c3RvbVRva2VuID0gdG90cC5zaWduSW5XaXRoQ3VzdG9tVG9rZW47XG5leHBvcnRzLnNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkID0gdG90cC5zaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZDtcbmV4cG9ydHMuc2lnbkluV2l0aEVtYWlsTGluayA9IHRvdHAuc2lnbkluV2l0aEVtYWlsTGluaztcbmV4cG9ydHMuc2lnbkluV2l0aFBob25lTnVtYmVyID0gdG90cC5zaWduSW5XaXRoUGhvbmVOdW1iZXI7XG5leHBvcnRzLnNpZ25JbldpdGhQb3B1cCA9IHRvdHAuc2lnbkluV2l0aFBvcHVwO1xuZXhwb3J0cy5zaWduSW5XaXRoUmVkaXJlY3QgPSB0b3RwLnNpZ25JbldpdGhSZWRpcmVjdDtcbmV4cG9ydHMuc2lnbk91dCA9IHRvdHAuc2lnbk91dDtcbmV4cG9ydHMudW5saW5rID0gdG90cC51bmxpbms7XG5leHBvcnRzLnVwZGF0ZUN1cnJlbnRVc2VyID0gdG90cC51cGRhdGVDdXJyZW50VXNlcjtcbmV4cG9ydHMudXBkYXRlRW1haWwgPSB0b3RwLnVwZGF0ZUVtYWlsO1xuZXhwb3J0cy51cGRhdGVQYXNzd29yZCA9IHRvdHAudXBkYXRlUGFzc3dvcmQ7XG5leHBvcnRzLnVwZGF0ZVBob25lTnVtYmVyID0gdG90cC51cGRhdGVQaG9uZU51bWJlcjtcbmV4cG9ydHMudXBkYXRlUHJvZmlsZSA9IHRvdHAudXBkYXRlUHJvZmlsZTtcbmV4cG9ydHMudXNlRGV2aWNlTGFuZ3VhZ2UgPSB0b3RwLnVzZURldmljZUxhbmd1YWdlO1xuZXhwb3J0cy52YWxpZGF0ZVBhc3N3b3JkID0gdG90cC52YWxpZGF0ZVBhc3N3b3JkO1xuZXhwb3J0cy52ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCA9IHRvdHAudmVyaWZ5QmVmb3JlVXBkYXRlRW1haWw7XG5leHBvcnRzLnZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlID0gdG90cC52ZXJpZnlQYXNzd29yZFJlc2V0Q29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node/totp-7195c207.js":
/*!****************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node/totp-7195c207.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar app = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/index.cjs.js\");\nvar util = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/index.node.cjs.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nvar component = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/index.cjs.js\");\nvar logger = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/index.cjs.js\");\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enum of factors that may be used for multifactor authentication.\n *\n * @public\n */\nconst FactorId = {\n    /** Phone as second factor */\n    PHONE: 'phone',\n    TOTP: 'totp'\n};\n/**\n * Enumeration of supported providers.\n *\n * @public\n */\nconst ProviderId = {\n    /** Facebook provider ID */\n    FACEBOOK: 'facebook.com',\n    /** GitHub provider ID */\n    GITHUB: 'github.com',\n    /** Google provider ID */\n    GOOGLE: 'google.com',\n    /** Password provider */\n    PASSWORD: 'password',\n    /** Phone provider */\n    PHONE: 'phone',\n    /** Twitter provider ID */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported sign-in methods.\n *\n * @public\n */\nconst SignInMethod = {\n    /** Email link sign in method */\n    EMAIL_LINK: 'emailLink',\n    /** Email/password sign in method */\n    EMAIL_PASSWORD: 'password',\n    /** Facebook sign in method */\n    FACEBOOK: 'facebook.com',\n    /** GitHub sign in method */\n    GITHUB: 'github.com',\n    /** Google sign in method */\n    GOOGLE: 'google.com',\n    /** Phone sign in method */\n    PHONE: 'phone',\n    /** Twitter sign in method */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported operation types.\n *\n * @public\n */\nconst OperationType = {\n    /** Operation involving linking an additional provider to an already signed-in user. */\n    LINK: 'link',\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */\n    REAUTHENTICATE: 'reauthenticate',\n    /** Operation involving signing in a user. */\n    SIGN_IN: 'signIn'\n};\n/**\n * An enumeration of the possible email action types.\n *\n * @public\n */\nconst ActionCodeOperation = {\n    /** The email link sign-in action. */\n    EMAIL_SIGNIN: 'EMAIL_SIGNIN',\n    /** The password reset action. */\n    PASSWORD_RESET: 'PASSWORD_RESET',\n    /** The email revocation action. */\n    RECOVER_EMAIL: 'RECOVER_EMAIL',\n    /** The revert second factor addition email action. */\n    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',\n    /** The revert second factor addition email action. */\n    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',\n    /** The email verification action. */\n    VERIFY_EMAIL: 'VERIFY_EMAIL'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _debugErrorMap() {\n    return {\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */]: '',\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: \"This app, identified by the domain where it's hosted, is not \" +\n            'authorized to use Firebase Authentication with the provided API key. ' +\n            'Review your key configuration in the Google API console.',\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +\n            'Android package name or iOS bundle ID) provided is not installed on ' +\n            'this device.',\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +\n            'already used or the domain associated with it does not match the list ' +\n            'of whitelisted domains.',\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +\n            'again.',\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +\n            'again before retrying this request.',\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.',\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +\n            'conditions.',\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +\n            'no longer be configured to use the emulator. Try calling ' +\n            '\"connectAuthEmulator()\" sooner.',\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +\n            ' The reCAPTCHA token response is either invalid or expired.',\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registered for the current project.',\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */]: \"This user's credential isn't valid for this project. This can happen \" +\n            \"if the user's token has been tampered with, or if the user isn't for \" +\n            'the project associated with this API key.',\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +\n            'invalid. Please resend the verification code sms and be sure to use the ' +\n            'verification code provided by the user.',\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +\n            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +\n            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +\n            'cordova-plugin-customurlscheme.',\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */]: 'The supplied auth credential is incorrect, malformed or has expired.',\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +\n            'only supports OAuth providers.',\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +\n            'specified API key.',\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +\n            'project. Edit the list of authorized domains from the Firebase console.',\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +\n            'expired, or has already been used.',\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +\n            'phone number in a format that can be parsed into E.164 format. E.164 ' +\n            'phone numbers are written in the format [+][country code][subscriber ' +\n            'number including area code].',\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +\n            'recipient email address is invalid.',\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */]: \"The Auth instance's tenant ID is invalid.\",\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +\n            'by following the instructions in the Firebase console.',\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +\n            'assertion. A reCAPTCHA response token needs to be provided.',\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +\n            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +\n            'in the ID token payload.',\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +\n            'sign-in credentials. Sign in using a provider associated with this ' +\n            'email address.',\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',\n        [\"null-user\" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +\n            'requires a non-null user object.',\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +\n            'Enable it in the Firebase console, under the sign-in method tab of the ' +\n            'Auth section.',\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +\n            'running on. \"location.protocol\" must be http, https or chrome-extension' +\n            ' and web storage must be enabled.',\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */]: \"The project's quota for this operation has been exceeded.\",\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */]: \"The user's credential is no longer valid. The user must sign in again.\",\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +\n            'Try again later.',\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +\n            'the domain in the Firebase console.',\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +\n            'have been deleted.',\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */]: '',\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +\n            'different options. To avoid this error, call initializeAuth() with the ' +\n            'same options as when it was originally called, or call getAuth() to return the' +\n            ' already initialized instance.',\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.',\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */]: 'The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.',\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: 'The password does not meet the requirements.'\n    };\n}\nfunction _prodErrorMap() {\n    // We will include this one message in the prod error map since by the very\n    // nature of this error, developers will never be able to see the message\n    // using the debugErrorMap (which is installed during auth initialization).\n    return {\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.'\n    };\n}\n/**\n * A verbose error map with detailed descriptions for most error codes.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst debugErrorMap = _debugErrorMap;\n/**\n * A minimal error map with all verbose error messages stripped.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst prodErrorMap = _prodErrorMap;\nconst _DEFAULT_AUTH_ERROR_FACTORY = new util.ErrorFactory('auth', 'Firebase', _prodErrorMap());\n/**\n * A map of potential `Auth` error codes, for easier comparison with errors\n * thrown by the SDK.\n *\n * @remarks\n * Note that you can't tree-shake individual keys\n * in the map, so by using the map you might substantially increase your\n * bundle size.\n *\n * @public\n */\nconst AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\n    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',\n    ARGUMENT_ERROR: 'auth/argument-error',\n    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',\n    APP_NOT_INSTALLED: 'auth/app-not-installed',\n    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',\n    CODE_EXPIRED: 'auth/code-expired',\n    CORDOVA_NOT_READY: 'auth/cordova-not-ready',\n    CORS_UNSUPPORTED: 'auth/cors-unsupported',\n    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',\n    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',\n    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',\n    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',\n    EMAIL_EXISTS: 'auth/email-already-in-use',\n    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',\n    EXPIRED_OOB_CODE: 'auth/expired-action-code',\n    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',\n    INTERNAL_ERROR: 'auth/internal-error',\n    INVALID_API_KEY: 'auth/invalid-api-key',\n    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',\n    INVALID_APP_ID: 'auth/invalid-app-id',\n    INVALID_AUTH: 'auth/invalid-user-token',\n    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',\n    INVALID_CERT_HASH: 'auth/invalid-cert-hash',\n    INVALID_CODE: 'auth/invalid-verification-code',\n    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',\n    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',\n    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',\n    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',\n    INVALID_EMAIL: 'auth/invalid-email',\n    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',\n    INVALID_IDP_RESPONSE: 'auth/invalid-credential',\n    INVALID_LOGIN_CREDENTIALS: 'auth/invalid-credential',\n    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',\n    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',\n    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',\n    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',\n    INVALID_OOB_CODE: 'auth/invalid-action-code',\n    INVALID_ORIGIN: 'auth/unauthorized-domain',\n    INVALID_PASSWORD: 'auth/wrong-password',\n    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',\n    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',\n    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',\n    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',\n    INVALID_SENDER: 'auth/invalid-sender',\n    INVALID_SESSION_INFO: 'auth/invalid-verification-id',\n    INVALID_TENANT_ID: 'auth/invalid-tenant-id',\n    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',\n    MFA_REQUIRED: 'auth/multi-factor-auth-required',\n    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',\n    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',\n    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',\n    MISSING_CODE: 'auth/missing-verification-code',\n    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',\n    MISSING_IFRAME_START: 'auth/missing-iframe-start',\n    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',\n    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',\n    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',\n    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',\n    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',\n    MISSING_SESSION_INFO: 'auth/missing-verification-id',\n    MODULE_DESTROYED: 'auth/app-deleted',\n    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',\n    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',\n    NULL_USER: 'auth/null-user',\n    NO_AUTH_EVENT: 'auth/no-auth-event',\n    NO_SUCH_PROVIDER: 'auth/no-such-provider',\n    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',\n    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',\n    POPUP_BLOCKED: 'auth/popup-blocked',\n    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',\n    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',\n    QUOTA_EXCEEDED: 'auth/quota-exceeded',\n    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',\n    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',\n    REJECTED_CREDENTIAL: 'auth/rejected-credential',\n    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',\n    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',\n    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',\n    TIMEOUT: 'auth/timeout',\n    TOKEN_EXPIRED: 'auth/user-token-expired',\n    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',\n    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',\n    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',\n    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',\n    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',\n    UNVERIFIED_EMAIL: 'auth/unverified-email',\n    USER_CANCELLED: 'auth/user-cancelled',\n    USER_DELETED: 'auth/user-not-found',\n    USER_DISABLED: 'auth/user-disabled',\n    USER_MISMATCH: 'auth/user-mismatch',\n    USER_SIGNED_OUT: 'auth/user-signed-out',\n    WEAK_PASSWORD: 'auth/weak-password',\n    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',\n    ALREADY_INITIALIZED: 'auth/already-initialized',\n    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',\n    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',\n    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',\n    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',\n    MISSING_CLIENT_TYPE: 'auth/missing-client-type',\n    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',\n    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',\n    INVALID_REQ_TYPE: 'auth/invalid-req-type'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new logger.Logger('@firebase/auth');\nfunction _logWarn(msg, ...args) {\n    if (logClient.logLevel <= logger.LogLevel.WARN) {\n        logClient.warn(`Auth (${app.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction _logError(msg, ...args) {\n    if (logClient.logLevel <= logger.LogLevel.ERROR) {\n        logClient.error(`Auth (${app.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _fail(authOrCode, ...rest) {\n    throw createErrorInternal(authOrCode, ...rest);\n}\nfunction _createError(authOrCode, ...rest) {\n    return createErrorInternal(authOrCode, ...rest);\n}\nfunction _errorWithCustomMessage(auth, code, message) {\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });\n    const factory = new util.ErrorFactory('auth', 'Firebase', errorMap);\n    return factory.create(code, {\n        appName: auth.name\n    });\n}\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */, 'Operations that alter the current user are not supported in conjunction with FirebaseServerApp');\n}\nfunction createErrorInternal(authOrCode, ...rest) {\n    if (typeof authOrCode !== 'string') {\n        const code = rest[0];\n        const fullParams = [...rest.slice(1)];\n        if (fullParams[0]) {\n            fullParams[0].appName = authOrCode.name;\n        }\n        return authOrCode._errorFactory.create(code, ...fullParams);\n    }\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\n}\nfunction _assert(assertion, authOrCode, ...rest) {\n    if (!assertion) {\n        throw createErrorInternal(authOrCode, ...rest);\n    }\n}\n/**\n * Unconditionally fails, throwing an internal error with the given message.\n *\n * @param failure type of failure encountered\n * @throws Error\n */\nfunction debugFail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\n    _logError(message);\n    // NOTE: We don't use FirebaseError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * @param assertion\n * @param message\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        debugFail(message);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _getCurrentUrl() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';\n}\nfunction _isHttpOrHttps() {\n    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\n}\nfunction _getCurrentScheme() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine whether the browser is working online\n */\nfunction _isOnline() {\n    if (typeof navigator !== 'undefined' &&\n        navigator &&\n        'onLine' in navigator &&\n        typeof navigator.onLine === 'boolean' &&\n        // Apply only for traditional web apps and Chrome extensions.\n        // This is especially true for Cordova apps which have unreliable\n        // navigator.onLine behavior unless cordova-plugin-network-information is\n        // installed which overwrites the native navigator.onLine value and\n        // defines navigator.connection.\n        (_isHttpOrHttps() || util.isBrowserExtension() || 'connection' in navigator)) {\n        return navigator.onLine;\n    }\n    // If we can't determine the state, assume it is online.\n    return true;\n}\nfunction _getUserLanguage() {\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const navigatorLanguage = navigator;\n    return (\n    // Most reliable, but only supported in Chrome/Firefox.\n    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||\n        // Supported in most browsers, but returns the language of the browser\n        // UI, not the language set in browser settings.\n        navigatorLanguage.language ||\n        // Couldn't determine language.\n        null);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A structure to help pick between a range of long and short delay durations\n * depending on the current environment. In general, the long delay is used for\n * mobile environments whereas short delays are used for desktop environments.\n */\nclass Delay {\n    constructor(shortDelay, longDelay) {\n        this.shortDelay = shortDelay;\n        this.longDelay = longDelay;\n        // Internal error when improperly initialized.\n        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');\n        this.isMobile = util.isMobileCordova() || util.isReactNative();\n    }\n    get() {\n        if (!_isOnline()) {\n            // Pick the shorter timeout.\n            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);\n        }\n        // If running in a mobile environment, return the long delay, otherwise\n        // return the short delay.\n        // This could be improved in the future to dynamically change based on other\n        // variables instead of just reading the current environment.\n        return this.isMobile ? this.longDelay : this.shortDelay;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _emulatorUrl(config, path) {\n    debugAssert(config.emulator, 'Emulator should always be set here');\n    const { url } = config.emulator;\n    if (!path) {\n        return url;\n    }\n    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FetchProvider {\n    static initialize(fetchImpl, headersImpl, responseImpl) {\n        this.fetchImpl = fetchImpl;\n        if (headersImpl) {\n            this.headersImpl = headersImpl;\n        }\n        if (responseImpl) {\n            this.responseImpl = responseImpl;\n        }\n    }\n    static fetch() {\n        if (this.fetchImpl) {\n            return this.fetchImpl;\n        }\n        if (typeof self !== 'undefined' && 'fetch' in self) {\n            return self.fetch;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.fetch) {\n            return globalThis.fetch;\n        }\n        if (typeof fetch !== 'undefined') {\n            return fetch;\n        }\n        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static headers() {\n        if (this.headersImpl) {\n            return this.headersImpl;\n        }\n        if (typeof self !== 'undefined' && 'Headers' in self) {\n            return self.Headers;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Headers) {\n            return globalThis.Headers;\n        }\n        if (typeof Headers !== 'undefined') {\n            return Headers;\n        }\n        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static response() {\n        if (this.responseImpl) {\n            return this.responseImpl;\n        }\n        if (typeof self !== 'undefined' && 'Response' in self) {\n            return self.Response;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Response) {\n            return globalThis.Response;\n        }\n        if (typeof Response !== 'undefined') {\n            return Response;\n        }\n        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Map from errors returned by the server to errors to developer visible errors\n */\nconst SERVER_ERROR_MAP = {\n    // Custom token errors.\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Create Auth URI errors.\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Sign in with email and password errors (some apply to sign up too).\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */,\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\n    // invalid.\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    // Sign up with email and password errors.\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */,\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,\n    // Verify assertion for sign in with credential errors:\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Send Password reset email errors:\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */,\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */,\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Operations that require ID token in request:\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */,\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    // Other errors.\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */,\n    // Phone Auth related errors.\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */,\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */,\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */,\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */,\n    // Other action code errors when additional settings passed.\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n    // This is OK as this error will be caught by client side validation.\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,\n    // getProjectConfig errors when clientId is passed.\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,\n    // User actions (sign-up or deletion) disabled errors.\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,\n    // Multi factor related errors.\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */,\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */,\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */,\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,\n    // Blocking functions related errors.\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Recaptcha related errors.\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */,\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\nfunction _addTidIfNecessary(auth, request) {\n    if (auth.tenantId && !request.tenantId) {\n        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });\n    }\n    return request;\n}\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\n    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {\n        let body = {};\n        let params = {};\n        if (request) {\n            if (method === \"GET\" /* HttpMethod.GET */) {\n                params = request;\n            }\n            else {\n                body = {\n                    body: JSON.stringify(request)\n                };\n            }\n        }\n        const query = util.querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/json';\n        if (auth.languageCode) {\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;\n        }\n        const fetchArgs = Object.assign({ method,\n            headers }, body);\n        /* Security-conscious server-side frameworks tend to have built in mitigations for referrer\n           problems\". See the Cloudflare GitHub issue #487: Error: The 'referrerPolicy' field on\n           'RequestInitializerDict' is not implemented.\"\n           https://github.com/cloudflare/next-on-pages/issues/487 */\n        if (!util.isCloudflareWorker()) {\n            fetchArgs.referrerPolicy = 'no-referrer';\n        }\n        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), fetchArgs);\n    });\n}\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\n    auth._canInitEmulator = false;\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\n    try {\n        const networkTimeout = new NetworkTimeout(auth);\n        const response = await Promise.race([\n            fetchFn(),\n            networkTimeout.promise\n        ]);\n        // If we've reached this point, the fetch succeeded and the networkTimeout\n        // didn't throw; clear the network timeout delay so that Node won't hang\n        networkTimeout.clearNetworkTimeout();\n        const json = await response.json();\n        if ('needConfirmation' in json) {\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, json);\n        }\n        if (response.ok && !('errorMessage' in json)) {\n            return json;\n        }\n        else {\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);\n            }\n            else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */) {\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */, json);\n            }\n            else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */) {\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */, json);\n            }\n            const authError = errorMap[serverErrorCode] ||\n                serverErrorCode\n                    .toLowerCase()\n                    .replace(/[_\\s]+/g, '-');\n            if (serverErrorMessage) {\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\n            }\n            else {\n                _fail(auth, authError);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof util.FirebaseError) {\n            throw e;\n        }\n        // Changing this to a different error code will log user out when there is a network error\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });\n    }\n}\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\n    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);\n    if ('mfaPendingCredential' in serverResponse) {\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */, {\n            _serverResponse: serverResponse\n        });\n    }\n    return serverResponse;\n}\nfunction _getFinalTarget(auth, host, path, query) {\n    const base = `${host}${path}?${query}`;\n    if (!auth.config.emulator) {\n        return `${auth.config.apiScheme}://${base}`;\n    }\n    return _emulatorUrl(auth.config, base);\n}\nfunction _parseEnforcementState(enforcementStateStr) {\n    switch (enforcementStateStr) {\n        case 'ENFORCE':\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */;\n        case 'AUDIT':\n            return \"AUDIT\" /* EnforcementState.AUDIT */;\n        case 'OFF':\n            return \"OFF\" /* EnforcementState.OFF */;\n        default:\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */;\n    }\n}\nclass NetworkTimeout {\n    clearNetworkTimeout() {\n        clearTimeout(this.timer);\n    }\n    constructor(auth) {\n        this.auth = auth;\n        // Node timers and browser timers are fundamentally incompatible, but we\n        // don't care about the value here\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timer = null;\n        this.promise = new Promise((_, reject) => {\n            this.timer = setTimeout(() => {\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));\n            }, DEFAULT_API_TIMEOUT_MS.get());\n        });\n    }\n}\nfunction _makeTaggedError(auth, code, response) {\n    const errorParams = {\n        appName: auth.name\n    };\n    if (response.email) {\n        errorParams.email = response.email;\n    }\n    if (response.phoneNumber) {\n        errorParams.phoneNumber = response.phoneNumber;\n    }\n    const error = _createError(auth, code, errorParams);\n    // We know customData is defined on error because errorParams is defined\n    error.customData._tokenResponse = response;\n    return error;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isEnterprise(grecaptcha) {\n    return (grecaptcha !== undefined &&\n        grecaptcha.enterprise !== undefined);\n}\nclass RecaptchaConfig {\n    constructor(response) {\n        /**\n         * The reCAPTCHA site key.\n         */\n        this.siteKey = '';\n        /**\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\n         */\n        this.recaptchaEnforcementState = [];\n        if (response.recaptchaKey === undefined) {\n            throw new Error('recaptchaKey undefined');\n        }\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\n        this.siteKey = response.recaptchaKey.split('/')[3];\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\n    }\n    /**\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\n     *\n     * @param providerStr - The provider whose enforcement state is to be returned.\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\n     */\n    getProviderEnforcementState(providerStr) {\n        if (!this.recaptchaEnforcementState ||\n            this.recaptchaEnforcementState.length === 0) {\n            return null;\n        }\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState) {\n            if (recaptchaEnforcementState.provider &&\n                recaptchaEnforcementState.provider === providerStr) {\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\n     *\n     * @param providerStr - The provider whose enablement state is to be returned.\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\n     */\n    isProviderEnabled(providerStr) {\n        return (this.getProviderEnforcementState(providerStr) ===\n            \"ENFORCE\" /* EnforcementState.ENFORCE */ ||\n            this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */);\n    }\n    /**\n     * Returns true if reCAPTCHA Enterprise protection is enabled in at least one provider, otherwise\n     * returns false.\n     *\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for at least one provider.\n     */\n    isAnyProviderEnabled() {\n        return (this.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) ||\n            this.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function getRecaptchaConfig(auth, request) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function deleteAccount(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */, request);\n}\nasync function deleteLinkedAccounts(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\nasync function getAccountInfo(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction utcTimestampToDateString(utcTimestamp) {\n    if (!utcTimestamp) {\n        return undefined;\n    }\n    try {\n        // Convert to date object.\n        const date = new Date(Number(utcTimestamp));\n        // Test date is valid.\n        if (!isNaN(date.getTime())) {\n            // Convert to UTC date string.\n            return date.toUTCString();\n        }\n    }\n    catch (e) {\n        // Do nothing. undefined will be returned.\n    }\n    return undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nfunction getIdToken(user, forceRefresh = false) {\n    return util.getModularInstance(user).getIdToken(forceRefresh);\n}\n/**\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nasync function getIdTokenResult(user, forceRefresh = false) {\n    const userInternal = util.getModularInstance(user);\n    const token = await userInternal.getIdToken(forceRefresh);\n    const claims = _parseToken(token);\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];\n    return {\n        claims,\n        token,\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\n        signInProvider: signInProvider || null,\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null\n    };\n}\nfunction secondsStringToMilliseconds(seconds) {\n    return Number(seconds) * 1000;\n}\nfunction _parseToken(token) {\n    const [algorithm, payload, signature] = token.split('.');\n    if (algorithm === undefined ||\n        payload === undefined ||\n        signature === undefined) {\n        _logError('JWT malformed, contained fewer than 3 sections');\n        return null;\n    }\n    try {\n        const decoded = util.base64Decode(payload);\n        if (!decoded) {\n            _logError('Failed to decode base64 JWT payload');\n            return null;\n        }\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());\n        return null;\n    }\n}\n/**\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\n */\nfunction _tokenExpiresIn(token) {\n    const parsedToken = _parseToken(token);\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.exp !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.iat !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\n    if (bypassAuthState) {\n        return promise;\n    }\n    try {\n        return await promise;\n    }\n    catch (e) {\n        if (e instanceof util.FirebaseError && isUserInvalidated(e)) {\n            if (user.auth.currentUser === user) {\n                await user.auth.signOut();\n            }\n        }\n        throw e;\n    }\n}\nfunction isUserInvalidated({ code }) {\n    return (code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */}` ||\n        code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */}`);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ProactiveRefresh {\n    constructor(user) {\n        this.user = user;\n        this.isRunning = false;\n        // Node timers and browser timers return fundamentally different types.\n        // We don't actually care what the value is but TS won't accept unknown and\n        // we can't cast properly in both environments.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timerId = null;\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n    }\n    _start() {\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.schedule();\n    }\n    _stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        this.isRunning = false;\n        if (this.timerId !== null) {\n            clearTimeout(this.timerId);\n        }\n    }\n    getInterval(wasError) {\n        var _a;\n        if (wasError) {\n            const interval = this.errorBackoff;\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);\n            return interval;\n        }\n        else {\n            // Reset the error backoff\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;\n            return Math.max(0, interval);\n        }\n    }\n    schedule(wasError = false) {\n        if (!this.isRunning) {\n            // Just in case...\n            return;\n        }\n        const interval = this.getInterval(wasError);\n        this.timerId = setTimeout(async () => {\n            await this.iteration();\n        }, interval);\n    }\n    async iteration() {\n        try {\n            await this.user.getIdToken(true);\n        }\n        catch (e) {\n            // Only retry on network errors\n            if ((e === null || e === void 0 ? void 0 : e.code) ===\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                this.schedule(/* wasError */ true);\n            }\n            return;\n        }\n        this.schedule();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserMetadata {\n    constructor(createdAt, lastLoginAt) {\n        this.createdAt = createdAt;\n        this.lastLoginAt = lastLoginAt;\n        this._initializeTime();\n    }\n    _initializeTime() {\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\n        this.creationTime = utcTimestampToDateString(this.createdAt);\n    }\n    _copy(metadata) {\n        this.createdAt = metadata.createdAt;\n        this.lastLoginAt = metadata.lastLoginAt;\n        this._initializeTime();\n    }\n    toJSON() {\n        return {\n            createdAt: this.createdAt,\n            lastLoginAt: this.lastLoginAt\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reloadWithoutSaving(user) {\n    var _a;\n    const auth = user.auth;\n    const idToken = await user.getIdToken();\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const coreAccount = response.users[0];\n    user._notifyReloadListener(coreAccount);\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)\n        ? extractProviderData(coreAccount.providerUserInfo)\n        : [];\n    const providerData = mergeProviderData(user.providerData, newProviderData);\n    // Preserves the non-nonymous status of the stored user, even if no more\n    // credentials (federated or email/password) are linked to the user. If\n    // the user was previously anonymous, then use provider data to update.\n    // On the other hand, if it was not anonymous before, it should never be\n    // considered anonymous now.\n    const oldIsAnonymous = user.isAnonymous;\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\n    const updates = {\n        uid: coreAccount.localId,\n        displayName: coreAccount.displayName || null,\n        photoURL: coreAccount.photoUrl || null,\n        email: coreAccount.email || null,\n        emailVerified: coreAccount.emailVerified || false,\n        phoneNumber: coreAccount.phoneNumber || null,\n        tenantId: coreAccount.tenantId || null,\n        providerData,\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n        isAnonymous\n    };\n    Object.assign(user, updates);\n}\n/**\n * Reloads user account data, if signed in.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function reload(user) {\n    const userInternal = util.getModularInstance(user);\n    await _reloadWithoutSaving(userInternal);\n    // Even though the current user hasn't changed, update\n    // current user will trigger a persistence update w/ the\n    // new info.\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\n}\nfunction mergeProviderData(original, newData) {\n    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));\n    return [...deduped, ...newData];\n}\nfunction extractProviderData(providers) {\n    return providers.map((_a) => {\n        var { providerId } = _a, provider = tslib.__rest(_a, [\"providerId\"]);\n        return {\n            providerId,\n            uid: provider.rawId || '',\n            displayName: provider.displayName || null,\n            email: provider.email || null,\n            phoneNumber: provider.phoneNumber || null,\n            photoURL: provider.photoUrl || null\n        };\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function requestStsToken(auth, refreshToken) {\n    const response = await _performFetchWithErrorHandling(auth, {}, async () => {\n        const body = util.querystring({\n            'grant_type': 'refresh_token',\n            'refresh_token': refreshToken\n        }).slice(1);\n        const { tokenApiHost, apiKey } = auth.config;\n        const url = _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */, `key=${apiKey}`);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';\n        return FetchProvider.fetch()(url, {\n            method: \"POST\" /* HttpMethod.POST */,\n            headers,\n            body\n        });\n    });\n    // The response comes back in snake_case. Convert to camel:\n    return {\n        accessToken: response.access_token,\n        expiresIn: response.expires_in,\n        refreshToken: response.refresh_token\n    };\n}\nasync function revokeToken(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\n * it references AuthInternal which has a circular dependency with UserInternal.\n *\n * @internal\n */\nclass StsTokenManager {\n    constructor() {\n        this.refreshToken = null;\n        this.accessToken = null;\n        this.expirationTime = null;\n    }\n    get isExpired() {\n        return (!this.expirationTime ||\n            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);\n    }\n    updateFromServerResponse(response) {\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.idToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.refreshToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'\n            ? Number(response.expiresIn)\n            : _tokenExpiresIn(response.idToken);\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\n    }\n    updateFromIdToken(idToken) {\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = _tokenExpiresIn(idToken);\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\n    }\n    async getToken(auth, forceRefresh = false) {\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\n            return this.accessToken;\n        }\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */);\n        if (this.refreshToken) {\n            await this.refresh(auth, this.refreshToken);\n            return this.accessToken;\n        }\n        return null;\n    }\n    clearRefreshToken() {\n        this.refreshToken = null;\n    }\n    async refresh(auth, oldToken) {\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\n    }\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\n        this.refreshToken = refreshToken || null;\n        this.accessToken = accessToken || null;\n        this.expirationTime = Date.now() + expiresInSec * 1000;\n    }\n    static fromJSON(appName, object) {\n        const { refreshToken, accessToken, expirationTime } = object;\n        const manager = new StsTokenManager();\n        if (refreshToken) {\n            _assert(typeof refreshToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.refreshToken = refreshToken;\n        }\n        if (accessToken) {\n            _assert(typeof accessToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.accessToken = accessToken;\n        }\n        if (expirationTime) {\n            _assert(typeof expirationTime === 'number', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.expirationTime = expirationTime;\n        }\n        return manager;\n    }\n    toJSON() {\n        return {\n            refreshToken: this.refreshToken,\n            accessToken: this.accessToken,\n            expirationTime: this.expirationTime\n        };\n    }\n    _assign(stsTokenManager) {\n        this.accessToken = stsTokenManager.accessToken;\n        this.refreshToken = stsTokenManager.refreshToken;\n        this.expirationTime = stsTokenManager.expirationTime;\n    }\n    _clone() {\n        return Object.assign(new StsTokenManager(), this.toJSON());\n    }\n    _performRefresh() {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction assertStringOrUndefined(assertion, appName) {\n    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, { appName });\n}\nclass UserImpl {\n    constructor(_a) {\n        var { uid, auth, stsTokenManager } = _a, opt = tslib.__rest(_a, [\"uid\", \"auth\", \"stsTokenManager\"]);\n        // For the user object, provider is always Firebase.\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */;\n        this.proactiveRefresh = new ProactiveRefresh(this);\n        this.reloadUserInfo = null;\n        this.reloadListener = null;\n        this.uid = uid;\n        this.auth = auth;\n        this.stsTokenManager = stsTokenManager;\n        this.accessToken = stsTokenManager.accessToken;\n        this.displayName = opt.displayName || null;\n        this.email = opt.email || null;\n        this.emailVerified = opt.emailVerified || false;\n        this.phoneNumber = opt.phoneNumber || null;\n        this.photoURL = opt.photoURL || null;\n        this.isAnonymous = opt.isAnonymous || false;\n        this.tenantId = opt.tenantId || null;\n        this.providerData = opt.providerData ? [...opt.providerData] : [];\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\n    }\n    async getIdToken(forceRefresh) {\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        if (this.accessToken !== accessToken) {\n            this.accessToken = accessToken;\n            await this.auth._persistUserIfCurrent(this);\n            this.auth._notifyListenersIfCurrent(this);\n        }\n        return accessToken;\n    }\n    getIdTokenResult(forceRefresh) {\n        return getIdTokenResult(this, forceRefresh);\n    }\n    reload() {\n        return reload(this);\n    }\n    _assign(user) {\n        if (this === user) {\n            return;\n        }\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.displayName = user.displayName;\n        this.photoURL = user.photoURL;\n        this.email = user.email;\n        this.emailVerified = user.emailVerified;\n        this.phoneNumber = user.phoneNumber;\n        this.isAnonymous = user.isAnonymous;\n        this.tenantId = user.tenantId;\n        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));\n        this.metadata._copy(user.metadata);\n        this.stsTokenManager._assign(user.stsTokenManager);\n    }\n    _clone(auth) {\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));\n        newUser.metadata._copy(this.metadata);\n        return newUser;\n    }\n    _onReload(callback) {\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.reloadListener = callback;\n        if (this.reloadUserInfo) {\n            this._notifyReloadListener(this.reloadUserInfo);\n            this.reloadUserInfo = null;\n        }\n    }\n    _notifyReloadListener(userInfo) {\n        if (this.reloadListener) {\n            this.reloadListener(userInfo);\n        }\n        else {\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\n            this.reloadUserInfo = userInfo;\n        }\n    }\n    _startProactiveRefresh() {\n        this.proactiveRefresh._start();\n    }\n    _stopProactiveRefresh() {\n        this.proactiveRefresh._stop();\n    }\n    async _updateTokensIfNecessary(response, reload = false) {\n        let tokensRefreshed = false;\n        if (response.idToken &&\n            response.idToken !== this.stsTokenManager.accessToken) {\n            this.stsTokenManager.updateFromServerResponse(response);\n            tokensRefreshed = true;\n        }\n        if (reload) {\n            await _reloadWithoutSaving(this);\n        }\n        await this.auth._persistUserIfCurrent(this);\n        if (tokensRefreshed) {\n            this.auth._notifyListenersIfCurrent(this);\n        }\n    }\n    async delete() {\n        if (app._isFirebaseServerApp(this.auth.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\n        }\n        const idToken = await this.getIdToken();\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));\n        this.stsTokenManager.clearRefreshToken();\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\n        //       cancels pending actions...\n        return this.auth.signOut();\n    }\n    toJSON() {\n        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), \n            // Redirect event ID must be maintained in case there is a pending\n            // redirect event.\n            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { \n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\n            apiKey: this.auth.config.apiKey, appName: this.auth.name });\n    }\n    get refreshToken() {\n        return this.stsTokenManager.refreshToken || '';\n    }\n    static _fromJSON(auth, object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\n        _assert(typeof uid === 'string', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(displayName, auth.name);\n        assertStringOrUndefined(email, auth.name);\n        _assert(typeof emailVerified === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof isAnonymous === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(phoneNumber, auth.name);\n        assertStringOrUndefined(photoURL, auth.name);\n        assertStringOrUndefined(tenantId, auth.name);\n        assertStringOrUndefined(_redirectEventId, auth.name);\n        assertStringOrUndefined(createdAt, auth.name);\n        assertStringOrUndefined(lastLoginAt, auth.name);\n        const user = new UserImpl({\n            uid,\n            auth,\n            email,\n            emailVerified,\n            displayName,\n            isAnonymous,\n            photoURL,\n            phoneNumber,\n            tenantId,\n            stsTokenManager,\n            createdAt,\n            lastLoginAt\n        });\n        if (providerData && Array.isArray(providerData)) {\n            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));\n        }\n        if (_redirectEventId) {\n            user._redirectEventId = _redirectEventId;\n        }\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: idTokenResponse.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // Updates the user info and data and resolves with a user instance.\n        await _reloadWithoutSaving(user);\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromGetAccountInfoResponse(auth, response, idToken) {\n        const coreAccount = response.users[0];\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const providerData = coreAccount.providerUserInfo !== undefined\n            ? extractProviderData(coreAccount.providerUserInfo)\n            : [];\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromIdToken(idToken);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: coreAccount.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // update the user with data from the GetAccountInfo response.\n        const updates = {\n            uid: coreAccount.localId,\n            displayName: coreAccount.displayName || null,\n            photoURL: coreAccount.photoUrl || null,\n            email: coreAccount.email || null,\n            emailVerified: coreAccount.emailVerified || false,\n            phoneNumber: coreAccount.phoneNumber || null,\n            tenantId: coreAccount.tenantId || null,\n            providerData,\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) &&\n                !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\n        };\n        Object.assign(user, updates);\n        return user;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst instanceCache = new Map();\nfunction _getInstance(cls) {\n    debugAssert(cls instanceof Function, 'Expected a class definition');\n    let instance = instanceCache.get(cls);\n    if (instance) {\n        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');\n        return instance;\n    }\n    instance = new cls();\n    instanceCache.set(cls, instance);\n    return instance;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass InMemoryPersistence {\n    constructor() {\n        this.type = \"NONE\" /* PersistenceType.NONE */;\n        this.storage = {};\n    }\n    async _isAvailable() {\n        return true;\n    }\n    async _set(key, value) {\n        this.storage[key] = value;\n    }\n    async _get(key) {\n        const value = this.storage[key];\n        return value === undefined ? null : value;\n    }\n    async _remove(key) {\n        delete this.storage[key];\n    }\n    _addListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n    _removeListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n}\nInMemoryPersistence.type = 'NONE';\n/**\n * An implementation of {@link Persistence} of type 'NONE'.\n *\n * @public\n */\nconst inMemoryPersistence = InMemoryPersistence;\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _persistenceKeyName(key, apiKey, appName) {\n    return `${\"firebase\" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;\n}\nclass PersistenceUserManager {\n    constructor(persistence, auth, userKey) {\n        this.persistence = persistence;\n        this.auth = auth;\n        this.userKey = userKey;\n        const { config, name } = this.auth;\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\n    }\n    setCurrentUser(user) {\n        return this.persistence._set(this.fullUserKey, user.toJSON());\n    }\n    async getCurrentUser() {\n        const blob = await this.persistence._get(this.fullUserKey);\n        return blob ? UserImpl._fromJSON(this.auth, blob) : null;\n    }\n    removeCurrentUser() {\n        return this.persistence._remove(this.fullUserKey);\n    }\n    savePersistenceForRedirect() {\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\n    }\n    async setPersistence(newPersistence) {\n        if (this.persistence === newPersistence) {\n            return;\n        }\n        const currentUser = await this.getCurrentUser();\n        await this.removeCurrentUser();\n        this.persistence = newPersistence;\n        if (currentUser) {\n            return this.setCurrentUser(currentUser);\n        }\n    }\n    delete() {\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\n    }\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */) {\n        if (!persistenceHierarchy.length) {\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\n        }\n        // Eliminate any persistences that are not available\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (await persistence._isAvailable()) {\n                return persistence;\n            }\n            return undefined;\n        }))).filter(persistence => persistence);\n        // Fall back to the first persistence listed, or in memory if none available\n        let selectedPersistence = availablePersistences[0] ||\n            _getInstance(inMemoryPersistence);\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\n        // Pull out the existing user, setting the chosen persistence to that\n        // persistence if the user exists.\n        let userToMigrate = null;\n        // Note, here we check for a user in _all_ persistences, not just the\n        // ones deemed available. If we can migrate a user out of a broken\n        // persistence, we will (but only if that persistence supports migration).\n        for (const persistence of persistenceHierarchy) {\n            try {\n                const blob = await persistence._get(key);\n                if (blob) {\n                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\n                    if (persistence !== selectedPersistence) {\n                        userToMigrate = user;\n                    }\n                    selectedPersistence = persistence;\n                    break;\n                }\n            }\n            catch (_a) { }\n        }\n        // If we find the user in a persistence that does support migration, use\n        // that migration path (of only persistences that support migration)\n        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);\n        // If the persistence does _not_ allow migration, just finish off here\n        if (!selectedPersistence._shouldAllowMigration ||\n            !migrationHierarchy.length) {\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\n        }\n        selectedPersistence = migrationHierarchy[0];\n        if (userToMigrate) {\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\n            // we'll just let it bubble to surface the error.\n            await selectedPersistence._set(key, userToMigrate.toJSON());\n        }\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\n        await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (persistence !== selectedPersistence) {\n                try {\n                    await persistence._remove(key);\n                }\n                catch (_a) { }\n            }\n        }));\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine the browser for the purposes of reporting usage to the API\n */\nfunction _getBrowserName(userAgent) {\n    const ua = userAgent.toLowerCase();\n    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {\n        return \"Opera\" /* BrowserName.OPERA */;\n    }\n    else if (_isIEMobile(ua)) {\n        // Windows phone IEMobile browser.\n        return \"IEMobile\" /* BrowserName.IEMOBILE */;\n    }\n    else if (ua.includes('msie') || ua.includes('trident/')) {\n        return \"IE\" /* BrowserName.IE */;\n    }\n    else if (ua.includes('edge/')) {\n        return \"Edge\" /* BrowserName.EDGE */;\n    }\n    else if (_isFirefox(ua)) {\n        return \"Firefox\" /* BrowserName.FIREFOX */;\n    }\n    else if (ua.includes('silk/')) {\n        return \"Silk\" /* BrowserName.SILK */;\n    }\n    else if (_isBlackBerry(ua)) {\n        // Blackberry browser.\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */;\n    }\n    else if (_isWebOS(ua)) {\n        // WebOS default browser.\n        return \"Webos\" /* BrowserName.WEBOS */;\n    }\n    else if (_isSafari(ua)) {\n        return \"Safari\" /* BrowserName.SAFARI */;\n    }\n    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&\n        !ua.includes('edge/')) {\n        return \"Chrome\" /* BrowserName.CHROME */;\n    }\n    else if (_isAndroid(ua)) {\n        // Android stock browser.\n        return \"Android\" /* BrowserName.ANDROID */;\n    }\n    else {\n        // Most modern browsers have name/version at end of user agent string.\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\n        const matches = userAgent.match(re);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\n            return matches[1];\n        }\n    }\n    return \"Other\" /* BrowserName.OTHER */;\n}\nfunction _isFirefox(ua = util.getUA()) {\n    return /firefox\\//i.test(ua);\n}\nfunction _isSafari(userAgent = util.getUA()) {\n    const ua = userAgent.toLowerCase();\n    return (ua.includes('safari/') &&\n        !ua.includes('chrome/') &&\n        !ua.includes('crios/') &&\n        !ua.includes('android'));\n}\nfunction _isChromeIOS(ua = util.getUA()) {\n    return /crios\\//i.test(ua);\n}\nfunction _isIEMobile(ua = util.getUA()) {\n    return /iemobile/i.test(ua);\n}\nfunction _isAndroid(ua = util.getUA()) {\n    return /android/i.test(ua);\n}\nfunction _isBlackBerry(ua = util.getUA()) {\n    return /blackberry/i.test(ua);\n}\nfunction _isWebOS(ua = util.getUA()) {\n    return /webos/i.test(ua);\n}\nfunction _isIOS(ua = util.getUA()) {\n    return (/iphone|ipad|ipod/i.test(ua) ||\n        (/macintosh/i.test(ua) && /mobile/i.test(ua)));\n}\nfunction _isIOS7Or8(ua = util.getUA()) {\n    return (/(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) ||\n        /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua));\n}\nfunction _isIE10() {\n    return util.isIE() && document.documentMode === 10;\n}\nfunction _isMobileBrowser(ua = util.getUA()) {\n    // TODO: implement getBrowserName equivalent for OS.\n    return (_isIOS(ua) ||\n        _isAndroid(ua) ||\n        _isWebOS(ua) ||\n        _isBlackBerry(ua) ||\n        /windows phone/i.test(ua) ||\n        _isIEMobile(ua));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Determine the SDK version string\n */\nfunction _getClientVersion(clientPlatform, frameworks = []) {\n    let reportedPlatform;\n    switch (clientPlatform) {\n        case \"Browser\" /* ClientPlatform.BROWSER */:\n            // In a browser environment, report the browser name.\n            reportedPlatform = _getBrowserName(util.getUA());\n            break;\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            // Technically a worker runs from a browser but we need to differentiate a\n            // worker from a browser.\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n            reportedPlatform = `${_getBrowserName(util.getUA())}-${clientPlatform}`;\n            break;\n        default:\n            reportedPlatform = clientPlatform;\n    }\n    const reportedFrameworks = frameworks.length\n        ? frameworks.join(',')\n        : 'FirebaseCore-web'; /* default value if no other framework is used */\n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */}/${app.SDK_VERSION}/${reportedFrameworks}`;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthMiddlewareQueue {\n    constructor(auth) {\n        this.auth = auth;\n        this.queue = [];\n    }\n    pushCallback(callback, onAbort) {\n        // The callback could be sync or async. Wrap it into a\n        // function that is always async.\n        const wrappedCallback = (user) => new Promise((resolve, reject) => {\n            try {\n                const result = callback(user);\n                // Either resolve with existing promise or wrap a non-promise\n                // return value into a promise.\n                resolve(result);\n            }\n            catch (e) {\n                // Sync callback throws.\n                reject(e);\n            }\n        });\n        // Attach the onAbort if present\n        wrappedCallback.onAbort = onAbort;\n        this.queue.push(wrappedCallback);\n        const index = this.queue.length - 1;\n        return () => {\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\n            // indexing of other elements.\n            this.queue[index] = () => Promise.resolve();\n        };\n    }\n    async runMiddleware(nextUser) {\n        if (this.auth.currentUser === nextUser) {\n            return;\n        }\n        // While running the middleware, build a temporary stack of onAbort\n        // callbacks to call if one middleware callback rejects.\n        const onAbortStack = [];\n        try {\n            for (const beforeStateCallback of this.queue) {\n                await beforeStateCallback(nextUser);\n                // Only push the onAbort if the callback succeeds\n                if (beforeStateCallback.onAbort) {\n                    onAbortStack.push(beforeStateCallback.onAbort);\n                }\n            }\n        }\n        catch (e) {\n            // Run all onAbort, with separate try/catch to ignore any errors and\n            // continue\n            onAbortStack.reverse();\n            for (const onAbort of onAbortStack) {\n                try {\n                    onAbort();\n                }\n                catch (_) {\n                    /* swallow error */\n                }\n            }\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */, {\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\n *\n * @param auth Auth object.\n * @param request Password policy request.\n * @returns Password policy response.\n */\nasync function _getPasswordPolicy(auth, request = {}) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Minimum min password length enforced by the backend, even if no minimum length is set.\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\n/**\n * Stores password policy requirements and provides password validation against the policy.\n *\n * @internal\n */\nclass PasswordPolicyImpl {\n    constructor(response) {\n        var _a, _b, _c, _d;\n        // Only include custom strength options defined in the response.\n        const responseOptions = response.customStrengthOptions;\n        this.customStrengthOptions = {};\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\n        this.customStrengthOptions.minPasswordLength =\n            (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\n        if (responseOptions.maxPasswordLength) {\n            this.customStrengthOptions.maxPasswordLength =\n                responseOptions.maxPasswordLength;\n        }\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsLowercaseLetter =\n                responseOptions.containsLowercaseCharacter;\n        }\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsUppercaseLetter =\n                responseOptions.containsUppercaseCharacter;\n        }\n        if (responseOptions.containsNumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNumericCharacter =\n                responseOptions.containsNumericCharacter;\n        }\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNonAlphanumericCharacter =\n                responseOptions.containsNonAlphanumericCharacter;\n        }\n        this.enforcementState = response.enforcementState;\n        if (this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED') {\n            this.enforcementState = 'OFF';\n        }\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\n        this.allowedNonAlphanumericCharacters =\n            (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join('')) !== null && _c !== void 0 ? _c : '';\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\n        this.schemaVersion = response.schemaVersion;\n    }\n    validatePassword(password) {\n        var _a, _b, _c, _d, _e, _f;\n        const status = {\n            isValid: true,\n            passwordPolicy: this\n        };\n        // Check the password length and character options.\n        this.validatePasswordLengthOptions(password, status);\n        this.validatePasswordCharacterOptions(password, status);\n        // Combine the status into single isValid property.\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\n        return status;\n    }\n    /**\n     * Validates that the password meets the length options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordLengthOptions(password, status) {\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\n        if (minPasswordLength) {\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\n        }\n        if (maxPasswordLength) {\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\n        }\n    }\n    /**\n     * Validates that the password meets the character options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordCharacterOptions(password, status) {\n        // Assign statuses for requirements even if the password is an empty string.\n        this.updatePasswordCharacterOptionsStatuses(status, \n        /* containsLowercaseCharacter= */ false, \n        /* containsUppercaseCharacter= */ false, \n        /* containsNumericCharacter= */ false, \n        /* containsNonAlphanumericCharacter= */ false);\n        let passwordChar;\n        for (let i = 0; i < password.length; i++) {\n            passwordChar = password.charAt(i);\n            this.updatePasswordCharacterOptionsStatuses(status, \n            /* containsLowercaseCharacter= */ passwordChar >= 'a' &&\n                passwordChar <= 'z', \n            /* containsUppercaseCharacter= */ passwordChar >= 'A' &&\n                passwordChar <= 'Z', \n            /* containsNumericCharacter= */ passwordChar >= '0' &&\n                passwordChar <= '9', \n            /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\n        }\n    }\n    /**\n     * Updates the running validation status with the statuses for the character options.\n     * Expected to be called each time a character is processed to update each option status\n     * based on the current character.\n     *\n     * @param status Validation status.\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\n     * @param containsNumericCharacter Whether the character is a numeric character.\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\n     */\n    updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\n        if (this.customStrengthOptions.containsLowercaseLetter) {\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsUppercaseLetter) {\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsNumericCharacter) {\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\n        }\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthImpl {\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n        this.appCheckServiceProvider = appCheckServiceProvider;\n        this.config = config;\n        this.currentUser = null;\n        this.emulatorConfig = null;\n        this.operations = Promise.resolve();\n        this.authStateSubscription = new Subscription(this);\n        this.idTokenSubscription = new Subscription(this);\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\n        this.redirectUser = null;\n        this.isProactiveRefreshEnabled = false;\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\n        // Any network calls will set this to true and prevent subsequent emulator\n        // initialization\n        this._canInitEmulator = true;\n        this._isInitialized = false;\n        this._deleted = false;\n        this._initializationPromise = null;\n        this._popupRedirectResolver = null;\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\n        this._agentRecaptchaConfig = null;\n        this._tenantRecaptchaConfigs = {};\n        this._projectPasswordPolicy = null;\n        this._tenantPasswordPolicies = {};\n        // Tracks the last notified UID for state change listeners to prevent\n        // repeated calls to the callbacks. Undefined means it's never been\n        // called, whereas null means it's been called with a signed out user\n        this.lastNotifiedUid = undefined;\n        this.languageCode = null;\n        this.tenantId = null;\n        this.settings = { appVerificationDisabledForTesting: false };\n        this.frameworks = [];\n        this.name = app.name;\n        this.clientVersion = config.sdkClientVersion;\n    }\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\n        if (popupRedirectResolver) {\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\n        }\n        // Have to check for app deletion throughout initialization (after each\n        // promise resolution)\n        this._initializationPromise = this.queue(async () => {\n            var _a, _b;\n            if (this._deleted) {\n                return;\n            }\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\n            if (this._deleted) {\n                return;\n            }\n            // Initialize the resolver early if necessary (only applicable to web:\n            // this will cause the iframe to load immediately in certain cases)\n            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {\n                // If this fails, don't halt auth loading\n                try {\n                    await this._popupRedirectResolver._initialize(this);\n                }\n                catch (e) {\n                    /* Ignore the error */\n                }\n            }\n            await this.initializeCurrentUser(popupRedirectResolver);\n            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;\n            if (this._deleted) {\n                return;\n            }\n            this._isInitialized = true;\n        });\n        return this._initializationPromise;\n    }\n    /**\n     * If the persistence is changed in another window, the user manager will let us know\n     */\n    async _onStorageEvent() {\n        if (this._deleted) {\n            return;\n        }\n        const user = await this.assertedPersistence.getCurrentUser();\n        if (!this.currentUser && !user) {\n            // No change, do nothing (was signed out and remained signed out).\n            return;\n        }\n        // If the same user is to be synchronized.\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\n            // Data update, simply copy data changes.\n            this._currentUser._assign(user);\n            // If tokens changed from previous user tokens, this will trigger\n            // notifyAuthListeners_.\n            await this.currentUser.getIdToken();\n            return;\n        }\n        // Update current Auth state. Either a new login or logout.\n        // Skip blocking callbacks, they should not apply to a change in another tab.\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\n    }\n    async initializeCurrentUserFromIdToken(idToken) {\n        try {\n            const response = await getAccountInfo(this, { idToken });\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\n            await this.directlySetCurrentUser(user);\n        }\n        catch (err) {\n            console.warn('FirebaseServerApp could not login user with provided authIdToken: ', err);\n            await this.directlySetCurrentUser(null);\n        }\n    }\n    async initializeCurrentUser(popupRedirectResolver) {\n        var _a;\n        if (app._isFirebaseServerApp(this.app)) {\n            const idToken = this.app.settings.authIdToken;\n            if (idToken) {\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\n                // attach an emulator, if desired.\n                return new Promise(resolve => {\n                    setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\n                });\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        // First check to see if we have a pending redirect event.\n        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());\n        let futureCurrentUser = previouslyStoredUser;\n        let needsTocheckMiddleware = false;\n        if (popupRedirectResolver && this.config.authDomain) {\n            await this.getOrInitRedirectPersistenceManager();\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\n            // matches the redirect user, then we want to initially sign in with the\n            // new user object from result.\n            // TODO(samgho): More thoroughly test all of this\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&\n                (result === null || result === void 0 ? void 0 : result.user)) {\n                futureCurrentUser = result.user;\n                needsTocheckMiddleware = true;\n            }\n        }\n        // If no user in persistence, there is no current user. Set to null.\n        if (!futureCurrentUser) {\n            return this.directlySetCurrentUser(null);\n        }\n        if (!futureCurrentUser._redirectEventId) {\n            // This isn't a redirect link operation, we can reload and bail.\n            // First though, ensure that we check the middleware is happy.\n            if (needsTocheckMiddleware) {\n                try {\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\n                }\n                catch (e) {\n                    futureCurrentUser = previouslyStoredUser;\n                    // We know this is available since the bit is only set when the\n                    // resolver is available\n                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));\n                }\n            }\n            if (futureCurrentUser) {\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        await this.getOrInitRedirectPersistenceManager();\n        // If the redirect user's event ID matches the current user's event ID,\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\n        // This is important for the reauthenticateWithRedirect() flow.\n        if (this.redirectUser &&\n            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\n            return this.directlySetCurrentUser(futureCurrentUser);\n        }\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n    }\n    async tryRedirectSignIn(redirectResolver) {\n        // The redirect user needs to be checked (and signed in if available)\n        // during auth initialization. All of the normal sign in and link/reauth\n        // flows call back into auth and push things onto the promise queue. We\n        // need to await the result of the redirect sign in *inside the promise\n        // queue*. This presents a problem: we run into deadlock. See:\n        //    ┌> [Initialization] ─────┐\n        //    ┌> [<other queue tasks>] │\n        //    └─ [getRedirectResult] <─┘\n        //    where [] are tasks on the queue and arrows denote awaits\n        // Initialization will never complete because it's waiting on something\n        // that's waiting for initialization to complete!\n        //\n        // Instead, this method calls getRedirectResult() (stored in\n        // _completeRedirectFn) with an optional parameter that instructs all of\n        // the underlying auth operations to skip anything that mutates auth state.\n        let result = null;\n        try {\n            // We know this._popupRedirectResolver is set since redirectResolver\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\n        }\n        catch (e) {\n            // Swallow any errors here; the code can retrieve them in\n            // getRedirectResult().\n            await this._setRedirectUser(null);\n        }\n        return result;\n    }\n    async reloadAndSetCurrentUserOrClear(user) {\n        try {\n            await _reloadWithoutSaving(user);\n        }\n        catch (e) {\n            if ((e === null || e === void 0 ? void 0 : e.code) !==\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                // Something's wrong with the user's token. Log them out and remove\n                // them from storage\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        return this.directlySetCurrentUser(user);\n    }\n    useDeviceLanguage() {\n        this.languageCode = _getUserLanguage();\n    }\n    async _delete() {\n        this._deleted = true;\n    }\n    async updateCurrentUser(userExtern) {\n        if (app._isFirebaseServerApp(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // The public updateCurrentUser method needs to make a copy of the user,\n        // and also check that the project matches\n        const user = userExtern\n            ? util.getModularInstance(userExtern)\n            : null;\n        if (user) {\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */);\n        }\n        return this._updateCurrentUser(user && user._clone(this));\n    }\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\n        if (this._deleted) {\n            return;\n        }\n        if (user) {\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n        }\n        if (!skipBeforeStateCallbacks) {\n            await this.beforeStateQueue.runMiddleware(user);\n        }\n        return this.queue(async () => {\n            await this.directlySetCurrentUser(user);\n            this.notifyAuthListeners();\n        });\n    }\n    async signOut() {\n        if (app._isFirebaseServerApp(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // Run first, to block _setRedirectUser() if any callbacks fail.\n        await this.beforeStateQueue.runMiddleware(null);\n        // Clear the redirect user when signOut is called\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\n            await this._setRedirectUser(null);\n        }\n        // Prevent callbacks from being called again in _updateCurrentUser, as\n        // they were already called in the first line.\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\n    }\n    setPersistence(persistence) {\n        if (app._isFirebaseServerApp(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        return this.queue(async () => {\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\n        });\n    }\n    _getRecaptchaConfig() {\n        if (this.tenantId == null) {\n            return this._agentRecaptchaConfig;\n        }\n        else {\n            return this._tenantRecaptchaConfigs[this.tenantId];\n        }\n    }\n    async validatePassword(password) {\n        if (!this._getPasswordPolicyInternal()) {\n            await this._updatePasswordPolicy();\n        }\n        // Password policy will be defined after fetching.\n        const passwordPolicy = this._getPasswordPolicyInternal();\n        // Check that the policy schema version is supported by the SDK.\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\n        if (passwordPolicy.schemaVersion !==\n            this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */, {}));\n        }\n        return passwordPolicy.validatePassword(password);\n    }\n    _getPasswordPolicyInternal() {\n        if (this.tenantId === null) {\n            return this._projectPasswordPolicy;\n        }\n        else {\n            return this._tenantPasswordPolicies[this.tenantId];\n        }\n    }\n    async _updatePasswordPolicy() {\n        const response = await _getPasswordPolicy(this);\n        const passwordPolicy = new PasswordPolicyImpl(response);\n        if (this.tenantId === null) {\n            this._projectPasswordPolicy = passwordPolicy;\n        }\n        else {\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\n        }\n    }\n    _getPersistence() {\n        return this.assertedPersistence.persistence.type;\n    }\n    _updateErrorMap(errorMap) {\n        this._errorFactory = new util.ErrorFactory('auth', 'Firebase', errorMap());\n    }\n    onAuthStateChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\n    }\n    beforeAuthStateChanged(callback, onAbort) {\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\n    }\n    onIdTokenChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\n    }\n    authStateReady() {\n        return new Promise((resolve, reject) => {\n            if (this.currentUser) {\n                resolve();\n            }\n            else {\n                const unsubscribe = this.onAuthStateChanged(() => {\n                    unsubscribe();\n                    resolve();\n                }, reject);\n            }\n        });\n    }\n    /**\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n     */\n    async revokeAccessToken(token) {\n        if (this.currentUser) {\n            const idToken = await this.currentUser.getIdToken();\n            // Generalize this to accept other providers once supported.\n            const request = {\n                providerId: 'apple.com',\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */,\n                token,\n                idToken\n            };\n            if (this.tenantId != null) {\n                request.tenantId = this.tenantId;\n            }\n            await revokeToken(this, request);\n        }\n    }\n    toJSON() {\n        var _a;\n        return {\n            apiKey: this.config.apiKey,\n            authDomain: this.config.authDomain,\n            appName: this.name,\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\n        };\n    }\n    async _setRedirectUser(user, popupRedirectResolver) {\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\n        return user === null\n            ? redirectManager.removeCurrentUser()\n            : redirectManager.setCurrentUser(user);\n    }\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\n        if (!this.redirectPersistenceManager) {\n            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||\n                this._popupRedirectResolver;\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], \"redirectUser\" /* KeyName.REDIRECT_USER */);\n            this.redirectUser =\n                await this.redirectPersistenceManager.getCurrentUser();\n        }\n        return this.redirectPersistenceManager;\n    }\n    async _redirectUserForId(id) {\n        var _a, _b;\n        // Make sure we've cleared any pending persistence actions if we're not in\n        // the initializer\n        if (this._isInitialized) {\n            await this.queue(async () => { });\n        }\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\n            return this._currentUser;\n        }\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\n            return this.redirectUser;\n        }\n        return null;\n    }\n    async _persistUserIfCurrent(user) {\n        if (user === this.currentUser) {\n            return this.queue(async () => this.directlySetCurrentUser(user));\n        }\n    }\n    /** Notifies listeners only if the user is current */\n    _notifyListenersIfCurrent(user) {\n        if (user === this.currentUser) {\n            this.notifyAuthListeners();\n        }\n    }\n    _key() {\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\n    }\n    _startProactiveRefresh() {\n        this.isProactiveRefreshEnabled = true;\n        if (this.currentUser) {\n            this._currentUser._startProactiveRefresh();\n        }\n    }\n    _stopProactiveRefresh() {\n        this.isProactiveRefreshEnabled = false;\n        if (this.currentUser) {\n            this._currentUser._stopProactiveRefresh();\n        }\n    }\n    /** Returns the current user cast as the internal type */\n    get _currentUser() {\n        return this.currentUser;\n    }\n    notifyAuthListeners() {\n        var _a, _b;\n        if (!this._isInitialized) {\n            return;\n        }\n        this.idTokenSubscription.next(this.currentUser);\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\n        if (this.lastNotifiedUid !== currentUid) {\n            this.lastNotifiedUid = currentUid;\n            this.authStateSubscription.next(this.currentUser);\n        }\n    }\n    registerStateListener(subscription, nextOrObserver, error, completed) {\n        if (this._deleted) {\n            return () => { };\n        }\n        const cb = typeof nextOrObserver === 'function'\n            ? nextOrObserver\n            : nextOrObserver.next.bind(nextOrObserver);\n        let isUnsubscribed = false;\n        const promise = this._isInitialized\n            ? Promise.resolve()\n            : this._initializationPromise;\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // The callback needs to be called asynchronously per the spec.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promise.then(() => {\n            if (isUnsubscribed) {\n                return;\n            }\n            cb(this.currentUser);\n        });\n        if (typeof nextOrObserver === 'function') {\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n        else {\n            const unsubscribe = subscription.addObserver(nextOrObserver);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n    }\n    /**\n     * Unprotected (from race conditions) method to set the current user. This\n     * should only be called from within a queued callback. This is necessary\n     * because the queue shouldn't rely on another queued callback.\n     */\n    async directlySetCurrentUser(user) {\n        if (this.currentUser && this.currentUser !== user) {\n            this._currentUser._stopProactiveRefresh();\n        }\n        if (user && this.isProactiveRefreshEnabled) {\n            user._startProactiveRefresh();\n        }\n        this.currentUser = user;\n        if (user) {\n            await this.assertedPersistence.setCurrentUser(user);\n        }\n        else {\n            await this.assertedPersistence.removeCurrentUser();\n        }\n    }\n    queue(action) {\n        // In case something errors, the callback still should be called in order\n        // to keep the promise chain alive\n        this.operations = this.operations.then(action, action);\n        return this.operations;\n    }\n    get assertedPersistence() {\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.persistenceManager;\n    }\n    _logFramework(framework) {\n        if (!framework || this.frameworks.includes(framework)) {\n            return;\n        }\n        this.frameworks.push(framework);\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n        this.frameworks.sort();\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\n    }\n    _getFrameworks() {\n        return this.frameworks;\n    }\n    async _getAdditionalHeaders() {\n        var _a;\n        // Additional headers on every request\n        const headers = {\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion\n        };\n        if (this.app.options.appId) {\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;\n        }\n        // If the heartbeat service exists, add the heartbeat string\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider\n            .getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\n        if (heartbeatsHeader) {\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;\n        }\n        // If the App Check service exists, add the App Check token in the headers\n        const appCheckToken = await this._getAppCheckToken();\n        if (appCheckToken) {\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;\n        }\n        return headers;\n    }\n    async _getAppCheckToken() {\n        var _a;\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider\n            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\n            // Context: appCheck.getToken() will never throw even if an error happened.\n            // In the error case, a dummy token will be returned along with an error field describing\n            // the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\n        }\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\n    }\n}\n/**\n * Method to be used to cast down to our private implementation of Auth.\n * It will also handle unwrapping from the compat type if necessary\n *\n * @param auth Auth object passed in from developer\n */\nfunction _castAuth(auth) {\n    return util.getModularInstance(auth);\n}\n/** Helper class to wrap subscriber logic */\nclass Subscription {\n    constructor(auth) {\n        this.auth = auth;\n        this.observer = null;\n        this.addObserver = util.createSubscribe(observer => (this.observer = observer));\n    }\n    get next() {\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.observer.next.bind(this.observer);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet externalJSProvider = {\n    async loadJS() {\n        throw new Error('Unable to load external scripts');\n    },\n    recaptchaV2Script: '',\n    recaptchaEnterpriseScript: '',\n    gapiScript: ''\n};\nfunction _loadJS(url) {\n    return externalJSProvider.loadJS(url);\n}\nfunction _recaptchaEnterpriseScriptUrl() {\n    return externalJSProvider.recaptchaEnterpriseScript;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MockGreCAPTCHATopLevel {\n    constructor() {\n        this.enterprise = new MockGreCAPTCHA();\n    }\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\nclass MockGreCAPTCHA {\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';\nconst FAKE_TOKEN = 'NO_RECAPTCHA';\nclass RecaptchaEnterpriseVerifier {\n    /**\n     *\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\n     *\n     */\n    constructor(authExtern) {\n        /**\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\n         */\n        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\n        this.auth = _castAuth(authExtern);\n    }\n    /**\n     * Executes the verification process.\n     *\n     * @returns A Promise for a token that can be used to assert the validity of a request.\n     */\n    async verify(action = 'verify', forceRefresh = false) {\n        async function retrieveSiteKey(auth) {\n            if (!forceRefresh) {\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\n                    return auth._agentRecaptchaConfig.siteKey;\n                }\n                if (auth.tenantId != null &&\n                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\n                }\n            }\n            return new Promise(async (resolve, reject) => {\n                getRecaptchaConfig(auth, {\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                })\n                    .then(response => {\n                    if (response.recaptchaKey === undefined) {\n                        reject(new Error('recaptcha Enterprise site key undefined'));\n                    }\n                    else {\n                        const config = new RecaptchaConfig(response);\n                        if (auth.tenantId == null) {\n                            auth._agentRecaptchaConfig = config;\n                        }\n                        else {\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\n                        }\n                        return resolve(config.siteKey);\n                    }\n                })\n                    .catch(error => {\n                    reject(error);\n                });\n            });\n        }\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\n            const grecaptcha = window.grecaptcha;\n            if (isEnterprise(grecaptcha)) {\n                grecaptcha.enterprise.ready(() => {\n                    grecaptcha.enterprise\n                        .execute(siteKey, { action })\n                        .then(token => {\n                        resolve(token);\n                    })\n                        .catch(() => {\n                        resolve(FAKE_TOKEN);\n                    });\n                });\n            }\n            else {\n                reject(Error('No reCAPTCHA enterprise script loaded.'));\n            }\n        }\n        // Returns Promise for a mock token when appVerificationDisabledForTesting is true.\n        if (this.auth.settings.appVerificationDisabledForTesting) {\n            const mockRecaptcha = new MockGreCAPTCHATopLevel();\n            return mockRecaptcha.execute('siteKey', { action: 'verify' });\n        }\n        return new Promise((resolve, reject) => {\n            retrieveSiteKey(this.auth)\n                .then(siteKey => {\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\n                }\n                else {\n                    if (typeof window === 'undefined') {\n                        reject(new Error('RecaptchaVerifier is only supported in browser'));\n                        return;\n                    }\n                    let url = _recaptchaEnterpriseScriptUrl();\n                    if (url.length !== 0) {\n                        url += siteKey;\n                    }\n                    _loadJS(url)\n                        .then(() => {\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\n                    })\n                        .catch(error => {\n                        reject(error);\n                    });\n                }\n            })\n                .catch(error => {\n                reject(error);\n            });\n        });\n    }\n}\nasync function injectRecaptchaFields(auth, request, action, isCaptchaResp = false, isFakeToken = false) {\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\n    let captchaResponse;\n    if (isFakeToken) {\n        captchaResponse = FAKE_TOKEN;\n    }\n    else {\n        try {\n            captchaResponse = await verifier.verify(action);\n        }\n        catch (error) {\n            captchaResponse = await verifier.verify(action, true);\n        }\n    }\n    const newRequest = Object.assign({}, request);\n    if (action === \"mfaSmsEnrollment\" /* RecaptchaActionName.MFA_SMS_ENROLLMENT */ ||\n        action === \"mfaSmsSignIn\" /* RecaptchaActionName.MFA_SMS_SIGNIN */) {\n        if ('phoneEnrollmentInfo' in newRequest) {\n            const phoneNumber = newRequest.phoneEnrollmentInfo.phoneNumber;\n            const recaptchaToken = newRequest.phoneEnrollmentInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneEnrollmentInfo': {\n                    phoneNumber,\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        else if ('phoneSignInInfo' in newRequest) {\n            const recaptchaToken = newRequest.phoneSignInInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneSignInInfo': {\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        return newRequest;\n    }\n    if (!isCaptchaResp) {\n        Object.assign(newRequest, { captchaResponse });\n    }\n    else {\n        Object.assign(newRequest, { 'captchaResp': captchaResponse });\n    }\n    Object.assign(newRequest, { 'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ });\n    Object.assign(newRequest, {\n        'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    return newRequest;\n}\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod, recaptchaAuthProvider) {\n    var _a, _b;\n    if (recaptchaAuthProvider === \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) {\n        if ((_a = authInstance\n            ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n            return actionMethod(authInstance, requestWithRecaptcha);\n        }\n        else {\n            return actionMethod(authInstance, request).catch(async (error) => {\n                if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {\n                    console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\n                    const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n                    return actionMethod(authInstance, requestWithRecaptcha);\n                }\n                else {\n                    return Promise.reject(error);\n                }\n            });\n        }\n    }\n    else if (recaptchaAuthProvider === \"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */) {\n        if ((_b = authInstance\n            ._getRecaptchaConfig()) === null || _b === void 0 ? void 0 : _b.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName);\n            return actionMethod(authInstance, requestWithRecaptcha).catch(async (error) => {\n                var _a;\n                if (((_a = authInstance\n                    ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.getProviderEnforcementState(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) === \"AUDIT\" /* EnforcementState.AUDIT */) {\n                    // AUDIT mode\n                    if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}` ||\n                        error.code === `auth/${\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */}`) {\n                        console.log(`Failed to verify with reCAPTCHA Enterprise. Automatically triggering the reCAPTCHA v2 flow to complete the ${actionName} flow.`);\n                        // reCAPTCHA Enterprise token is missing or reCAPTCHA Enterprise token\n                        // check fails.\n                        // Fallback to reCAPTCHA v2 flow.\n                        const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n                        true // isFakeToken\n                        );\n                        // This will call the PhoneApiCaller to fetch and inject reCAPTCHA v2 token.\n                        return actionMethod(authInstance, requestWithRecaptchaFields);\n                    }\n                }\n                // ENFORCE mode or AUDIT mode with any other error.\n                return Promise.reject(error);\n            });\n        }\n        else {\n            // Do reCAPTCHA v2 flow.\n            const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n            true // isFakeToken\n            );\n            // This will call the PhoneApiCaller to fetch and inject v2 token.\n            return actionMethod(authInstance, requestWithRecaptchaFields);\n        }\n    }\n    else {\n        return Promise.reject(recaptchaAuthProvider + ' provider is not supported.');\n    }\n}\nasync function _initializeRecaptchaConfig(auth) {\n    const authInternal = _castAuth(auth);\n    const response = await getRecaptchaConfig(authInternal, {\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    const config = new RecaptchaConfig(response);\n    if (authInternal.tenantId == null) {\n        authInternal._agentRecaptchaConfig = config;\n    }\n    else {\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\n    }\n    if (config.isAnyProviderEnabled()) {\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\n        void verifier.verify();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Initializes an {@link Auth} instance with fine-grained control over\n * {@link Dependencies}.\n *\n * @remarks\n *\n * This function allows more control over the {@link Auth} instance than\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\n * need control over which persistence layer is used, or to minimize bundle\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\n *\n * For example, if your app only uses anonymous accounts and you only want\n * accounts saved for the current session, initialize `Auth` with:\n *\n * ```js\n * const auth = initializeAuth(app, {\n *   persistence: browserSessionPersistence,\n *   popupRedirectResolver: undefined,\n * });\n * ```\n *\n * @public\n */\nfunction initializeAuth(app$1, deps) {\n    const provider = app._getProvider(app$1, 'auth');\n    if (provider.isInitialized()) {\n        const auth = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if (util.deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\n            return auth;\n        }\n        else {\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */);\n        }\n    }\n    const auth = provider.initialize({ options: deps });\n    return auth;\n}\nfunction _initializeAuthInstance(auth, deps) {\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\n    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\n        auth._updateErrorMap(deps.errorMap);\n    }\n    // This promise is intended to float; auth initialization happens in the\n    // background, meanwhile the auth object may be used by the app.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\n}\n\n/**\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\n * Firebase Auth services.\n *\n * @remarks\n * This must be called synchronously immediately following the first call to\n * {@link initializeAuth}.  Do not use with production credentials as emulator\n * traffic is not encrypted.\n *\n *\n * @example\n * ```javascript\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\n * `true` to disable the warning banner attached to the DOM.\n *\n * @public\n */\nfunction connectAuthEmulator(auth, url, options) {\n    const authInternal = _castAuth(auth);\n    _assert(authInternal._canInitEmulator, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\n    const protocol = extractProtocol(url);\n    const { host, port } = extractHostAndPort(url);\n    const portStr = port === null ? '' : `:${port}`;\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\n    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };\n    authInternal.settings.appVerificationDisabledForTesting = true;\n    authInternal.emulatorConfig = Object.freeze({\n        host,\n        port,\n        protocol: protocol.replace(':', ''),\n        options: Object.freeze({ disableWarnings })\n    });\n    if (!disableWarnings) {\n        emitEmulatorWarning();\n    }\n}\nfunction extractProtocol(url) {\n    const protocolEnd = url.indexOf(':');\n    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);\n}\nfunction extractHostAndPort(url) {\n    const protocol = extractProtocol(url);\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\n    if (!authority) {\n        return { host: '', port: null };\n    }\n    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out \"username:password@\".\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\n    if (bracketedIPv6) {\n        const host = bracketedIPv6[1];\n        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };\n    }\n    else {\n        const [host, port] = hostAndPort.split(':');\n        return { host, port: parsePort(port) };\n    }\n}\nfunction parsePort(portStr) {\n    if (!portStr) {\n        return null;\n    }\n    const port = Number(portStr);\n    if (isNaN(port)) {\n        return null;\n    }\n    return port;\n}\nfunction emitEmulatorWarning() {\n    function attachBanner() {\n        const el = document.createElement('p');\n        const sty = el.style;\n        el.innerText =\n            'Running in emulator mode. Do not use with production credentials.';\n        sty.position = 'fixed';\n        sty.width = '100%';\n        sty.backgroundColor = '#ffffff';\n        sty.border = '.1em solid #000000';\n        sty.color = '#b50000';\n        sty.bottom = '0px';\n        sty.left = '0px';\n        sty.margin = '0px';\n        sty.zIndex = '10000';\n        sty.textAlign = 'center';\n        el.classList.add('firebase-emulator-warning');\n        document.body.appendChild(el);\n    }\n    if (typeof console !== 'undefined' && typeof console.info === 'function') {\n        console.info('WARNING: You are using the Auth Emulator,' +\n            ' which is intended for local testing only.  Do not use with' +\n            ' production credentials.');\n    }\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n        if (document.readyState === 'loading') {\n            window.addEventListener('DOMContentLoaded', attachBanner);\n        }\n        else {\n            attachBanner();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by an {@link AuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass AuthCredential {\n    /** @internal */\n    constructor(\n    /**\n     * The authentication provider ID for the credential.\n     *\n     * @remarks\n     * For example, 'facebook.com', or 'google.com'.\n     */\n    providerId, \n    /**\n     * The authentication sign in method for the credential.\n     *\n     * @remarks\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\n     */\n    signInMethod) {\n        this.providerId = providerId;\n        this.signInMethod = signInMethod;\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns a JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getIdTokenResponse(_auth) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _linkToIdToken(_auth, _idToken) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getReauthenticationResolver(_auth) {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function resetPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function updateEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\n// format as updateEmailPassword.\nasync function linkEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, request);\n}\nasync function applyActionCode$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPassword(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function sendOobCode(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));\n}\nasync function sendEmailVerification$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendPasswordResetEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendSignInLinkToEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function verifyAndChangeEmail(auth, request) {\n    return sendOobCode(auth, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithEmailLink$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\nasync function signInWithEmailLinkForLinking(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\n * {@link ProviderId}.PASSWORD\n *\n * @remarks\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @public\n */\nclass EmailAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _email, \n    /** @internal */\n    _password, signInMethod, \n    /** @internal */\n    _tenantId = null) {\n        super(\"password\" /* ProviderId.PASSWORD */, signInMethod);\n        this._email = _email;\n        this._password = _password;\n        this._tenantId = _tenantId;\n    }\n    /** @internal */\n    static _fromEmailAndPassword(email, password) {\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */);\n    }\n    /** @internal */\n    static _fromEmailAndCode(email, oobCode, tenantId = null) {\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */, tenantId);\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        return {\n            email: this._email,\n            password: this._password,\n            signInMethod: this.signInMethod,\n            tenantId: this._tenantId\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\n     *\n     * @param json - Either `object` or the stringified representation of the object. When string is\n     * provided, `JSON.parse` would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */) {\n                return this._fromEmailAndPassword(obj.email, obj.password);\n            }\n            else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */) {\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\n            }\n        }\n        return null;\n    }\n    /** @internal */\n    async _getIdTokenResponse(auth) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */, signInWithPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLink$1(auth, {\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    async _linkToIdToken(auth, idToken) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    idToken,\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, linkEmailPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLinkForLinking(auth, {\n                    idToken,\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return this._getIdTokenResponse(auth);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithIdp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI$1 = 'http://localhost';\n/**\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass OAuthCredential extends AuthCredential {\n    constructor() {\n        super(...arguments);\n        this.pendingToken = null;\n    }\n    /** @internal */\n    static _fromParams(params) {\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\n        if (params.idToken || params.accessToken) {\n            // OAuth 2 and either ID token or access token.\n            if (params.idToken) {\n                cred.idToken = params.idToken;\n            }\n            if (params.accessToken) {\n                cred.accessToken = params.accessToken;\n            }\n            // Add nonce if available and no pendingToken is present.\n            if (params.nonce && !params.pendingToken) {\n                cred.nonce = params.nonce;\n            }\n            if (params.pendingToken) {\n                cred.pendingToken = params.pendingToken;\n            }\n        }\n        else if (params.oauthToken && params.oauthTokenSecret) {\n            // OAuth 1 and OAuth token with token secret\n            cred.accessToken = params.oauthToken;\n            cred.secret = params.oauthTokenSecret;\n        }\n        else {\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        }\n        return cred;\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            idToken: this.idToken,\n            accessToken: this.accessToken,\n            secret: this.secret,\n            nonce: this.nonce,\n            pendingToken: this.pendingToken,\n            providerId: this.providerId,\n            signInMethod: this.signInMethod\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod } = obj, rest = tslib.__rest(obj, [\"providerId\", \"signInMethod\"]);\n        if (!providerId || !signInMethod) {\n            return null;\n        }\n        const cred = new OAuthCredential(providerId, signInMethod);\n        cred.idToken = rest.idToken || undefined;\n        cred.accessToken = rest.accessToken || undefined;\n        cred.secret = rest.secret;\n        cred.nonce = rest.nonce;\n        cred.pendingToken = rest.pendingToken || null;\n        return cred;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    buildRequest() {\n        const request = {\n            requestUri: IDP_REQUEST_URI$1,\n            returnSecureToken: true\n        };\n        if (this.pendingToken) {\n            request.pendingToken = this.pendingToken;\n        }\n        else {\n            const postBody = {};\n            if (this.idToken) {\n                postBody['id_token'] = this.idToken;\n            }\n            if (this.accessToken) {\n                postBody['access_token'] = this.accessToken;\n            }\n            if (this.secret) {\n                postBody['oauth_token_secret'] = this.secret;\n            }\n            postBody['providerId'] = this.providerId;\n            if (this.nonce && !this.pendingToken) {\n                postBody['nonce'] = this.nonce;\n            }\n            request.postBody = util.querystring(postBody);\n        }\n        return request;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPhoneNumber$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n}\nasync function linkWithPhoneNumber$1(auth, request) {\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n    if (response.temporaryProof) {\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, response);\n    }\n    return response;\n}\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */\n};\nasync function verifyPhoneNumberForExisting(auth, request) {\n    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the credentials returned by {@link PhoneAuthProvider}.\n *\n * @public\n */\nclass PhoneAuthCredential extends AuthCredential {\n    constructor(params) {\n        super(\"phone\" /* ProviderId.PHONE */, \"phone\" /* SignInMethod.PHONE */);\n        this.params = params;\n    }\n    /** @internal */\n    static _fromVerification(verificationId, verificationCode) {\n        return new PhoneAuthCredential({ verificationId, verificationCode });\n    }\n    /** @internal */\n    static _fromTokenResponse(phoneNumber, temporaryProof) {\n        return new PhoneAuthCredential({ phoneNumber, temporaryProof });\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _makeVerificationRequest() {\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\n        if (temporaryProof && phoneNumber) {\n            return { temporaryProof, phoneNumber };\n        }\n        return {\n            sessionInfo: verificationId,\n            code: verificationCode\n        };\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        const obj = {\n            providerId: this.providerId\n        };\n        if (this.params.phoneNumber) {\n            obj.phoneNumber = this.params.phoneNumber;\n        }\n        if (this.params.temporaryProof) {\n            obj.temporaryProof = this.params.temporaryProof;\n        }\n        if (this.params.verificationCode) {\n            obj.verificationCode = this.params.verificationCode;\n        }\n        if (this.params.verificationId) {\n            obj.verificationId = this.params.verificationId;\n        }\n        return obj;\n    }\n    /** Generates a phone credential based on a plain object or a JSON string. */\n    static fromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\n        if (!verificationCode &&\n            !verificationId &&\n            !phoneNumber &&\n            !temporaryProof) {\n            return null;\n        }\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode,\n            phoneNumber,\n            temporaryProof\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Maps the mode string in action code URL to Action Code Info operation.\n *\n * @param mode\n */\nfunction parseMode(mode) {\n    switch (mode) {\n        case 'recoverEmail':\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */;\n        case 'resetPassword':\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */;\n        case 'signIn':\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n        case 'verifyEmail':\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */;\n        case 'verifyAndChangeEmail':\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;\n        case 'revertSecondFactorAddition':\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;\n        default:\n            return null;\n    }\n}\n/**\n * Helper to parse FDL links\n *\n * @param url\n */\nfunction parseDeepLink(url) {\n    const link = util.querystringDecode(util.extractQuerystring(url))['link'];\n    // Double link case (automatic redirect).\n    const doubleDeepLink = link\n        ? util.querystringDecode(util.extractQuerystring(link))['deep_link_id']\n        : null;\n    // iOS custom scheme links.\n    const iOSDeepLink = util.querystringDecode(util.extractQuerystring(url))['deep_link_id'];\n    const iOSDoubleDeepLink = iOSDeepLink\n        ? util.querystringDecode(util.extractQuerystring(iOSDeepLink))['link']\n        : null;\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\n * A utility class to parse email action URLs such as password reset, email verification,\n * email link sign in, etc.\n *\n * @public\n */\nclass ActionCodeURL {\n    /**\n     * @param actionLink - The link from which to extract the URL.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @internal\n     */\n    constructor(actionLink) {\n        var _a, _b, _c, _d, _e, _f;\n        const searchParams = util.querystringDecode(util.extractQuerystring(actionLink));\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);\n        // Validate API key, code and mode.\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        this.apiKey = apiKey;\n        this.operation = operation;\n        this.code = code;\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;\n        this.languageCode = (_e = searchParams[\"languageCode\" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;\n    }\n    /**\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\n     * otherwise returns null.\n     *\n     * @param link  - The email action link string.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @public\n     */\n    static parseLink(link) {\n        const actionLink = parseDeepLink(link);\n        try {\n            return new ActionCodeURL(actionLink);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/**\n * Parses the email action link string and returns an {@link ActionCodeURL} if\n * the link is valid, otherwise returns null.\n *\n * @public\n */\nfunction parseActionCodeURL(link) {\n    return ActionCodeURL.parseLink(link);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating {@link EmailAuthCredential}.\n *\n * @public\n */\nclass EmailAuthProvider {\n    constructor() {\n        /**\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\n         */\n        this.providerId = EmailAuthProvider.PROVIDER_ID;\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and password.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credential(email, password);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\n     * ```\n     *\n     * @param email - Email address.\n     * @param password - User account password.\n     * @returns The auth provider credential.\n     */\n    static credential(email, password) {\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\n     * email link operation.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * await sendSignInLinkToEmail(auth, email);\n     * // Obtain emailLink from user.\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\n     * ```\n     *\n     * @param auth - The {@link Auth} instance used to verify the link.\n     * @param email - Email address.\n     * @param emailLink - Sign-in email link.\n     * @returns - The auth provider credential.\n     */\n    static credentialWithLink(email, emailLink) {\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\n    }\n}\n/**\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\n */\nEmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\n */\nEmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_LINK.\n */\nEmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\n *\n * This class is not meant to be instantiated directly.\n *\n * @public\n */\nclass FederatedAuthProvider {\n    /**\n     * Constructor for generic OAuth providers.\n     *\n     * @param providerId - Provider for which credentials should be generated.\n     */\n    constructor(providerId) {\n        this.providerId = providerId;\n        /** @internal */\n        this.defaultLanguageCode = null;\n        /** @internal */\n        this.customParameters = {};\n    }\n    /**\n     * Set the language gode.\n     *\n     * @param languageCode - language code\n     */\n    setDefaultLanguage(languageCode) {\n        this.defaultLanguageCode = languageCode;\n    }\n    /**\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\n     * operations.\n     *\n     * @remarks\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\n     *\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\n     */\n    setCustomParameters(customOAuthParameters) {\n        this.customParameters = customOAuthParameters;\n        return this;\n    }\n    /**\n     * Retrieve the current list of {@link CustomParameters}.\n     */\n    getCustomParameters() {\n        return this.customParameters;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Common code to all OAuth providers. This is separate from the\n * {@link OAuthProvider} so that child providers (like\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\n * Instead, they rely on a static `credential` method.\n */\nclass BaseOAuthProvider extends FederatedAuthProvider {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this.scopes = [];\n    }\n    /**\n     * Add an OAuth scope to the credential.\n     *\n     * @param scope - Provider OAuth scope to add.\n     */\n    addScope(scope) {\n        // If not already added, add scope to list.\n        if (!this.scopes.includes(scope)) {\n            this.scopes.push(scope);\n        }\n        return this;\n    }\n    /**\n     * Retrieve the current list of OAuth scopes.\n     */\n    getScopes() {\n        return [...this.scopes];\n    }\n}\n/**\n * Provider for generating generic {@link OAuthCredential}.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new OAuthProvider('google.com');\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a OAuth Access Token for the provider.\n *   const credential = provider.credentialFromResult(auth, result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new OAuthProvider('google.com');\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a OAuth Access Token for the provider.\n * const credential = provider.credentialFromResult(auth, result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass OAuthProvider extends BaseOAuthProvider {\n    /**\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        _assert('providerId' in obj && 'signInMethod' in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return OAuthCredential._fromParams(obj);\n    }\n    /**\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\n     *\n     * @remarks\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\n     * the raw nonce must match the nonce field in the ID token.\n     *\n     * @example\n     * ```javascript\n     * // `googleUser` from the onsuccess Google Sign In callback.\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\n     * const provider = new OAuthProvider('google.com');\n     * const credential = provider.credential({\n     *   idToken: googleUser.getAuthResponse().id_token,\n     * });\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param params - Either the options object containing the ID token, access token and raw nonce\n     * or the ID token string.\n     */\n    credential(params) {\n        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));\n    }\n    /** An internal credential method that accepts more permissive options */\n    _credential(params) {\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        // For OAuthCredential, sign in method is same as providerId.\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));\n    }\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\n        if (!oauthAccessToken &&\n            !oauthTokenSecret &&\n            !oauthIdToken &&\n            !pendingToken) {\n            return null;\n        }\n        if (!providerId) {\n            return null;\n        }\n        try {\n            return new OAuthProvider(providerId)._credential({\n                idToken: oauthIdToken,\n                accessToken: oauthAccessToken,\n                nonce,\n                pendingToken\n            });\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new FacebookAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('user_birthday');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Facebook Access Token.\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new FacebookAuthProvider();\n * provider.addScope('user_birthday');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Facebook Access Token.\n * const credential = FacebookAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass FacebookAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */);\n    }\n    /**\n     * Creates a credential for Facebook.\n     *\n     * @example\n     * ```javascript\n     * // `event` from the Facebook auth.authResponseChange callback.\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param accessToken - Facebook access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: FacebookAuthProvider.PROVIDER_ID,\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.FACEBOOK. */\nFacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */;\n/** Always set to {@link ProviderId}.FACEBOOK. */\nFacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GoogleAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Google Access Token.\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GoogleAuthProvider();\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Google Access Token.\n * const credential = GoogleAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass GoogleAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"google.com\" /* ProviderId.GOOGLE */);\n        this.addScope('profile');\n    }\n    /**\n     * Creates a credential for Google. At least one of ID token and access token is required.\n     *\n     * @example\n     * ```javascript\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param idToken - Google ID token.\n     * @param accessToken - Google access token.\n     */\n    static credential(idToken, accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GoogleAuthProvider.PROVIDER_ID,\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\n            idToken,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\n        if (!oauthIdToken && !oauthAccessToken) {\n            // This could be an oauth 1 credential or a phone credential\n            return null;\n        }\n        try {\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GOOGLE. */\nGoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */;\n/** Always set to {@link ProviderId}.GOOGLE. */\nGoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\n *\n * @remarks\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\n * the {@link signInWithPopup} handler:\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GithubAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('repo');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a GitHub Access Token.\n *   const credential = GithubAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GithubAuthProvider();\n * provider.addScope('repo');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a GitHub Access Token.\n * const credential = GithubAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass GithubAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"github.com\" /* ProviderId.GITHUB */);\n    }\n    /**\n     * Creates a credential for GitHub.\n     *\n     * @param accessToken - GitHub access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GithubAuthProvider.PROVIDER_ID,\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GITHUB. */\nGithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */;\n/** Always set to {@link ProviderId}.GITHUB. */\nGithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI = 'http://localhost';\n/**\n * @public\n */\nclass SAMLAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(providerId, pendingToken) {\n        super(providerId, providerId);\n        this.pendingToken = pendingToken;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            signInMethod: this.signInMethod,\n            providerId: this.providerId,\n            pendingToken: this.pendingToken\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod, pendingToken } = obj;\n        if (!providerId ||\n            !signInMethod ||\n            !pendingToken ||\n            providerId !== signInMethod) {\n            return null;\n        }\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    /**\n     * Helper static method to avoid exposing the constructor to end users.\n     *\n     * @internal\n     */\n    static _create(providerId, pendingToken) {\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    buildRequest() {\n        return {\n            requestUri: IDP_REQUEST_URI,\n            returnSecureToken: true,\n            pendingToken: this.pendingToken\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst SAML_PROVIDER_PREFIX = 'saml.';\n/**\n * An {@link AuthProvider} for SAML.\n *\n * @public\n */\nclass SAMLAuthProvider extends FederatedAuthProvider {\n    /**\n     * Constructor. The providerId must start with \"saml.\"\n     * @param providerId - SAML provider ID.\n     */\n    constructor(providerId) {\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        super(providerId);\n    }\n    /**\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\n     * successful SAML flow completes.\n     *\n     * @remarks\n     *\n     * For example, to get an {@link AuthCredential}, you could write the\n     * following code:\n     *\n     * ```js\n     * const userCredential = await signInWithPopup(auth, samlProvider);\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\n     * ```\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));\n    }\n    /**\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const credential = SAMLAuthCredential.fromJSON(json);\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return credential;\n    }\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { pendingToken, providerId } = tokenResponse;\n        if (!pendingToken || !providerId) {\n            return null;\n        }\n        try {\n            return SAMLAuthCredential._create(providerId, pendingToken);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new TwitterAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Twitter Access Token and Secret.\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n *   const secret = credential.secret;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new TwitterAuthProvider();\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Twitter Access Token and Secret.\n * const credential = TwitterAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * const secret = credential.secret;\n * ```\n *\n * @public\n */\nclass TwitterAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"twitter.com\" /* ProviderId.TWITTER */);\n    }\n    /**\n     * Creates a credential for Twitter.\n     *\n     * @param token - Twitter access token.\n     * @param secret - Twitter secret.\n     */\n    static credential(token, secret) {\n        return OAuthCredential._fromParams({\n            providerId: TwitterAuthProvider.PROVIDER_ID,\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\n            oauthToken: token,\n            oauthTokenSecret: secret\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\n        if (!oauthAccessToken || !oauthTokenSecret) {\n            return null;\n        }\n        try {\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.TWITTER. */\nTwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */;\n/** Always set to {@link ProviderId}.TWITTER. */\nTwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signUp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserCredentialImpl {\n    constructor(params) {\n        this.user = params.user;\n        this.providerId = params.providerId;\n        this._tokenResponse = params._tokenResponse;\n        this.operationType = params.operationType;\n    }\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\n        const providerId = providerIdForResponse(idTokenResponse);\n        const userCred = new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: idTokenResponse,\n            operationType\n        });\n        return userCred;\n    }\n    static async _forOperation(user, operationType, response) {\n        await user._updateTokensIfNecessary(response, /* reload */ true);\n        const providerId = providerIdForResponse(response);\n        return new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: response,\n            operationType\n        });\n    }\n}\nfunction providerIdForResponse(response) {\n    if (response.providerId) {\n        return response.providerId;\n    }\n    if ('phoneNumber' in response) {\n        return \"phone\" /* ProviderId.PHONE */;\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in as an anonymous user.\n *\n * @remarks\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\n * new anonymous user identity will be created and returned.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nasync function signInAnonymously(auth) {\n    var _a;\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    await authInternal._initializationPromise;\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\n        // If an anonymous user is already signed in, no need to sign them in again.\n        return new UserCredentialImpl({\n            user: authInternal.currentUser,\n            providerId: null,\n            operationType: \"signIn\" /* OperationType.SIGN_IN */\n        });\n    }\n    const response = await signUp(authInternal, {\n        returnSecureToken: true\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response, true);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorError extends util.FirebaseError {\n    constructor(auth, error, operationType, user) {\n        var _a;\n        super(error.code, error.message);\n        this.operationType = operationType;\n        this.user = user;\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\n        this.customData = {\n            appName: auth.name,\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\n            _serverResponse: error.customData._serverResponse,\n            operationType\n        };\n    }\n    static _fromErrorAndOperation(auth, error, operationType, user) {\n        return new MultiFactorError(auth, error, operationType, user);\n    }\n}\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */\n        ? credential._getReauthenticationResolver(auth)\n        : credential._getIdTokenResponse(auth);\n    return idTokenProvider.catch(error => {\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */}`) {\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a set of UserInfo provider data and converts it to a set of names\n */\nfunction providerDataAsNames(providerData) {\n    return new Set(providerData\n        .map(({ providerId }) => providerId)\n        .filter(pid => !!pid));\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unlinks a provider from a user account.\n *\n * @param user - The user.\n * @param providerId - The provider to unlink.\n *\n * @public\n */\nasync function unlink(user, providerId) {\n    const userInternal = util.getModularInstance(user);\n    await _assertLinkedStatus(true, userInternal, providerId);\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\n        idToken: await userInternal.getIdToken(),\n        deleteProvider: [providerId]\n    });\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\n    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */)) {\n        userInternal.phoneNumber = null;\n    }\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    return userInternal;\n}\nasync function _link(user, credential, bypassAuthState = false) {\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */, response);\n}\nasync function _assertLinkedStatus(expected, user, provider) {\n    await _reloadWithoutSaving(user);\n    const providerIds = providerDataAsNames(user.providerData);\n    const code = expected === false\n        ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */\n        : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */;\n    _assert(providerIds.has(provider) === expected, user.auth, code);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reauthenticate(user, credential, bypassAuthState = false) {\n    const { auth } = user;\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */;\n    try {\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const parsed = _parseToken(response.idToken);\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const { sub: localId } = parsed;\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        return UserCredentialImpl._forOperation(user, operationType, response);\n    }\n    catch (e) {\n        // Convert user deleted error into user mismatch\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */}`) {\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        }\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _signInWithCredential(auth, credential, bypassAuthState = false) {\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */;\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\n    if (!bypassAuthState) {\n        await auth._updateCurrentUser(userCredential.user);\n    }\n    return userCredential;\n}\n/**\n * Asynchronously signs in with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function signInWithCredential(auth, credential) {\n    return _signInWithCredential(_castAuth(auth), credential);\n}\n/**\n * Links the user account with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function linkWithCredential(user, credential) {\n    const userInternal = util.getModularInstance(user);\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\n    return _link(userInternal, credential);\n}\n/**\n * Re-authenticates a user using a fresh credential.\n *\n * @remarks\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\n * or a `TOKEN_EXPIRED` error.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function reauthenticateWithCredential(user, credential) {\n    return _reauthenticate(util.getModularInstance(user), credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithCustomToken$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in using a custom token.\n *\n * @remarks\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\n * be generated by an auth backend using the\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\n *\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param customToken - The custom token to sign in with.\n *\n * @public\n */\nasync function signInWithCustomToken(auth, customToken) {\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const response = await signInWithCustomToken$1(authInternal, {\n        token: customToken,\n        returnSecureToken: true\n    });\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(cred.user);\n    return cred;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorInfoImpl {\n    constructor(factorId, response) {\n        this.factorId = factorId;\n        this.uid = response.mfaEnrollmentId;\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\n        this.displayName = response.displayName;\n    }\n    static _fromServerResponse(auth, enrollment) {\n        if ('phoneInfo' in enrollment) {\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        else if ('totpInfo' in enrollment) {\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n}\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"phone\" /* FactorId.PHONE */, response);\n        this.phoneNumber = response.phoneInfo;\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new PhoneMultiFactorInfoImpl(enrollment);\n    }\n}\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"totp\" /* FactorId.TOTP */, response);\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new TotpMultiFactorInfoImpl(enrollment);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\n    var _a;\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */);\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||\n        actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);\n    request.continueUrl = actionCodeSettings.url;\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\n    if (actionCodeSettings.iOS) {\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\n    }\n    if (actionCodeSettings.android) {\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);\n        request.androidInstallApp = actionCodeSettings.android.installApp;\n        request.androidMinimumVersionCode =\n            actionCodeSettings.android.minimumVersion;\n        request.androidPackageName = actionCodeSettings.android.packageName;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\n * cached for the project or tenant.\n *\n * @remarks\n * We only fetch the password policy if the password did not meet policy requirements and\n * there is an existing policy cached. A developer must call validatePassword at least\n * once for the cache to be automatically updated.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @private\n */\nasync function recachePasswordPolicy(auth) {\n    const authInternal = _castAuth(auth);\n    if (authInternal._getPasswordPolicyInternal()) {\n        await authInternal._updatePasswordPolicy();\n    }\n}\n/**\n * Sends a password reset email to the given email address. This method does not throw an error when\n * there's no user account with the given email address and\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n *\n * @remarks\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\n * the email sent to the user, along with the new password specified by the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain code from user.\n * await confirmPasswordReset('user@example.com', code);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendPasswordResetEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n    }\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendPasswordResetEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Completes the password reset process, given a confirmation code and new password.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A confirmation code sent to the user.\n * @param newPassword - The new password.\n *\n * @public\n */\nasync function confirmPasswordReset(auth, oobCode, newPassword) {\n    await resetPassword(util.getModularInstance(auth), {\n        oobCode,\n        newPassword\n    })\n        .catch(async (error) => {\n        if (error.code ===\n            `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    // Do not return the email.\n}\n/**\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function applyActionCode(auth, oobCode) {\n    await applyActionCode$1(util.getModularInstance(auth), { oobCode });\n}\n/**\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @returns metadata about the code.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function checkActionCode(auth, oobCode) {\n    const authModular = util.getModularInstance(auth);\n    const response = await resetPassword(authModular, { oobCode });\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\n    // VERIFY_AND_CHANGE_EMAIL.\n    // New email should not be empty if the request type is\n    // VERIFY_AND_CHANGE_EMAIL.\n    // Multi-factor info could not be empty if the request type is\n    // REVERT_SECOND_FACTOR_ADDITION.\n    const operation = response.requestType;\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    switch (operation) {\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */:\n            break;\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            break;\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // fall through\n        default:\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n    // The multi-factor info for revert second factor addition\n    let multiFactorInfo = null;\n    if (response.mfaInfo) {\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\n    }\n    return {\n        data: {\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.newEmail\n                : response.email) || null,\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.email\n                : response.newEmail) || null,\n            multiFactorInfo\n        },\n        operation\n    };\n}\n/**\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\n *\n * @returns the user's email address if valid.\n *\n * @param auth - The {@link Auth} instance.\n * @param code - A verification code sent to the user.\n *\n * @public\n */\nasync function verifyPasswordResetCode(auth, code) {\n    const { data } = await checkActionCode(util.getModularInstance(auth), code);\n    // Email should always be present since a code was sent to it\n    return data.email;\n}\n/**\n * Creates a new user account associated with the specified email address and password.\n *\n * @remarks\n * On successful creation of the user account, this user will also be signed in to your application.\n *\n * User account creation can fail if the account already exists or the password is invalid.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The email address acts as a unique identifier for the user and enables an email-based\n * password reset. This function will create a new user account and set the initial user password.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param password - The user's chosen password.\n *\n * @public\n */\nasync function createUserWithEmailAndPassword(auth, email, password) {\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const request = {\n        returnSecureToken: true,\n        email,\n        password,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, signUp, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n    const response = await signUpResponse.catch(error => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\n * Asynchronously signs in using an email and password.\n *\n * @remarks\n * Fails with an error if the email address and password do not match. When\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\n * email/password.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The user's password is NOT the password used to access the user's email account. The\n * email address serves as a unique identifier for the user, and the password is used to access\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The users email address.\n * @param password - The users password.\n *\n * @public\n */\nfunction signInWithEmailAndPassword(auth, email, password) {\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    return signInWithCredential(util.getModularInstance(auth), EmailAuthProvider.credential(email, password)).catch(async (error) => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sends a sign-in email link to the user with the specified email.\n *\n * @remarks\n * The sign-in operation has to always be completed in the app unlike other out of band email\n * actions (password reset and email verifications). This is because, at the end of the flow,\n * the user is expected to be signed in and their Auth state persisted within the app.\n *\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\n * address and the email link supplied in the email sent to the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n * @param authInternal - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    function setActionCodeSettings(request, actionCodeSettings) {\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        if (actionCodeSettings) {\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n        }\n    }\n    setActionCodeSettings(request, actionCodeSettings);\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendSignInLinkToEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\n *\n * @param auth - The {@link Auth} instance.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nfunction isSignInWithEmailLink(auth, emailLink) {\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n}\n/**\n * Asynchronously signs in using an email and sign-in email link.\n *\n * @remarks\n * If no link is passed, the link is inferred from the current URL.\n *\n * Fails with an error if the email address is invalid or OTP in email link expires.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nasync function signInWithEmailLink(auth, email, emailLink) {\n    if (app._isFirebaseServerApp(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authModular = util.getModularInstance(auth);\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\n    // instance.\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n    return signInWithCredential(authModular, credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function createAuthUri(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets the list of possible sign in methods for the given email address. This method returns an\n * empty list when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, irrespective of the number of authentication methods available for the given email.\n *\n * @remarks\n * This is useful to differentiate methods of sign-in for the same provider, eg.\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\n * {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n *\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\n * Learn more in the Identity Platform documentation for\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\n * @public\n */\nasync function fetchSignInMethodsForEmail(auth, email) {\n    // createAuthUri returns an error if continue URI is not http or https.\n    // For environments like Cordova, Chrome extensions, native frameworks, file\n    // systems, etc, use http://localhost as continue URL.\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';\n    const request = {\n        identifier: email,\n        continueUri\n    };\n    const { signinMethods } = await createAuthUri(util.getModularInstance(auth), request);\n    return signinMethods || [];\n}\n/**\n * Sends a verification email to a user.\n *\n * @remarks\n * The verification process is completed by calling {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendEmailVerification(user, actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendEmailVerification(user, actionCodeSettings) {\n    const userInternal = util.getModularInstance(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */,\n        idToken\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\n    if (email !== user.email) {\n        await user.reload();\n    }\n}\n/**\n * Sends a verification email to a new email address.\n *\n * @remarks\n * The user's email will be updated to the new one after being verified.\n *\n * If you have a custom email action handler, you can complete the verification process by calling\n * {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param newEmail - The new email address to be verified before update.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\n    const userInternal = util.getModularInstance(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,\n        idToken,\n        newEmail\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\n    if (email !== user.email) {\n        // If the local copy of the email on user is outdated, reload the\n        // user.\n        await user.reload();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function updateProfile$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates a user's profile data.\n *\n * @param user - The user.\n * @param profile - The profile's `displayName` and `photoURL` to update.\n *\n * @public\n */\nasync function updateProfile(user, { displayName, photoURL: photoUrl }) {\n    if (displayName === undefined && photoUrl === undefined) {\n        return;\n    }\n    const userInternal = util.getModularInstance(user);\n    const idToken = await userInternal.getIdToken();\n    const profileRequest = {\n        idToken,\n        displayName,\n        photoUrl,\n        returnSecureToken: true\n    };\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\n    userInternal.displayName = response.displayName || null;\n    userInternal.photoURL = response.photoUrl || null;\n    // Update the password provider as well\n    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === \"password\" /* ProviderId.PASSWORD */);\n    if (passwordProvider) {\n        passwordProvider.displayName = userInternal.displayName;\n        passwordProvider.photoURL = userInternal.photoURL;\n    }\n    await userInternal._updateTokensIfNecessary(response);\n}\n/**\n * Updates the user's email address.\n *\n * @remarks\n * An email will be sent to the original email address (if it was set) that allows to revoke the\n * email address change, in order to protect them from account hijacking.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newEmail - The new email address.\n *\n * Throws \"auth/operation-not-allowed\" error when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\n *\n * @public\n */\nfunction updateEmail(user, newEmail) {\n    const userInternal = util.getModularInstance(user);\n    if (app._isFirebaseServerApp(userInternal.auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\n    }\n    return updateEmailOrPassword(userInternal, newEmail, null);\n}\n/**\n * Updates the user's password.\n *\n * @remarks\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newPassword - The new password.\n *\n * @public\n */\nfunction updatePassword(user, newPassword) {\n    return updateEmailOrPassword(util.getModularInstance(user), null, newPassword);\n}\nasync function updateEmailOrPassword(user, email, password) {\n    const { auth } = user;\n    const idToken = await user.getIdToken();\n    const request = {\n        idToken,\n        returnSecureToken: true\n    };\n    if (email) {\n        request.email = email;\n    }\n    if (password) {\n        request.password = password;\n    }\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\n    await user._updateTokensIfNecessary(response, /* reload */ true);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parse the `AdditionalUserInfo` from the ID token response.\n *\n */\nfunction _fromIdTokenResponse(idTokenResponse) {\n    var _a, _b;\n    if (!idTokenResponse) {\n        return null;\n    }\n    const { providerId } = idTokenResponse;\n    const profile = idTokenResponse.rawUserInfo\n        ? JSON.parse(idTokenResponse.rawUserInfo)\n        : {};\n    const isNewUser = idTokenResponse.isNewUser ||\n        idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */;\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];\n        if (signInProvider) {\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */ &&\n                signInProvider !== \"custom\" /* ProviderId.CUSTOM */\n                ? signInProvider\n                : null;\n            // Uses generic class in accordance with the legacy SDK.\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\n        }\n    }\n    if (!providerId) {\n        return null;\n    }\n    switch (providerId) {\n        case \"facebook.com\" /* ProviderId.FACEBOOK */:\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\n        case \"github.com\" /* ProviderId.GITHUB */:\n            return new GithubAdditionalUserInfo(isNewUser, profile);\n        case \"google.com\" /* ProviderId.GOOGLE */:\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\n        case \"twitter.com\" /* ProviderId.TWITTER */:\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\n        case \"custom\" /* ProviderId.CUSTOM */:\n        case \"anonymous\" /* ProviderId.ANONYMOUS */:\n            return new GenericAdditionalUserInfo(isNewUser, null);\n        default:\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\n    }\n}\nclass GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile = {}) {\n        this.isNewUser = isNewUser;\n        this.providerId = providerId;\n        this.profile = profile;\n    }\n}\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile, username) {\n        super(isNewUser, providerId, profile);\n        this.username = username;\n    }\n}\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */, profile);\n    }\n}\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);\n    }\n}\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */, profile);\n    }\n}\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile, screenName) {\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */, profile, screenName);\n    }\n}\n/**\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\n *\n * @param userCredential - The user credential.\n *\n * @public\n */\nfunction getAdditionalUserInfo(userCredential) {\n    const { user, _tokenResponse } = userCredential;\n    if (user.isAnonymous && !_tokenResponse) {\n        // Handle the special case where signInAnonymously() gets called twice.\n        // No network call is made so there's nothing to actually fill this in\n        return {\n            providerId: null,\n            isNewUser: false,\n            profile: null\n        };\n    }\n    return _fromIdTokenResponse(_tokenResponse);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Non-optional auth methods.\n/**\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\n * `Auth` session and applies this type of persistence for future sign-in requests, including\n * sign-in with redirect requests.\n *\n * @remarks\n * This makes it easy for a user signing in to specify whether their session should be\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\n * that are shared by other users or have sensitive data.\n *\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @example\n * ```javascript\n * setPersistence(auth, browserSessionPersistence);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param persistence - The {@link Persistence} to use.\n * @returns A `Promise` that resolves once the persistence change has completed\n *\n * @public\n */\nfunction setPersistence(auth, persistence) {\n    return util.getModularInstance(auth).setPersistence(persistence);\n}\n/**\n * Loads the reCAPTCHA configuration into the `Auth` instance.\n *\n * @remarks\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\n * verification flow should be triggered for each auth provider, into the\n * current Auth session.\n *\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\n * auth flows.\n *\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\n *\n * This method does not work in a Node.js environment.\n *\n * @example\n * ```javascript\n * initializeRecaptchaConfig(auth);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction initializeRecaptchaConfig(auth) {\n    return _initializeRecaptchaConfig(auth);\n}\n/**\n * Validates the password against the password policy configured for the project or tenant.\n *\n * @remarks\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\n * policy configured for the project. Otherwise, this method will use the policy configured\n * for the tenant. If a password policy has not been configured, then the default policy\n * configured for all projects will be used.\n *\n * If an auth flow fails because a submitted password does not meet the password policy\n * requirements and this method has previously been called, then this method will use the\n * most recent policy available when called again.\n *\n * @example\n * ```javascript\n * validatePassword(auth, 'some-password');\n * ```\n *\n * @param auth The {@link Auth} instance.\n * @param password The password to validate.\n *\n * @public\n */\nasync function validatePassword(auth, password) {\n    const authInternal = _castAuth(auth);\n    return authInternal.validatePassword(password);\n}\n/**\n * Adds an observer for changes to the signed-in user's ID token.\n *\n * @remarks\n * This includes sign-in, sign-out, and token refresh events.\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onIdTokenChanged(auth, nextOrObserver, error, completed) {\n    return util.getModularInstance(auth).onIdTokenChanged(nextOrObserver, error, completed);\n}\n/**\n * Adds a blocking callback that runs before an auth state change\n * sets a new user.\n *\n * @param auth - The {@link Auth} instance.\n * @param callback - callback triggered before new user value is set.\n *   If this throws, it blocks the user from being set.\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\n *   callback throws, allowing you to undo any side effects.\n */\nfunction beforeAuthStateChanged(auth, callback, onAbort) {\n    return util.getModularInstance(auth).beforeAuthStateChanged(callback, onAbort);\n}\n/**\n * Adds an observer for changes to the user's sign-in state.\n *\n * @remarks\n * To keep the old behavior, see {@link onIdTokenChanged}.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onAuthStateChanged(auth, nextOrObserver, error, completed) {\n    return util.getModularInstance(auth).onAuthStateChanged(nextOrObserver, error, completed);\n}\n/**\n * Sets the current language to the default device/browser preference.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction useDeviceLanguage(auth) {\n    util.getModularInstance(auth).useDeviceLanguage();\n}\n/**\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\n * {@link Auth} instance.\n *\n * @remarks\n * A new instance copy of the user provided will be made and set as currentUser.\n *\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\n * like other sign in methods.\n *\n * The operation fails with an error if the user to be updated belongs to a different Firebase\n * project.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param user - The new {@link User}.\n *\n * @public\n */\nfunction updateCurrentUser(auth, user) {\n    return util.getModularInstance(auth).updateCurrentUser(user);\n}\n/**\n * Signs out the current user.\n *\n * @remarks\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction signOut(auth) {\n    return util.getModularInstance(auth).signOut();\n}\n/**\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n *\n * @param auth - The {@link Auth} instance.\n * @param token - The Apple OAuth access token.\n *\n * @public\n */\nfunction revokeAccessToken(auth, token) {\n    const authInternal = _castAuth(auth);\n    return authInternal.revokeAccessToken(token);\n}\n/**\n * Deletes and signs out the user.\n *\n * @remarks\n * Important: this is a security-sensitive operation that requires the user to have recently\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function deleteUser(user) {\n    return util.getModularInstance(user).delete();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorSessionImpl {\n    constructor(type, credential, user) {\n        this.type = type;\n        this.credential = credential;\n        this.user = user;\n    }\n    static _fromIdtoken(idToken, user) {\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */, idToken, user);\n    }\n    static _fromMfaPendingCredential(mfaPendingCredential) {\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);\n    }\n    toJSON() {\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */\n            ? 'idToken'\n            : 'pendingCredential';\n        return {\n            multiFactorSession: {\n                [key]: this.credential\n            }\n        };\n    }\n    static fromJSON(obj) {\n        var _a, _b;\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\n            }\n            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\n            }\n        }\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorResolverImpl {\n    constructor(session, hints, signInResolver) {\n        this.session = session;\n        this.hints = hints;\n        this.signInResolver = signInResolver;\n    }\n    /** @internal */\n    static _fromError(authExtern, error) {\n        const auth = _castAuth(authExtern);\n        const serverResponse = error.customData._serverResponse;\n        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\n        return new MultiFactorResolverImpl(session, hints, async (assertion) => {\n            const mfaResponse = await assertion._process(auth, session);\n            // Clear out the unneeded fields from the old login response\n            delete serverResponse.mfaInfo;\n            delete serverResponse.mfaPendingCredential;\n            // Use in the new token & refresh token in the old response\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\n            switch (error.operationType) {\n                case \"signIn\" /* OperationType.SIGN_IN */:\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\n                    await auth._updateCurrentUser(userCredential.user);\n                    return userCredential;\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */:\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\n                default:\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            }\n        });\n    }\n    async resolveSignIn(assertionExtern) {\n        const assertion = assertionExtern;\n        return this.signInResolver(assertion);\n    }\n}\n/**\n * Provides a {@link MultiFactorResolver} suitable for completion of a\n * multi-factor flow.\n *\n * @param auth - The {@link Auth} instance.\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\n * reauthentication operation.\n *\n * @public\n */\nfunction getMultiFactorResolver(auth, error) {\n    var _a;\n    const authModular = util.getModularInstance(auth);\n    const errorInternal = error;\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction startEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction finalizeEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction withdrawMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorUserImpl {\n    constructor(user) {\n        this.user = user;\n        this.enrolledFactors = [];\n        user._onReload(userInfo => {\n            if (userInfo.mfaInfo) {\n                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\n            }\n        });\n    }\n    static _fromUser(user) {\n        return new MultiFactorUserImpl(user);\n    }\n    async getSession() {\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\n    }\n    async enroll(assertionExtern, displayName) {\n        const assertion = assertionExtern;\n        const session = (await this.getSession());\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\n        // New tokens will be issued after enrollment of the new second factors.\n        // They need to be updated on the user.\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\n        // The user needs to be reloaded to get the new multi-factor information\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\n        // will be updated.\n        return this.user.reload();\n    }\n    async unenroll(infoOrUid) {\n        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;\n        const idToken = await this.user.getIdToken();\n        try {\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\n                idToken,\n                mfaEnrollmentId\n            }));\n            // Remove the second factor from the user's list.\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);\n            // Depending on whether the backend decided to revoke the user's session,\n            // the tokenResponse may be empty. If the tokens were not updated (and they\n            // are now invalid), reloading the user will discover this and invalidate\n            // the user's state accordingly.\n            await this.user._updateTokensIfNecessary(idTokenResponse);\n            await this.user.reload();\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n}\nconst multiFactorUserCache = new WeakMap();\n/**\n * The {@link MultiFactorUser} corresponding to the user.\n *\n * @remarks\n * This is used to access all multi-factor properties and operations related to the user.\n *\n * @param user - The user.\n *\n * @public\n */\nfunction multiFactor(user) {\n    const userModular = util.getModularInstance(user);\n    if (!multiFactorUserCache.has(userModular)) {\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\n    }\n    return multiFactorUserCache.get(userModular);\n}\n\nvar name = \"@firebase/auth\";\nvar version = \"1.8.1\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthInterop {\n    constructor(auth) {\n        this.auth = auth;\n        this.internalListeners = new Map();\n    }\n    getUid() {\n        var _a;\n        this.assertAuthConfigured();\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\n    }\n    async getToken(forceRefresh) {\n        this.assertAuthConfigured();\n        await this.auth._initializationPromise;\n        if (!this.auth.currentUser) {\n            return null;\n        }\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\n        return { accessToken };\n    }\n    addAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        if (this.internalListeners.has(listener)) {\n            return;\n        }\n        const unsubscribe = this.auth.onIdTokenChanged(user => {\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\n        });\n        this.internalListeners.set(listener, unsubscribe);\n        this.updateProactiveRefresh();\n    }\n    removeAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        const unsubscribe = this.internalListeners.get(listener);\n        if (!unsubscribe) {\n            return;\n        }\n        this.internalListeners.delete(listener);\n        unsubscribe();\n        this.updateProactiveRefresh();\n    }\n    assertAuthConfigured() {\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);\n    }\n    updateProactiveRefresh() {\n        if (this.internalListeners.size > 0) {\n            this.auth._startProactiveRefresh();\n        }\n        else {\n            this.auth._stopProactiveRefresh();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getVersionForPlatform(clientPlatform) {\n    switch (clientPlatform) {\n        case \"Node\" /* ClientPlatform.NODE */:\n            return 'node';\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */:\n            return 'rn';\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            return 'webworker';\n        case \"Cordova\" /* ClientPlatform.CORDOVA */:\n            return 'cordova';\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */:\n            return 'web-extension';\n        default:\n            return undefined;\n    }\n}\n/** @internal */\nfunction registerAuth(clientPlatform) {\n    app._registerComponent(new component.Component(\"auth\" /* _ComponentName.AUTH */, (container, { options: deps }) => {\n        const app = container.getProvider('app').getImmediate();\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\n        const appCheckServiceProvider = container.getProvider('app-check-internal');\n        const { apiKey, authDomain } = app.options;\n        _assert(apiKey && !apiKey.includes(':'), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });\n        const config = {\n            apiKey,\n            authDomain,\n            clientPlatform,\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */,\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */,\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */,\n            sdkClientVersion: _getClientVersion(clientPlatform)\n        };\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\n        _initializeAuthInstance(authInstance, deps);\n        return authInstance;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\n        /**\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\n         * For why we do this, See go/firebase-next-auth-init\n         */\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n        /**\n         * Because all firebase products that depend on auth depend on auth-internal directly,\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\n         */\n        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */);\n        authInternalProvider.initialize();\n    }));\n    app._registerComponent(new component.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */, container => {\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */).getImmediate());\n        return (auth => new AuthInterop(auth))(auth);\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n    app.registerVersion(name, version, getVersionForPlatform(clientPlatform));\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    app.registerVersion(name, version, 'cjs2017');\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\nFetchProvider.initialize(fetch, Headers, Response);\n// First, we set up the various platform-specific features for Node (register\n// the version and declare the Node getAuth function)\nfunction getAuth(app$1 = app.getApp()) {\n    const provider = app._getProvider(app$1, 'auth');\n    if (provider.isInitialized()) {\n        return provider.getImmediate();\n    }\n    const auth = initializeAuth(app$1);\n    const authEmulatorHost = util.getDefaultEmulatorHost('auth');\n    if (authEmulatorHost) {\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\n    }\n    return auth;\n}\nregisterAuth(\"Node\" /* ClientPlatform.NODE */);\n// The rest of this file contains no-ops and errors for browser-specific\n// methods. We keep the browser and Node entry points the same, but features\n// that only work in browsers are set to either do nothing (setPersistence) or\n// to reject with an auth/operation-not-supported-in-this-environment error.\n// The below exports are pulled into the main entry point by a rollup alias\n// plugin (overwriting the default browser imports).\n/** auth/operation-not-supported-in-this-environment */\nconst NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n/** Reject with auth/operation-not-supported-in-this-environment */\nasync function fail() {\n    throw NOT_AVAILABLE_ERROR;\n}\n/**\n * A class which will throw with\n * auth/operation-not-supported-in-this-environment if instantiated\n */\nclass FailClass {\n    constructor() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\nconst browserLocalPersistence = inMemoryPersistence;\nconst browserSessionPersistence = inMemoryPersistence;\nconst indexedDBLocalPersistence = inMemoryPersistence;\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\nconst PhoneAuthProvider = FailClass;\nconst signInWithPhoneNumber = fail;\nconst linkWithPhoneNumber = fail;\nconst reauthenticateWithPhoneNumber = fail;\nconst updatePhoneNumber = fail;\nconst signInWithPopup = fail;\nconst linkWithPopup = fail;\nconst reauthenticateWithPopup = fail;\nconst signInWithRedirect = fail;\nconst linkWithRedirect = fail;\nconst reauthenticateWithRedirect = fail;\nconst getRedirectResult = fail;\nconst RecaptchaVerifier = FailClass;\nclass PhoneMultiFactorGenerator {\n    static assertion() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\n// Set persistence should no-op instead of fail. Changing the prototype will\n// make sure both setPersistence(auth, persistence) and\n// auth.setPersistence(persistence) are covered.\nAuthImpl.prototype.setPersistence = async () => { };\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction finalizeSignInTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorAssertionImpl {\n    constructor(factorId) {\n        this.factorId = factorId;\n    }\n    _process(auth, session, displayName) {\n        switch (session.type) {\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */:\n                return this._finalizeEnroll(auth, session.credential, displayName);\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */:\n                return this._finalizeSignIn(auth, session.credential);\n            default:\n                return debugFail('unexpected MultiFactorSessionType');\n        }\n    }\n}\n\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * @public\n */\nclass TotpMultiFactorGenerator {\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\n     * the TOTP (time-based one-time password) second factor.\n     * This assertion is used to complete enrollment in TOTP second factor.\n     *\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorUser.enroll}.\n     */\n    static assertionForEnrollment(secret, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\n    }\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\n     * This assertion is used to complete signIn with TOTP as the second factor.\n     *\n     * @param enrollmentId identifies the enrolled TOTP second factor.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorResolver.resolveSignIn}.\n     */\n    static assertionForSignIn(enrollmentId, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\n    }\n    /**\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\n     * Used for generating a QR code URL or inputting into a TOTP app.\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\n     *\n     * @param session The {@link MultiFactorSession} that the user is part of.\n     * @returns A promise to {@link TotpSecret}.\n     */\n    static async generateSecret(session) {\n        var _a;\n        const mfaSession = session;\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\n            idToken: mfaSession.credential,\n            totpEnrollmentInfo: {}\n        });\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\n    }\n}\n/**\n * The identifier of the TOTP second factor: `totp`.\n */\nTotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */;\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\n    constructor(otp, enrollmentId, secret) {\n        super(\"totp\" /* FactorId.TOTP */);\n        this.otp = otp;\n        this.enrollmentId = enrollmentId;\n        this.secret = secret;\n    }\n    /** @internal */\n    static _fromSecret(secret, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\n    }\n    /** @internal */\n    static _fromEnrollmentId(enrollmentId, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\n    }\n    /** @internal */\n    async _finalizeEnroll(auth, idToken, displayName) {\n        _assert(typeof this.secret !== 'undefined', auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return finalizeEnrollTotpMfa(auth, {\n            idToken,\n            displayName,\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\n        });\n    }\n    /** @internal */\n    async _finalizeSignIn(auth, mfaPendingCredential) {\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        const totpVerificationInfo = { verificationCode: this.otp };\n        return finalizeSignInTotpMfa(auth, {\n            mfaPendingCredential,\n            mfaEnrollmentId: this.enrollmentId,\n            totpVerificationInfo\n        });\n    }\n}\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * Stores the shared secret key and other parameters to generate time-based OTPs.\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\n * @public\n */\nclass TotpSecret {\n    // The public members are declared outside the constructor so the docs can be generated.\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {\n        this.sessionInfo = sessionInfo;\n        this.auth = auth;\n        this.secretKey = secretKey;\n        this.hashingAlgorithm = hashingAlgorithm;\n        this.codeLength = codeLength;\n        this.codeIntervalSeconds = codeIntervalSeconds;\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\n    }\n    /** @internal */\n    static _fromStartTotpMfaEnrollmentResponse(response, auth) {\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\n    }\n    /** @internal */\n    _makeTotpVerificationInfo(otp) {\n        return { sessionInfo: this.sessionInfo, verificationCode: otp };\n    }\n    /**\n     * Returns a QR code URL as described in\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\n     *\n     * @param accountName the name of the account/app along with a user identifier.\n     * @param issuer issuer of the TOTP (likely the app name).\n     * @returns A QR code URL string.\n     */\n    generateQrCodeUrl(accountName, issuer) {\n        var _a;\n        let useDefaults = false;\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\n            useDefaults = true;\n        }\n        if (useDefaults) {\n            if (_isEmptyString(accountName)) {\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';\n            }\n            if (_isEmptyString(issuer)) {\n                issuer = this.auth.name;\n            }\n        }\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\n    }\n}\n/** @internal */\nfunction _isEmptyString(input) {\n    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;\n}\n\nexports.AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY;\nexports.ActionCodeOperation = ActionCodeOperation;\nexports.ActionCodeURL = ActionCodeURL;\nexports.AuthCredential = AuthCredential;\nexports.AuthImpl = AuthImpl;\nexports.BaseOAuthProvider = BaseOAuthProvider;\nexports.EmailAuthCredential = EmailAuthCredential;\nexports.EmailAuthProvider = EmailAuthProvider;\nexports.FacebookAuthProvider = FacebookAuthProvider;\nexports.FactorId = FactorId;\nexports.FederatedAuthProvider = FederatedAuthProvider;\nexports.FetchProvider = FetchProvider;\nexports.GithubAuthProvider = GithubAuthProvider;\nexports.GoogleAuthProvider = GoogleAuthProvider;\nexports.OAuthCredential = OAuthCredential;\nexports.OAuthProvider = OAuthProvider;\nexports.OperationType = OperationType;\nexports.PhoneAuthCredential = PhoneAuthCredential;\nexports.PhoneAuthProvider = PhoneAuthProvider;\nexports.PhoneMultiFactorGenerator = PhoneMultiFactorGenerator;\nexports.ProviderId = ProviderId;\nexports.RecaptchaVerifier = RecaptchaVerifier;\nexports.SAMLAuthCredential = SAMLAuthCredential;\nexports.SAMLAuthProvider = SAMLAuthProvider;\nexports.SignInMethod = SignInMethod;\nexports.TotpMultiFactorGenerator = TotpMultiFactorGenerator;\nexports.TotpSecret = TotpSecret;\nexports.TwitterAuthProvider = TwitterAuthProvider;\nexports.UserImpl = UserImpl;\nexports._assert = _assert;\nexports._castAuth = _castAuth;\nexports._createError = _createError;\nexports._emulatorUrl = _emulatorUrl;\nexports._fail = _fail;\nexports._getClientVersion = _getClientVersion;\nexports._getInstance = _getInstance;\nexports._isAndroid = _isAndroid;\nexports._isIE10 = _isIE10;\nexports._isIOS = _isIOS;\nexports._isIOS7Or8 = _isIOS7Or8;\nexports._isMobileBrowser = _isMobileBrowser;\nexports._link = _link;\nexports._performApiRequest = _performApiRequest;\nexports._persistenceKeyName = _persistenceKeyName;\nexports._reauthenticate = _reauthenticate;\nexports._serverAppCurrentUserOperationNotSupportedError = _serverAppCurrentUserOperationNotSupportedError;\nexports._signInWithCredential = _signInWithCredential;\nexports.applyActionCode = applyActionCode;\nexports.beforeAuthStateChanged = beforeAuthStateChanged;\nexports.browserLocalPersistence = browserLocalPersistence;\nexports.browserPopupRedirectResolver = browserPopupRedirectResolver;\nexports.browserSessionPersistence = browserSessionPersistence;\nexports.checkActionCode = checkActionCode;\nexports.confirmPasswordReset = confirmPasswordReset;\nexports.connectAuthEmulator = connectAuthEmulator;\nexports.createUserWithEmailAndPassword = createUserWithEmailAndPassword;\nexports.debugAssert = debugAssert;\nexports.debugErrorMap = debugErrorMap;\nexports.deleteUser = deleteUser;\nexports.fetchSignInMethodsForEmail = fetchSignInMethodsForEmail;\nexports.getAdditionalUserInfo = getAdditionalUserInfo;\nexports.getAuth = getAuth;\nexports.getIdToken = getIdToken;\nexports.getIdTokenResult = getIdTokenResult;\nexports.getMultiFactorResolver = getMultiFactorResolver;\nexports.getRedirectResult = getRedirectResult;\nexports.inMemoryPersistence = inMemoryPersistence;\nexports.indexedDBLocalPersistence = indexedDBLocalPersistence;\nexports.initializeAuth = initializeAuth;\nexports.initializeRecaptchaConfig = initializeRecaptchaConfig;\nexports.isSignInWithEmailLink = isSignInWithEmailLink;\nexports.linkWithCredential = linkWithCredential;\nexports.linkWithPhoneNumber = linkWithPhoneNumber;\nexports.linkWithPopup = linkWithPopup;\nexports.linkWithRedirect = linkWithRedirect;\nexports.multiFactor = multiFactor;\nexports.onAuthStateChanged = onAuthStateChanged;\nexports.onIdTokenChanged = onIdTokenChanged;\nexports.parseActionCodeURL = parseActionCodeURL;\nexports.prodErrorMap = prodErrorMap;\nexports.reauthenticateWithCredential = reauthenticateWithCredential;\nexports.reauthenticateWithPhoneNumber = reauthenticateWithPhoneNumber;\nexports.reauthenticateWithPopup = reauthenticateWithPopup;\nexports.reauthenticateWithRedirect = reauthenticateWithRedirect;\nexports.reload = reload;\nexports.revokeAccessToken = revokeAccessToken;\nexports.sendEmailVerification = sendEmailVerification;\nexports.sendPasswordResetEmail = sendPasswordResetEmail;\nexports.sendSignInLinkToEmail = sendSignInLinkToEmail;\nexports.setPersistence = setPersistence;\nexports.signInAnonymously = signInAnonymously;\nexports.signInWithCredential = signInWithCredential;\nexports.signInWithCustomToken = signInWithCustomToken;\nexports.signInWithEmailAndPassword = signInWithEmailAndPassword;\nexports.signInWithEmailLink = signInWithEmailLink;\nexports.signInWithIdp = signInWithIdp;\nexports.signInWithPhoneNumber = signInWithPhoneNumber;\nexports.signInWithPopup = signInWithPopup;\nexports.signInWithRedirect = signInWithRedirect;\nexports.signOut = signOut;\nexports.unlink = unlink;\nexports.updateCurrentUser = updateCurrentUser;\nexports.updateEmail = updateEmail;\nexports.updatePassword = updatePassword;\nexports.updatePhoneNumber = updatePhoneNumber;\nexports.updateProfile = updateProfile;\nexports.useDeviceLanguage = useDeviceLanguage;\nexports.validatePassword = validatePassword;\nexports.verifyBeforeUpdateEmail = verifyBeforeUpdateEmail;\nexports.verifyPasswordResetCode = verifyPasswordResetCode;\n//# sourceMappingURL=totp-7195c207.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlL3RvdHAtNzE5NWMyMDcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDJFQUFlO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHVEQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFxQjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsaUZBQWtCOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxpQkFBaUI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0IsS0FBSyxJQUFJO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQixLQUFLLElBQUk7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFCQUFxQixpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFJLEVBQUUsNENBQTRDO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyx5QkFBeUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHlCQUF5QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsc0JBQXNCO0FBQ2pIO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLEtBQUssR0FBRyxNQUFNO0FBQ3pDO0FBQ0Esa0JBQWtCLHNCQUFzQixLQUFLLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQyw2QkFBNkIsa0RBQWtEO0FBQy9FLHlCQUF5Qix1REFBdUQ7QUFDaEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQW9FO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQix1QkFBdUI7QUFDdkMsaUdBQWlHLE9BQU87QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1Q0FBdUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0Q0FBNEM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNJQUFzSSxTQUFTO0FBQy9JO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkJBQTZCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsV0FBVyxzREFBc0Q7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzVkFBc1Y7QUFDblk7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBGQUEwRjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QyxHQUFHLElBQUksR0FBRyxPQUFPLEdBQUcsUUFBUTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QixHQUFHLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGNBQWMsaUJBQWlCLEdBQUcseUNBQXlDLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CO0FBQ3BIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9FQUFvRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwwQkFBMEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7QUFDQSxnQ0FBZ0MsK0RBQStEO0FBQy9GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNFQUFzRTtBQUNqSCxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzRUFBc0U7QUFDckgsK0NBQStDLG9FQUFvRTtBQUNuSCxrSkFBa0osWUFBWTtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRCxJQUFJLGNBQWM7QUFDbEIsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1QkFBdUI7QUFDL0U7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6Qiw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBLHFDQUFxQyxRQUFRLFNBQVMsSUFBSSxLQUFLLEVBQUUsUUFBUTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEMsUUFBUSxtQkFBbUI7QUFDM0Isa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlCQUF5QjtBQUNuRixJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQyxJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUNBQW1DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixzQkFBc0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0NBQW9DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYyxxQkFBcUI7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZCQUE2QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFnRTtBQUNoRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFnRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQkFBcUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCLElBQUkseUJBQXlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWEsd0JBQXdCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsYUFBYSw0REFBNEQ7QUFDbEo7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSw2Q0FBNkMsK0JBQStCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRkFBb0Y7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixLQUFLLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCLEtBQUssaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixLQUFLLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9DQUFvQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCLFFBQVEsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQkFBK0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCLEtBQUssaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOERBQThEO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsa0RBQWtEO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxjQUFjLFlBQVk7QUFDOUUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLCtEQUErRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLDhGQUE4RjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEZBQThGO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHFDQUFxQztBQUNoRztBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEZBQThGO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsMkJBQTJCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMEJBQTBCO0FBQ25HO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCLElBQUksbUJBQW1CO0FBQ3ZCLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdIQUF3SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzQkFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaUNBQWlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVksY0FBYyxZQUFZO0FBQzlFLG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHVCQUF1QjtBQUNsRztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFLElBQUksWUFBWTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEIsS0FBSyx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHFCQUFxQixzRUFBc0U7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtFQUFrRSxLQUFLO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckMsMEdBQTBHLG1CQUFtQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQsUUFBUSw2QkFBNkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELFFBQVEsd0NBQXdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRCw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sR0FBRyxZQUFZLFVBQVUsZUFBZSxVQUFVLE9BQU8sYUFBYSxzQkFBc0IsVUFBVSxnQkFBZ0I7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRCwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLGdCQUFnQjtBQUNoQiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQixnQ0FBZ0M7QUFDaEMsa0JBQWtCO0FBQ2xCLDJCQUEyQjtBQUMzQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsY0FBYztBQUNkLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLHVEQUF1RDtBQUN2RCw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLGlDQUFpQztBQUNqQyx1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLDJCQUEyQjtBQUMzQixzQ0FBc0M7QUFDdEMsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsa0NBQWtDO0FBQ2xDLDZCQUE2QjtBQUM3QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZixjQUFjO0FBQ2QseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIi9ob21lL3JndGVjaDAwOC9hY2FkZW1pYy1jb25uZWN0LXByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS90b3RwLTcxOTVjMjA3LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFwcCA9IHJlcXVpcmUoJ0BmaXJlYmFzZS9hcHAnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnQGZpcmViYXNlL3V0aWwnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgY29tcG9uZW50ID0gcmVxdWlyZSgnQGZpcmViYXNlL2NvbXBvbmVudCcpO1xudmFyIGxvZ2dlciA9IHJlcXVpcmUoJ0BmaXJlYmFzZS9sb2dnZXInKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQW4gZW51bSBvZiBmYWN0b3JzIHRoYXQgbWF5IGJlIHVzZWQgZm9yIG11bHRpZmFjdG9yIGF1dGhlbnRpY2F0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgRmFjdG9ySWQgPSB7XG4gICAgLyoqIFBob25lIGFzIHNlY29uZCBmYWN0b3IgKi9cbiAgICBQSE9ORTogJ3Bob25lJyxcbiAgICBUT1RQOiAndG90cCdcbn07XG4vKipcbiAqIEVudW1lcmF0aW9uIG9mIHN1cHBvcnRlZCBwcm92aWRlcnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBQcm92aWRlcklkID0ge1xuICAgIC8qKiBGYWNlYm9vayBwcm92aWRlciBJRCAqL1xuICAgIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcbiAgICAvKiogR2l0SHViIHByb3ZpZGVyIElEICovXG4gICAgR0lUSFVCOiAnZ2l0aHViLmNvbScsXG4gICAgLyoqIEdvb2dsZSBwcm92aWRlciBJRCAqL1xuICAgIEdPT0dMRTogJ2dvb2dsZS5jb20nLFxuICAgIC8qKiBQYXNzd29yZCBwcm92aWRlciAqL1xuICAgIFBBU1NXT1JEOiAncGFzc3dvcmQnLFxuICAgIC8qKiBQaG9uZSBwcm92aWRlciAqL1xuICAgIFBIT05FOiAncGhvbmUnLFxuICAgIC8qKiBUd2l0dGVyIHByb3ZpZGVyIElEICovXG4gICAgVFdJVFRFUjogJ3R3aXR0ZXIuY29tJ1xufTtcbi8qKlxuICogRW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIHNpZ24taW4gbWV0aG9kcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFNpZ25Jbk1ldGhvZCA9IHtcbiAgICAvKiogRW1haWwgbGluayBzaWduIGluIG1ldGhvZCAqL1xuICAgIEVNQUlMX0xJTks6ICdlbWFpbExpbmsnLFxuICAgIC8qKiBFbWFpbC9wYXNzd29yZCBzaWduIGluIG1ldGhvZCAqL1xuICAgIEVNQUlMX1BBU1NXT1JEOiAncGFzc3dvcmQnLFxuICAgIC8qKiBGYWNlYm9vayBzaWduIGluIG1ldGhvZCAqL1xuICAgIEZBQ0VCT09LOiAnZmFjZWJvb2suY29tJyxcbiAgICAvKiogR2l0SHViIHNpZ24gaW4gbWV0aG9kICovXG4gICAgR0lUSFVCOiAnZ2l0aHViLmNvbScsXG4gICAgLyoqIEdvb2dsZSBzaWduIGluIG1ldGhvZCAqL1xuICAgIEdPT0dMRTogJ2dvb2dsZS5jb20nLFxuICAgIC8qKiBQaG9uZSBzaWduIGluIG1ldGhvZCAqL1xuICAgIFBIT05FOiAncGhvbmUnLFxuICAgIC8qKiBUd2l0dGVyIHNpZ24gaW4gbWV0aG9kICovXG4gICAgVFdJVFRFUjogJ3R3aXR0ZXIuY29tJ1xufTtcbi8qKlxuICogRW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIG9wZXJhdGlvbiB0eXBlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IE9wZXJhdGlvblR5cGUgPSB7XG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgbGlua2luZyBhbiBhZGRpdGlvbmFsIHByb3ZpZGVyIHRvIGFuIGFscmVhZHkgc2lnbmVkLWluIHVzZXIuICovXG4gICAgTElOSzogJ2xpbmsnLFxuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHVzaW5nIGEgcHJvdmlkZXIgdG8gcmVhdXRoZW50aWNhdGUgYW4gYWxyZWFkeSBzaWduZWQtaW4gdXNlci4gKi9cbiAgICBSRUFVVEhFTlRJQ0FURTogJ3JlYXV0aGVudGljYXRlJyxcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyBzaWduaW5nIGluIGEgdXNlci4gKi9cbiAgICBTSUdOX0lOOiAnc2lnbkluJ1xufTtcbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdGhlIHBvc3NpYmxlIGVtYWlsIGFjdGlvbiB0eXBlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEFjdGlvbkNvZGVPcGVyYXRpb24gPSB7XG4gICAgLyoqIFRoZSBlbWFpbCBsaW5rIHNpZ24taW4gYWN0aW9uLiAqL1xuICAgIEVNQUlMX1NJR05JTjogJ0VNQUlMX1NJR05JTicsXG4gICAgLyoqIFRoZSBwYXNzd29yZCByZXNldCBhY3Rpb24uICovXG4gICAgUEFTU1dPUkRfUkVTRVQ6ICdQQVNTV09SRF9SRVNFVCcsXG4gICAgLyoqIFRoZSBlbWFpbCByZXZvY2F0aW9uIGFjdGlvbi4gKi9cbiAgICBSRUNPVkVSX0VNQUlMOiAnUkVDT1ZFUl9FTUFJTCcsXG4gICAgLyoqIFRoZSByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvbiBlbWFpbCBhY3Rpb24uICovXG4gICAgUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT046ICdSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTicsXG4gICAgLyoqIFRoZSByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvbiBlbWFpbCBhY3Rpb24uICovXG4gICAgVkVSSUZZX0FORF9DSEFOR0VfRU1BSUw6ICdWRVJJRllfQU5EX0NIQU5HRV9FTUFJTCcsXG4gICAgLyoqIFRoZSBlbWFpbCB2ZXJpZmljYXRpb24gYWN0aW9uLiAqL1xuICAgIFZFUklGWV9FTUFJTDogJ1ZFUklGWV9FTUFJTCdcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfZGVidWdFcnJvck1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbXCJhZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuQURNSU5fT05MWV9PUEVSQVRJT04gKi9dOiAnVGhpcyBvcGVyYXRpb24gaXMgcmVzdHJpY3RlZCB0byBhZG1pbmlzdHJhdG9ycyBvbmx5LicsXG4gICAgICAgIFtcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqL106ICcnLFxuICAgICAgICBbXCJhcHAtbm90LWF1dGhvcml6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFQUF9OT1RfQVVUSE9SSVpFRCAqL106IFwiVGhpcyBhcHAsIGlkZW50aWZpZWQgYnkgdGhlIGRvbWFpbiB3aGVyZSBpdCdzIGhvc3RlZCwgaXMgbm90IFwiICtcbiAgICAgICAgICAgICdhdXRob3JpemVkIHRvIHVzZSBGaXJlYmFzZSBBdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBBUEkga2V5LiAnICtcbiAgICAgICAgICAgICdSZXZpZXcgeW91ciBrZXkgY29uZmlndXJhdGlvbiBpbiB0aGUgR29vZ2xlIEFQSSBjb25zb2xlLicsXG4gICAgICAgIFtcImFwcC1ub3QtaW5zdGFsbGVkXCIgLyogQXV0aEVycm9yQ29kZS5BUFBfTk9UX0lOU1RBTExFRCAqL106ICdUaGUgcmVxdWVzdGVkIG1vYmlsZSBhcHBsaWNhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBpZGVudGlmaWVyICgnICtcbiAgICAgICAgICAgICdBbmRyb2lkIHBhY2thZ2UgbmFtZSBvciBpT1MgYnVuZGxlIElEKSBwcm92aWRlZCBpcyBub3QgaW5zdGFsbGVkIG9uICcgK1xuICAgICAgICAgICAgJ3RoaXMgZGV2aWNlLicsXG4gICAgICAgIFtcImNhcHRjaGEtY2hlY2stZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5DQVBUQ0hBX0NIRUNLX0ZBSUxFRCAqL106ICdUaGUgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkLCBleHBpcmVkLCAnICtcbiAgICAgICAgICAgICdhbHJlYWR5IHVzZWQgb3IgdGhlIGRvbWFpbiBhc3NvY2lhdGVkIHdpdGggaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGxpc3QgJyArXG4gICAgICAgICAgICAnb2Ygd2hpdGVsaXN0ZWQgZG9tYWlucy4nLFxuICAgICAgICBbXCJjb2RlLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRCAqL106ICdUaGUgU01TIGNvZGUgaGFzIGV4cGlyZWQuIFBsZWFzZSByZS1zZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSB0byB0cnkgJyArXG4gICAgICAgICAgICAnYWdhaW4uJyxcbiAgICAgICAgW1wiY29yZG92YS1ub3QtcmVhZHlcIiAvKiBBdXRoRXJyb3JDb2RlLkNPUkRPVkFfTk9UX1JFQURZICovXTogJ0NvcmRvdmEgZnJhbWV3b3JrIGlzIG5vdCByZWFkeS4nLFxuICAgICAgICBbXCJjb3JzLXVuc3VwcG9ydGVkXCIgLyogQXV0aEVycm9yQ29kZS5DT1JTX1VOU1VQUE9SVEVEICovXTogJ1RoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLicsXG4gICAgICAgIFtcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi9dOiAnVGhpcyBjcmVkZW50aWFsIGlzIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGEgZGlmZmVyZW50IHVzZXIgYWNjb3VudC4nLFxuICAgICAgICBbXCJjdXN0b20tdG9rZW4tbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfTUlTTUFUQ0ggKi9dOiAnVGhlIGN1c3RvbSB0b2tlbiBjb3JyZXNwb25kcyB0byBhIGRpZmZlcmVudCBhdWRpZW5jZS4nLFxuICAgICAgICBbXCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBzZW5zaXRpdmUgYW5kIHJlcXVpcmVzIHJlY2VudCBhdXRoZW50aWNhdGlvbi4gTG9nIGluICcgK1xuICAgICAgICAgICAgJ2FnYWluIGJlZm9yZSByZXRyeWluZyB0aGlzIHJlcXVlc3QuJyxcbiAgICAgICAgW1wiZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aFwiIC8qIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIICovXTogJ0Fub3RoZXIgRmlyZWJhc2UgU0RLIHdhcyBpbml0aWFsaXplZCBhbmQgaXMgdHJ5aW5nIHRvIHVzZSBBdXRoIGJlZm9yZSBBdXRoIGlzICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdzdGFydGluZyBhbnkgb3RoZXIgRmlyZWJhc2UgU0RLLicsXG4gICAgICAgIFtcImR5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkXCIgLyogQXV0aEVycm9yQ29kZS5EWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRCAqL106ICdQbGVhc2UgYWN0aXZhdGUgRHluYW1pYyBMaW5rcyBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZSBhbmQgYWdyZWUgdG8gdGhlIHRlcm1zIGFuZCAnICtcbiAgICAgICAgICAgICdjb25kaXRpb25zLicsXG4gICAgICAgIFtcImVtYWlsLWNoYW5nZS1uZWVkcy12ZXJpZmljYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0NIQU5HRV9ORUVEU19WRVJJRklDQVRJT04gKi9dOiAnTXVsdGktZmFjdG9yIHVzZXJzIG11c3QgYWx3YXlzIGhhdmUgYSB2ZXJpZmllZCBlbWFpbC4nLFxuICAgICAgICBbXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovXTogJ1RoZSBlbWFpbCBhZGRyZXNzIGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgYWNjb3VudC4nLFxuICAgICAgICBbXCJlbXVsYXRvci1jb25maWctZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5FTVVMQVRPUl9DT05GSUdfRkFJTEVEICovXTogJ0F1dGggaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkIHRvIG1ha2UgYSBuZXR3b3JrIGNhbGwuIEF1dGggY2FuICcgK1xuICAgICAgICAgICAgJ25vIGxvbmdlciBiZSBjb25maWd1cmVkIHRvIHVzZSB0aGUgZW11bGF0b3IuIFRyeSBjYWxsaW5nICcgK1xuICAgICAgICAgICAgJ1wiY29ubmVjdEF1dGhFbXVsYXRvcigpXCIgc29vbmVyLicsXG4gICAgICAgIFtcImV4cGlyZWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREUgKi9dOiAnVGhlIGFjdGlvbiBjb2RlIGhhcyBleHBpcmVkLicsXG4gICAgICAgIFtcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCIgLyogQXV0aEVycm9yQ29kZS5FWFBJUkVEX1BPUFVQX1JFUVVFU1QgKi9dOiAnVGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gY2FuY2VsbGVkIGR1ZSB0byBhbm90aGVyIGNvbmZsaWN0aW5nIHBvcHVwIGJlaW5nIG9wZW5lZC4nLFxuICAgICAgICBbXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMICovXTogJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBjb250YWlucyBhbiBpbnZhbGlkIGFwcGxpY2F0aW9uIHZlcmlmaWVyLicgK1xuICAgICAgICAgICAgJyBUaGUgcmVDQVBUQ0hBIHRva2VuIHJlc3BvbnNlIGlzIGVpdGhlciBpbnZhbGlkIG9yIGV4cGlyZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hcHAtaWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBQX0lEICovXTogJ1RoZSBtb2JpbGUgYXBwIGlkZW50aWZpZXIgaXMgbm90IHJlZ2lzdGVyZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcbiAgICAgICAgW1wiaW52YWxpZC11c2VyLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FVVEggKi9dOiBcIlRoaXMgdXNlcidzIGNyZWRlbnRpYWwgaXNuJ3QgdmFsaWQgZm9yIHRoaXMgcHJvamVjdC4gVGhpcyBjYW4gaGFwcGVuIFwiICtcbiAgICAgICAgICAgIFwiaWYgdGhlIHVzZXIncyB0b2tlbiBoYXMgYmVlbiB0YW1wZXJlZCB3aXRoLCBvciBpZiB0aGUgdXNlciBpc24ndCBmb3IgXCIgK1xuICAgICAgICAgICAgJ3RoZSBwcm9qZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFQSSBrZXkuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hdXRoLWV2ZW50XCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FVVEhfRVZFTlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPREUgKi9dOiAnVGhlIFNNUyB2ZXJpZmljYXRpb24gY29kZSB1c2VkIHRvIGNyZWF0ZSB0aGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIGlzICcgK1xuICAgICAgICAgICAgJ2ludmFsaWQuIFBsZWFzZSByZXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHNtcyBhbmQgYmUgc3VyZSB0byB1c2UgdGhlICcgK1xuICAgICAgICAgICAgJ3ZlcmlmaWNhdGlvbiBjb2RlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLicsXG4gICAgICAgIFtcImludmFsaWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSSAqL106ICdUaGUgY29udGludWUgVVJMIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0IGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09SRE9WQV9DT05GSUdVUkFUSU9OICovXTogJ1RoZSBmb2xsb3dpbmcgQ29yZG92YSBwbHVnaW5zIG11c3QgYmUgaW5zdGFsbGVkIHRvIGVuYWJsZSBPQXV0aCBzaWduLWluOiAnICtcbiAgICAgICAgICAgICdjb3Jkb3ZhLXBsdWdpbi1idWlsZGluZm8sIGNvcmRvdmEtdW5pdmVyc2FsLWxpbmtzLXBsdWdpbiwgJyArXG4gICAgICAgICAgICAnY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiwgY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGFuZCAnICtcbiAgICAgICAgICAgICdjb3Jkb3ZhLXBsdWdpbi1jdXN0b211cmxzY2hlbWUuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jdXN0b20tdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1VTVE9NX1RPS0VOICovXTogJ1RoZSBjdXN0b20gdG9rZW4gZm9ybWF0IGlzIGluY29ycmVjdC4gUGxlYXNlIGNoZWNrIHRoZSBkb2N1bWVudGF0aW9uLicsXG4gICAgICAgIFtcImludmFsaWQtZHluYW1pYy1saW5rLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9EWU5BTUlDX0xJTktfRE9NQUlOICovXTogJ1RoZSBwcm92aWRlZCBkeW5hbWljIGxpbmsgZG9tYWluIGlzIG5vdCBjb25maWd1cmVkIG9yIGF1dGhvcml6ZWQgZm9yIHRoZSBjdXJyZW50IHByb2plY3QuJyxcbiAgICAgICAgW1wiaW52YWxpZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTUFJTCAqL106ICdUaGUgZW1haWwgYWRkcmVzcyBpcyBiYWRseSBmb3JtYXR0ZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1lbXVsYXRvci1zY2hlbWVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1VTEFUT1JfU0NIRU1FICovXTogJ0VtdWxhdG9yIFVSTCBtdXN0IHN0YXJ0IHdpdGggYSB2YWxpZCBzY2hlbWUgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pLicsXG4gICAgICAgIFtcImludmFsaWQtYXBpLWtleVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUElfS0VZICovXTogJ1lvdXIgQVBJIGtleSBpcyBpbnZhbGlkLCBwbGVhc2UgY2hlY2sgeW91IGhhdmUgY29waWVkIGl0IGNvcnJlY3RseS4nLFxuICAgICAgICBbXCJpbnZhbGlkLWNlcnQtaGFzaFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DRVJUX0hBU0ggKi9dOiAnVGhlIFNIQS0xIGNlcnRpZmljYXRlIGhhc2ggcHJvdmlkZWQgaXMgaW52YWxpZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqL106ICdUaGUgc3VwcGxpZWQgYXV0aCBjcmVkZW50aWFsIGlzIGluY29ycmVjdCwgbWFsZm9ybWVkIG9yIGhhcyBleHBpcmVkLicsXG4gICAgICAgIFtcImludmFsaWQtbWVzc2FnZS1wYXlsb2FkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0VfUEFZTE9BRCAqL106ICdUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gaXRzIG1lc3NhZ2UuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuJyxcbiAgICAgICAgW1wiaW52YWxpZC1tdWx0aS1mYWN0b3Itc2Vzc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9NRkFfU0VTU0lPTiAqL106ICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgcHJvb2Ygb2YgZmlyc3QgZmFjdG9yIHN1Y2Nlc3NmdWwgc2lnbi1pbi4nLFxuICAgICAgICBbXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX1BST1ZJREVSICovXTogJ0VtYWlsQXV0aFByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgb3BlcmF0aW9uLiBUaGlzIG9wZXJhdGlvbiAnICtcbiAgICAgICAgICAgICdvbmx5IHN1cHBvcnRzIE9BdXRoIHByb3ZpZGVycy4nLFxuICAgICAgICBbXCJpbnZhbGlkLW9hdXRoLWNsaWVudC1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQgKi9dOiAnVGhlIE9BdXRoIGNsaWVudCBJRCBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCBvciBkb2VzIG5vdCBtYXRjaCB0aGUgJyArXG4gICAgICAgICAgICAnc3BlY2lmaWVkIEFQSSBrZXkuJyxcbiAgICAgICAgW1widW5hdXRob3JpemVkLWRvbWFpblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PUklHSU4gKi9dOiAnVGhpcyBkb21haW4gaXMgbm90IGF1dGhvcml6ZWQgZm9yIE9BdXRoIG9wZXJhdGlvbnMgZm9yIHlvdXIgRmlyZWJhc2UgJyArXG4gICAgICAgICAgICAncHJvamVjdC4gRWRpdCB0aGUgbGlzdCBvZiBhdXRob3JpemVkIGRvbWFpbnMgZnJvbSB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgICAgICBbXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovXTogJ1RoZSBhY3Rpb24gY29kZSBpcyBpbnZhbGlkLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGNvZGUgaXMgbWFsZm9ybWVkLCAnICtcbiAgICAgICAgICAgICdleHBpcmVkLCBvciBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuJyxcbiAgICAgICAgW1wid3JvbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEFTU1dPUkQgKi9dOiAnVGhlIHBhc3N3b3JkIGlzIGludmFsaWQgb3IgdGhlIHVzZXIgZG9lcyBub3QgaGF2ZSBhIHBhc3N3b3JkLicsXG4gICAgICAgIFtcImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QRVJTSVNURU5DRSAqL106ICdUaGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUgaXMgaW52YWxpZC4gSXQgY2FuIG9ubHkgYmUgbG9jYWwsIHNlc3Npb24gb3Igbm9uZS4nLFxuICAgICAgICBbXCJpbnZhbGlkLXBob25lLW51bWJlclwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QSE9ORV9OVU1CRVIgKi9dOiAnVGhlIGZvcm1hdCBvZiB0aGUgcGhvbmUgbnVtYmVyIHByb3ZpZGVkIGlzIGluY29ycmVjdC4gUGxlYXNlIGVudGVyIHRoZSAnICtcbiAgICAgICAgICAgICdwaG9uZSBudW1iZXIgaW4gYSBmb3JtYXQgdGhhdCBjYW4gYmUgcGFyc2VkIGludG8gRS4xNjQgZm9ybWF0LiBFLjE2NCAnICtcbiAgICAgICAgICAgICdwaG9uZSBudW1iZXJzIGFyZSB3cml0dGVuIGluIHRoZSBmb3JtYXQgWytdW2NvdW50cnkgY29kZV1bc3Vic2NyaWJlciAnICtcbiAgICAgICAgICAgICdudW1iZXIgaW5jbHVkaW5nIGFyZWEgY29kZV0uJyxcbiAgICAgICAgW1wiaW52YWxpZC1wcm92aWRlci1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QUk9WSURFUl9JRCAqL106ICdUaGUgc3BlY2lmaWVkIHByb3ZpZGVyIElEIGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1yZWNpcGllbnQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDSVBJRU5UX0VNQUlMICovXTogJ1RoZSBlbWFpbCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGZhaWxlZCB0byBzZW5kIGFzIHRoZSBwcm92aWRlZCAnICtcbiAgICAgICAgICAgICdyZWNpcGllbnQgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtc2VuZGVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFTkRFUiAqL106ICdUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIHNlbmRlciBlbWFpbCBvciBuYW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLicsXG4gICAgICAgIFtcImludmFsaWQtdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GTyAqL106ICdUaGUgdmVyaWZpY2F0aW9uIElEIHVzZWQgdG8gY3JlYXRlIHRoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgaXMgaW52YWxpZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXRlbmFudC1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9URU5BTlRfSUQgKi9dOiBcIlRoZSBBdXRoIGluc3RhbmNlJ3MgdGVuYW50IElEIGlzIGludmFsaWQuXCIsXG4gICAgICAgIFtcImxvZ2luLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRUQgKi9dOiAnTG9naW4gYmxvY2tlZCBieSB1c2VyLXByb3ZpZGVkIG1ldGhvZDogeyRvcmlnaW5hbE1lc3NhZ2V9JyxcbiAgICAgICAgW1wibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovXTogJ0FuIEFuZHJvaWQgUGFja2FnZSBOYW1lIG11c3QgYmUgcHJvdmlkZWQgaWYgdGhlIEFuZHJvaWQgQXBwIGlzIHJlcXVpcmVkIHRvIGJlIGluc3RhbGxlZC4nLFxuICAgICAgICBbXCJhdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQVVUSF9ET01BSU4gKi9dOiAnQmUgc3VyZSB0byBpbmNsdWRlIGF1dGhEb21haW4gd2hlbiBjYWxsaW5nIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKSwgJyArXG4gICAgICAgICAgICAnYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcbiAgICAgICAgW1wibWlzc2luZy1hcHAtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BUFBfQ1JFREVOVElBTCAqL106ICdUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgbWlzc2luZyBhbiBhcHBsaWNhdGlvbiB2ZXJpZmllciAnICtcbiAgICAgICAgICAgICdhc3NlcnRpb24uIEEgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLicsXG4gICAgICAgIFtcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ09ERSAqL106ICdUaGUgcGhvbmUgYXV0aCBjcmVkZW50aWFsIHdhcyBjcmVhdGVkIHdpdGggYW4gZW1wdHkgU01TIHZlcmlmaWNhdGlvbiBjb2RlLicsXG4gICAgICAgIFtcIm1pc3NpbmctY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NPTlRJTlVFX1VSSSAqL106ICdBIGNvbnRpbnVlIFVSTCBtdXN0IGJlIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0LicsXG4gICAgICAgIFtcIm1pc3NpbmctaWZyYW1lLXN0YXJ0XCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lGUkFNRV9TVEFSVCAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgICAgIFtcIm1pc3NpbmctaW9zLWJ1bmRsZS1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEICovXTogJ0FuIGlPUyBCdW5kbGUgSUQgbXVzdCBiZSBwcm92aWRlZCBpZiBhbiBBcHAgU3RvcmUgSUQgaXMgcHJvdmlkZWQuJyxcbiAgICAgICAgW1wibWlzc2luZy1vci1pbnZhbGlkLW5vbmNlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX09SX0lOVkFMSURfTk9OQ0UgKi9dOiAnVGhlIHJlcXVlc3QgZG9lcyBub3QgY29udGFpbiBhIHZhbGlkIG5vbmNlLiBUaGlzIGNhbiBvY2N1ciBpZiB0aGUgJyArXG4gICAgICAgICAgICAnU0hBLTI1NiBoYXNoIG9mIHRoZSBwcm92aWRlZCByYXcgbm9uY2UgZG9lcyBub3QgbWF0Y2ggdGhlIGhhc2hlZCBub25jZSAnICtcbiAgICAgICAgICAgICdpbiB0aGUgSUQgdG9rZW4gcGF5bG9hZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BBU1NXT1JEICovXTogJ0Egbm9uLWVtcHR5IHBhc3N3b3JkIG11c3QgYmUgcHJvdmlkZWQnLFxuICAgICAgICBbXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1pbmZvXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9JTkZPICovXTogJ05vIHNlY29uZCBmYWN0b3IgaWRlbnRpZmllciBpcyBwcm92aWRlZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9TRVNTSU9OICovXTogJ1RoZSByZXF1ZXN0IGlzIG1pc3NpbmcgcHJvb2Ygb2YgZmlyc3QgZmFjdG9yIHN1Y2Nlc3NmdWwgc2lnbi1pbi4nLFxuICAgICAgICBbXCJtaXNzaW5nLXBob25lLW51bWJlclwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QSE9ORV9OVU1CRVIgKi9dOiAnVG8gc2VuZCB2ZXJpZmljYXRpb24gY29kZXMsIHByb3ZpZGUgYSBwaG9uZSBudW1iZXIgZm9yIHRoZSByZWNpcGllbnQuJyxcbiAgICAgICAgW1wibWlzc2luZy12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPICovXTogJ1RoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgd2FzIGNyZWF0ZWQgd2l0aCBhbiBlbXB0eSB2ZXJpZmljYXRpb24gSUQuJyxcbiAgICAgICAgW1wiYXBwLWRlbGV0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1PRFVMRV9ERVNUUk9ZRUQgKi9dOiAnVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLicsXG4gICAgICAgIFtcIm11bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX0lORk9fTk9UX0ZPVU5EICovXTogJ1RoZSB1c2VyIGRvZXMgbm90IGhhdmUgYSBzZWNvbmQgZmFjdG9yIG1hdGNoaW5nIHRoZSBpZGVudGlmaWVyIHByb3ZpZGVkLicsXG4gICAgICAgIFtcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi9dOiAnUHJvb2Ygb2Ygb3duZXJzaGlwIG9mIGEgc2Vjb25kIGZhY3RvciBpcyByZXF1aXJlZCB0byBjb21wbGV0ZSBzaWduLWluLicsXG4gICAgICAgIFtcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovXTogJ0FuIGFjY291bnQgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGUgc2FtZSBlbWFpbCBhZGRyZXNzIGJ1dCBkaWZmZXJlbnQgJyArXG4gICAgICAgICAgICAnc2lnbi1pbiBjcmVkZW50aWFscy4gU2lnbiBpbiB1c2luZyBhIHByb3ZpZGVyIGFzc29jaWF0ZWQgd2l0aCB0aGlzICcgK1xuICAgICAgICAgICAgJ2VtYWlsIGFkZHJlc3MuJyxcbiAgICAgICAgW1wibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqL106ICdBIG5ldHdvcmsgQXV0aEVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLicsXG4gICAgICAgIFtcIm5vLWF1dGgtZXZlbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk5PX0FVVEhfRVZFTlQgKi9dOiAnQW4gaW50ZXJuYWwgQXV0aEVycm9yIGhhcyBvY2N1cnJlZC4nLFxuICAgICAgICBbXCJuby1zdWNoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSICovXTogJ1VzZXIgd2FzIG5vdCBsaW5rZWQgdG8gYW4gYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBwcm92aWRlci4nLFxuICAgICAgICBbXCJudWxsLXVzZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk5VTExfVVNFUiAqL106ICdBIG51bGwgdXNlciBvYmplY3Qgd2FzIHByb3ZpZGVkIGFzIHRoZSBhcmd1bWVudCBmb3IgYW4gb3BlcmF0aW9uIHdoaWNoICcgK1xuICAgICAgICAgICAgJ3JlcXVpcmVzIGEgbm9uLW51bGwgdXNlciBvYmplY3QuJyxcbiAgICAgICAgW1wib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX0FMTE9XRUQgKi9dOiAnVGhlIGdpdmVuIHNpZ24taW4gcHJvdmlkZXIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgRmlyZWJhc2UgcHJvamVjdC4gJyArXG4gICAgICAgICAgICAnRW5hYmxlIGl0IGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLCB1bmRlciB0aGUgc2lnbi1pbiBtZXRob2QgdGFiIG9mIHRoZSAnICtcbiAgICAgICAgICAgICdBdXRoIHNlY3Rpb24uJyxcbiAgICAgICAgW1wib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURUQgKi9dOiAnVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgZW52aXJvbm1lbnQgdGhpcyBhcHBsaWNhdGlvbiBpcyAnICtcbiAgICAgICAgICAgICdydW5uaW5nIG9uLiBcImxvY2F0aW9uLnByb3RvY29sXCIgbXVzdCBiZSBodHRwLCBodHRwcyBvciBjaHJvbWUtZXh0ZW5zaW9uJyArXG4gICAgICAgICAgICAnIGFuZCB3ZWIgc3RvcmFnZSBtdXN0IGJlIGVuYWJsZWQuJyxcbiAgICAgICAgW1wicG9wdXAtYmxvY2tlZFwiIC8qIEF1dGhFcnJvckNvZGUuUE9QVVBfQkxPQ0tFRCAqL106ICdVbmFibGUgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBwb3B1cC4gSXQgbWF5IGhhdmUgYmVlbiBibG9ja2VkIGJ5IHRoZSBicm93c2VyLicsXG4gICAgICAgIFtcInBvcHVwLWNsb3NlZC1ieS11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5QT1BVUF9DTE9TRURfQllfVVNFUiAqL106ICdUaGUgcG9wdXAgaGFzIGJlZW4gY2xvc2VkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nIHRoZSBvcGVyYXRpb24uJyxcbiAgICAgICAgW1wicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBST1ZJREVSX0FMUkVBRFlfTElOS0VEICovXTogJ1VzZXIgY2FuIG9ubHkgYmUgbGlua2VkIHRvIG9uZSBpZGVudGl0eSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLicsXG4gICAgICAgIFtcInF1b3RhLWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5RVU9UQV9FWENFRURFRCAqL106IFwiVGhlIHByb2plY3QncyBxdW90YSBmb3IgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gZXhjZWVkZWQuXCIsXG4gICAgICAgIFtcInJlZGlyZWN0LWNhbmNlbGxlZC1ieS11c2VyXCIgLyogQXV0aEVycm9yQ29kZS5SRURJUkVDVF9DQU5DRUxMRURfQllfVVNFUiAqL106ICdUaGUgcmVkaXJlY3Qgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBieSB0aGUgdXNlciBiZWZvcmUgZmluYWxpemluZy4nLFxuICAgICAgICBbXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiIC8qIEF1dGhFcnJvckNvZGUuUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkcgKi9dOiAnQSByZWRpcmVjdCBzaWduLWluIG9wZXJhdGlvbiBpcyBhbHJlYWR5IHBlbmRpbmcuJyxcbiAgICAgICAgW1wicmVqZWN0ZWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuUkVKRUNURURfQ1JFREVOVElBTCAqL106ICdUaGUgcmVxdWVzdCBjb250YWlucyBtYWxmb3JtZWQgb3IgbWlzbWF0Y2hpbmcgY3JlZGVudGlhbHMuJyxcbiAgICAgICAgW1wic2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEICovXTogJ1RoZSBzZWNvbmQgZmFjdG9yIGlzIGFscmVhZHkgZW5yb2xsZWQgb24gdGhpcyBhY2NvdW50LicsXG4gICAgICAgIFtcIm1heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqL106ICdUaGUgbWF4aW11bSBhbGxvd2VkIG51bWJlciBvZiBzZWNvbmQgZmFjdG9ycyBvbiBhIHVzZXIgaGFzIGJlZW4gZXhjZWVkZWQuJyxcbiAgICAgICAgW1widGVuYW50LWlkLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0ggKi9dOiBcIlRoZSBwcm92aWRlZCB0ZW5hbnQgSUQgZG9lcyBub3QgbWF0Y2ggdGhlIEF1dGggaW5zdGFuY2UncyB0ZW5hbnQgSURcIixcbiAgICAgICAgW1widGltZW91dFwiIC8qIEF1dGhFcnJvckNvZGUuVElNRU9VVCAqL106ICdUaGUgb3BlcmF0aW9uIGhhcyB0aW1lZCBvdXQuJyxcbiAgICAgICAgW1widXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovXTogXCJUaGUgdXNlcidzIGNyZWRlbnRpYWwgaXMgbm8gbG9uZ2VyIHZhbGlkLiBUaGUgdXNlciBtdXN0IHNpZ24gaW4gYWdhaW4uXCIsXG4gICAgICAgIFtcInRvby1tYW55LXJlcXVlc3RzXCIgLyogQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi9dOiAnV2UgaGF2ZSBibG9ja2VkIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgZGV2aWNlIGR1ZSB0byB1bnVzdWFsIGFjdGl2aXR5LiAnICtcbiAgICAgICAgICAgICdUcnkgYWdhaW4gbGF0ZXIuJyxcbiAgICAgICAgW1widW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTiAqL106ICdUaGUgZG9tYWluIG9mIHRoZSBjb250aW51ZSBVUkwgaXMgbm90IHdoaXRlbGlzdGVkLiAgUGxlYXNlIHdoaXRlbGlzdCAnICtcbiAgICAgICAgICAgICd0aGUgZG9tYWluIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLWZpcnN0LWZhY3RvclwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfRklSU1RfRkFDVE9SICovXTogJ0Vucm9sbGluZyBhIHNlY29uZCBmYWN0b3Igb3Igc2lnbmluZyBpbiB3aXRoIGEgbXVsdGktZmFjdG9yIGFjY291bnQgcmVxdWlyZXMgc2lnbi1pbiB3aXRoIGEgc3VwcG9ydGVkIGZpcnN0IGZhY3Rvci4nLFxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QRVJTSVNURU5DRSAqL106ICdUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzcGVjaWZpZWQgcGVyc2lzdGVuY2UgdHlwZS4nLFxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC10ZW5hbnQtb3BlcmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYSBtdWx0aS10ZW5hbnQgY29udGV4dC4nLFxuICAgICAgICBbXCJ1bnZlcmlmaWVkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5VTlZFUklGSUVEX0VNQUlMICovXTogJ1RoZSBvcGVyYXRpb24gcmVxdWlyZXMgYSB2ZXJpZmllZCBlbWFpbC4nLFxuICAgICAgICBbXCJ1c2VyLWNhbmNlbGxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9DQU5DRUxMRUQgKi9dOiAnVGhlIHVzZXIgZGlkIG5vdCBncmFudCB5b3VyIGFwcGxpY2F0aW9uIHRoZSBwZXJtaXNzaW9ucyBpdCByZXF1ZXN0ZWQuJyxcbiAgICAgICAgW1widXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqL106ICdUaGVyZSBpcyBubyB1c2VyIHJlY29yZCBjb3JyZXNwb25kaW5nIHRvIHRoaXMgaWRlbnRpZmllci4gVGhlIHVzZXIgbWF5ICcgK1xuICAgICAgICAgICAgJ2hhdmUgYmVlbiBkZWxldGVkLicsXG4gICAgICAgIFtcInVzZXItZGlzYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUQgKi9dOiAnVGhlIHVzZXIgYWNjb3VudCBoYXMgYmVlbiBkaXNhYmxlZCBieSBhbiBhZG1pbmlzdHJhdG9yLicsXG4gICAgICAgIFtcInVzZXItbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0ggKi9dOiAnVGhlIHN1cHBsaWVkIGNyZWRlbnRpYWxzIGRvIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBwcmV2aW91c2x5IHNpZ25lZCBpbiB1c2VyLicsXG4gICAgICAgIFtcInVzZXItc2lnbmVkLW91dFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9TSUdORURfT1VUICovXTogJycsXG4gICAgICAgIFtcIndlYWstcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLldFQUtfUEFTU1dPUkQgKi9dOiAnVGhlIHBhc3N3b3JkIG11c3QgYmUgNiBjaGFyYWN0ZXJzIGxvbmcgb3IgbW9yZS4nLFxuICAgICAgICBbXCJ3ZWItc3RvcmFnZS11bnN1cHBvcnRlZFwiIC8qIEF1dGhFcnJvckNvZGUuV0VCX1NUT1JBR0VfVU5TVVBQT1JURUQgKi9dOiAnVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQgb3IgM3JkIHBhcnR5IGNvb2tpZXMgYW5kIGRhdGEgbWF5IGJlIGRpc2FibGVkLicsXG4gICAgICAgIFtcImFscmVhZHktaW5pdGlhbGl6ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFMUkVBRFlfSU5JVElBTElaRUQgKi9dOiAnaW5pdGlhbGl6ZUF1dGgoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgJ2RpZmZlcmVudCBvcHRpb25zLiBUbyBhdm9pZCB0aGlzIGVycm9yLCBjYWxsIGluaXRpYWxpemVBdXRoKCkgd2l0aCB0aGUgJyArXG4gICAgICAgICAgICAnc2FtZSBvcHRpb25zIGFzIHdoZW4gaXQgd2FzIG9yaWdpbmFsbHkgY2FsbGVkLCBvciBjYWxsIGdldEF1dGgoKSB0byByZXR1cm4gdGhlJyArXG4gICAgICAgICAgICAnIGFscmVhZHkgaW5pdGlhbGl6ZWQgaW5zdGFuY2UuJyxcbiAgICAgICAgW1wibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovXTogJ1RoZSByZUNBUFRDSEEgdG9rZW4gaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gKi9dOiAnVGhlIHJlQ0FQVENIQSB0b2tlbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLWFjdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OICovXTogJ1RoZSByZUNBUFRDSEEgYWN0aW9uIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wicmVjYXB0Y2hhLW5vdC1lbmFibGVkXCIgLyogQXV0aEVycm9yQ29kZS5SRUNBUFRDSEFfTk9UX0VOQUJMRUQgKi9dOiAncmVDQVBUQ0hBIEVudGVycHJpc2UgaW50ZWdyYXRpb24gaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgcHJvamVjdC4nLFxuICAgICAgICBbXCJtaXNzaW5nLWNsaWVudC10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0NMSUVOVF9UWVBFICovXTogJ1RoZSByZUNBUFRDSEEgY2xpZW50IHR5cGUgaXMgbWlzc2luZyB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OICovXTogJ1RoZSByZUNBUFRDSEEgdmVyc2lvbiBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcImludmFsaWQtcmVxLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEUgKi9dOiAnSW52YWxpZCByZXF1ZXN0IHBhcmFtZXRlcnMuJyxcbiAgICAgICAgW1wiaW52YWxpZC1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTiAqL106ICdUaGUgcmVDQVBUQ0hBIHZlcnNpb24gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqL106ICdUaGUgcGFzc3dvcmQgcG9saWN5IHJlY2VpdmVkIGZyb20gdGhlIGJhY2tlbmQgdXNlcyBhIHNjaGVtYSB2ZXJzaW9uIHRoYXQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIEZpcmViYXNlIFNESy4nLFxuICAgICAgICBbXCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi9dOiAnVGhlIHBhc3N3b3JkIGRvZXMgbm90IG1lZXQgdGhlIHJlcXVpcmVtZW50cy4nXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9wcm9kRXJyb3JNYXAoKSB7XG4gICAgLy8gV2Ugd2lsbCBpbmNsdWRlIHRoaXMgb25lIG1lc3NhZ2UgaW4gdGhlIHByb2QgZXJyb3IgbWFwIHNpbmNlIGJ5IHRoZSB2ZXJ5XG4gICAgLy8gbmF0dXJlIG9mIHRoaXMgZXJyb3IsIGRldmVsb3BlcnMgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHNlZSB0aGUgbWVzc2FnZVxuICAgIC8vIHVzaW5nIHRoZSBkZWJ1Z0Vycm9yTWFwICh3aGljaCBpcyBpbnN0YWxsZWQgZHVyaW5nIGF1dGggaW5pdGlhbGl6YXRpb24pLlxuICAgIHJldHVybiB7XG4gICAgICAgIFtcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqL106ICdBbm90aGVyIEZpcmViYXNlIFNESyB3YXMgaW5pdGlhbGl6ZWQgYW5kIGlzIHRyeWluZyB0byB1c2UgQXV0aCBiZWZvcmUgQXV0aCBpcyAnICtcbiAgICAgICAgICAgICdpbml0aWFsaXplZC4gUGxlYXNlIGJlIHN1cmUgdG8gY2FsbCBgaW5pdGlhbGl6ZUF1dGhgIG9yIGBnZXRBdXRoYCBiZWZvcmUgJyArXG4gICAgICAgICAgICAnc3RhcnRpbmcgYW55IG90aGVyIEZpcmViYXNlIFNESy4nXG4gICAgfTtcbn1cbi8qKlxuICogQSB2ZXJib3NlIGVycm9yIG1hcCB3aXRoIGRldGFpbGVkIGRlc2NyaXB0aW9ucyBmb3IgbW9zdCBlcnJvciBjb2Rlcy5cbiAqXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZGVidWdFcnJvck1hcCA9IF9kZWJ1Z0Vycm9yTWFwO1xuLyoqXG4gKiBBIG1pbmltYWwgZXJyb3IgbWFwIHdpdGggYWxsIHZlcmJvc2UgZXJyb3IgbWVzc2FnZXMgc3RyaXBwZWQuXG4gKlxuICogU2VlIGRpc2N1c3Npb24gYXQge0BsaW5rIEF1dGhFcnJvck1hcH1cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHByb2RFcnJvck1hcCA9IF9wcm9kRXJyb3JNYXA7XG5jb25zdCBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlkgPSBuZXcgdXRpbC5FcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBfcHJvZEVycm9yTWFwKCkpO1xuLyoqXG4gKiBBIG1hcCBvZiBwb3RlbnRpYWwgYEF1dGhgIGVycm9yIGNvZGVzLCBmb3IgZWFzaWVyIGNvbXBhcmlzb24gd2l0aCBlcnJvcnNcbiAqIHRocm93biBieSB0aGUgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBOb3RlIHRoYXQgeW91IGNhbid0IHRyZWUtc2hha2UgaW5kaXZpZHVhbCBrZXlzXG4gKiBpbiB0aGUgbWFwLCBzbyBieSB1c2luZyB0aGUgbWFwIHlvdSBtaWdodCBzdWJzdGFudGlhbGx5IGluY3JlYXNlIHlvdXJcbiAqIGJ1bmRsZSBzaXplLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgQVVUSF9FUlJPUl9DT0RFU19NQVBfRE9fTk9UX1VTRV9JTlRFUk5BTExZID0ge1xuICAgIEFETUlOX09OTFlfT1BFUkFUSU9OOiAnYXV0aC9hZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXG4gICAgQVJHVU1FTlRfRVJST1I6ICdhdXRoL2FyZ3VtZW50LWVycm9yJyxcbiAgICBBUFBfTk9UX0FVVEhPUklaRUQ6ICdhdXRoL2FwcC1ub3QtYXV0aG9yaXplZCcsXG4gICAgQVBQX05PVF9JTlNUQUxMRUQ6ICdhdXRoL2FwcC1ub3QtaW5zdGFsbGVkJyxcbiAgICBDQVBUQ0hBX0NIRUNLX0ZBSUxFRDogJ2F1dGgvY2FwdGNoYS1jaGVjay1mYWlsZWQnLFxuICAgIENPREVfRVhQSVJFRDogJ2F1dGgvY29kZS1leHBpcmVkJyxcbiAgICBDT1JET1ZBX05PVF9SRUFEWTogJ2F1dGgvY29yZG92YS1ub3QtcmVhZHknLFxuICAgIENPUlNfVU5TVVBQT1JURUQ6ICdhdXRoL2NvcnMtdW5zdXBwb3J0ZWQnLFxuICAgIENSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0U6ICdhdXRoL2NyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2UnLFxuICAgIENSRURFTlRJQUxfTUlTTUFUQ0g6ICdhdXRoL2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXG4gICAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOiAnYXV0aC9yZXF1aXJlcy1yZWNlbnQtbG9naW4nLFxuICAgIERFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSDogJ2F1dGgvZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aCcsXG4gICAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQ6ICdhdXRoL2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcbiAgICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OOiAnYXV0aC9lbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uJyxcbiAgICBFTUFJTF9FWElTVFM6ICdhdXRoL2VtYWlsLWFscmVhZHktaW4tdXNlJyxcbiAgICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEOiAnYXV0aC9lbXVsYXRvci1jb25maWctZmFpbGVkJyxcbiAgICBFWFBJUkVEX09PQl9DT0RFOiAnYXV0aC9leHBpcmVkLWFjdGlvbi1jb2RlJyxcbiAgICBFWFBJUkVEX1BPUFVQX1JFUVVFU1Q6ICdhdXRoL2NhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0JyxcbiAgICBJTlRFUk5BTF9FUlJPUjogJ2F1dGgvaW50ZXJuYWwtZXJyb3InLFxuICAgIElOVkFMSURfQVBJX0tFWTogJ2F1dGgvaW52YWxpZC1hcGkta2V5JyxcbiAgICBJTlZBTElEX0FQUF9DUkVERU5USUFMOiAnYXV0aC9pbnZhbGlkLWFwcC1jcmVkZW50aWFsJyxcbiAgICBJTlZBTElEX0FQUF9JRDogJ2F1dGgvaW52YWxpZC1hcHAtaWQnLFxuICAgIElOVkFMSURfQVVUSDogJ2F1dGgvaW52YWxpZC11c2VyLXRva2VuJyxcbiAgICBJTlZBTElEX0FVVEhfRVZFTlQ6ICdhdXRoL2ludmFsaWQtYXV0aC1ldmVudCcsXG4gICAgSU5WQUxJRF9DRVJUX0hBU0g6ICdhdXRoL2ludmFsaWQtY2VydC1oYXNoJyxcbiAgICBJTlZBTElEX0NPREU6ICdhdXRoL2ludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGUnLFxuICAgIElOVkFMSURfQ09OVElOVUVfVVJJOiAnYXV0aC9pbnZhbGlkLWNvbnRpbnVlLXVyaScsXG4gICAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT046ICdhdXRoL2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcbiAgICBJTlZBTElEX0NVU1RPTV9UT0tFTjogJ2F1dGgvaW52YWxpZC1jdXN0b20tdG9rZW4nLFxuICAgIElOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTjogJ2F1dGgvaW52YWxpZC1keW5hbWljLWxpbmstZG9tYWluJyxcbiAgICBJTlZBTElEX0VNQUlMOiAnYXV0aC9pbnZhbGlkLWVtYWlsJyxcbiAgICBJTlZBTElEX0VNVUxBVE9SX1NDSEVNRTogJ2F1dGgvaW52YWxpZC1lbXVsYXRvci1zY2hlbWUnLFxuICAgIElOVkFMSURfSURQX1JFU1BPTlNFOiAnYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWwnLFxuICAgIElOVkFMSURfTE9HSU5fQ1JFREVOVElBTFM6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXG4gICAgSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6ICdhdXRoL2ludmFsaWQtbWVzc2FnZS1wYXlsb2FkJyxcbiAgICBJTlZBTElEX01GQV9TRVNTSU9OOiAnYXV0aC9pbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcbiAgICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRDogJ2F1dGgvaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxuICAgIElOVkFMSURfT0FVVEhfUFJPVklERVI6ICdhdXRoL2ludmFsaWQtb2F1dGgtcHJvdmlkZXInLFxuICAgIElOVkFMSURfT09CX0NPREU6ICdhdXRoL2ludmFsaWQtYWN0aW9uLWNvZGUnLFxuICAgIElOVkFMSURfT1JJR0lOOiAnYXV0aC91bmF1dGhvcml6ZWQtZG9tYWluJyxcbiAgICBJTlZBTElEX1BBU1NXT1JEOiAnYXV0aC93cm9uZy1wYXNzd29yZCcsXG4gICAgSU5WQUxJRF9QRVJTSVNURU5DRTogJ2F1dGgvaW52YWxpZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgICBJTlZBTElEX1BIT05FX05VTUJFUjogJ2F1dGgvaW52YWxpZC1waG9uZS1udW1iZXInLFxuICAgIElOVkFMSURfUFJPVklERVJfSUQ6ICdhdXRoL2ludmFsaWQtcHJvdmlkZXItaWQnLFxuICAgIElOVkFMSURfUkVDSVBJRU5UX0VNQUlMOiAnYXV0aC9pbnZhbGlkLXJlY2lwaWVudC1lbWFpbCcsXG4gICAgSU5WQUxJRF9TRU5ERVI6ICdhdXRoL2ludmFsaWQtc2VuZGVyJyxcbiAgICBJTlZBTElEX1NFU1NJT05fSU5GTzogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24taWQnLFxuICAgIElOVkFMSURfVEVOQU5UX0lEOiAnYXV0aC9pbnZhbGlkLXRlbmFudC1pZCcsXG4gICAgTUZBX0lORk9fTk9UX0ZPVU5EOiAnYXV0aC9tdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxuICAgIE1GQV9SRVFVSVJFRDogJ2F1dGgvbXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWQnLFxuICAgIE1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUU6ICdhdXRoL21pc3NpbmctYW5kcm9pZC1wa2ctbmFtZScsXG4gICAgTUlTU0lOR19BUFBfQ1JFREVOVElBTDogJ2F1dGgvbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXG4gICAgTUlTU0lOR19BVVRIX0RPTUFJTjogJ2F1dGgvYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkJyxcbiAgICBNSVNTSU5HX0NPREU6ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGUnLFxuICAgIE1JU1NJTkdfQ09OVElOVUVfVVJJOiAnYXV0aC9taXNzaW5nLWNvbnRpbnVlLXVyaScsXG4gICAgTUlTU0lOR19JRlJBTUVfU1RBUlQ6ICdhdXRoL21pc3NpbmctaWZyYW1lLXN0YXJ0JyxcbiAgICBNSVNTSU5HX0lPU19CVU5ETEVfSUQ6ICdhdXRoL21pc3NpbmctaW9zLWJ1bmRsZS1pZCcsXG4gICAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFOiAnYXV0aC9taXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxuICAgIE1JU1NJTkdfTUZBX0lORk86ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLWluZm8nLFxuICAgIE1JU1NJTkdfTUZBX1NFU1NJT046ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb24nLFxuICAgIE1JU1NJTkdfUEhPTkVfTlVNQkVSOiAnYXV0aC9taXNzaW5nLXBob25lLW51bWJlcicsXG4gICAgTUlTU0lOR19TRVNTSU9OX0lORk86ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWlkJyxcbiAgICBNT0RVTEVfREVTVFJPWUVEOiAnYXV0aC9hcHAtZGVsZXRlZCcsXG4gICAgTkVFRF9DT05GSVJNQVRJT046ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxuICAgIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQ6ICdhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWQnLFxuICAgIE5VTExfVVNFUjogJ2F1dGgvbnVsbC11c2VyJyxcbiAgICBOT19BVVRIX0VWRU5UOiAnYXV0aC9uby1hdXRoLWV2ZW50JyxcbiAgICBOT19TVUNIX1BST1ZJREVSOiAnYXV0aC9uby1zdWNoLXByb3ZpZGVyJyxcbiAgICBPUEVSQVRJT05fTk9UX0FMTE9XRUQ6ICdhdXRoL29wZXJhdGlvbi1ub3QtYWxsb3dlZCcsXG4gICAgT1BFUkFUSU9OX05PVF9TVVBQT1JURUQ6ICdhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxuICAgIFBPUFVQX0JMT0NLRUQ6ICdhdXRoL3BvcHVwLWJsb2NrZWQnLFxuICAgIFBPUFVQX0NMT1NFRF9CWV9VU0VSOiAnYXV0aC9wb3B1cC1jbG9zZWQtYnktdXNlcicsXG4gICAgUFJPVklERVJfQUxSRUFEWV9MSU5LRUQ6ICdhdXRoL3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcbiAgICBRVU9UQV9FWENFRURFRDogJ2F1dGgvcXVvdGEtZXhjZWVkZWQnLFxuICAgIFJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSOiAnYXV0aC9yZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlcicsXG4gICAgUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkc6ICdhdXRoL3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcbiAgICBSRUpFQ1RFRF9DUkVERU5USUFMOiAnYXV0aC9yZWplY3RlZC1jcmVkZW50aWFsJyxcbiAgICBTRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQ6ICdhdXRoL3NlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2UnLFxuICAgIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQ6ICdhdXRoL21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXG4gICAgVEVOQU5UX0lEX01JU01BVENIOiAnYXV0aC90ZW5hbnQtaWQtbWlzbWF0Y2gnLFxuICAgIFRJTUVPVVQ6ICdhdXRoL3RpbWVvdXQnLFxuICAgIFRPS0VOX0VYUElSRUQ6ICdhdXRoL3VzZXItdG9rZW4tZXhwaXJlZCcsXG4gICAgVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSOiAnYXV0aC90b28tbWFueS1yZXF1ZXN0cycsXG4gICAgVU5BVVRIT1JJWkVEX0RPTUFJTjogJ2F1dGgvdW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaScsXG4gICAgVU5TVVBQT1JURURfRklSU1RfRkFDVE9SOiAnYXV0aC91bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxuICAgIFVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFOiAnYXV0aC91bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgICBVTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OOiAnYXV0aC91bnN1cHBvcnRlZC10ZW5hbnQtb3BlcmF0aW9uJyxcbiAgICBVTlZFUklGSUVEX0VNQUlMOiAnYXV0aC91bnZlcmlmaWVkLWVtYWlsJyxcbiAgICBVU0VSX0NBTkNFTExFRDogJ2F1dGgvdXNlci1jYW5jZWxsZWQnLFxuICAgIFVTRVJfREVMRVRFRDogJ2F1dGgvdXNlci1ub3QtZm91bmQnLFxuICAgIFVTRVJfRElTQUJMRUQ6ICdhdXRoL3VzZXItZGlzYWJsZWQnLFxuICAgIFVTRVJfTUlTTUFUQ0g6ICdhdXRoL3VzZXItbWlzbWF0Y2gnLFxuICAgIFVTRVJfU0lHTkVEX09VVDogJ2F1dGgvdXNlci1zaWduZWQtb3V0JyxcbiAgICBXRUFLX1BBU1NXT1JEOiAnYXV0aC93ZWFrLXBhc3N3b3JkJyxcbiAgICBXRUJfU1RPUkFHRV9VTlNVUFBPUlRFRDogJ2F1dGgvd2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWQnLFxuICAgIEFMUkVBRFlfSU5JVElBTElaRUQ6ICdhdXRoL2FscmVhZHktaW5pdGlhbGl6ZWQnLFxuICAgIFJFQ0FQVENIQV9OT1RfRU5BQkxFRDogJ2F1dGgvcmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcbiAgICBNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdG9rZW4nLFxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1RPS0VOOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS10b2tlbicsXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxuICAgIE1JU1NJTkdfQ0xJRU5UX1RZUEU6ICdhdXRoL21pc3NpbmctY2xpZW50LXR5cGUnLFxuICAgIE1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL21pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb24nLFxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxuICAgIElOVkFMSURfUkVRX1RZUEU6ICdhdXRoL2ludmFsaWQtcmVxLXR5cGUnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbG9nQ2xpZW50ID0gbmV3IGxvZ2dlci5Mb2dnZXIoJ0BmaXJlYmFzZS9hdXRoJyk7XG5mdW5jdGlvbiBfbG9nV2Fybihtc2csIC4uLmFyZ3MpIHtcbiAgICBpZiAobG9nQ2xpZW50LmxvZ0xldmVsIDw9IGxvZ2dlci5Mb2dMZXZlbC5XQVJOKSB7XG4gICAgICAgIGxvZ0NsaWVudC53YXJuKGBBdXRoICgke2FwcC5TREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfbG9nRXJyb3IobXNnLCAuLi5hcmdzKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBsb2dnZXIuTG9nTGV2ZWwuRVJST1IpIHtcbiAgICAgICAgbG9nQ2xpZW50LmVycm9yKGBBdXRoICgke2FwcC5TREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfZmFpbChhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XG4gICAgdGhyb3cgY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVFcnJvcihhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3JNYXAgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb2RFcnJvck1hcCgpKSwgeyBbY29kZV06IG1lc3NhZ2UgfSk7XG4gICAgY29uc3QgZmFjdG9yeSA9IG5ldyB1dGlsLkVycm9yRmFjdG9yeSgnYXV0aCcsICdGaXJlYmFzZScsIGVycm9yTWFwKTtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGUoY29kZSwge1xuICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpIHtcbiAgICByZXR1cm4gX2Vycm9yV2l0aEN1c3RvbU1lc3NhZ2UoYXV0aCwgXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLywgJ09wZXJhdGlvbnMgdGhhdCBhbHRlciB0aGUgY3VycmVudCB1c2VyIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNvbmp1bmN0aW9uIHdpdGggRmlyZWJhc2VTZXJ2ZXJBcHAnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCkge1xuICAgIGlmICh0eXBlb2YgYXV0aE9yQ29kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHJlc3RbMF07XG4gICAgICAgIGNvbnN0IGZ1bGxQYXJhbXMgPSBbLi4ucmVzdC5zbGljZSgxKV07XG4gICAgICAgIGlmIChmdWxsUGFyYW1zWzBdKSB7XG4gICAgICAgICAgICBmdWxsUGFyYW1zWzBdLmFwcE5hbWUgPSBhdXRoT3JDb2RlLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGhPckNvZGUuX2Vycm9yRmFjdG9yeS5jcmVhdGUoY29kZSwgLi4uZnVsbFBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlkuY3JlYXRlKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gX2Fzc2VydChhc3NlcnRpb24sIGF1dGhPckNvZGUsIC4uLnJlc3QpIHtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xuICAgIH1cbn1cbi8qKlxuICogVW5jb25kaXRpb25hbGx5IGZhaWxzLCB0aHJvd2luZyBhbiBpbnRlcm5hbCBlcnJvciB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBmYWlsdXJlIHR5cGUgb2YgZmFpbHVyZSBlbmNvdW50ZXJlZFxuICogQHRocm93cyBFcnJvclxuICovXG5mdW5jdGlvbiBkZWJ1Z0ZhaWwoZmFpbHVyZSkge1xuICAgIC8vIExvZyB0aGUgZmFpbHVyZSBpbiBhZGRpdGlvbiB0byB0aHJvdyBhbiBleGNlcHRpb24sIGp1c3QgaW4gY2FzZSB0aGVcbiAgICAvLyBleGNlcHRpb24gaXMgc3dhbGxvd2VkLlxuICAgIGNvbnN0IG1lc3NhZ2UgPSBgSU5URVJOQUwgQVNTRVJUSU9OIEZBSUxFRDogYCArIGZhaWx1cmU7XG4gICAgX2xvZ0Vycm9yKG1lc3NhZ2UpO1xuICAgIC8vIE5PVEU6IFdlIGRvbid0IHVzZSBGaXJlYmFzZUVycm9yIGhlcmUgYmVjYXVzZSB0aGVzZSBhcmUgaW50ZXJuYWwgZmFpbHVyZXNcbiAgICAvLyB0aGF0IGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoZSB1c2VyLiAoQWxzbyBpdCB3b3VsZCBjcmVhdGUgYSBjaXJjdWxhclxuICAgIC8vIGRlcGVuZGVuY3kgYmV0d2VlbiB0aGUgZXJyb3IgYW5kIGFzc2VydCBtb2R1bGVzIHdoaWNoIGRvZXNuJ3Qgd29yay4pXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBGYWlscyBpZiB0aGUgZ2l2ZW4gYXNzZXJ0aW9uIGNvbmRpdGlvbiBpcyBmYWxzZSwgdGhyb3dpbmcgYW4gRXJyb3Igd2l0aCB0aGVcbiAqIGdpdmVuIG1lc3NhZ2UgaWYgaXQgZGlkLlxuICpcbiAqIEBwYXJhbSBhc3NlcnRpb25cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGRlYnVnQXNzZXJ0KGFzc2VydGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgIGRlYnVnRmFpbChtZXNzYWdlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfZ2V0Q3VycmVudFVybCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfYSA9IHNlbGYubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkgfHwgJyc7XG59XG5mdW5jdGlvbiBfaXNIdHRwT3JIdHRwcygpIHtcbiAgICByZXR1cm4gX2dldEN1cnJlbnRTY2hlbWUoKSA9PT0gJ2h0dHA6JyB8fCBfZ2V0Q3VycmVudFNjaGVtZSgpID09PSAnaHR0cHM6Jztcbn1cbmZ1bmN0aW9uIF9nZXRDdXJyZW50U2NoZW1lKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gc2VsZi5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByb3RvY29sKSkgfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgd29ya2luZyBvbmxpbmVcbiAqL1xuZnVuY3Rpb24gX2lzT25saW5lKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBuYXZpZ2F0b3IgJiZcbiAgICAgICAgJ29uTGluZScgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3Iub25MaW5lID09PSAnYm9vbGVhbicgJiZcbiAgICAgICAgLy8gQXBwbHkgb25seSBmb3IgdHJhZGl0aW9uYWwgd2ViIGFwcHMgYW5kIENocm9tZSBleHRlbnNpb25zLlxuICAgICAgICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgdHJ1ZSBmb3IgQ29yZG92YSBhcHBzIHdoaWNoIGhhdmUgdW5yZWxpYWJsZVxuICAgICAgICAvLyBuYXZpZ2F0b3Iub25MaW5lIGJlaGF2aW9yIHVubGVzcyBjb3Jkb3ZhLXBsdWdpbi1uZXR3b3JrLWluZm9ybWF0aW9uIGlzXG4gICAgICAgIC8vIGluc3RhbGxlZCB3aGljaCBvdmVyd3JpdGVzIHRoZSBuYXRpdmUgbmF2aWdhdG9yLm9uTGluZSB2YWx1ZSBhbmRcbiAgICAgICAgLy8gZGVmaW5lcyBuYXZpZ2F0b3IuY29ubmVjdGlvbi5cbiAgICAgICAgKF9pc0h0dHBPckh0dHBzKCkgfHwgdXRpbC5pc0Jyb3dzZXJFeHRlbnNpb24oKSB8fCAnY29ubmVjdGlvbicgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcbiAgICB9XG4gICAgLy8gSWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBzdGF0ZSwgYXNzdW1lIGl0IGlzIG9ubGluZS5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9nZXRVc2VyTGFuZ3VhZ2UoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBuYXZpZ2F0b3JMYW5ndWFnZSA9IG5hdmlnYXRvcjtcbiAgICByZXR1cm4gKFxuICAgIC8vIE1vc3QgcmVsaWFibGUsIGJ1dCBvbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWUvRmlyZWZveC5cbiAgICAobmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzICYmIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlc1swXSkgfHxcbiAgICAgICAgLy8gU3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZXR1cm5zIHRoZSBsYW5ndWFnZSBvZiB0aGUgYnJvd3NlclxuICAgICAgICAvLyBVSSwgbm90IHRoZSBsYW5ndWFnZSBzZXQgaW4gYnJvd3NlciBzZXR0aW5ncy5cbiAgICAgICAgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2UgfHxcbiAgICAgICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGxhbmd1YWdlLlxuICAgICAgICBudWxsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBzdHJ1Y3R1cmUgdG8gaGVscCBwaWNrIGJldHdlZW4gYSByYW5nZSBvZiBsb25nIGFuZCBzaG9ydCBkZWxheSBkdXJhdGlvbnNcbiAqIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gZ2VuZXJhbCwgdGhlIGxvbmcgZGVsYXkgaXMgdXNlZCBmb3JcbiAqIG1vYmlsZSBlbnZpcm9ubWVudHMgd2hlcmVhcyBzaG9ydCBkZWxheXMgYXJlIHVzZWQgZm9yIGRlc2t0b3AgZW52aXJvbm1lbnRzLlxuICovXG5jbGFzcyBEZWxheSB7XG4gICAgY29uc3RydWN0b3Ioc2hvcnREZWxheSwgbG9uZ0RlbGF5KSB7XG4gICAgICAgIHRoaXMuc2hvcnREZWxheSA9IHNob3J0RGVsYXk7XG4gICAgICAgIHRoaXMubG9uZ0RlbGF5ID0gbG9uZ0RlbGF5O1xuICAgICAgICAvLyBJbnRlcm5hbCBlcnJvciB3aGVuIGltcHJvcGVybHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGRlYnVnQXNzZXJ0KGxvbmdEZWxheSA+IHNob3J0RGVsYXksICdTaG9ydCBkZWxheSBzaG91bGQgYmUgbGVzcyB0aGFuIGxvbmcgZGVsYXkhJyk7XG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSB1dGlsLmlzTW9iaWxlQ29yZG92YSgpIHx8IHV0aWwuaXNSZWFjdE5hdGl2ZSgpO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGlmICghX2lzT25saW5lKCkpIHtcbiAgICAgICAgICAgIC8vIFBpY2sgdGhlIHNob3J0ZXIgdGltZW91dC5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbig1MDAwIC8qIERlbGF5TWluLk9GRkxJTkUgKi8sIHRoaXMuc2hvcnREZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcnVubmluZyBpbiBhIG1vYmlsZSBlbnZpcm9ubWVudCwgcmV0dXJuIHRoZSBsb25nIGRlbGF5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzaG9ydCBkZWxheS5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBpbXByb3ZlZCBpbiB0aGUgZnV0dXJlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBiYXNlZCBvbiBvdGhlclxuICAgICAgICAvLyB2YXJpYWJsZXMgaW5zdGVhZCBvZiBqdXN0IHJlYWRpbmcgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAgICAgIHJldHVybiB0aGlzLmlzTW9iaWxlID8gdGhpcy5sb25nRGVsYXkgOiB0aGlzLnNob3J0RGVsYXk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX2VtdWxhdG9yVXJsKGNvbmZpZywgcGF0aCkge1xuICAgIGRlYnVnQXNzZXJ0KGNvbmZpZy5lbXVsYXRvciwgJ0VtdWxhdG9yIHNob3VsZCBhbHdheXMgYmUgc2V0IGhlcmUnKTtcbiAgICBjb25zdCB7IHVybCB9ID0gY29uZmlnLmVtdWxhdG9yO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dXJsfSR7cGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aH1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRmV0Y2hQcm92aWRlciB7XG4gICAgc3RhdGljIGluaXRpYWxpemUoZmV0Y2hJbXBsLCBoZWFkZXJzSW1wbCwgcmVzcG9uc2VJbXBsKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hJbXBsID0gZmV0Y2hJbXBsO1xuICAgICAgICBpZiAoaGVhZGVyc0ltcGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc0ltcGwgPSBoZWFkZXJzSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VJbXBsKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlSW1wbCA9IHJlc3BvbnNlSW1wbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZmV0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hJbXBsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2ZldGNoJyBpbiBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5mZXRjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzLmZldGNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBmZXRjaCBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcbiAgICB9XG4gICAgc3RhdGljIGhlYWRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdIZWFkZXJzJyBpbiBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5IZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5IZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5IZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgSGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBIZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgSGVhZGVycyBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcbiAgICB9XG4gICAgc3RhdGljIHJlc3BvbnNlKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNwb25zZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlSW1wbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICdSZXNwb25zZScgaW4gc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLlJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcy5SZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIFJlc3BvbnNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnRmFpbCgnQ291bGQgbm90IGZpbmQgUmVzcG9uc2UgaW1wbGVtZW50YXRpb24sIG1ha2Ugc3VyZSB5b3UgY2FsbCBGZXRjaFByb3ZpZGVyLmluaXRpYWxpemUoKSB3aXRoIGFuIGFwcHJvcHJpYXRlIHBvbHlmaWxsJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBNYXAgZnJvbSBlcnJvcnMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciB0byBlcnJvcnMgdG8gZGV2ZWxvcGVyIHZpc2libGUgZXJyb3JzXG4gKi9cbmNvbnN0IFNFUlZFUl9FUlJPUl9NQVAgPSB7XG4gICAgLy8gQ3VzdG9tIHRva2VuIGVycm9ycy5cbiAgICBbXCJDUkVERU5USUFMX01JU01BVENIXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9NSVNNQVRDSCAqL106IFwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX01JU01BVENIICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX0NVU1RPTV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ1VTVE9NX1RPS0VOICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXG4gICAgLy8gQ3JlYXRlIEF1dGggVVJJIGVycm9ycy5cbiAgICBbXCJJTlZBTElEX0lERU5USUZJRVJcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0lERU5USUZJRVIgKi9dOiBcImludmFsaWQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRU1BSUwgKi8sXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICAgIFtcIk1JU1NJTkdfQ09OVElOVUVfVVJJXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DT05USU5VRV9VUkkgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBTaWduIGluIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIGVycm9ycyAoc29tZSBhcHBseSB0byBzaWduIHVwIHRvbykuXG4gICAgW1wiSU5WQUxJRF9QQVNTV09SRFwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUEFTU1dPUkQgKi9dOiBcIndyb25nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BBU1NXT1JEICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX1BBU1NXT1JEXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19QQVNTV09SRCAqL106IFwibWlzc2luZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19QQVNTV09SRCAqLyxcbiAgICAvLyBUaHJvd24gaWYgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbiBpcyBlbmFibGVkIGluIHRoZSBwcm9qZWN0IGFuZCB0aGUgZW1haWwgb3IgcGFzc3dvcmQgaXNcbiAgICAvLyBpbnZhbGlkLlxuICAgIFtcIklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFNcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0xPR0lOX0NSRURFTlRJQUxTICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcbiAgICAvLyBTaWduIHVwIHdpdGggZW1haWwgYW5kIHBhc3N3b3JkIGVycm9ycy5cbiAgICBbXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi9dOiBcImVtYWlsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMgKi8sXG4gICAgW1wiUEFTU1dPUkRfTE9HSU5fRElTQUJMRURcIiAvKiBTZXJ2ZXJFcnJvci5QQVNTV09SRF9MT0dJTl9ESVNBQkxFRCAqL106IFwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX0FMTE9XRUQgKi8sXG4gICAgLy8gVmVyaWZ5IGFzc2VydGlvbiBmb3Igc2lnbiBpbiB3aXRoIGNyZWRlbnRpYWwgZXJyb3JzOlxuICAgIFtcIklOVkFMSURfSURQX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JRFBfUkVTUE9OU0UgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxuICAgIFtcIklOVkFMSURfUEVORElOR19UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUEVORElOR19UT0tFTiAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXG4gICAgW1wiRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRURcIiAvKiBTZXJ2ZXJFcnJvci5GRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCAqL106IFwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSAqLyxcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gICAgW1wiTUlTU0lOR19SRVFfVFlQRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVRX1RZUEUgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBTZW5kIFBhc3N3b3JkIHJlc2V0IGVtYWlsIGVycm9yczpcbiAgICBbXCJFTUFJTF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi8sXG4gICAgW1wiUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUXCIgLyogU2VydmVyRXJyb3IuUkVTRVRfUEFTU1dPUkRfRVhDRUVEX0xJTUlUICovXTogXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovLFxuICAgIFtcIkVYUElSRURfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5FWFBJUkVEX09PQl9DT0RFICovXTogXCJleHBpcmVkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5FWFBJUkVEX09PQl9DT0RFICovLFxuICAgIFtcIklOVkFMSURfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX09PQl9DT0RFICovXTogXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09PQl9DT0RFICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX09PQl9DT0RFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19PT0JfQ09ERSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxuICAgIC8vIE9wZXJhdGlvbnMgdGhhdCByZXF1aXJlIElEIHRva2VuIGluIHJlcXVlc3Q6XG4gICAgW1wiQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOXCIgLyogU2VydmVyRXJyb3IuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovXTogXCJyZXF1aXJlcy1yZWNlbnQtbG9naW5cIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTiAqLyxcbiAgICBbXCJJTlZBTElEX0lEX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9JRF9UT0tFTiAqL106IFwiaW52YWxpZC11c2VyLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FVVEggKi8sXG4gICAgW1wiVE9LRU5fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlRPS0VOX0VYUElSRUQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcbiAgICBbXCJVU0VSX05PVF9GT1VORFwiIC8qIFNlcnZlckVycm9yLlVTRVJfTk9UX0ZPVU5EICovXTogXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi8sXG4gICAgLy8gT3RoZXIgZXJyb3JzLlxuICAgIFtcIlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUlwiIC8qIFNlcnZlckVycm9yLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqL106IFwidG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqLyxcbiAgICBbXCJQQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UU1wiIC8qIFNlcnZlckVycm9yLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovXTogXCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi8sXG4gICAgLy8gUGhvbmUgQXV0aCByZWxhdGVkIGVycm9ycy5cbiAgICBbXCJJTlZBTElEX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0NPREUgKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09ERSAqLyxcbiAgICBbXCJJTlZBTElEX1NFU1NJT05fSU5GT1wiIC8qIFNlcnZlckVycm9yLklOVkFMSURfU0VTU0lPTl9JTkZPICovXTogXCJpbnZhbGlkLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi8sXG4gICAgW1wiSU5WQUxJRF9URU1QT1JBUllfUFJPT0ZcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1RFTVBPUkFSWV9QUk9PRiAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXG4gICAgW1wiTUlTU0lOR19TRVNTSU9OX0lORk9cIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1NFU1NJT05fSU5GTyAqL106IFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfU0VTU0lPTl9JTkZPICovLFxuICAgIFtcIlNFU1NJT05fRVhQSVJFRFwiIC8qIFNlcnZlckVycm9yLlNFU1NJT05fRVhQSVJFRCAqL106IFwiY29kZS1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5DT0RFX0VYUElSRUQgKi8sXG4gICAgLy8gT3RoZXIgYWN0aW9uIGNvZGUgZXJyb3JzIHdoZW4gYWRkaXRpb25hbCBzZXR0aW5ncyBwYXNzZWQuXG4gICAgLy8gTUlTU0lOR19DT05USU5VRV9VUkkgaXMgZ2V0dGluZyBtYXBwZWQgdG8gSU5URVJOQUxfRVJST1IgYWJvdmUuXG4gICAgLy8gVGhpcyBpcyBPSyBhcyB0aGlzIGVycm9yIHdpbGwgYmUgY2F1Z2h0IGJ5IGNsaWVudCBzaWRlIHZhbGlkYXRpb24uXG4gICAgW1wiTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi9dOiBcIm1pc3NpbmctYW5kcm9pZC1wa2ctbmFtZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqLyxcbiAgICBbXCJVTkFVVEhPUklaRURfRE9NQUlOXCIgLyogU2VydmVyRXJyb3IuVU5BVVRIT1JJWkVEX0RPTUFJTiAqL106IFwidW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuVU5BVVRIT1JJWkVEX0RPTUFJTiAqLyxcbiAgICAvLyBnZXRQcm9qZWN0Q29uZmlnIGVycm9ycyB3aGVuIGNsaWVudElkIGlzIHBhc3NlZC5cbiAgICBbXCJJTlZBTElEX09BVVRIX0NMSUVOVF9JRFwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEICovXTogXCJpbnZhbGlkLW9hdXRoLWNsaWVudC1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQgKi8sXG4gICAgLy8gVXNlciBhY3Rpb25zIChzaWduLXVwIG9yIGRlbGV0aW9uKSBkaXNhYmxlZCBlcnJvcnMuXG4gICAgW1wiQURNSU5fT05MWV9PUEVSQVRJT05cIiAvKiBTZXJ2ZXJFcnJvci5BRE1JTl9PTkxZX09QRVJBVElPTiAqL106IFwiYWRtaW4tcmVzdHJpY3RlZC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLkFETUlOX09OTFlfT1BFUkFUSU9OICovLFxuICAgIC8vIE11bHRpIGZhY3RvciByZWxhdGVkIGVycm9ycy5cbiAgICBbXCJJTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcImludmFsaWQtbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUZBX1NFU1NJT04gKi8sXG4gICAgW1wiTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuTUZBX0VOUk9MTE1FTlRfTk9UX0ZPVU5EICovXTogXCJtdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9JTkZPX05PVF9GT1VORCAqLyxcbiAgICBbXCJNSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19NRkFfRU5ST0xMTUVOVF9JRCAqL106IFwibWlzc2luZy1tdWx0aS1mYWN0b3ItaW5mb1wiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfSU5GTyAqLyxcbiAgICBbXCJNSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUxcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9QRU5ESU5HX0NSRURFTlRJQUwgKi9dOiBcIm1pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT04gKi8sXG4gICAgW1wiU0VDT05EX0ZBQ1RPUl9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0VYSVNUUyAqL106IFwic2Vjb25kLWZhY3Rvci1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9BTFJFQURZX0VOUk9MTEVEICovLFxuICAgIFtcIlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERURcIiAvKiBTZXJ2ZXJFcnJvci5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovXTogXCJtYXhpbXVtLXNlY29uZC1mYWN0b3ItY291bnQtZXhjZWVkZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgKi8sXG4gICAgLy8gQmxvY2tpbmcgZnVuY3Rpb25zIHJlbGF0ZWQgZXJyb3JzLlxuICAgIFtcIkJMT0NLSU5HX0ZVTkNUSU9OX0VSUk9SX1JFU1BPTlNFXCIgLyogU2VydmVyRXJyb3IuQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0UgKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBSZWNhcHRjaGEgcmVsYXRlZCBlcnJvcnMuXG4gICAgW1wiUkVDQVBUQ0hBX05PVF9FTkFCTEVEXCIgLyogU2VydmVyRXJyb3IuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovXTogXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqLyxcbiAgICBbXCJNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovXTogXCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi8sXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovLFxuICAgIFtcIklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi8sXG4gICAgW1wiTUlTU0lOR19DTElFTlRfVFlQRVwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi9dOiBcIm1pc3NpbmctY2xpZW50LXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi8sXG4gICAgW1wiTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTlwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiBcIm1pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04gKi8sXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiBcImludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT04gKi8sXG4gICAgW1wiSU5WQUxJRF9SRVFfVFlQRVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVRX1RZUEUgKi9dOiBcImludmFsaWQtcmVxLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVRX1RZUEUgKi9cbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX0FQSV9USU1FT1VUX01TID0gbmV3IERlbGF5KDMwMDAwLCA2MDAwMCk7XG5mdW5jdGlvbiBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkge1xuICAgIGlmIChhdXRoLnRlbmFudElkICYmICFyZXF1ZXN0LnRlbmFudElkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IHRlbmFudElkOiBhdXRoLnRlbmFudElkIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBtZXRob2QsIHBhdGgsIHJlcXVlc3QsIGN1c3RvbUVycm9yTWFwID0ge30pIHtcbiAgICByZXR1cm4gX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIGN1c3RvbUVycm9yTWFwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBib2R5ID0ge307XG4gICAgICAgIGxldCBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIgLyogSHR0cE1ldGhvZC5HRVQgKi8pIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSByZXF1ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdXRpbC5xdWVyeXN0cmluZyhPYmplY3QuYXNzaWduKHsga2V5OiBhdXRoLmNvbmZpZy5hcGlLZXkgfSwgcGFyYW1zKSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBhdXRoLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCIgLyogSHR0cEhlYWRlci5DT05URU5UX1RZUEUgKi9dID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICBpZiAoYXV0aC5sYW5ndWFnZUNvZGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUxvY2FsZVwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9MT0NBTEUgKi9dID0gYXV0aC5sYW5ndWFnZUNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmV0Y2hBcmdzID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMgfSwgYm9keSk7XG4gICAgICAgIC8qIFNlY3VyaXR5LWNvbnNjaW91cyBzZXJ2ZXItc2lkZSBmcmFtZXdvcmtzIHRlbmQgdG8gaGF2ZSBidWlsdCBpbiBtaXRpZ2F0aW9ucyBmb3IgcmVmZXJyZXJcbiAgICAgICAgICAgcHJvYmxlbXNcIi4gU2VlIHRoZSBDbG91ZGZsYXJlIEdpdEh1YiBpc3N1ZSAjNDg3OiBFcnJvcjogVGhlICdyZWZlcnJlclBvbGljeScgZmllbGQgb25cbiAgICAgICAgICAgJ1JlcXVlc3RJbml0aWFsaXplckRpY3QnIGlzIG5vdCBpbXBsZW1lbnRlZC5cIlxuICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS9uZXh0LW9uLXBhZ2VzL2lzc3Vlcy80ODcgKi9cbiAgICAgICAgaWYgKCF1dGlsLmlzQ2xvdWRmbGFyZVdvcmtlcigpKSB7XG4gICAgICAgICAgICBmZXRjaEFyZ3MucmVmZXJyZXJQb2xpY3kgPSAnbm8tcmVmZXJyZXInO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkoX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGF1dGguY29uZmlnLmFwaUhvc3QsIHBhdGgsIHF1ZXJ5KSwgZmV0Y2hBcmdzKTtcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCBjdXN0b21FcnJvck1hcCwgZmV0Y2hGbikge1xuICAgIGF1dGguX2NhbkluaXRFbXVsYXRvciA9IGZhbHNlO1xuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBTRVJWRVJfRVJST1JfTUFQKSwgY3VzdG9tRXJyb3JNYXApO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtUaW1lb3V0ID0gbmV3IE5ldHdvcmtUaW1lb3V0KGF1dGgpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBmZXRjaEZuKCksXG4gICAgICAgICAgICBuZXR3b3JrVGltZW91dC5wcm9taXNlXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoaXMgcG9pbnQsIHRoZSBmZXRjaCBzdWNjZWVkZWQgYW5kIHRoZSBuZXR3b3JrVGltZW91dFxuICAgICAgICAvLyBkaWRuJ3QgdGhyb3c7IGNsZWFyIHRoZSBuZXR3b3JrIHRpbWVvdXQgZGVsYXkgc28gdGhhdCBOb2RlIHdvbid0IGhhbmdcbiAgICAgICAgbmV0d29ya1RpbWVvdXQuY2xlYXJOZXR3b3JrVGltZW91dCgpO1xuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoJ25lZWRDb25maXJtYXRpb24nIGluIGpzb24pIHtcbiAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqLywganNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rICYmICEoJ2Vycm9yTWVzc2FnZScgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uub2sgPyBqc29uLmVycm9yTWVzc2FnZSA6IGpzb24uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnN0IFtzZXJ2ZXJFcnJvckNvZGUsIHNlcnZlckVycm9yTWVzc2FnZV0gPSBlcnJvck1lc3NhZ2Uuc3BsaXQoJyA6ICcpO1xuICAgICAgICAgICAgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRFwiIC8qIFNlcnZlckVycm9yLkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEICovKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0UgKi8sIGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VydmVyRXJyb3JDb2RlID09PSBcIkVNQUlMX0VYSVNUU1wiIC8qIFNlcnZlckVycm9yLkVNQUlMX0VYSVNUUyAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJlbWFpbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfRVhJU1RTICovLCBqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJVU0VSX0RJU0FCTEVEXCIgLyogU2VydmVyRXJyb3IuVVNFUl9ESVNBQkxFRCAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJ1c2VyLWRpc2FibGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RJU0FCTEVEICovLCBqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhFcnJvciA9IGVycm9yTWFwW3NlcnZlckVycm9yQ29kZV0gfHxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvckNvZGVcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tfXFxzXSsvZywgJy0nKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBhdXRoRXJyb3IsIHNlcnZlckVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBhdXRoRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgdXRpbC5GaXJlYmFzZUVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoYW5naW5nIHRoaXMgdG8gYSBkaWZmZXJlbnQgZXJyb3IgY29kZSB3aWxsIGxvZyB1c2VyIG91dCB3aGVuIHRoZXJlIGlzIGEgbmV0d29yayBlcnJvclxuICAgICAgICAvLyBiZWNhdXNlIHdlIHRyZWF0IGFueSBlcnJvciBvdGhlciB0aGFuIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQgYXMgdG9rZW4gaXMgaW52YWxpZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9ibG9iLzRmYmM3MzYxMGQ3MGJlNGUwODUyZTdkZTYzYTM5Y2I3ODk3ZTg1NDYvcGFja2FnZXMvYXV0aC9zcmMvY29yZS9hdXRoL2F1dGhfaW1wbC50cyNMMzA5LUwzMTZcbiAgICAgICAgX2ZhaWwoYXV0aCwgXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovLCB7ICdtZXNzYWdlJzogU3RyaW5nKGUpIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBtZXRob2QsIHBhdGgsIHJlcXVlc3QsIGN1c3RvbUVycm9yTWFwID0ge30pIHtcbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBtZXRob2QsIHBhdGgsIHJlcXVlc3QsIGN1c3RvbUVycm9yTWFwKTtcbiAgICBpZiAoJ21mYVBlbmRpbmdDcmVkZW50aWFsJyBpbiBzZXJ2ZXJSZXNwb25zZSkge1xuICAgICAgICBfZmFpbChhdXRoLCBcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi8sIHtcbiAgICAgICAgICAgIF9zZXJ2ZXJSZXNwb25zZTogc2VydmVyUmVzcG9uc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXJ2ZXJSZXNwb25zZTtcbn1cbmZ1bmN0aW9uIF9nZXRGaW5hbFRhcmdldChhdXRoLCBob3N0LCBwYXRoLCBxdWVyeSkge1xuICAgIGNvbnN0IGJhc2UgPSBgJHtob3N0fSR7cGF0aH0/JHtxdWVyeX1gO1xuICAgIGlmICghYXV0aC5jb25maWcuZW11bGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGAke2F1dGguY29uZmlnLmFwaVNjaGVtZX06Ly8ke2Jhc2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIF9lbXVsYXRvclVybChhdXRoLmNvbmZpZywgYmFzZSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFbmZvcmNlbWVudFN0YXRlKGVuZm9yY2VtZW50U3RhdGVTdHIpIHtcbiAgICBzd2l0Y2ggKGVuZm9yY2VtZW50U3RhdGVTdHIpIHtcbiAgICAgICAgY2FzZSAnRU5GT1JDRSc6XG4gICAgICAgICAgICByZXR1cm4gXCJFTkZPUkNFXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFICovO1xuICAgICAgICBjYXNlICdBVURJVCc6XG4gICAgICAgICAgICByZXR1cm4gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi87XG4gICAgICAgIGNhc2UgJ09GRic6XG4gICAgICAgICAgICByZXR1cm4gXCJPRkZcIiAvKiBFbmZvcmNlbWVudFN0YXRlLk9GRiAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIkVORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFTUVOVF9TVEFURV9VTlNQRUNJRklFRCAqLztcbiAgICB9XG59XG5jbGFzcyBOZXR3b3JrVGltZW91dCB7XG4gICAgY2xlYXJOZXR3b3JrVGltZW91dCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIC8vIE5vZGUgdGltZXJzIGFuZCBicm93c2VyIHRpbWVycyBhcmUgZnVuZGFtZW50YWxseSBpbmNvbXBhdGlibGUsIGJ1dCB3ZVxuICAgICAgICAvLyBkb24ndCBjYXJlIGFib3V0IHRoZSB2YWx1ZSBoZXJlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChfY3JlYXRlRXJyb3IodGhpcy5hdXRoLCBcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi8pKTtcbiAgICAgICAgICAgIH0sIERFRkFVTFRfQVBJX1RJTUVPVVRfTVMuZ2V0KCkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIGNvZGUsIHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZXJyb3JQYXJhbXMgPSB7XG4gICAgICAgIGFwcE5hbWU6IGF1dGgubmFtZVxuICAgIH07XG4gICAgaWYgKHJlc3BvbnNlLmVtYWlsKSB7XG4gICAgICAgIGVycm9yUGFyYW1zLmVtYWlsID0gcmVzcG9uc2UuZW1haWw7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5waG9uZU51bWJlcikge1xuICAgICAgICBlcnJvclBhcmFtcy5waG9uZU51bWJlciA9IHJlc3BvbnNlLnBob25lTnVtYmVyO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IF9jcmVhdGVFcnJvcihhdXRoLCBjb2RlLCBlcnJvclBhcmFtcyk7XG4gICAgLy8gV2Uga25vdyBjdXN0b21EYXRhIGlzIGRlZmluZWQgb24gZXJyb3IgYmVjYXVzZSBlcnJvclBhcmFtcyBpcyBkZWZpbmVkXG4gICAgZXJyb3IuY3VzdG9tRGF0YS5fdG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZShncmVjYXB0Y2hhKSB7XG4gICAgcmV0dXJuIChncmVjYXB0Y2hhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlICE9PSB1bmRlZmluZWQpO1xufVxuY2xhc3MgUmVjYXB0Y2hhQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlQ0FQVENIQSBzaXRlIGtleS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l0ZUtleSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgcHJvdmlkZXJzIGFuZCB0aGVpciBlbmFibGVtZW50IHN0YXR1cyBmb3IgcmVDQVBUQ0hBIEVudGVycHJpc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgPSBbXTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnJlY2FwdGNoYUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2FwdGNoYUtleSB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGFtcGxlIHJlc3BvbnNlLnJlY2FwdGNoYUtleTogXCJwcm9qZWN0cy9wcm9qMTIzL2tleXMvc2l0ZWtleTEyM1wiXG4gICAgICAgIHRoaXMuc2l0ZUtleSA9IHJlc3BvbnNlLnJlY2FwdGNoYUtleS5zcGxpdCgnLycpWzNdO1xuICAgICAgICB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgPSByZXNwb25zZS5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZUNBUFRDSEEgRW50ZXJwcmlzZSBlbmZvcmNlbWVudCBzdGF0ZSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyU3RyIC0gVGhlIHByb3ZpZGVyIHdob3NlIGVuZm9yY2VtZW50IHN0YXRlIGlzIHRvIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm5zIFRoZSByZUNBUFRDSEEgRW50ZXJwcmlzZSBlbmZvcmNlbWVudCBzdGF0ZSBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikge1xuICAgICAgICBpZiAoIXRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSB8fFxuICAgICAgICAgICAgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlIG9mIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgJiZcbiAgICAgICAgICAgICAgICByZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlLnByb3ZpZGVyID09PSBwcm92aWRlclN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFyc2VFbmZvcmNlbWVudFN0YXRlKHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUuZW5mb3JjZW1lbnRTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVDQVBUQ0hBIEVudGVycHJpc2UgZW5mb3JjZW1lbnQgc3RhdGUgZm9yIHRoZSBwcm92aWRlciBpcyBzZXQgdG8gRU5GT1JDRSBvciBBVURJVC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlclN0ciAtIFRoZSBwcm92aWRlciB3aG9zZSBlbmFibGVtZW50IHN0YXRlIGlzIHRvIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHJlQ0FQVENIQSBFbnRlcnByaXNlIHByb3RlY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhlIGdpdmVuIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGlzUHJvdmlkZXJFbmFibGVkKHByb3ZpZGVyU3RyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUocHJvdmlkZXJTdHIpID09PVxuICAgICAgICAgICAgXCJFTkZPUkNFXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5FTkZPUkNFICovIHx8XG4gICAgICAgICAgICB0aGlzLmdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikgPT09IFwiQVVESVRcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkFVRElUICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHJlQ0FQVENIQSBFbnRlcnByaXNlIHByb3RlY3Rpb24gaXMgZW5hYmxlZCBpbiBhdCBsZWFzdCBvbmUgcHJvdmlkZXIsIG90aGVyd2lzZVxuICAgICAqIHJldHVybnMgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCByZUNBUFRDSEEgRW50ZXJwcmlzZSBwcm90ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIGF0IGxlYXN0IG9uZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICBpc0FueVByb3ZpZGVyRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzUHJvdmlkZXJFbmFibGVkKFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pIHx8XG4gICAgICAgICAgICB0aGlzLmlzUHJvdmlkZXJFbmFibGVkKFwiUEhPTkVfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuUEhPTkVfUFJPVklERVIgKi8pKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZWNhcHRjaGFDb25maWcoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJHRVRcIiAvKiBIdHRwTWV0aG9kLkdFVCAqLywgXCIvdjIvcmVjYXB0Y2hhQ29uZmlnXCIgLyogRW5kcG9pbnQuR0VUX1JFQ0FQVENIQV9DT05GSUcgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVBY2NvdW50KGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6ZGVsZXRlXCIgLyogRW5kcG9pbnQuREVMRVRFX0FDQ09VTlQgKi8sIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlTGlua2VkQWNjb3VudHMoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjY291bnRJbmZvKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6bG9va3VwXCIgLyogRW5kcG9pbnQuR0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodXRjVGltZXN0YW1wKSB7XG4gICAgaWYgKCF1dGNUaW1lc3RhbXApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ29udmVydCB0byBkYXRlIG9iamVjdC5cbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKE51bWJlcih1dGNUaW1lc3RhbXApKTtcbiAgICAgICAgLy8gVGVzdCBkYXRlIGlzIHZhbGlkLlxuICAgICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBVVEMgZGF0ZSBzdHJpbmcuXG4gICAgICAgICAgICByZXR1cm4gZGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcuIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgSlNPTiBXZWIgVG9rZW4gKEpXVCkgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciB0byBhIEZpcmViYXNlIHNlcnZpY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9rZW4gaWYgaXQgaGFzIG5vdCBleHBpcmVkIG9yIGlmIGl0IHdpbGwgbm90IGV4cGlyZSBpbiB0aGUgbmV4dCBmaXZlXG4gKiBtaW51dGVzLiBPdGhlcndpc2UsIHRoaXMgd2lsbCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0dXJuIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiB0b2tlbiBleHBpcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0SWRUb2tlbih1c2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICAgIHJldHVybiB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBkZXNlcmlhbGl6ZWQgSlNPTiBXZWIgVG9rZW4gKEpXVCkgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciB0byBhIEZpcmViYXNlIHNlcnZpY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9rZW4gaWYgaXQgaGFzIG5vdCBleHBpcmVkIG9yIGlmIGl0IHdpbGwgbm90IGV4cGlyZSBpbiB0aGUgbmV4dCBmaXZlXG4gKiBtaW51dGVzLiBPdGhlcndpc2UsIHRoaXMgd2lsbCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0dXJuIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiB0b2tlbiBleHBpcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SWRUb2tlblJlc3VsdCh1c2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgdXNlckludGVybmFsLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbiAgICBjb25zdCBjbGFpbXMgPSBfcGFyc2VUb2tlbih0b2tlbik7XG4gICAgX2Fzc2VydChjbGFpbXMgJiYgY2xhaW1zLmV4cCAmJiBjbGFpbXMuYXV0aF90aW1lICYmIGNsYWltcy5pYXQsIHVzZXJJbnRlcm5hbC5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgY29uc3QgZmlyZWJhc2UgPSB0eXBlb2YgY2xhaW1zLmZpcmViYXNlID09PSAnb2JqZWN0JyA/IGNsYWltcy5maXJlYmFzZSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzaWduSW5Qcm92aWRlciA9IGZpcmViYXNlID09PSBudWxsIHx8IGZpcmViYXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJlYmFzZVsnc2lnbl9pbl9wcm92aWRlciddO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYWltcyxcbiAgICAgICAgdG9rZW4sXG4gICAgICAgIGF1dGhUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5hdXRoX3RpbWUpKSxcbiAgICAgICAgaXNzdWVkQXRUaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5pYXQpKSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyhzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoY2xhaW1zLmV4cCkpLFxuICAgICAgICBzaWduSW5Qcm92aWRlcjogc2lnbkluUHJvdmlkZXIgfHwgbnVsbCxcbiAgICAgICAgc2lnbkluU2Vjb25kRmFjdG9yOiAoZmlyZWJhc2UgPT09IG51bGwgfHwgZmlyZWJhc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcmViYXNlWydzaWduX2luX3NlY29uZF9mYWN0b3InXSkgfHwgbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBzZWNvbmRzU3RyaW5nVG9NaWxsaXNlY29uZHMoc2Vjb25kcykge1xuICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcykgKiAxMDAwO1xufVxuZnVuY3Rpb24gX3BhcnNlVG9rZW4odG9rZW4pIHtcbiAgICBjb25zdCBbYWxnb3JpdGhtLCBwYXlsb2FkLCBzaWduYXR1cmVdID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAoYWxnb3JpdGhtID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgcGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9sb2dFcnJvcignSldUIG1hbGZvcm1lZCwgY29udGFpbmVkIGZld2VyIHRoYW4gMyBzZWN0aW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHV0aWwuYmFzZTY0RGVjb2RlKHBheWxvYWQpO1xuICAgICAgICBpZiAoIWRlY29kZWQpIHtcbiAgICAgICAgICAgIF9sb2dFcnJvcignRmFpbGVkIHRvIGRlY29kZSBiYXNlNjQgSldUIHBheWxvYWQnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBfbG9nRXJyb3IoJ0NhdWdodCBlcnJvciBwYXJzaW5nIEpXVCBwYXlsb2FkIGFzIEpTT04nLCBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdCBleHBpcmVzSW4gVFRMIGZyb20gYSB0b2tlbiBieSBzdWJ0cmFjdGluZyB0aGUgZXhwaXJhdGlvbiBmcm9tIHRoZSBpc3N1YW5jZS5cbiAqL1xuZnVuY3Rpb24gX3Rva2VuRXhwaXJlc0luKHRva2VuKSB7XG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBfcGFyc2VUb2tlbih0b2tlbik7XG4gICAgX2Fzc2VydChwYXJzZWRUb2tlbiwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmV4cCAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICBfYXNzZXJ0KHR5cGVvZiBwYXJzZWRUb2tlbi5pYXQgIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgcmV0dXJuIE51bWJlcihwYXJzZWRUb2tlbi5leHApIC0gTnVtYmVyKHBhcnNlZFRva2VuLmlhdCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBwcm9taXNlLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xuICAgIGlmIChieXBhc3NBdXRoU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIHV0aWwuRmlyZWJhc2VFcnJvciAmJiBpc1VzZXJJbnZhbGlkYXRlZChlKSkge1xuICAgICAgICAgICAgaWYgKHVzZXIuYXV0aC5jdXJyZW50VXNlciA9PT0gdXNlcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVzZXIuYXV0aC5zaWduT3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1VzZXJJbnZhbGlkYXRlZCh7IGNvZGUgfSkge1xuICAgIHJldHVybiAoY29kZSA9PT0gYGF1dGgvJHtcInVzZXItZGlzYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUQgKi99YCB8fFxuICAgICAgICBjb2RlID09PSBgYXV0aC8ke1widXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovfWApO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgUHJvYWN0aXZlUmVmcmVzaCB7XG4gICAgY29uc3RydWN0b3IodXNlcikge1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgcmV0dXJuIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBjYXJlIHdoYXQgdGhlIHZhbHVlIGlzIGJ1dCBUUyB3b24ndCBhY2NlcHQgdW5rbm93biBhbmRcbiAgICAgICAgLy8gd2UgY2FuJ3QgY2FzdCBwcm9wZXJseSBpbiBib3RoIGVudmlyb25tZW50cy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy50aW1lcklkID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSAzMDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01JTiAqLztcbiAgICB9XG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgX3N0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy50aW1lcklkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbnRlcnZhbCh3YXNFcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh3YXNFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmVycm9yQmFja29mZjtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5lcnJvckJhY2tvZmYgKiAyLCA5NjAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NQVggKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVycm9yIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gMzAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NSU4gKi87XG4gICAgICAgICAgICBjb25zdCBleHBUaW1lID0gKF9hID0gdGhpcy51c2VyLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gZXhwVGltZSAtIERhdGUubm93KCkgLSAzMDAwMDAgLyogRHVyYXRpb24uT0ZGU0VUICovO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2hlZHVsZSh3YXNFcnJvciA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZS4uLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5nZXRJbnRlcnZhbCh3YXNFcnJvcik7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pdGVyYXRpb24oKTtcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBhc3luYyBpdGVyYXRpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gT25seSByZXRyeSBvbiBuZXR3b3JrIGVycm9yc1xuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgPT09XG4gICAgICAgICAgICAgICAgYGF1dGgvJHtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi99YCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoLyogd2FzRXJyb3IgKi8gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIFVzZXJNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IoY3JlYXRlZEF0LCBsYXN0TG9naW5BdCkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5sYXN0TG9naW5BdCA9IGxhc3RMb2dpbkF0O1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZVRpbWUoKSB7XG4gICAgICAgIHRoaXMubGFzdFNpZ25JblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5sYXN0TG9naW5BdCk7XG4gICAgICAgIHRoaXMuY3JlYXRpb25UaW1lID0gdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHRoaXMuY3JlYXRlZEF0KTtcbiAgICB9XG4gICAgX2NvcHkobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBtZXRhZGF0YS5jcmVhdGVkQXQ7XG4gICAgICAgIHRoaXMubGFzdExvZ2luQXQgPSBtZXRhZGF0YS5sYXN0TG9naW5BdDtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVRpbWUoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlZEF0OiB0aGlzLmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIGxhc3RMb2dpbkF0OiB0aGlzLmxhc3RMb2dpbkF0XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdXRoID0gdXNlci5hdXRoO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIGdldEFjY291bnRJbmZvKGF1dGgsIHsgaWRUb2tlbiB9KSk7XG4gICAgX2Fzc2VydChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudXNlcnMubGVuZ3RoLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcbiAgICB1c2VyLl9ub3RpZnlSZWxvYWRMaXN0ZW5lcihjb3JlQWNjb3VudCk7XG4gICAgY29uc3QgbmV3UHJvdmlkZXJEYXRhID0gKChfYSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXG4gICAgICAgID8gZXh0cmFjdFByb3ZpZGVyRGF0YShjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvKVxuICAgICAgICA6IFtdO1xuICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IG1lcmdlUHJvdmlkZXJEYXRhKHVzZXIucHJvdmlkZXJEYXRhLCBuZXdQcm92aWRlckRhdGEpO1xuICAgIC8vIFByZXNlcnZlcyB0aGUgbm9uLW5vbnltb3VzIHN0YXR1cyBvZiB0aGUgc3RvcmVkIHVzZXIsIGV2ZW4gaWYgbm8gbW9yZVxuICAgIC8vIGNyZWRlbnRpYWxzIChmZWRlcmF0ZWQgb3IgZW1haWwvcGFzc3dvcmQpIGFyZSBsaW5rZWQgdG8gdGhlIHVzZXIuIElmXG4gICAgLy8gdGhlIHVzZXIgd2FzIHByZXZpb3VzbHkgYW5vbnltb3VzLCB0aGVuIHVzZSBwcm92aWRlciBkYXRhIHRvIHVwZGF0ZS5cbiAgICAvLyBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgaXQgd2FzIG5vdCBhbm9ueW1vdXMgYmVmb3JlLCBpdCBzaG91bGQgbmV2ZXIgYmVcbiAgICAvLyBjb25zaWRlcmVkIGFub255bW91cyBub3cuXG4gICAgY29uc3Qgb2xkSXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xuICAgIGNvbnN0IG5ld0lzQW5vbnltb3VzID0gISh1c2VyLmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiYgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBpc0Fub255bW91cyA9ICFvbGRJc0Fub255bW91cyA/IGZhbHNlIDogbmV3SXNBbm9ueW1vdXM7XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgICAgdWlkOiBjb3JlQWNjb3VudC5sb2NhbElkLFxuICAgICAgICBkaXNwbGF5TmFtZTogY29yZUFjY291bnQuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXG4gICAgICAgIGVtYWlsOiBjb3JlQWNjb3VudC5lbWFpbCB8fCBudWxsLFxuICAgICAgICBlbWFpbFZlcmlmaWVkOiBjb3JlQWNjb3VudC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlLFxuICAgICAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcbiAgICAgICAgdGVuYW50SWQ6IGNvcmVBY2NvdW50LnRlbmFudElkIHx8IG51bGwsXG4gICAgICAgIHByb3ZpZGVyRGF0YSxcbiAgICAgICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXG4gICAgICAgIGlzQW5vbnltb3VzXG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xufVxuLyoqXG4gKiBSZWxvYWRzIHVzZXIgYWNjb3VudCBkYXRhLCBpZiBzaWduZWQgaW4uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbG9hZCh1c2VyKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gdXRpbC5nZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlckludGVybmFsKTtcbiAgICAvLyBFdmVuIHRob3VnaCB0aGUgY3VycmVudCB1c2VyIGhhc24ndCBjaGFuZ2VkLCB1cGRhdGVcbiAgICAvLyBjdXJyZW50IHVzZXIgd2lsbCB0cmlnZ2VyIGEgcGVyc2lzdGVuY2UgdXBkYXRlIHcvIHRoZVxuICAgIC8vIG5ldyBpbmZvLlxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICAgIHVzZXJJbnRlcm5hbC5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodXNlckludGVybmFsKTtcbn1cbmZ1bmN0aW9uIG1lcmdlUHJvdmlkZXJEYXRhKG9yaWdpbmFsLCBuZXdEYXRhKSB7XG4gICAgY29uc3QgZGVkdXBlZCA9IG9yaWdpbmFsLmZpbHRlcihvID0+ICFuZXdEYXRhLnNvbWUobiA9PiBuLnByb3ZpZGVySWQgPT09IG8ucHJvdmlkZXJJZCkpO1xuICAgIHJldHVybiBbLi4uZGVkdXBlZCwgLi4ubmV3RGF0YV07XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvdmlkZXJEYXRhKHByb3ZpZGVycykge1xuICAgIHJldHVybiBwcm92aWRlcnMubWFwKChfYSkgPT4ge1xuICAgICAgICB2YXIgeyBwcm92aWRlcklkIH0gPSBfYSwgcHJvdmlkZXIgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInByb3ZpZGVySWRcIl0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHVpZDogcHJvdmlkZXIucmF3SWQgfHwgJycsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogcHJvdmlkZXIuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIGVtYWlsOiBwcm92aWRlci5lbWFpbCB8fCBudWxsLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IHByb3ZpZGVyLnBob25lTnVtYmVyIHx8IG51bGwsXG4gICAgICAgICAgICBwaG90b1VSTDogcHJvdmlkZXIucGhvdG9VcmwgfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdFN0c1Rva2VuKGF1dGgsIHJlZnJlc2hUb2tlbikge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1GZXRjaFdpdGhFcnJvckhhbmRsaW5nKGF1dGgsIHt9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1dGlsLnF1ZXJ5c3RyaW5nKHtcbiAgICAgICAgICAgICdncmFudF90eXBlJzogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgICAgJ3JlZnJlc2hfdG9rZW4nOiByZWZyZXNoVG9rZW5cbiAgICAgICAgfSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHsgdG9rZW5BcGlIb3N0LCBhcGlLZXkgfSA9IGF1dGguY29uZmlnO1xuICAgICAgICBjb25zdCB1cmwgPSBfZ2V0RmluYWxUYXJnZXQoYXV0aCwgdG9rZW5BcGlIb3N0LCBcIi92MS90b2tlblwiIC8qIEVuZHBvaW50LlRPS0VOICovLCBga2V5PSR7YXBpS2V5fWApO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgYXV0aC5fZ2V0QWRkaXRpb25hbEhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiIC8qIEh0dHBIZWFkZXIuQ09OVEVOVF9UWVBFICovXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICByZXR1cm4gRmV0Y2hQcm92aWRlci5mZXRjaCgpKHVybCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBUaGUgcmVzcG9uc2UgY29tZXMgYmFjayBpbiBzbmFrZV9jYXNlLiBDb252ZXJ0IHRvIGNhbWVsOlxuICAgIHJldHVybiB7XG4gICAgICAgIGFjY2Vzc1Rva2VuOiByZXNwb25zZS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgIGV4cGlyZXNJbjogcmVzcG9uc2UuZXhwaXJlc19pbixcbiAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZS5yZWZyZXNoX3Rva2VuXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJldm9rZVRva2VuKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHM6cmV2b2tlVG9rZW5cIiAvKiBFbmRwb2ludC5SRVZPS0VfVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFdlIG5lZWQgdG8gbWFyayB0aGlzIGNsYXNzIGFzIGludGVybmFsIGV4cGxpY2l0bHkgdG8gZXhjbHVkZSBpdCBpbiB0aGUgcHVibGljIHR5cGluZ3MsIGJlY2F1c2VcbiAqIGl0IHJlZmVyZW5jZXMgQXV0aEludGVybmFsIHdoaWNoIGhhcyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCBVc2VySW50ZXJuYWwuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFN0c1Rva2VuTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaXNFeHBpcmVkKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmV4cGlyYXRpb25UaW1lIHx8XG4gICAgICAgICAgICBEYXRlLm5vdygpID4gdGhpcy5leHBpcmF0aW9uVGltZSAtIDMwMDAwIC8qIEJ1ZmZlci5UT0tFTl9SRUZSRVNIICovKTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZXNwb25zZS5pZFRva2VuICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZXNwb25zZS5yZWZyZXNoVG9rZW4gIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9ICdleHBpcmVzSW4nIGluIHJlc3BvbnNlICYmIHR5cGVvZiByZXNwb25zZS5leHBpcmVzSW4gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IE51bWJlcihyZXNwb25zZS5leHBpcmVzSW4pXG4gICAgICAgICAgICA6IF90b2tlbkV4cGlyZXNJbihyZXNwb25zZS5pZFRva2VuKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKHJlc3BvbnNlLmlkVG9rZW4sIHJlc3BvbnNlLnJlZnJlc2hUb2tlbiwgZXhwaXJlc0luKTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbikge1xuICAgICAgICBfYXNzZXJ0KGlkVG9rZW4ubGVuZ3RoICE9PSAwLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IF90b2tlbkV4cGlyZXNJbihpZFRva2VuKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGlkVG9rZW4sIG51bGwsIGV4cGlyZXNJbik7XG4gICAgfVxuICAgIGFzeW5jIGdldFRva2VuKGF1dGgsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIHRoaXMuYWNjZXNzVG9rZW4gJiYgIXRoaXMuaXNFeHBpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMucmVmcmVzaFRva2VuLCBhdXRoLCBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyk7XG4gICAgICAgIGlmICh0aGlzLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoKGF1dGgsIHRoaXMucmVmcmVzaFRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjbGVhclJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBudWxsO1xuICAgIH1cbiAgICBhc3luYyByZWZyZXNoKGF1dGgsIG9sZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgZXhwaXJlc0luIH0gPSBhd2FpdCByZXF1ZXN0U3RzVG9rZW4oYXV0aCwgb2xkVG9rZW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgTnVtYmVyKGV4cGlyZXNJbikpO1xuICAgIH1cbiAgICB1cGRhdGVUb2tlbnNBbmRFeHBpcmF0aW9uKGFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGV4cGlyZXNJblNlYykge1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlZnJlc2hUb2tlbiB8fCBudWxsO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW4gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IERhdGUubm93KCkgKyBleHBpcmVzSW5TZWMgKiAxMDAwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04oYXBwTmFtZSwgb2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHsgcmVmcmVzaFRva2VuLCBhY2Nlc3NUb2tlbiwgZXhwaXJhdGlvblRpbWUgfSA9IG9iamVjdDtcbiAgICAgICAgY29uc3QgbWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcbiAgICAgICAgaWYgKHJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgX2Fzc2VydCh0eXBlb2YgcmVmcmVzaFRva2VuID09PSAnc3RyaW5nJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sIHtcbiAgICAgICAgICAgICAgICBhcHBOYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1hbmFnZXIucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgX2Fzc2VydCh0eXBlb2YgYWNjZXNzVG9rZW4gPT09ICdzdHJpbmcnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFuYWdlci5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgX2Fzc2VydCh0eXBlb2YgZXhwaXJhdGlvblRpbWUgPT09ICdudW1iZXInLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFuYWdlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWZyZXNoVG9rZW46IHRoaXMucmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW46IHRoaXMuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZTogdGhpcy5leHBpcmF0aW9uVGltZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYXNzaWduKHN0c1Rva2VuTWFuYWdlcikge1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuO1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBzdHNUb2tlbk1hbmFnZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgfVxuICAgIF9jbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFN0c1Rva2VuTWFuYWdlcigpLCB0aGlzLnRvSlNPTigpKTtcbiAgICB9XG4gICAgX3BlcmZvcm1SZWZyZXNoKCkge1xuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChhc3NlcnRpb24sIGFwcE5hbWUpIHtcbiAgICBfYXNzZXJ0KHR5cGVvZiBhc3NlcnRpb24gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhc3NlcnRpb24gPT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywgeyBhcHBOYW1lIH0pO1xufVxuY2xhc3MgVXNlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7IHVpZCwgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyIH0gPSBfYSwgb3B0ID0gdHNsaWIuX19yZXN0KF9hLCBbXCJ1aWRcIiwgXCJhdXRoXCIsIFwic3RzVG9rZW5NYW5hZ2VyXCJdKTtcbiAgICAgICAgLy8gRm9yIHRoZSB1c2VyIG9iamVjdCwgcHJvdmlkZXIgaXMgYWx3YXlzIEZpcmViYXNlLlxuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBcImZpcmViYXNlXCIgLyogUHJvdmlkZXJJZC5GSVJFQkFTRSAqLztcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoID0gbmV3IFByb2FjdGl2ZVJlZnJlc2godGhpcyk7XG4gICAgICAgIHRoaXMucmVsb2FkVXNlckluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLnJlbG9hZExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy51aWQgPSB1aWQ7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyID0gc3RzVG9rZW5NYW5hZ2VyO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuO1xuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gb3B0LmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgIHRoaXMuZW1haWwgPSBvcHQuZW1haWwgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gb3B0LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSBvcHQucGhvbmVOdW1iZXIgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5waG90b1VSTCA9IG9wdC5waG90b1VSTCB8fCBudWxsO1xuICAgICAgICB0aGlzLmlzQW5vbnltb3VzID0gb3B0LmlzQW5vbnltb3VzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gb3B0LnRlbmFudElkIHx8IG51bGw7XG4gICAgICAgIHRoaXMucHJvdmlkZXJEYXRhID0gb3B0LnByb3ZpZGVyRGF0YSA/IFsuLi5vcHQucHJvdmlkZXJEYXRhXSA6IFtdO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IFVzZXJNZXRhZGF0YShvcHQuY3JlYXRlZEF0IHx8IHVuZGVmaW5lZCwgb3B0Lmxhc3RMb2dpbkF0IHx8IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGFzeW5jIGdldElkVG9rZW4oZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgdGhpcy5zdHNUb2tlbk1hbmFnZXIuZ2V0VG9rZW4odGhpcy5hdXRoLCBmb3JjZVJlZnJlc2gpKTtcbiAgICAgICAgX2Fzc2VydChhY2Nlc3NUb2tlbiwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICE9PSBhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2Nlc3NUb2tlbjtcbiAgICB9XG4gICAgZ2V0SWRUb2tlblJlc3VsdChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuIGdldElkVG9rZW5SZXN1bHQodGhpcywgZm9yY2VSZWZyZXNoKTtcbiAgICB9XG4gICAgcmVsb2FkKCkge1xuICAgICAgICByZXR1cm4gcmVsb2FkKHRoaXMpO1xuICAgIH1cbiAgICBfYXNzaWduKHVzZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IHVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMudWlkID09PSB1c2VyLnVpZCwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSB1c2VyLmRpc3BsYXlOYW1lO1xuICAgICAgICB0aGlzLnBob3RvVVJMID0gdXNlci5waG90b1VSTDtcbiAgICAgICAgdGhpcy5lbWFpbCA9IHVzZXIuZW1haWw7XG4gICAgICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IHVzZXIuZW1haWxWZXJpZmllZDtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHVzZXIucGhvbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gdXNlci50ZW5hbnRJZDtcbiAgICAgICAgdGhpcy5wcm92aWRlckRhdGEgPSB1c2VyLnByb3ZpZGVyRGF0YS5tYXAodXNlckluZm8gPT4gKE9iamVjdC5hc3NpZ24oe30sIHVzZXJJbmZvKSkpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLl9jb3B5KHVzZXIubWV0YWRhdGEpO1xuICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci5fYXNzaWduKHVzZXIuc3RzVG9rZW5NYW5hZ2VyKTtcbiAgICB9XG4gICAgX2Nsb25lKGF1dGgpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlciA9IG5ldyBVc2VySW1wbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMpLCB7IGF1dGgsIHN0c1Rva2VuTWFuYWdlcjogdGhpcy5zdHNUb2tlbk1hbmFnZXIuX2Nsb25lKCkgfSkpO1xuICAgICAgICBuZXdVc2VyLm1ldGFkYXRhLl9jb3B5KHRoaXMubWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gbmV3VXNlcjtcbiAgICB9XG4gICAgX29uUmVsb2FkKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZXJlIHNob3VsZCBvbmx5IGV2ZXIgYmUgb25lIGxpc3RlbmVyLCBhbmQgdGhhdCBpcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiBNdWx0aUZhY3RvclVzZXJcbiAgICAgICAgX2Fzc2VydCghdGhpcy5yZWxvYWRMaXN0ZW5lciwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHRoaXMucmVsb2FkVXNlckluZm8pIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlbG9hZExpc3RlbmVyKHRoaXMucmVsb2FkVXNlckluZm8pO1xuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX25vdGlmeVJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbG9hZExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZExpc3RlbmVyKHVzZXJJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGxpc3RlbmVyIGlzIHN1YnNjcmliZWQgeWV0LCBzYXZlIHRoZSByZXN1bHQgc28gaXQncyBhdmFpbGFibGUgd2hlbiB0aGV5IGRvIHN1YnNjcmliZVxuICAgICAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IHVzZXJJbmZvO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RhcnQoKTtcbiAgICB9XG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2guX3N0b3AoKTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCByZWxvYWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdG9rZW5zUmVmcmVzaGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXNwb25zZS5pZFRva2VuICYmXG4gICAgICAgICAgICByZXNwb25zZS5pZFRva2VuICE9PSB0aGlzLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRva2Vuc1JlZnJlc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbG9hZCkge1xuICAgICAgICAgICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh0aGlzKTtcbiAgICAgICAgaWYgKHRva2Vuc1JlZnJlc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKCkge1xuICAgICAgICBpZiAoYXBwLl9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXV0aC5hcHApKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcy5hdXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuZ2V0SWRUb2tlbigpO1xuICAgICAgICBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLCBkZWxldGVBY2NvdW50KHRoaXMuYXV0aCwgeyBpZFRva2VuIH0pKTtcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIuY2xlYXJSZWZyZXNoVG9rZW4oKTtcbiAgICAgICAgLy8gVE9ETzogRGV0ZXJtaW5lIGlmIGNhbmNlbGxhYmxlLXByb21pc2VzIGFyZSBuZWNlc3NhcnkgdG8gdXNlIGluIHRoaXMgY2xhc3Mgc28gdGhhdCBkZWxldGUoKVxuICAgICAgICAvLyAgICAgICBjYW5jZWxzIHBlbmRpbmcgYWN0aW9ucy4uLlxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoLnNpZ25PdXQoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdWlkOiB0aGlzLnVpZCwgZW1haWw6IHRoaXMuZW1haWwgfHwgdW5kZWZpbmVkLCBlbWFpbFZlcmlmaWVkOiB0aGlzLmVtYWlsVmVyaWZpZWQsIGRpc3BsYXlOYW1lOiB0aGlzLmRpc3BsYXlOYW1lIHx8IHVuZGVmaW5lZCwgaXNBbm9ueW1vdXM6IHRoaXMuaXNBbm9ueW1vdXMsIHBob3RvVVJMOiB0aGlzLnBob3RvVVJMIHx8IHVuZGVmaW5lZCwgcGhvbmVOdW1iZXI6IHRoaXMucGhvbmVOdW1iZXIgfHwgdW5kZWZpbmVkLCB0ZW5hbnRJZDogdGhpcy50ZW5hbnRJZCB8fCB1bmRlZmluZWQsIHByb3ZpZGVyRGF0YTogdGhpcy5wcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKSwgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci50b0pTT04oKSwgXG4gICAgICAgICAgICAvLyBSZWRpcmVjdCBldmVudCBJRCBtdXN0IGJlIG1haW50YWluZWQgaW4gY2FzZSB0aGVyZSBpcyBhIHBlbmRpbmdcbiAgICAgICAgICAgIC8vIHJlZGlyZWN0IGV2ZW50LlxuICAgICAgICAgICAgX3JlZGlyZWN0RXZlbnRJZDogdGhpcy5fcmVkaXJlY3RFdmVudElkIH0sIHRoaXMubWV0YWRhdGEudG9KU09OKCkpLCB7IFxuICAgICAgICAgICAgLy8gUmVxdWlyZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgbGVnYWN5IFNESyAoZ28vZmlyZWJhc2UtYXV0aC1zZGstcGVyc2lzdGVuY2UtcGFyc2luZyk6XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXV0aC5jb25maWcuYXBpS2V5LCBhcHBOYW1lOiB0aGlzLmF1dGgubmFtZSB9KTtcbiAgICB9XG4gICAgZ2V0IHJlZnJlc2hUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLnJlZnJlc2hUb2tlbiB8fCAnJztcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tSlNPTihhdXRoLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSAoX2EgPSBvYmplY3QuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZW1haWwgPSAoX2IgPSBvYmplY3QuZW1haWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSAoX2MgPSBvYmplY3QucGhvbmVOdW1iZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGhvdG9VUkwgPSAoX2QgPSBvYmplY3QucGhvdG9VUkwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdGVuYW50SWQgPSAoX2UgPSBvYmplY3QudGVuYW50SWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgX3JlZGlyZWN0RXZlbnRJZCA9IChfZiA9IG9iamVjdC5fcmVkaXJlY3RFdmVudElkKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRBdCA9IChfZyA9IG9iamVjdC5jcmVhdGVkQXQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbGFzdExvZ2luQXQgPSAoX2ggPSBvYmplY3QubGFzdExvZ2luQXQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgeyB1aWQsIGVtYWlsVmVyaWZpZWQsIGlzQW5vbnltb3VzLCBwcm92aWRlckRhdGEsIHN0c1Rva2VuTWFuYWdlcjogcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIgfSA9IG9iamVjdDtcbiAgICAgICAgX2Fzc2VydCh1aWQgJiYgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gU3RzVG9rZW5NYW5hZ2VyLmZyb21KU09OKHRoaXMubmFtZSwgcGxhaW5PYmplY3RUb2tlbk1hbmFnZXIpO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGRpc3BsYXlOYW1lLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChlbWFpbCwgYXV0aC5uYW1lKTtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgZW1haWxWZXJpZmllZCA9PT0gJ2Jvb2xlYW4nLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIGlzQW5vbnltb3VzID09PSAnYm9vbGVhbicsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQocGhvbmVOdW1iZXIsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob3RvVVJMLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZCh0ZW5hbnRJZCwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoX3JlZGlyZWN0RXZlbnRJZCwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoY3JlYXRlZEF0LCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChsYXN0TG9naW5BdCwgYXV0aC5uYW1lKTtcbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICAgICAgICB1aWQsXG4gICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBlbWFpbFZlcmlmaWVkLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgICBpc0Fub255bW91cyxcbiAgICAgICAgICAgIHBob3RvVVJMLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICB0ZW5hbnRJZCxcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgICAgICAgIGxhc3RMb2dpbkF0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvdmlkZXJEYXRhICYmIEFycmF5LmlzQXJyYXkocHJvdmlkZXJEYXRhKSkge1xuICAgICAgICAgICAgdXNlci5wcm92aWRlckRhdGEgPSBwcm92aWRlckRhdGEubWFwKHVzZXJJbmZvID0+IChPYmplY3QuYXNzaWduKHt9LCB1c2VySW5mbykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3JlZGlyZWN0RXZlbnRJZCkge1xuICAgICAgICAgICAgdXNlci5fcmVkaXJlY3RFdmVudElkID0gX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIFVzZXIgZnJvbSBhbiBpZFRva2VuIHNlcnZlciByZXNwb25zZVxuICAgICAqIEBwYXJhbSBhdXRoXG4gICAgICogQHBhcmFtIGlkVG9rZW5SZXNwb25zZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBfZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBpZFRva2VuUmVzcG9uc2UsIGlzQW5vbnltb3VzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xuICAgICAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbVNlcnZlclJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIEZpcmViYXNlIEF1dGggdXNlci5cbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICAgICAgICB1aWQ6IGlkVG9rZW5SZXNwb25zZS5sb2NhbElkLFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgIHN0c1Rva2VuTWFuYWdlcixcbiAgICAgICAgICAgIGlzQW5vbnltb3VzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVcGRhdGVzIHRoZSB1c2VyIGluZm8gYW5kIGRhdGEgYW5kIHJlc29sdmVzIHdpdGggYSB1c2VyIGluc3RhbmNlLlxuICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh1c2VyKTtcbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBVc2VyIGZyb20gYW4gaWRUb2tlbiBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gYXV0aFxuICAgICAqIEBwYXJhbSBpZFRva2VuUmVzcG9uc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21HZXRBY2NvdW50SW5mb1Jlc3BvbnNlKGF1dGgsIHJlc3BvbnNlLCBpZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IGNvcmVBY2NvdW50ID0gcmVzcG9uc2UudXNlcnNbMF07XG4gICAgICAgIF9hc3NlcnQoY29yZUFjY291bnQubG9jYWxJZCAhPT0gdW5kZWZpbmVkLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBleHRyYWN0UHJvdmlkZXJEYXRhKGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCBpc0Fub255bW91cyA9ICEoY29yZUFjY291bnQuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJiAhKHByb3ZpZGVyRGF0YSA9PT0gbnVsbCB8fCBwcm92aWRlckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3ZpZGVyRGF0YS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBzdHNUb2tlbk1hbmFnZXIgPSBuZXcgU3RzVG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgIHN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tSWRUb2tlbihpZFRva2VuKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgRmlyZWJhc2UgQXV0aCB1c2VyLlxuICAgICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXJJbXBsKHtcbiAgICAgICAgICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXG4gICAgICAgICAgICBpc0Fub255bW91c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSB1c2VyIHdpdGggZGF0YSBmcm9tIHRoZSBHZXRBY2NvdW50SW5mbyByZXNwb25zZS5cbiAgICAgICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgICAgICAgIHVpZDogY29yZUFjY291bnQubG9jYWxJZCxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBjb3JlQWNjb3VudC5kaXNwbGF5TmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXG4gICAgICAgICAgICBlbWFpbDogY29yZUFjY291bnQuZW1haWwgfHwgbnVsbCxcbiAgICAgICAgICAgIGVtYWlsVmVyaWZpZWQ6IGNvcmVBY2NvdW50LmVtYWlsVmVyaWZpZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcbiAgICAgICAgICAgIHRlbmFudElkOiBjb3JlQWNjb3VudC50ZW5hbnRJZCB8fCBudWxsLFxuICAgICAgICAgICAgcHJvdmlkZXJEYXRhLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXG4gICAgICAgICAgICBpc0Fub255bW91czogIShjb3JlQWNjb3VudC5lbWFpbCAmJiBjb3JlQWNjb3VudC5wYXNzd29yZEhhc2gpICYmXG4gICAgICAgICAgICAgICAgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xuICAgICAgICByZXR1cm4gdXNlcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBpbnN0YW5jZUNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gX2dldEluc3RhbmNlKGNscykge1xuICAgIGRlYnVnQXNzZXJ0KGNscyBpbnN0YW5jZW9mIEZ1bmN0aW9uLCAnRXhwZWN0ZWQgYSBjbGFzcyBkZWZpbml0aW9uJyk7XG4gICAgbGV0IGluc3RhbmNlID0gaW5zdGFuY2VDYWNoZS5nZXQoY2xzKTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgZGVidWdBc3NlcnQoaW5zdGFuY2UgaW5zdGFuY2VvZiBjbHMsICdJbnN0YW5jZSBzdG9yZWQgaW4gY2FjaGUgbWlzbWF0Y2hlZCB3aXRoIGNsYXNzJyk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgaW5zdGFuY2UgPSBuZXcgY2xzKCk7XG4gICAgaW5zdGFuY2VDYWNoZS5zZXQoY2xzLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgSW5NZW1vcnlQZXJzaXN0ZW5jZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiTk9ORVwiIC8qIFBlcnNpc3RlbmNlVHlwZS5OT05FICovO1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fTtcbiAgICB9XG4gICAgYXN5bmMgX2lzQXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYXN5bmMgX3NldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIF9nZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdG9yYWdlW2tleV07XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zdG9yYWdlW2tleV07XG4gICAgfVxuICAgIF9hZGRMaXN0ZW5lcihfa2V5LCBfbGlzdGVuZXIpIHtcbiAgICAgICAgLy8gTGlzdGVuZXJzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBpbi1tZW1vcnkgc3RvcmFnZSBzaW5jZSBpdCBjYW5ub3QgYmUgc2hhcmVkIGFjcm9zcyB3aW5kb3dzL3dvcmtlcnNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2tleSwgX2xpc3RlbmVyKSB7XG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5Jbk1lbW9yeVBlcnNpc3RlbmNlLnR5cGUgPSAnTk9ORSc7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBQZXJzaXN0ZW5jZX0gb2YgdHlwZSAnTk9ORScuXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBpbk1lbW9yeVBlcnNpc3RlbmNlID0gSW5NZW1vcnlQZXJzaXN0ZW5jZTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9wZXJzaXN0ZW5jZUtleU5hbWUoa2V5LCBhcGlLZXksIGFwcE5hbWUpIHtcbiAgICByZXR1cm4gYCR7XCJmaXJlYmFzZVwiIC8qIE5hbWVzcGFjZS5QRVJTSVNURU5DRSAqL306JHtrZXl9OiR7YXBpS2V5fToke2FwcE5hbWV9YDtcbn1cbmNsYXNzIFBlcnNpc3RlbmNlVXNlck1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHBlcnNpc3RlbmNlLCBhdXRoLCB1c2VyS2V5KSB7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy51c2VyS2V5ID0gdXNlcktleTtcbiAgICAgICAgY29uc3QgeyBjb25maWcsIG5hbWUgfSA9IHRoaXMuYXV0aDtcbiAgICAgICAgdGhpcy5mdWxsVXNlcktleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodGhpcy51c2VyS2V5LCBjb25maWcuYXBpS2V5LCBuYW1lKTtcbiAgICAgICAgdGhpcy5mdWxsUGVyc2lzdGVuY2VLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKFwicGVyc2lzdGVuY2VcIiAvKiBLZXlOYW1lLlBFUlNJU1RFTkNFX1VTRVIgKi8sIGNvbmZpZy5hcGlLZXksIG5hbWUpO1xuICAgICAgICB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyID0gYXV0aC5fb25TdG9yYWdlRXZlbnQuYmluZChhdXRoKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5fYWRkTGlzdGVuZXIodGhpcy5mdWxsVXNlcktleSwgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHNldEN1cnJlbnRVc2VyKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3NldCh0aGlzLmZ1bGxVc2VyS2V5LCB1c2VyLnRvSlNPTigpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q3VycmVudFVzZXIoKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB0aGlzLnBlcnNpc3RlbmNlLl9nZXQodGhpcy5mdWxsVXNlcktleSk7XG4gICAgICAgIHJldHVybiBibG9iID8gVXNlckltcGwuX2Zyb21KU09OKHRoaXMuYXV0aCwgYmxvYikgOiBudWxsO1xuICAgIH1cbiAgICByZW1vdmVDdXJyZW50VXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVuY2UuX3JlbW92ZSh0aGlzLmZ1bGxVc2VyS2V5KTtcbiAgICB9XG4gICAgc2F2ZVBlcnNpc3RlbmNlRm9yUmVkaXJlY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsUGVyc2lzdGVuY2VLZXksIHRoaXMucGVyc2lzdGVuY2UudHlwZSk7XG4gICAgfVxuICAgIGFzeW5jIHNldFBlcnNpc3RlbmNlKG5ld1BlcnNpc3RlbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlID09PSBuZXdQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gYXdhaXQgdGhpcy5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUN1cnJlbnRVc2VyKCk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBuZXdQZXJzaXN0ZW5jZTtcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRDdXJyZW50VXNlcihjdXJyZW50VXNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlLl9yZW1vdmVMaXN0ZW5lcih0aGlzLmZ1bGxVc2VyS2V5LCB0aGlzLmJvdW5kRXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShhdXRoLCBwZXJzaXN0ZW5jZUhpZXJhcmNoeSwgdXNlcktleSA9IFwiYXV0aFVzZXJcIiAvKiBLZXlOYW1lLkFVVEhfVVNFUiAqLykge1xuICAgICAgICBpZiAoIXBlcnNpc3RlbmNlSGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKF9nZXRJbnN0YW5jZShpbk1lbW9yeVBlcnNpc3RlbmNlKSwgYXV0aCwgdXNlcktleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxpbWluYXRlIGFueSBwZXJzaXN0ZW5jZXMgdGhhdCBhcmUgbm90IGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBhdmFpbGFibGVQZXJzaXN0ZW5jZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocGVyc2lzdGVuY2VIaWVyYXJjaHkubWFwKGFzeW5jIChwZXJzaXN0ZW5jZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHBlcnNpc3RlbmNlLl9pc0F2YWlsYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlcnNpc3RlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSkpKS5maWx0ZXIocGVyc2lzdGVuY2UgPT4gcGVyc2lzdGVuY2UpO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGZpcnN0IHBlcnNpc3RlbmNlIGxpc3RlZCwgb3IgaW4gbWVtb3J5IGlmIG5vbmUgYXZhaWxhYmxlXG4gICAgICAgIGxldCBzZWxlY3RlZFBlcnNpc3RlbmNlID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzWzBdIHx8XG4gICAgICAgICAgICBfZ2V0SW5zdGFuY2UoaW5NZW1vcnlQZXJzaXN0ZW5jZSk7XG4gICAgICAgIGNvbnN0IGtleSA9IF9wZXJzaXN0ZW5jZUtleU5hbWUodXNlcktleSwgYXV0aC5jb25maWcuYXBpS2V5LCBhdXRoLm5hbWUpO1xuICAgICAgICAvLyBQdWxsIG91dCB0aGUgZXhpc3RpbmcgdXNlciwgc2V0dGluZyB0aGUgY2hvc2VuIHBlcnNpc3RlbmNlIHRvIHRoYXRcbiAgICAgICAgLy8gcGVyc2lzdGVuY2UgaWYgdGhlIHVzZXIgZXhpc3RzLlxuICAgICAgICBsZXQgdXNlclRvTWlncmF0ZSA9IG51bGw7XG4gICAgICAgIC8vIE5vdGUsIGhlcmUgd2UgY2hlY2sgZm9yIGEgdXNlciBpbiBfYWxsXyBwZXJzaXN0ZW5jZXMsIG5vdCBqdXN0IHRoZVxuICAgICAgICAvLyBvbmVzIGRlZW1lZCBhdmFpbGFibGUuIElmIHdlIGNhbiBtaWdyYXRlIGEgdXNlciBvdXQgb2YgYSBicm9rZW5cbiAgICAgICAgLy8gcGVyc2lzdGVuY2UsIHdlIHdpbGwgKGJ1dCBvbmx5IGlmIHRoYXQgcGVyc2lzdGVuY2Ugc3VwcG9ydHMgbWlncmF0aW9uKS5cbiAgICAgICAgZm9yIChjb25zdCBwZXJzaXN0ZW5jZSBvZiBwZXJzaXN0ZW5jZUhpZXJhcmNoeSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcGVyc2lzdGVuY2UuX2dldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBVc2VySW1wbC5fZnJvbUpTT04oYXV0aCwgYmxvYik7IC8vIHRocm93cyBmb3IgdW5wYXJzYWJsZSBibG9iICh3cm9uZyBmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlclRvTWlncmF0ZSA9IHVzZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IHBlcnNpc3RlbmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGZpbmQgdGhlIHVzZXIgaW4gYSBwZXJzaXN0ZW5jZSB0aGF0IGRvZXMgc3VwcG9ydCBtaWdyYXRpb24sIHVzZVxuICAgICAgICAvLyB0aGF0IG1pZ3JhdGlvbiBwYXRoIChvZiBvbmx5IHBlcnNpc3RlbmNlcyB0aGF0IHN1cHBvcnQgbWlncmF0aW9uKVxuICAgICAgICBjb25zdCBtaWdyYXRpb25IaWVyYXJjaHkgPSBhdmFpbGFibGVQZXJzaXN0ZW5jZXMuZmlsdGVyKHAgPT4gcC5fc2hvdWxkQWxsb3dNaWdyYXRpb24pO1xuICAgICAgICAvLyBJZiB0aGUgcGVyc2lzdGVuY2UgZG9lcyBfbm90XyBhbGxvdyBtaWdyYXRpb24sIGp1c3QgZmluaXNoIG9mZiBoZXJlXG4gICAgICAgIGlmICghc2VsZWN0ZWRQZXJzaXN0ZW5jZS5fc2hvdWxkQWxsb3dNaWdyYXRpb24gfHxcbiAgICAgICAgICAgICFtaWdyYXRpb25IaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IG1pZ3JhdGlvbkhpZXJhcmNoeVswXTtcbiAgICAgICAgaWYgKHVzZXJUb01pZ3JhdGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbm9ybWFsbHkgc2hvdWxkbid0IHRocm93IHNpbmNlIGNob3NlblBlcnNpc3RlbmNlLmlzQXZhaWxhYmxlKCkgaXMgdHJ1ZSwgYnV0IGlmIGl0IGRvZXNcbiAgICAgICAgICAgIC8vIHdlJ2xsIGp1c3QgbGV0IGl0IGJ1YmJsZSB0byBzdXJmYWNlIHRoZSBlcnJvci5cbiAgICAgICAgICAgIGF3YWl0IHNlbGVjdGVkUGVyc2lzdGVuY2UuX3NldChrZXksIHVzZXJUb01pZ3JhdGUudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gY2xlYXIgdGhlIGtleSBpbiBvdGhlciBwZXJzaXN0ZW5jZXMgYnV0IGlnbm9yZSBlcnJvcnMuIFRoaXMgaGVscHMgcHJldmVudCBpc3N1ZXNcbiAgICAgICAgLy8gc3VjaCBhcyB1c2VycyBnZXR0aW5nIHN0dWNrIHdpdGggYSBwcmV2aW91cyBhY2NvdW50IGFmdGVyIHNpZ25pbmcgb3V0IGFuZCByZWZyZXNoaW5nIHRoZSB0YWIuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyAocGVyc2lzdGVuY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChwZXJzaXN0ZW5jZSAhPT0gc2VsZWN0ZWRQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHBlcnNpc3RlbmNlLl9yZW1vdmUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIoc2VsZWN0ZWRQZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIGJyb3dzZXIgZm9yIHRoZSBwdXJwb3NlcyBvZiByZXBvcnRpbmcgdXNhZ2UgdG8gdGhlIEFQSVxuICovXG5mdW5jdGlvbiBfZ2V0QnJvd3Nlck5hbWUodXNlckFnZW50KSB7XG4gICAgY29uc3QgdWEgPSB1c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodWEuaW5jbHVkZXMoJ29wZXJhLycpIHx8IHVhLmluY2x1ZGVzKCdvcHIvJykgfHwgdWEuaW5jbHVkZXMoJ29waW9zLycpKSB7XG4gICAgICAgIHJldHVybiBcIk9wZXJhXCIgLyogQnJvd3Nlck5hbWUuT1BFUkEgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0lFTW9iaWxlKHVhKSkge1xuICAgICAgICAvLyBXaW5kb3dzIHBob25lIElFTW9iaWxlIGJyb3dzZXIuXG4gICAgICAgIHJldHVybiBcIklFTW9iaWxlXCIgLyogQnJvd3Nlck5hbWUuSUVNT0JJTEUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdtc2llJykgfHwgdWEuaW5jbHVkZXMoJ3RyaWRlbnQvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiSUVcIiAvKiBCcm93c2VyTmFtZS5JRSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiRWRnZVwiIC8qIEJyb3dzZXJOYW1lLkVER0UgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0ZpcmVmb3godWEpKSB7XG4gICAgICAgIHJldHVybiBcIkZpcmVmb3hcIiAvKiBCcm93c2VyTmFtZS5GSVJFRk9YICovO1xuICAgIH1cbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnc2lsay8nKSkge1xuICAgICAgICByZXR1cm4gXCJTaWxrXCIgLyogQnJvd3Nlck5hbWUuU0lMSyAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzQmxhY2tCZXJyeSh1YSkpIHtcbiAgICAgICAgLy8gQmxhY2tiZXJyeSBicm93c2VyLlxuICAgICAgICByZXR1cm4gXCJCbGFja2JlcnJ5XCIgLyogQnJvd3Nlck5hbWUuQkxBQ0tCRVJSWSAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzV2ViT1ModWEpKSB7XG4gICAgICAgIC8vIFdlYk9TIGRlZmF1bHQgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIFwiV2Vib3NcIiAvKiBCcm93c2VyTmFtZS5XRUJPUyAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzU2FmYXJpKHVhKSkge1xuICAgICAgICByZXR1cm4gXCJTYWZhcmlcIiAvKiBCcm93c2VyTmFtZS5TQUZBUkkgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKCh1YS5pbmNsdWRlcygnY2hyb21lLycpIHx8IF9pc0Nocm9tZUlPUyh1YSkpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnZWRnZS8nKSkge1xuICAgICAgICByZXR1cm4gXCJDaHJvbWVcIiAvKiBCcm93c2VyTmFtZS5DSFJPTUUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0FuZHJvaWQodWEpKSB7XG4gICAgICAgIC8vIEFuZHJvaWQgc3RvY2sgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIFwiQW5kcm9pZFwiIC8qIEJyb3dzZXJOYW1lLkFORFJPSUQgKi87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNb3N0IG1vZGVybiBicm93c2VycyBoYXZlIG5hbWUvdmVyc2lvbiBhdCBlbmQgb2YgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHJlID0gLyhbYS16QS1aXFxkXFwuXSspXFwvW2EtekEtWlxcZFxcLl0qJC87XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmUpO1xuICAgICAgICBpZiAoKG1hdGNoZXMgPT09IG51bGwgfHwgbWF0Y2hlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hlcy5sZW5ndGgpID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJPdGhlclwiIC8qIEJyb3dzZXJOYW1lLk9USEVSICovO1xufVxuZnVuY3Rpb24gX2lzRmlyZWZveCh1YSA9IHV0aWwuZ2V0VUEoKSkge1xuICAgIHJldHVybiAvZmlyZWZveFxcLy9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzU2FmYXJpKHVzZXJBZ2VudCA9IHV0aWwuZ2V0VUEoKSkge1xuICAgIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuICh1YS5pbmNsdWRlcygnc2FmYXJpLycpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnY2hyb21lLycpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnY3Jpb3MvJykgJiZcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdhbmRyb2lkJykpO1xufVxuZnVuY3Rpb24gX2lzQ2hyb21lSU9TKHVhID0gdXRpbC5nZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9jcmlvc1xcLy9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzSUVNb2JpbGUodWEgPSB1dGlsLmdldFVBKCkpIHtcbiAgICByZXR1cm4gL2llbW9iaWxlL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNBbmRyb2lkKHVhID0gdXRpbC5nZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9hbmRyb2lkL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNCbGFja0JlcnJ5KHVhID0gdXRpbC5nZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9ibGFja2JlcnJ5L2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNXZWJPUyh1YSA9IHV0aWwuZ2V0VUEoKSkge1xuICAgIHJldHVybiAvd2Vib3MvaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc0lPUyh1YSA9IHV0aWwuZ2V0VUEoKSkge1xuICAgIHJldHVybiAoL2lwaG9uZXxpcGFkfGlwb2QvaS50ZXN0KHVhKSB8fFxuICAgICAgICAoL21hY2ludG9zaC9pLnRlc3QodWEpICYmIC9tb2JpbGUvaS50ZXN0KHVhKSkpO1xufVxuZnVuY3Rpb24gX2lzSU9TN09yOCh1YSA9IHV0aWwuZ2V0VUEoKSkge1xuICAgIHJldHVybiAoLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgN19cXGQvaS50ZXN0KHVhKSB8fFxuICAgICAgICAvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pLnRlc3QodWEpKTtcbn1cbmZ1bmN0aW9uIF9pc0lFMTAoKSB7XG4gICAgcmV0dXJuIHV0aWwuaXNJRSgpICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA9PT0gMTA7XG59XG5mdW5jdGlvbiBfaXNNb2JpbGVCcm93c2VyKHVhID0gdXRpbC5nZXRVQSgpKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGdldEJyb3dzZXJOYW1lIGVxdWl2YWxlbnQgZm9yIE9TLlxuICAgIHJldHVybiAoX2lzSU9TKHVhKSB8fFxuICAgICAgICBfaXNBbmRyb2lkKHVhKSB8fFxuICAgICAgICBfaXNXZWJPUyh1YSkgfHxcbiAgICAgICAgX2lzQmxhY2tCZXJyeSh1YSkgfHxcbiAgICAgICAgL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSB8fFxuICAgICAgICBfaXNJRU1vYmlsZSh1YSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypcbiAqIERldGVybWluZSB0aGUgU0RLIHZlcnNpb24gc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtLCBmcmFtZXdvcmtzID0gW10pIHtcbiAgICBsZXQgcmVwb3J0ZWRQbGF0Zm9ybTtcbiAgICBzd2l0Y2ggKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgICAgIGNhc2UgXCJCcm93c2VyXCIgLyogQ2xpZW50UGxhdGZvcm0uQlJPV1NFUiAqLzpcbiAgICAgICAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXG4gICAgICAgICAgICByZXBvcnRlZFBsYXRmb3JtID0gX2dldEJyb3dzZXJOYW1lKHV0aWwuZ2V0VUEoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIldvcmtlclwiIC8qIENsaWVudFBsYXRmb3JtLldPUktFUiAqLzpcbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5IGEgd29ya2VyIHJ1bnMgZnJvbSBhIGJyb3dzZXIgYnV0IHdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBhXG4gICAgICAgICAgICAvLyB3b3JrZXIgZnJvbSBhIGJyb3dzZXIuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogQ2hyb21lLVdvcmtlci9Kc0NvcmUvNC45LjEvRmlyZWJhc2VDb3JlLXdlYi5cbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBgJHtfZ2V0QnJvd3Nlck5hbWUodXRpbC5nZXRVQSgpKX0tJHtjbGllbnRQbGF0Zm9ybX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXBvcnRlZFBsYXRmb3JtID0gY2xpZW50UGxhdGZvcm07XG4gICAgfVxuICAgIGNvbnN0IHJlcG9ydGVkRnJhbWV3b3JrcyA9IGZyYW1ld29ya3MubGVuZ3RoXG4gICAgICAgID8gZnJhbWV3b3Jrcy5qb2luKCcsJylcbiAgICAgICAgOiAnRmlyZWJhc2VDb3JlLXdlYic7IC8qIGRlZmF1bHQgdmFsdWUgaWYgbm8gb3RoZXIgZnJhbWV3b3JrIGlzIHVzZWQgKi9cbiAgICByZXR1cm4gYCR7cmVwb3J0ZWRQbGF0Zm9ybX0vJHtcIkpzQ29yZVwiIC8qIENsaWVudEltcGxlbWVudGF0aW9uLkNPUkUgKi99LyR7YXBwLlNES19WRVJTSU9OfS8ke3JlcG9ydGVkRnJhbWV3b3Jrc31gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQXV0aE1pZGRsZXdhcmVRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfVxuICAgIHB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCkge1xuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgY291bGQgYmUgc3luYyBvciBhc3luYy4gV3JhcCBpdCBpbnRvIGFcbiAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBpcyBhbHdheXMgYXN5bmMuXG4gICAgICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICh1c2VyKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKHVzZXIpO1xuICAgICAgICAgICAgICAgIC8vIEVpdGhlciByZXNvbHZlIHdpdGggZXhpc3RpbmcgcHJvbWlzZSBvciB3cmFwIGEgbm9uLXByb21pc2VcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaW50byBhIHByb21pc2UuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBTeW5jIGNhbGxiYWNrIHRocm93cy5cbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBdHRhY2ggdGhlIG9uQWJvcnQgaWYgcHJlc2VudFxuICAgICAgICB3cmFwcGVkQ2FsbGJhY2sub25BYm9ydCA9IG9uQWJvcnQ7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh3cmFwcGVkQ2FsbGJhY2spO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlLiBSZXBsYWNlIHdpdGggbm8tb3AuIERvIG5vdCByZW1vdmUgZnJvbSBhcnJheSwgb3IgaXQgd2lsbCBkaXN0dXJiXG4gICAgICAgICAgICAvLyBpbmRleGluZyBvZiBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgICAgIHRoaXMucXVldWVbaW5kZXhdID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJ1bk1pZGRsZXdhcmUobmV4dFVzZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aC5jdXJyZW50VXNlciA9PT0gbmV4dFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGlsZSBydW5uaW5nIHRoZSBtaWRkbGV3YXJlLCBidWlsZCBhIHRlbXBvcmFyeSBzdGFjayBvZiBvbkFib3J0XG4gICAgICAgIC8vIGNhbGxiYWNrcyB0byBjYWxsIGlmIG9uZSBtaWRkbGV3YXJlIGNhbGxiYWNrIHJlamVjdHMuXG4gICAgICAgIGNvbnN0IG9uQWJvcnRTdGFjayA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBiZWZvcmVTdGF0ZUNhbGxiYWNrIG9mIHRoaXMucXVldWUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBiZWZvcmVTdGF0ZUNhbGxiYWNrKG5leHRVc2VyKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHB1c2ggdGhlIG9uQWJvcnQgaWYgdGhlIGNhbGxiYWNrIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZVN0YXRlQ2FsbGJhY2sub25BYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICBvbkFib3J0U3RhY2sucHVzaChiZWZvcmVTdGF0ZUNhbGxiYWNrLm9uQWJvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gUnVuIGFsbCBvbkFib3J0LCB3aXRoIHNlcGFyYXRlIHRyeS9jYXRjaCB0byBpZ25vcmUgYW55IGVycm9ycyBhbmRcbiAgICAgICAgICAgIC8vIGNvbnRpbnVlXG4gICAgICAgICAgICBvbkFib3J0U3RhY2sucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvbkFib3J0IG9mIG9uQWJvcnRTdGFjaykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgLyogc3dhbGxvdyBlcnJvciAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IHRoaXMuYXV0aC5fZXJyb3JGYWN0b3J5LmNyZWF0ZShcImxvZ2luLWJsb2NrZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkxPR0lOX0JMT0NLRUQgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRmV0Y2hlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGZvciB0aGUgY3VycmVudGx5IHNldCB0ZW5hbnQgb3IgdGhlIHByb2plY3QgaWYgbm8gdGVuYW50IGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gYXV0aCBBdXRoIG9iamVjdC5cbiAqIEBwYXJhbSByZXF1ZXN0IFBhc3N3b3JkIHBvbGljeSByZXF1ZXN0LlxuICogQHJldHVybnMgUGFzc3dvcmQgcG9saWN5IHJlc3BvbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfZ2V0UGFzc3dvcmRQb2xpY3koYXV0aCwgcmVxdWVzdCA9IHt9KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovLCBcIi92Mi9wYXNzd29yZFBvbGljeVwiIC8qIEVuZHBvaW50LkdFVF9QQVNTV09SRF9QT0xJQ1kgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBNaW5pbXVtIG1pbiBwYXNzd29yZCBsZW5ndGggZW5mb3JjZWQgYnkgdGhlIGJhY2tlbmQsIGV2ZW4gaWYgbm8gbWluaW11bSBsZW5ndGggaXMgc2V0LlxuY29uc3QgTUlOSU1VTV9NSU5fUEFTU1dPUkRfTEVOR1RIID0gNjtcbi8qKlxuICogU3RvcmVzIHBhc3N3b3JkIHBvbGljeSByZXF1aXJlbWVudHMgYW5kIHByb3ZpZGVzIHBhc3N3b3JkIHZhbGlkYXRpb24gYWdhaW5zdCB0aGUgcG9saWN5LlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQYXNzd29yZFBvbGljeUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIGN1c3RvbSBzdHJlbmd0aCBvcHRpb25zIGRlZmluZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICBjb25zdCByZXNwb25zZU9wdGlvbnMgPSByZXNwb25zZS5jdXN0b21TdHJlbmd0aE9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zID0ge307XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBvbmNlIHRoZSBiYWNrZW5kIGlzIHVwZGF0ZWQgdG8gaW5jbHVkZSB0aGUgbWluaW11bSBtaW4gcGFzc3dvcmQgbGVuZ3RoIGluc3RlYWQgb2YgdW5kZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gbWluaW11bSBsZW5ndGggc2V0LlxuICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5taW5QYXNzd29yZExlbmd0aCA9XG4gICAgICAgICAgICAoX2EgPSByZXNwb25zZU9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSDtcbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGggPVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyID1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMuY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU9wdGlvbnMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gcmVzcG9uc2UuZW5mb3JjZW1lbnRTdGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9PT0gJ0VORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEJykge1xuICAgICAgICAgICAgdGhpcy5lbmZvcmNlbWVudFN0YXRlID0gJ09GRic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFuIGVtcHR5IHN0cmluZyBpZiBubyBub24tYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYXJlIHNwZWNpZmllZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMgPVxuICAgICAgICAgICAgKF9jID0gKF9iID0gcmVzcG9uc2UuYWxsb3dlZE5vbkFscGhhbnVtZXJpY0NoYXJhY3RlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcnKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJyc7XG4gICAgICAgIHRoaXMuZm9yY2VVcGdyYWRlT25TaWduaW4gPSAoX2QgPSByZXNwb25zZS5mb3JjZVVwZ3JhZGVPblNpZ25pbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZW1hVmVyc2lvbiA9IHJlc3BvbnNlLnNjaGVtYVZlcnNpb247XG4gICAgfVxuICAgIHZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICBwYXNzd29yZFBvbGljeTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICAvLyBDaGVjayB0aGUgcGFzc3dvcmQgbGVuZ3RoIGFuZCBjaGFyYWN0ZXIgb3B0aW9ucy5cbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkTGVuZ3RoT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKTtcbiAgICAgICAgLy8gQ29tYmluZSB0aGUgc3RhdHVzIGludG8gc2luZ2xlIGlzVmFsaWQgcHJvcGVydHkuXG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYSA9IHN0YXR1cy5tZWV0c01pblBhc3N3b3JkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9iID0gc3RhdHVzLm1lZXRzTWF4UGFzc3dvcmRMZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpO1xuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2MgPSBzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRydWUpO1xuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2QgPSBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUpO1xuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2UgPSBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9mID0gc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgdGhlIHBhc3N3b3JkIG1lZXRzIHRoZSBsZW5ndGggb3B0aW9ucyBmb3IgdGhlIHBvbGljeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCBQYXNzd29yZCB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gc3RhdHVzIFZhbGlkYXRpb24gc3RhdHVzLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUGFzc3dvcmRMZW5ndGhPcHRpb25zKHBhc3N3b3JkLCBzdGF0dXMpIHtcbiAgICAgICAgY29uc3QgbWluUGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5taW5QYXNzd29yZExlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4UGFzc3dvcmRMZW5ndGggPSB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5tYXhQYXNzd29yZExlbmd0aDtcbiAgICAgICAgaWYgKG1pblBhc3N3b3JkTGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA+PSBtaW5QYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4UGFzc3dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YXR1cy5tZWV0c01heFBhc3N3b3JkTGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoIDw9IG1heFBhc3N3b3JkTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgY2hhcmFjdGVyIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgUGFzc3dvcmQgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKSB7XG4gICAgICAgIC8vIEFzc2lnbiBzdGF0dXNlcyBmb3IgcmVxdWlyZW1lbnRzIGV2ZW4gaWYgdGhlIHBhc3N3b3JkIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxuICAgICAgICAvKiBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gZmFsc2UsIFxuICAgICAgICAvKiBjb250YWluc051bWVyaWNDaGFyYWN0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXI9ICovIGZhbHNlKTtcbiAgICAgICAgbGV0IHBhc3N3b3JkQ2hhcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXNzd29yZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFzc3dvcmRDaGFyID0gcGFzc3dvcmQuY2hhckF0KGkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnNTdGF0dXNlcyhzdGF0dXMsIFxuICAgICAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIHBhc3N3b3JkQ2hhciA+PSAnYScgJiZcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJ3onLCBcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ0EnICYmXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICdaJywgXG4gICAgICAgICAgICAvKiBjb250YWluc051bWVyaWNDaGFyYWN0ZXI9ICovIHBhc3N3b3JkQ2hhciA+PSAnMCcgJiZcbiAgICAgICAgICAgICAgICBwYXNzd29yZENoYXIgPD0gJzknLCBcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzLmluY2x1ZGVzKHBhc3N3b3JkQ2hhcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJ1bm5pbmcgdmFsaWRhdGlvbiBzdGF0dXMgd2l0aCB0aGUgc3RhdHVzZXMgZm9yIHRoZSBjaGFyYWN0ZXIgb3B0aW9ucy5cbiAgICAgKiBFeHBlY3RlZCB0byBiZSBjYWxsZWQgZWFjaCB0aW1lIGEgY2hhcmFjdGVyIGlzIHByb2Nlc3NlZCB0byB1cGRhdGUgZWFjaCBvcHRpb24gc3RhdHVzXG4gICAgICogYmFzZWQgb24gdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbG93ZXJjYXNlIGxldHRlci5cbiAgICAgKiBAcGFyYW0gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGFuIHVwcGVyY2FzZSBsZXR0ZXIuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciBXaGV0aGVyIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1lcmljIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgdXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBjb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciwgY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciwgY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc0xvd2VyY2FzZUxldHRlciA9IGNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciB8fCAoc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyID0gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgfHwgKHN0YXR1cy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPSBjb250YWluc051bWVyaWNDaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIgPSBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBBdXRoSW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBwLCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsIGFwcENoZWNrU2VydmljZVByb3ZpZGVyLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyID0gYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbXVsYXRvckNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICAgIHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgICAgIHRoaXMuYmVmb3JlU3RhdGVRdWV1ZSA9IG5ldyBBdXRoTWlkZGxld2FyZVF1ZXVlKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLkVYUEVDVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiA9IDE7XG4gICAgICAgIC8vIEFueSBuZXR3b3JrIGNhbGxzIHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgcHJldmVudCBzdWJzZXF1ZW50IGVtdWxhdG9yXG4gICAgICAgIC8vIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuX2NhbkluaXRFbXVsYXRvciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBfREVGQVVMVF9BVVRIX0VSUk9SX0ZBQ1RPUlk7XG4gICAgICAgIHRoaXMuX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlncyA9IHt9O1xuICAgICAgICB0aGlzLl9wcm9qZWN0UGFzc3dvcmRQb2xpY3kgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzID0ge307XG4gICAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub3RpZmllZCBVSUQgZm9yIHN0YXRlIGNoYW5nZSBsaXN0ZW5lcnMgdG8gcHJldmVudFxuICAgICAgICAvLyByZXBlYXRlZCBjYWxscyB0byB0aGUgY2FsbGJhY2tzLiBVbmRlZmluZWQgbWVhbnMgaXQncyBuZXZlciBiZWVuXG4gICAgICAgIC8vIGNhbGxlZCwgd2hlcmVhcyBudWxsIG1lYW5zIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBhIHNpZ25lZCBvdXQgdXNlclxuICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYW5ndWFnZUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbmFudElkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHsgYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmZyYW1ld29ya3MgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lID0gYXBwLm5hbWU7XG4gICAgICAgIHRoaXMuY2xpZW50VmVyc2lvbiA9IGNvbmZpZy5zZGtDbGllbnRWZXJzaW9uO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZVdpdGhQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZUhpZXJhcmNoeSwgcG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciA9IF9nZXRJbnN0YW5jZShwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGFwcCBkZWxldGlvbiB0aHJvdWdob3V0IGluaXRpYWxpemF0aW9uIChhZnRlciBlYWNoXG4gICAgICAgIC8vIHByb21pc2UgcmVzb2x1dGlvbilcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciA9IGF3YWl0IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIuY3JlYXRlKHRoaXMsIHBlcnNpc3RlbmNlSGllcmFyY2h5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzb2x2ZXIgZWFybHkgaWYgbmVjZXNzYXJ5IChvbmx5IGFwcGxpY2FibGUgdG8gd2ViOlxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGNhdXNlIHRoZSBpZnJhbWUgdG8gbG9hZCBpbW1lZGlhdGVseSBpbiBjZXJ0YWluIGNhc2VzKVxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9zaG91bGRJbml0UHJvYWN0aXZlbHkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZhaWxzLCBkb24ndCBoYWx0IGF1dGggbG9hZGluZ1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlci5faW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWdub3JlIHRoZSBlcnJvciAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUN1cnJlbnRVc2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9ICgoX2IgPSB0aGlzLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudWlkKSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwZXJzaXN0ZW5jZSBpcyBjaGFuZ2VkIGluIGFub3RoZXIgd2luZG93LCB0aGUgdXNlciBtYW5hZ2VyIHdpbGwgbGV0IHVzIGtub3dcbiAgICAgKi9cbiAgICBhc3luYyBfb25TdG9yYWdlRXZlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFVzZXIgJiYgIXVzZXIpIHtcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZSwgZG8gbm90aGluZyAod2FzIHNpZ25lZCBvdXQgYW5kIHJlbWFpbmVkIHNpZ25lZCBvdXQpLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzYW1lIHVzZXIgaXMgdG8gYmUgc3luY2hyb25pemVkLlxuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlciAmJiB1c2VyICYmIHRoaXMuY3VycmVudFVzZXIudWlkID09PSB1c2VyLnVpZCkge1xuICAgICAgICAgICAgLy8gRGF0YSB1cGRhdGUsIHNpbXBseSBjb3B5IGRhdGEgY2hhbmdlcy5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9hc3NpZ24odXNlcik7XG4gICAgICAgICAgICAvLyBJZiB0b2tlbnMgY2hhbmdlZCBmcm9tIHByZXZpb3VzIHVzZXIgdG9rZW5zLCB0aGlzIHdpbGwgdHJpZ2dlclxuICAgICAgICAgICAgLy8gbm90aWZ5QXV0aExpc3RlbmVyc18uXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBBdXRoIHN0YXRlLiBFaXRoZXIgYSBuZXcgbG9naW4gb3IgbG9nb3V0LlxuICAgICAgICAvLyBTa2lwIGJsb2NraW5nIGNhbGxiYWNrcywgdGhleSBzaG91bGQgbm90IGFwcGx5IHRvIGEgY2hhbmdlIGluIGFub3RoZXIgdGFiLlxuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVDdXJyZW50VXNlcih1c2VyLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVDdXJyZW50VXNlckZyb21JZFRva2VuKGlkVG9rZW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZ2V0QWNjb3VudEluZm8odGhpcywgeyBpZFRva2VuIH0pO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXJJbXBsLl9mcm9tR2V0QWNjb3VudEluZm9SZXNwb25zZSh0aGlzLCByZXNwb25zZSwgaWRUb2tlbik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGaXJlYmFzZVNlcnZlckFwcCBjb3VsZCBub3QgbG9naW4gdXNlciB3aXRoIHByb3ZpZGVkIGF1dGhJZFRva2VuOiAnLCBlcnIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVDdXJyZW50VXNlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoYXBwLl9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IHRoaXMuYXBwLnNldHRpbmdzLmF1dGhJZFRva2VuO1xuICAgICAgICAgICAgaWYgKGlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgYXV0aCBvcGVyYXRpb24gaW4gdGhlIG5leHQgdGljayB0byBhbGxvdyBhIG1vbWVudCBmb3IgdGhlIGN1c3RvbWVyJ3MgYXBwIHRvXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGFuIGVtdWxhdG9yLCBpZiBkZXNpcmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluaXRpYWxpemVDdXJyZW50VXNlckZyb21JZFRva2VuKGlkVG9rZW4pLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHBlbmRpbmcgcmVkaXJlY3QgZXZlbnQuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID0gKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKTtcbiAgICAgICAgbGV0IGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgIGxldCBuZWVkc1RvY2hlY2tNaWRkbGV3YXJlID0gZmFsc2U7XG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVc2VyRXZlbnRJZCA9IChfYSA9IHRoaXMucmVkaXJlY3RVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJFdmVudElkID0gZnV0dXJlQ3VycmVudFVzZXIgPT09IG51bGwgfHwgZnV0dXJlQ3VycmVudFVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnRyeVJlZGlyZWN0U2lnbkluKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIHVzZXIgKGkuZS4gdGhlIG9sZCBcImN1cnJlbnRVc2VyXCIpIGhhcyBhIHJlZGlyZWN0SWQgdGhhdFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBuZXcgdXNlciBvYmplY3QgZnJvbSByZXN1bHQuXG4gICAgICAgICAgICAvLyBUT0RPKHNhbWdobyk6IE1vcmUgdGhvcm91Z2hseSB0ZXN0IGFsbCBvZiB0aGlzXG4gICAgICAgICAgICBpZiAoKCFyZWRpcmVjdFVzZXJFdmVudElkIHx8IHJlZGlyZWN0VXNlckV2ZW50SWQgPT09IHN0b3JlZFVzZXJFdmVudElkKSAmJlxuICAgICAgICAgICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQudXNlcikpIHtcbiAgICAgICAgICAgICAgICBmdXR1cmVDdXJyZW50VXNlciA9IHJlc3VsdC51c2VyO1xuICAgICAgICAgICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXG4gICAgICAgIGlmICghZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlci5fcmVkaXJlY3RFdmVudElkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzbid0IGEgcmVkaXJlY3QgbGluayBvcGVyYXRpb24sIHdlIGNhbiByZWxvYWQgYW5kIGJhaWwuXG4gICAgICAgICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxuICAgICAgICAgICAgaWYgKG5lZWRzVG9jaGVja01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyBpcyBhdmFpbGFibGUgc2luY2UgdGhlIGJpdCBpcyBvbmx5IHNldCB3aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0KHRoaXMsICgpID0+IFByb21pc2UucmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XG4gICAgICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXG4gICAgICAgIC8vIERPIE5PVCByZWxvYWQgdGhlIGN1cnJlbnQgdXNlciwgb3RoZXJ3aXNlIHRoZXknbGwgYmUgY2xlYXJlZCBmcm9tIHN0b3JhZ2UuXG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciB0aGUgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoKSBmbG93LlxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXIgJiZcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyLl9yZWRpcmVjdEV2ZW50SWQgPT09IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgfVxuICAgIGFzeW5jIHRyeVJlZGlyZWN0U2lnbkluKHJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgLy8gVGhlIHJlZGlyZWN0IHVzZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCAoYW5kIHNpZ25lZCBpbiBpZiBhdmFpbGFibGUpXG4gICAgICAgIC8vIGR1cmluZyBhdXRoIGluaXRpYWxpemF0aW9uLiBBbGwgb2YgdGhlIG5vcm1hbCBzaWduIGluIGFuZCBsaW5rL3JlYXV0aFxuICAgICAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxuICAgICAgICAvLyBuZWVkIHRvIGF3YWl0IHRoZSByZXN1bHQgb2YgdGhlIHJlZGlyZWN0IHNpZ24gaW4gKmluc2lkZSB0aGUgcHJvbWlzZVxuICAgICAgICAvLyBxdWV1ZSouIFRoaXMgcHJlc2VudHMgYSBwcm9ibGVtOiB3ZSBydW4gaW50byBkZWFkbG9jay4gU2VlOlxuICAgICAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICAgIC8vICAgIOKUjD4gWzxvdGhlciBxdWV1ZSB0YXNrcz5dIOKUglxuICAgICAgICAvLyAgICDilJTilIAgW2dldFJlZGlyZWN0UmVzdWx0XSA84pSA4pSYXG4gICAgICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uIHdpbGwgbmV2ZXIgY29tcGxldGUgYmVjYXVzZSBpdCdzIHdhaXRpbmcgb24gc29tZXRoaW5nXG4gICAgICAgIC8vIHRoYXQncyB3YWl0aW5nIGZvciBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZSFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW5zdGVhZCwgdGhpcyBtZXRob2QgY2FsbHMgZ2V0UmVkaXJlY3RSZXN1bHQoKSAoc3RvcmVkIGluXG4gICAgICAgIC8vIF9jb21wbGV0ZVJlZGlyZWN0Rm4pIHdpdGggYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgaW5zdHJ1Y3RzIGFsbCBvZlxuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxuICAgICAgICAgICAgLy8gaXMgcGFzc2VkIGluLiBUaGUgX2NvbXBsZXRlUmVkaXJlY3RGbiBleHBlY3RzIHRoZSB1bndyYXBwZWQgZXh0ZXJuLlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9jb21wbGV0ZVJlZGlyZWN0Rm4odGhpcywgcmVkaXJlY3RSZXNvbHZlciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgYW55IGVycm9ycyBoZXJlOyB0aGUgY29kZSBjYW4gcmV0cmlldmUgdGhlbSBpblxuICAgICAgICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyByZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIodXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNvZGUpICE9PVxuICAgICAgICAgICAgICAgIGBhdXRoLyR7XCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovfWApIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgfVxuICAgIHVzZURldmljZUxhbmd1YWdlKCkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IF9nZXRVc2VyTGFuZ3VhZ2UoKTtcbiAgICB9XG4gICAgYXN5bmMgX2RlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUN1cnJlbnRVc2VyKHVzZXJFeHRlcm4pIHtcbiAgICAgICAgaWYgKGFwcC5faXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmFwcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHB1YmxpYyB1cGRhdGVDdXJyZW50VXNlciBtZXRob2QgbmVlZHMgdG8gbWFrZSBhIGNvcHkgb2YgdGhlIHVzZXIsXG4gICAgICAgIC8vIGFuZCBhbHNvIGNoZWNrIHRoYXQgdGhlIHByb2plY3QgbWF0Y2hlc1xuICAgICAgICBjb25zdCB1c2VyID0gdXNlckV4dGVyblxuICAgICAgICAgICAgPyB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZSh1c2VyRXh0ZXJuKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgX2Fzc2VydCh1c2VyLmF1dGguY29uZmlnLmFwaUtleSA9PT0gdGhpcy5jb25maWcuYXBpS2V5LCB0aGlzLCBcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIodXNlciAmJiB1c2VyLl9jbG9uZSh0aGlzKSk7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVDdXJyZW50VXNlcih1c2VyLCBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHRoaXMudGVuYW50SWQgPT09IHVzZXIudGVuYW50SWQsIHRoaXMsIFwidGVuYW50LWlkLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0ggKi8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZSh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25PdXQoKSB7XG4gICAgICAgIGlmIChhcHAuX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biBmaXJzdCwgdG8gYmxvY2sgX3NldFJlZGlyZWN0VXNlcigpIGlmIGFueSBjYWxsYmFja3MgZmFpbC5cbiAgICAgICAgYXdhaXQgdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnJ1bk1pZGRsZXdhcmUobnVsbCk7XG4gICAgICAgIC8vIENsZWFyIHRoZSByZWRpcmVjdCB1c2VyIHdoZW4gc2lnbk91dCBpcyBjYWxsZWRcbiAgICAgICAgaWYgKHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIgfHwgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXRSZWRpcmVjdFVzZXIobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBjYWxsYmFja3MgZnJvbSBiZWluZyBjYWxsZWQgYWdhaW4gaW4gX3VwZGF0ZUN1cnJlbnRVc2VyLCBhc1xuICAgICAgICAvLyB0aGV5IHdlcmUgYWxyZWFkeSBjYWxsZWQgaW4gdGhlIGZpcnN0IGxpbmUuXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVDdXJyZW50VXNlcihudWxsLCAvKiBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgKi8gdHJ1ZSk7XG4gICAgfVxuICAgIHNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKSB7XG4gICAgICAgIGlmIChhcHAuX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodGhpcy5hcHApKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRQZXJzaXN0ZW5jZShfZ2V0SW5zdGFuY2UocGVyc2lzdGVuY2UpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRSZWNhcHRjaGFDb25maWcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW3RoaXMudGVuYW50SWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVBhc3N3b3JkUG9saWN5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFzc3dvcmQgcG9saWN5IHdpbGwgYmUgZGVmaW5lZCBhZnRlciBmZXRjaGluZy5cbiAgICAgICAgY29uc3QgcGFzc3dvcmRQb2xpY3kgPSB0aGlzLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCk7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIHBvbGljeSBzY2hlbWEgdmVyc2lvbiBpcyBzdXBwb3J0ZWQgYnkgdGhlIFNESy5cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoaXMgbG9naWMgdG8gdXNlIGEgbWF4IHN1cHBvcnRlZCBwb2xpY3kgc2NoZW1hIHZlcnNpb24gb25jZSB3ZSBoYXZlIG11bHRpcGxlIHNjaGVtYSB2ZXJzaW9ucy5cbiAgICAgICAgaWYgKHBhc3N3b3JkUG9saWN5LnNjaGVtYVZlcnNpb24gIT09XG4gICAgICAgICAgICB0aGlzLkVYUEVDVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJ1bnN1cHBvcnRlZC1wYXNzd29yZC1wb2xpY3ktc2NoZW1hLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BBU1NXT1JEX1BPTElDWV9TQ0hFTUFfVkVSU0lPTiAqLywge30pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFzc3dvcmRQb2xpY3kudmFsaWRhdGVQYXNzd29yZChwYXNzd29yZCk7XG4gICAgfVxuICAgIF9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkge1xuICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2plY3RQYXNzd29yZFBvbGljeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVQYXNzd29yZFBvbGljeSgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfZ2V0UGFzc3dvcmRQb2xpY3kodGhpcyk7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkUG9saWN5ID0gbmV3IFBhc3N3b3JkUG9saWN5SW1wbChyZXNwb25zZSk7XG4gICAgICAgIGlmICh0aGlzLnRlbmFudElkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9qZWN0UGFzc3dvcmRQb2xpY3kgPSBwYXNzd29yZFBvbGljeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbmFudFBhc3N3b3JkUG9saWNpZXNbdGhpcy50ZW5hbnRJZF0gPSBwYXNzd29yZFBvbGljeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0UGVyc2lzdGVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UucGVyc2lzdGVuY2UudHlwZTtcbiAgICB9XG4gICAgX3VwZGF0ZUVycm9yTWFwKGVycm9yTWFwKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yRmFjdG9yeSA9IG5ldyB1dGlsLkVycm9yRmFjdG9yeSgnYXV0aCcsICdGaXJlYmFzZScsIGVycm9yTWFwKCkpO1xuICAgIH1cbiAgICBvbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHRoaXMuYXV0aFN0YXRlU3Vic2NyaXB0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG4gICAgfVxuICAgIGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQoY2FsbGJhY2ssIG9uQWJvcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlU3RhdGVRdWV1ZS5wdXNoQ2FsbGJhY2soY2FsbGJhY2ssIG9uQWJvcnQpO1xuICAgIH1cbiAgICBvbklkVG9rZW5DaGFuZ2VkKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyU3RhdGVMaXN0ZW5lcih0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICB9XG4gICAgYXV0aFN0YXRlUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5vbkF1dGhTdGF0ZUNoYW5nZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgdGhlIGdpdmVuIGFjY2VzcyB0b2tlbi4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgQXBwbGUgT0F1dGggYWNjZXNzIHRva2Vucy5cbiAgICAgKi9cbiAgICBhc3luYyByZXZva2VBY2Nlc3NUb2tlbih0b2tlbikge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHRoaXMuY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgICAgICAgLy8gR2VuZXJhbGl6ZSB0aGlzIHRvIGFjY2VwdCBvdGhlciBwcm92aWRlcnMgb25jZSBzdXBwb3J0ZWQuXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVySWQ6ICdhcHBsZS5jb20nLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogXCJBQ0NFU1NfVE9LRU5cIiAvKiBUb2tlblR5cGUuQUNDRVNTX1RPS0VOICovLFxuICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgIGlkVG9rZW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50ZW5hbnRJZCA9IHRoaXMudGVuYW50SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCByZXZva2VUb2tlbih0aGlzLCByZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5jb25maWcuYXBpS2V5LFxuICAgICAgICAgICAgYXV0aERvbWFpbjogdGhpcy5jb25maWcuYXV0aERvbWFpbixcbiAgICAgICAgICAgIGFwcE5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGN1cnJlbnRVc2VyOiAoX2EgPSB0aGlzLl9jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9zZXRSZWRpcmVjdFVzZXIodXNlciwgcG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0TWFuYWdlciA9IGF3YWl0IHRoaXMuZ2V0T3JJbml0UmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbiAgICAgICAgcmV0dXJuIHVzZXIgPT09IG51bGxcbiAgICAgICAgICAgID8gcmVkaXJlY3RNYW5hZ2VyLnJlbW92ZUN1cnJlbnRVc2VyKClcbiAgICAgICAgICAgIDogcmVkaXJlY3RNYW5hZ2VyLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgX2dldEluc3RhbmNlKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyO1xuICAgICAgICAgICAgX2Fzc2VydChyZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlciA9IGF3YWl0IFBlcnNpc3RlbmNlVXNlck1hbmFnZXIuY3JlYXRlKHRoaXMsIFtfZ2V0SW5zdGFuY2UocmVzb2x2ZXIuX3JlZGlyZWN0UGVyc2lzdGVuY2UpXSwgXCJyZWRpcmVjdFVzZXJcIiAvKiBLZXlOYW1lLlJFRElSRUNUX1VTRVIgKi8pO1xuICAgICAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIgPVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcjtcbiAgICB9XG4gICAgYXN5bmMgX3JlZGlyZWN0VXNlckZvcklkKGlkKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBjbGVhcmVkIGFueSBwZW5kaW5nIHBlcnNpc3RlbmNlIGFjdGlvbnMgaWYgd2UncmUgbm90IGluXG4gICAgICAgIC8vIHRoZSBpbml0aWFsaXplclxuICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5fY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcmVkaXJlY3RFdmVudElkKSA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VXNlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYiA9IHRoaXMucmVkaXJlY3RVc2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuX3JlZGlyZWN0RXZlbnRJZCkgPT09IGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWRpcmVjdFVzZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIF9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VyKSB7XG4gICAgICAgIGlmICh1c2VyID09PSB0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBOb3RpZmllcyBsaXN0ZW5lcnMgb25seSBpZiB0aGUgdXNlciBpcyBjdXJyZW50ICovXG4gICAgX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh1c2VyKSB7XG4gICAgICAgIGlmICh1c2VyID09PSB0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfa2V5KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25maWcuYXV0aERvbWFpbn06JHt0aGlzLmNvbmZpZy5hcGlLZXl9OiR7dGhpcy5uYW1lfWA7XG4gICAgfVxuICAgIF9zdGFydFByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCkge1xuICAgICAgICB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVzZXIgY2FzdCBhcyB0aGUgaW50ZXJuYWwgdHlwZSAqL1xuICAgIGdldCBfY3VycmVudFVzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRVc2VyO1xuICAgIH1cbiAgICBub3RpZnlBdXRoTGlzdGVuZXJzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24ubmV4dCh0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgY29uc3QgY3VycmVudFVpZCA9IChfYiA9IChfYSA9IHRoaXMuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51aWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmxhc3ROb3RpZmllZFVpZCAhPT0gY3VycmVudFVpZCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSBjdXJyZW50VWlkO1xuICAgICAgICAgICAgdGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24ubmV4dCh0aGlzLmN1cnJlbnRVc2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWdpc3RlclN0YXRlTGlzdGVuZXIoc3Vic2NyaXB0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYiA9IHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBuZXh0T3JPYnNlcnZlclxuICAgICAgICAgICAgOiBuZXh0T3JPYnNlcnZlci5uZXh0LmJpbmQobmV4dE9yT2JzZXJ2ZXIpO1xuICAgICAgICBsZXQgaXNVbnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2lzSW5pdGlhbGl6ZWRcbiAgICAgICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIDogdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBfYXNzZXJ0KHByb21pc2UsIHRoaXMsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgLy8gVGhlIGNhbGxiYWNrIG5lZWRzIHRvIGJlIGNhbGxlZCBhc3luY2hyb25vdXNseSBwZXIgdGhlIHNwZWMuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1Vuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXh0T3JPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpcHRpb24uYWRkT2JzZXJ2ZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpc1Vuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnByb3RlY3RlZCAoZnJvbSByYWNlIGNvbmRpdGlvbnMpIG1ldGhvZCB0byBzZXQgdGhlIGN1cnJlbnQgdXNlci4gVGhpc1xuICAgICAqIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmcm9tIHdpdGhpbiBhIHF1ZXVlZCBjYWxsYmFjay4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICAgKiBiZWNhdXNlIHRoZSBxdWV1ZSBzaG91bGRuJ3QgcmVseSBvbiBhbm90aGVyIHF1ZXVlZCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBhc3luYyBkaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdGhpcy5jdXJyZW50VXNlciAhPT0gdXNlcikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXIgJiYgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkKSB7XG4gICAgICAgICAgICB1c2VyLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRVc2VyID0gdXNlcjtcbiAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5zZXRDdXJyZW50VXNlcih1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5yZW1vdmVDdXJyZW50VXNlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlKGFjdGlvbikge1xuICAgICAgICAvLyBJbiBjYXNlIHNvbWV0aGluZyBlcnJvcnMsIHRoZSBjYWxsYmFjayBzdGlsbCBzaG91bGQgYmUgY2FsbGVkIGluIG9yZGVyXG4gICAgICAgIC8vIHRvIGtlZXAgdGhlIHByb21pc2UgY2hhaW4gYWxpdmVcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gdGhpcy5vcGVyYXRpb25zLnRoZW4oYWN0aW9uLCBhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zO1xuICAgIH1cbiAgICBnZXQgYXNzZXJ0ZWRQZXJzaXN0ZW5jZSgpIHtcbiAgICAgICAgX2Fzc2VydCh0aGlzLnBlcnNpc3RlbmNlTWFuYWdlciwgdGhpcywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZU1hbmFnZXI7XG4gICAgfVxuICAgIF9sb2dGcmFtZXdvcmsoZnJhbWV3b3JrKSB7XG4gICAgICAgIGlmICghZnJhbWV3b3JrIHx8IHRoaXMuZnJhbWV3b3Jrcy5pbmNsdWRlcyhmcmFtZXdvcmspKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFtZXdvcmtzLnB1c2goZnJhbWV3b3JrKTtcbiAgICAgICAgLy8gU29ydCBhbHBoYWJldGljYWxseSBzbyB0aGF0IFwiRmlyZWJhc2VDb3JlLXdlYixGaXJlYmFzZVVJLXdlYlwiIGFuZFxuICAgICAgICAvLyBcIkZpcmViYXNlVUktd2ViLEZpcmViYXNlQ29yZS13ZWJcIiBhcmVuJ3Qgdmlld2VkIGFzIGRpZmZlcmVudC5cbiAgICAgICAgdGhpcy5mcmFtZXdvcmtzLnNvcnQoKTtcbiAgICAgICAgdGhpcy5jbGllbnRWZXJzaW9uID0gX2dldENsaWVudFZlcnNpb24odGhpcy5jb25maWcuY2xpZW50UGxhdGZvcm0sIHRoaXMuX2dldEZyYW1ld29ya3MoKSk7XG4gICAgfVxuICAgIF9nZXRGcmFtZXdvcmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXdvcmtzO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QWRkaXRpb25hbEhlYWRlcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gQWRkaXRpb25hbCBoZWFkZXJzIG9uIGV2ZXJ5IHJlcXVlc3RcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFtcIlgtQ2xpZW50LVZlcnNpb25cIiAvKiBIdHRwSGVhZGVyLlhfQ0xJRU5UX1ZFUlNJT04gKi9dOiB0aGlzLmNsaWVudFZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBwLm9wdGlvbnMuYXBwSWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLWdtcGlkXCIgLyogSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0dNUElEICovXSA9IHRoaXMuYXBwLm9wdGlvbnMuYXBwSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhlYXJ0YmVhdCBzZXJ2aWNlIGV4aXN0cywgYWRkIHRoZSBoZWFydGJlYXQgc3RyaW5nXG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdHNIZWFkZXIgPSBhd2FpdCAoKF9hID0gdGhpcy5oZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoe1xuICAgICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRIZWFydGJlYXRzSGVhZGVyKCkpO1xuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtRmlyZWJhc2UtQ2xpZW50XCIgLyogSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0NMSUVOVCAqL10gPSBoZWFydGJlYXRzSGVhZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBBcHAgQ2hlY2sgc2VydmljZSBleGlzdHMsIGFkZCB0aGUgQXBwIENoZWNrIHRva2VuIGluIHRoZSBoZWFkZXJzXG4gICAgICAgIGNvbnN0IGFwcENoZWNrVG9rZW4gPSBhd2FpdCB0aGlzLl9nZXRBcHBDaGVja1Rva2VuKCk7XG4gICAgICAgIGlmIChhcHBDaGVja1Rva2VuKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1BcHBDaGVja1wiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9BUFBfQ0hFQ0sgKi9dID0gYXBwQ2hlY2tUb2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgX2dldEFwcENoZWNrVG9rZW4oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlblJlc3VsdCA9IGF3YWl0ICgoX2EgPSB0aGlzLmFwcENoZWNrU2VydmljZVByb3ZpZGVyXG4gICAgICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRUb2tlbigpKTtcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IG51bGwgfHwgYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwQ2hlY2tUb2tlblJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgLy8gQ29udGV4dDogYXBwQ2hlY2suZ2V0VG9rZW4oKSB3aWxsIG5ldmVyIHRocm93IGV2ZW4gaWYgYW4gZXJyb3IgaGFwcGVuZWQuXG4gICAgICAgICAgICAvLyBJbiB0aGUgZXJyb3IgY2FzZSwgYSBkdW1teSB0b2tlbiB3aWxsIGJlIHJldHVybmVkIGFsb25nIHdpdGggYW4gZXJyb3IgZmllbGQgZGVzY3JpYmluZ1xuICAgICAgICAgICAgLy8gdGhlIGVycm9yLiBJbiBnZW5lcmFsLCB3ZSBzaG91bGRuJ3QgY2FyZSBhYm91dCB0aGUgZXJyb3IgY29uZGl0aW9uIGFuZCBqdXN0IHVzZVxuICAgICAgICAgICAgLy8gdGhlIHRva2VuIChhY3R1YWwgb3IgZHVtbXkpIHRvIHNlbmQgcmVxdWVzdHMuXG4gICAgICAgICAgICBfbG9nV2FybihgRXJyb3Igd2hpbGUgcmV0cmlldmluZyBBcHAgQ2hlY2sgdG9rZW46ICR7YXBwQ2hlY2tUb2tlblJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gbnVsbCB8fCBhcHBDaGVja1Rva2VuUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Rva2VuUmVzdWx0LnRva2VuO1xuICAgIH1cbn1cbi8qKlxuICogTWV0aG9kIHRvIGJlIHVzZWQgdG8gY2FzdCBkb3duIHRvIG91ciBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIEF1dGguXG4gKiBJdCB3aWxsIGFsc28gaGFuZGxlIHVud3JhcHBpbmcgZnJvbSB0aGUgY29tcGF0IHR5cGUgaWYgbmVjZXNzYXJ5XG4gKlxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QgcGFzc2VkIGluIGZyb20gZGV2ZWxvcGVyXG4gKi9cbmZ1bmN0aW9uIF9jYXN0QXV0aChhdXRoKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xufVxuLyoqIEhlbHBlciBjbGFzcyB0byB3cmFwIHN1YnNjcmliZXIgbG9naWMgKi9cbmNsYXNzIFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZGRPYnNlcnZlciA9IHV0aWwuY3JlYXRlU3Vic2NyaWJlKG9ic2VydmVyID0+ICh0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXIpKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7XG4gICAgICAgIF9hc3NlcnQodGhpcy5vYnNlcnZlciwgdGhpcy5hdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9ic2VydmVyLm5leHQuYmluZCh0aGlzLm9ic2VydmVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5sZXQgZXh0ZXJuYWxKU1Byb3ZpZGVyID0ge1xuICAgIGFzeW5jIGxvYWRKUygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9hZCBleHRlcm5hbCBzY3JpcHRzJyk7XG4gICAgfSxcbiAgICByZWNhcHRjaGFWMlNjcmlwdDogJycsXG4gICAgcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdDogJycsXG4gICAgZ2FwaVNjcmlwdDogJydcbn07XG5mdW5jdGlvbiBfbG9hZEpTKHVybCkge1xuICAgIHJldHVybiBleHRlcm5hbEpTUHJvdmlkZXIubG9hZEpTKHVybCk7XG59XG5mdW5jdGlvbiBfcmVjYXB0Y2hhRW50ZXJwcmlzZVNjcmlwdFVybCgpIHtcbiAgICByZXR1cm4gZXh0ZXJuYWxKU1Byb3ZpZGVyLnJlY2FwdGNoYUVudGVycHJpc2VTY3JpcHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNb2NrR3JlQ0FQVENIQVRvcExldmVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbnRlcnByaXNlID0gbmV3IE1vY2tHcmVDQVBUQ0hBKCk7XG4gICAgfVxuICAgIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGV4ZWN1dGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9zaXRlS2V5LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0b2tlbicpO1xuICAgIH1cbiAgICByZW5kZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9jb250YWluZXIsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5jbGFzcyBNb2NrR3JlQ0FQVENIQSB7XG4gICAgcmVhZHkoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgZXhlY3V0ZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3NpdGVLZXksIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ3Rva2VuJyk7XG4gICAgfVxuICAgIHJlbmRlcihcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX2NvbnRhaW5lciwgX3BhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRSA9ICdyZWNhcHRjaGEtZW50ZXJwcmlzZSc7XG5jb25zdCBGQUtFX1RPS0VOID0gJ05PX1JFQ0FQVENIQSc7XG5jbGFzcyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGhFeHRlcm4gLSBUaGUgY29ycmVzcG9uZGluZyBGaXJlYmFzZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhdXRoRXh0ZXJuKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVzIHRoZSB0eXBlIG9mIGFwcGxpY2F0aW9uIHZlcmlmaWVyIChlLmcuIFwicmVjYXB0Y2hhLWVudGVycHJpc2VcIikuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBSRUNBUFRDSEFfRU5URVJQUklTRV9WRVJJRklFUl9UWVBFO1xuICAgICAgICB0aGlzLmF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSB2ZXJpZmljYXRpb24gcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgYSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc2VydCB0aGUgdmFsaWRpdHkgb2YgYSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeShhY3Rpb24gPSAndmVyaWZ5JywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcmV0cmlldmVTaXRlS2V5KGF1dGgpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgPT0gbnVsbCAmJiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZy5zaXRlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoLnRlbmFudElkXS5zaXRlS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgZ2V0UmVjYXB0Y2hhQ29uZmlnKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnJlY2FwdGNoYUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdyZWNhcHRjaGEgRW50ZXJwcmlzZSBzaXRlIGtleSB1bmRlZmluZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb25maWcuc2l0ZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyZWNhcHRjaGEgPSB3aW5kb3cuZ3JlY2FwdGNoYTtcbiAgICAgICAgICAgIGlmIChpc0VudGVycHJpc2UoZ3JlY2FwdGNoYSkpIHtcbiAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2UucmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjdXRlKHNpdGVLZXksIHsgYWN0aW9uIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKEZBS0VfVE9LRU4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChFcnJvcignTm8gcmVDQVBUQ0hBIGVudGVycHJpc2Ugc2NyaXB0IGxvYWRlZC4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyBQcm9taXNlIGZvciBhIG1vY2sgdG9rZW4gd2hlbiBhcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHRoaXMuYXV0aC5zZXR0aW5ncy5hcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tSZWNhcHRjaGEgPSBuZXcgTW9ja0dyZUNBUFRDSEFUb3BMZXZlbCgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vY2tSZWNhcHRjaGEuZXhlY3V0ZSgnc2l0ZUtleScsIHsgYWN0aW9uOiAndmVyaWZ5JyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0cmlldmVTaXRlS2V5KHRoaXMuYXV0aClcbiAgICAgICAgICAgICAgICAudGhlbihzaXRlS2V5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0VudGVycHJpc2Uod2luZG93LmdyZWNhcHRjaGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdXJsID0gX3JlY2FwdGNoYUVudGVycHJpc2VTY3JpcHRVcmwoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVybC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBzaXRlS2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9sb2FkSlModXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmVSZWNhcHRjaGFUb2tlbihzaXRlS2V5LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoLCByZXF1ZXN0LCBhY3Rpb24sIGlzQ2FwdGNoYVJlc3AgPSBmYWxzZSwgaXNGYWtlVG9rZW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IHZlcmlmaWVyID0gbmV3IFJlY2FwdGNoYUVudGVycHJpc2VWZXJpZmllcihhdXRoKTtcbiAgICBsZXQgY2FwdGNoYVJlc3BvbnNlO1xuICAgIGlmIChpc0Zha2VUb2tlbikge1xuICAgICAgICBjYXB0Y2hhUmVzcG9uc2UgPSBGQUtFX1RPS0VOO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeShhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gYXdhaXQgdmVyaWZpZXIudmVyaWZ5KGFjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3UmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpO1xuICAgIGlmIChhY3Rpb24gPT09IFwibWZhU21zRW5yb2xsbWVudFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuTUZBX1NNU19FTlJPTExNRU5UICovIHx8XG4gICAgICAgIGFjdGlvbiA9PT0gXCJtZmFTbXNTaWduSW5cIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLk1GQV9TTVNfU0lHTklOICovKSB7XG4gICAgICAgIGlmICgncGhvbmVFbnJvbGxtZW50SW5mbycgaW4gbmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcGhvbmVOdW1iZXIgPSBuZXdSZXF1ZXN0LnBob25lRW5yb2xsbWVudEluZm8ucGhvbmVOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IG5ld1JlcXVlc3QucGhvbmVFbnJvbGxtZW50SW5mby5yZWNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICdwaG9uZUVucm9sbG1lbnRJbmZvJzoge1xuICAgICAgICAgICAgICAgICAgICBwaG9uZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovLFxuICAgICAgICAgICAgICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgncGhvbmVTaWduSW5JbmZvJyBpbiBuZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjb25zdCByZWNhcHRjaGFUb2tlbiA9IG5ld1JlcXVlc3QucGhvbmVTaWduSW5JbmZvLnJlY2FwdGNoYVRva2VuO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgJ3Bob25lU2lnbkluSW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVjYXB0Y2hhVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovLFxuICAgICAgICAgICAgICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UmVxdWVzdDtcbiAgICB9XG4gICAgaWYgKCFpc0NhcHRjaGFSZXNwKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwgeyBjYXB0Y2hhUmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NhcHRjaGFSZXNwJzogY2FwdGNoYVJlc3BvbnNlIH0pO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgJ2NsaWVudFR5cGUnOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovIH0pO1xuICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAncmVjYXB0Y2hhVmVyc2lvbic6IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3UmVxdWVzdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25NZXRob2QsIHJlY2FwdGNoYUF1dGhQcm92aWRlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHJlY2FwdGNoYUF1dGhQcm92aWRlciA9PT0gXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykge1xuICAgICAgICBpZiAoKF9hID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAuX2dldFJlY2FwdGNoYUNvbmZpZygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQcm92aWRlckVuYWJsZWQoXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgYWN0aW9uTmFtZSA9PT0gXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0KS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL31gKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2FjdGlvbk5hbWV9IGlzIHByb3RlY3RlZCBieSByZUNBUFRDSEEgRW50ZXJwcmlzZSBmb3IgdGhpcyBwcm9qZWN0LiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSBmbG93IGFuZCByZXN0YXJ0aW5nIHRoZSBmbG93LmApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUgPT09IFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVjYXB0Y2hhQXV0aFByb3ZpZGVyID09PSBcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSB7XG4gICAgICAgIGlmICgoX2IgPSBhdXRoSW5zdGFuY2VcbiAgICAgICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc1Byb3ZpZGVyRW5hYmxlZChcIlBIT05FX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLlBIT05FX1BST1ZJREVSICovKSkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIC5fZ2V0UmVjYXB0Y2hhQ29uZmlnKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm92aWRlckVuZm9yY2VtZW50U3RhdGUoXCJQSE9ORV9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5QSE9ORV9QUk9WSURFUiAqLykpID09PSBcIkFVRElUXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5BVURJVCAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBBVURJVCBtb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wibWlzc2luZy1yZWNhcHRjaGEtdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOICovfWAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQUF9DUkVERU5USUFMICovfWApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gdmVyaWZ5IHdpdGggcmVDQVBUQ0hBIEVudGVycHJpc2UuIEF1dG9tYXRpY2FsbHkgdHJpZ2dlcmluZyB0aGUgcmVDQVBUQ0hBIHYyIGZsb3cgdG8gY29tcGxldGUgdGhlICR7YWN0aW9uTmFtZX0gZmxvdy5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlQ0FQVENIQSBFbnRlcnByaXNlIHRva2VuIGlzIG1pc3Npbmcgb3IgcmVDQVBUQ0hBIEVudGVycHJpc2UgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZhaWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcmVDQVBUQ0hBIHYyIGZsb3cuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGZhbHNlLCAvLyBpc0NhcHRjaGFSZXNwXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlIC8vIGlzRmFrZVRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgdGhlIFBob25lQXBpQ2FsbGVyIHRvIGZldGNoIGFuZCBpbmplY3QgcmVDQVBUQ0hBIHYyIHRva2VuLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbk1ldGhvZChhdXRoSW5zdGFuY2UsIHJlcXVlc3RXaXRoUmVjYXB0Y2hhRmllbGRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFTkZPUkNFIG1vZGUgb3IgQVVESVQgbW9kZSB3aXRoIGFueSBvdGhlciBlcnJvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyByZUNBUFRDSEEgdjIgZmxvdy5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhRmllbGRzID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgZmFsc2UsIC8vIGlzQ2FwdGNoYVJlc3BcbiAgICAgICAgICAgIHRydWUgLy8gaXNGYWtlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgY2FsbCB0aGUgUGhvbmVBcGlDYWxsZXIgdG8gZmV0Y2ggYW5kIGluamVjdCB2MiB0b2tlbi5cbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWNhcHRjaGFBdXRoUHJvdmlkZXIgKyAnIHByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoSW50ZXJuYWwsIHtcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgdmVyc2lvbjogXCJSRUNBUFRDSEFfRU5URVJQUklTRVwiIC8qIFJlY2FwdGNoYVZlcnNpb24uRU5URVJQUklTRSAqL1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBSZWNhcHRjaGFDb25maWcocmVzcG9uc2UpO1xuICAgIGlmIChhdXRoSW50ZXJuYWwudGVuYW50SWQgPT0gbnVsbCkge1xuICAgICAgICBhdXRoSW50ZXJuYWwuX2FnZW50UmVjYXB0Y2hhQ29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXV0aEludGVybmFsLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGhJbnRlcm5hbC50ZW5hbnRJZF0gPSBjb25maWc7XG4gICAgfVxuICAgIGlmIChjb25maWcuaXNBbnlQcm92aWRlckVuYWJsZWQoKSkge1xuICAgICAgICBjb25zdCB2ZXJpZmllciA9IG5ldyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIoYXV0aEludGVybmFsKTtcbiAgICAgICAgdm9pZCB2ZXJpZmllci52ZXJpZnkoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIHtAbGluayBBdXRofSBpbnN0YW5jZSB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAqIHtAbGluayBEZXBlbmRlbmNpZXN9LlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgbW9yZSBjb250cm9sIG92ZXIgdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB0aGFuXG4gKiB7QGxpbmsgZ2V0QXV0aH0uIGBnZXRBdXRoYCB1c2VzIHBsYXRmb3JtLXNwZWNpZmljIGRlZmF1bHRzIHRvIHN1cHBseVxuICogdGhlIHtAbGluayBEZXBlbmRlbmNpZXN9LiBJbiBnZW5lcmFsLCBgZ2V0QXV0aGAgaXMgdGhlIGVhc2llc3Qgd2F5IHRvXG4gKiBpbml0aWFsaXplIEF1dGggYW5kIHdvcmtzIGZvciBtb3N0IHVzZSBjYXNlcy4gVXNlIGBpbml0aWFsaXplQXV0aGAgaWYgeW91XG4gKiBuZWVkIGNvbnRyb2wgb3ZlciB3aGljaCBwZXJzaXN0ZW5jZSBsYXllciBpcyB1c2VkLCBvciB0byBtaW5pbWl6ZSBidW5kbGVcbiAqIHNpemUgaWYgeW91J3JlIG5vdCB1c2luZyBlaXRoZXIgYHNpZ25JbldpdGhQb3B1cGAgb3IgYHNpZ25JbldpdGhSZWRpcmVjdGAuXG4gKlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdXIgYXBwIG9ubHkgdXNlcyBhbm9ueW1vdXMgYWNjb3VudHMgYW5kIHlvdSBvbmx5IHdhbnRcbiAqIGFjY291bnRzIHNhdmVkIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLCBpbml0aWFsaXplIGBBdXRoYCB3aXRoOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBhdXRoID0gaW5pdGlhbGl6ZUF1dGgoYXBwLCB7XG4gKiAgIHBlcnNpc3RlbmNlOiBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlLFxuICogICBwb3B1cFJlZGlyZWN0UmVzb2x2ZXI6IHVuZGVmaW5lZCxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQXV0aChhcHAkMSwgZGVwcykge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXBwLl9nZXRQcm92aWRlcihhcHAkMSwgJ2F1dGgnKTtcbiAgICBpZiAocHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbE9wdGlvbnMgPSBwcm92aWRlci5nZXRPcHRpb25zKCk7XG4gICAgICAgIGlmICh1dGlsLmRlZXBFcXVhbChpbml0aWFsT3B0aW9ucywgZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB2b2lkIDAgPyBkZXBzIDoge30pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXV0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiYWxyZWFkeS1pbml0aWFsaXplZFwiIC8qIEF1dGhFcnJvckNvZGUuQUxSRUFEWV9JTklUSUFMSVpFRCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXV0aCA9IHByb3ZpZGVyLmluaXRpYWxpemUoeyBvcHRpb25zOiBkZXBzIH0pO1xuICAgIHJldHVybiBhdXRoO1xufVxuZnVuY3Rpb24gX2luaXRpYWxpemVBdXRoSW5zdGFuY2UoYXV0aCwgZGVwcykge1xuICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wZXJzaXN0ZW5jZSkgfHwgW107XG4gICAgY29uc3QgaGllcmFyY2h5ID0gKEFycmF5LmlzQXJyYXkocGVyc2lzdGVuY2UpID8gcGVyc2lzdGVuY2UgOiBbcGVyc2lzdGVuY2VdKS5tYXAoX2dldEluc3RhbmNlKTtcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLmVycm9yTWFwKSB7XG4gICAgICAgIGF1dGguX3VwZGF0ZUVycm9yTWFwKGRlcHMuZXJyb3JNYXApO1xuICAgIH1cbiAgICAvLyBUaGlzIHByb21pc2UgaXMgaW50ZW5kZWQgdG8gZmxvYXQ7IGF1dGggaW5pdGlhbGl6YXRpb24gaGFwcGVucyBpbiB0aGVcbiAgICAvLyBiYWNrZ3JvdW5kLCBtZWFud2hpbGUgdGhlIGF1dGggb2JqZWN0IG1heSBiZSB1c2VkIGJ5IHRoZSBhcHAuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIGF1dGguX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UoaGllcmFyY2h5LCBkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMucG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgRmlyZWJhc2UgQXV0aCBFbXVsYXRvciwgaW5zdGVhZCBvZiBwcm9kdWN0aW9uXG4gKiBGaXJlYmFzZSBBdXRoIHNlcnZpY2VzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG11c3QgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgaW1tZWRpYXRlbHkgZm9sbG93aW5nIHRoZSBmaXJzdCBjYWxsIHRvXG4gKiB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9LiAgRG8gbm90IHVzZSB3aXRoIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMgYXMgZW11bGF0b3JcbiAqIHRyYWZmaWMgaXMgbm90IGVuY3J5cHRlZC5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgJ2h0dHA6Ly8xMjcuMC4wLjE6OTA5OScsIHsgZGlzYWJsZVdhcm5pbmdzOiB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYXQgd2hpY2ggdGhlIGVtdWxhdG9yIGlzIHJ1bm5pbmcgKGVnLCAnaHR0cDovL2xvY2FsaG9zdDo5MDk5JykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBgb3B0aW9ucy5kaXNhYmxlV2FybmluZ3NgIGRlZmF1bHRzIHRvIGBmYWxzZWAuIFNldCBpdCB0b1xuICogYHRydWVgIHRvIGRpc2FibGUgdGhlIHdhcm5pbmcgYmFubmVyIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBfYXNzZXJ0KGF1dGhJbnRlcm5hbC5fY2FuSW5pdEVtdWxhdG9yLCBhdXRoSW50ZXJuYWwsIFwiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqLyk7XG4gICAgX2Fzc2VydCgvXmh0dHBzPzpcXC9cXC8vLnRlc3QodXJsKSwgYXV0aEludGVybmFsLCBcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqLyk7XG4gICAgY29uc3QgZGlzYWJsZVdhcm5pbmdzID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVXYXJuaW5ncyk7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2wodXJsKTtcbiAgICBjb25zdCB7IGhvc3QsIHBvcnQgfSA9IGV4dHJhY3RIb3N0QW5kUG9ydCh1cmwpO1xuICAgIGNvbnN0IHBvcnRTdHIgPSBwb3J0ID09PSBudWxsID8gJycgOiBgOiR7cG9ydH1gO1xuICAgIC8vIEFsd2F5cyByZXBsYWNlIHBhdGggd2l0aCBcIi9cIiAoZXZlbiBpZiBpbnB1dCB1cmwgaGFkIG5vIHBhdGggYXQgYWxsLCBvciBoYWQgYSBkaWZmZXJlbnQgb25lKS5cbiAgICBhdXRoSW50ZXJuYWwuY29uZmlnLmVtdWxhdG9yID0geyB1cmw6IGAke3Byb3RvY29sfS8vJHtob3N0fSR7cG9ydFN0cn0vYCB9O1xuICAgIGF1dGhJbnRlcm5hbC5zZXR0aW5ncy5hcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcgPSB0cnVlO1xuICAgIGF1dGhJbnRlcm5hbC5lbXVsYXRvckNvbmZpZyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0LFxuICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSxcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmZyZWV6ZSh7IGRpc2FibGVXYXJuaW5ncyB9KVxuICAgIH0pO1xuICAgIGlmICghZGlzYWJsZVdhcm5pbmdzKSB7XG4gICAgICAgIGVtaXRFbXVsYXRvcldhcm5pbmcoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2wodXJsKSB7XG4gICAgY29uc3QgcHJvdG9jb2xFbmQgPSB1cmwuaW5kZXhPZignOicpO1xuICAgIHJldHVybiBwcm90b2NvbEVuZCA8IDAgPyAnJyA6IHVybC5zdWJzdHIoMCwgcHJvdG9jb2xFbmQgKyAxKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RIb3N0QW5kUG9ydCh1cmwpIHtcbiAgICBjb25zdCBwcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbCh1cmwpO1xuICAgIGNvbnN0IGF1dGhvcml0eSA9IC8oXFwvXFwvKT8oW14/Iy9dKykvLmV4ZWModXJsLnN1YnN0cihwcm90b2NvbC5sZW5ndGgpKTsgLy8gQmV0d2VlbiAvLyBhbmQgLywgPyBvciAjLlxuICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICAgIHJldHVybiB7IGhvc3Q6ICcnLCBwb3J0OiBudWxsIH07XG4gICAgfVxuICAgIGNvbnN0IGhvc3RBbmRQb3J0ID0gYXV0aG9yaXR5WzJdLnNwbGl0KCdAJykucG9wKCkgfHwgJyc7IC8vIFN0cmlwIG91dCBcInVzZXJuYW1lOnBhc3N3b3JkQFwiLlxuICAgIGNvbnN0IGJyYWNrZXRlZElQdjYgPSAvXihcXFtbXlxcXV0rXFxdKSg6fCQpLy5leGVjKGhvc3RBbmRQb3J0KTtcbiAgICBpZiAoYnJhY2tldGVkSVB2Nikge1xuICAgICAgICBjb25zdCBob3N0ID0gYnJhY2tldGVkSVB2NlsxXTtcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KGhvc3RBbmRQb3J0LnN1YnN0cihob3N0Lmxlbmd0aCArIDEpKSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW2hvc3QsIHBvcnRdID0gaG9zdEFuZFBvcnQuc3BsaXQoJzonKTtcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KHBvcnQpIH07XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQb3J0KHBvcnRTdHIpIHtcbiAgICBpZiAoIXBvcnRTdHIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBvcnQgPSBOdW1iZXIocG9ydFN0cik7XG4gICAgaWYgKGlzTmFOKHBvcnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9ydDtcbn1cbmZ1bmN0aW9uIGVtaXRFbXVsYXRvcldhcm5pbmcoKSB7XG4gICAgZnVuY3Rpb24gYXR0YWNoQmFubmVyKCkge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAgICAgY29uc3Qgc3R5ID0gZWwuc3R5bGU7XG4gICAgICAgIGVsLmlubmVyVGV4dCA9XG4gICAgICAgICAgICAnUnVubmluZyBpbiBlbXVsYXRvciBtb2RlLiBEbyBub3QgdXNlIHdpdGggcHJvZHVjdGlvbiBjcmVkZW50aWFscy4nO1xuICAgICAgICBzdHkucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBzdHkud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHN0eS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZic7XG4gICAgICAgIHN0eS5ib3JkZXIgPSAnLjFlbSBzb2xpZCAjMDAwMDAwJztcbiAgICAgICAgc3R5LmNvbG9yID0gJyNiNTAwMDAnO1xuICAgICAgICBzdHkuYm90dG9tID0gJzBweCc7XG4gICAgICAgIHN0eS5sZWZ0ID0gJzBweCc7XG4gICAgICAgIHN0eS5tYXJnaW4gPSAnMHB4JztcbiAgICAgICAgc3R5LnpJbmRleCA9ICcxMDAwMCc7XG4gICAgICAgIHN0eS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlyZWJhc2UtZW11bGF0b3Itd2FybmluZycpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5pbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnV0FSTklORzogWW91IGFyZSB1c2luZyB0aGUgQXV0aCBFbXVsYXRvciwnICtcbiAgICAgICAgICAgICcgd2hpY2ggaXMgaW50ZW5kZWQgZm9yIGxvY2FsIHRlc3Rpbmcgb25seS4gIERvIG5vdCB1c2Ugd2l0aCcgK1xuICAgICAgICAgICAgJyBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGF0dGFjaEJhbm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRhY2hCYW5uZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQXV0aENyZWRlbnRpYWwge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgSUQgZm9yIHRoZSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgZXhhbXBsZSwgJ2ZhY2Vib29rLmNvbScsIG9yICdnb29nbGUuY29tJy5cbiAgICAgKi9cbiAgICBwcm92aWRlcklkLCBcbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gc2lnbiBpbiBtZXRob2QgZm9yIHRoZSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgZXhhbXBsZSwge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQsIG9yXG4gICAgICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgc2lnbi1pbiBtZXRob2RcbiAgICAgKiBpZGVudGlmaWVyIGFzIHJldHVybmVkIGluIHtAbGluayBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbH0uXG4gICAgICovXG4gICAgc2lnbkluTWV0aG9kKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgICAgIHRoaXMuc2lnbkluTWV0aG9kID0gc2lnbkluTWV0aG9kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0SWRUb2tlblJlc3BvbnNlKF9hdXRoKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2xpbmtUb0lkVG9rZW4oX2F1dGgsIF9pZFRva2VuKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihfYXV0aCkge1xuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNldFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6cmVzZXRQYXNzd29yZFwiIC8qIEVuZHBvaW50LlJFU0VUX1BBU1NXT1JEICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xufVxuLy8gVXNlZCBmb3IgbGlua2luZyBhbiBlbWFpbC9wYXNzd29yZCBhY2NvdW50IHRvIGFuIGV4aXN0aW5nIGlkVG9rZW4uIFVzZXMgdGhlIHNhbWUgcmVxdWVzdC9yZXNwb25zZVxuLy8gZm9ybWF0IGFzIHVwZGF0ZUVtYWlsUGFzc3dvcmQuXG5hc3luYyBmdW5jdGlvbiBsaW5rRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25VcFwiIC8qIEVuZHBvaW50LlNJR05fVVAgKi8sIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBhc3N3b3JkXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BBU1NXT1JEICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzZW5kT29iQ29kZVwiIC8qIEVuZHBvaW50LlNFTkRfT09CX0NPREUgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kRW1haWxWZXJpZmljYXRpb24kMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kU2lnbkluTGlua1RvRW1haWwkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QW5kQ2hhbmdlRW1haWwoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmskMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhFbWFpbExpbmtcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfRU1BSUxfTElOSyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEVtYWlsTGlua1wiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9FTUFJTF9MSU5LICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IGZvclxuICoge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JEXG4gKlxuICogQHJlbWFya3NcbiAqIENvdmVycyBib3RoIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVtYWlsQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZW1haWwsIFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcGFzc3dvcmQsIHNpZ25Jbk1ldGhvZCwgXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90ZW5hbnRJZCA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoXCJwYXNzd29yZFwiIC8qIFByb3ZpZGVySWQuUEFTU1dPUkQgKi8sIHNpZ25Jbk1ldGhvZCk7XG4gICAgICAgIHRoaXMuX2VtYWlsID0gX2VtYWlsO1xuICAgICAgICB0aGlzLl9wYXNzd29yZCA9IF9wYXNzd29yZDtcbiAgICAgICAgdGhpcy5fdGVuYW50SWQgPSBfdGVuYW50SWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21FbWFpbEFuZFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtYWlsQXV0aENyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkLCBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgb29iQ29kZSwgdGVuYW50SWQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChlbWFpbCwgb29iQ29kZSwgXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLywgdGVuYW50SWQpO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kLFxuICAgICAgICAgICAgdGVuYW50SWQ6IHRoaXMuX3RlbmFudElkXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBFaXRoZXIgYG9iamVjdGAgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuIFdoZW4gc3RyaW5nIGlzXG4gICAgICogcHJvdmlkZWQsIGBKU09OLnBhcnNlYCB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICAgICAgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmouZW1haWwpICYmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoucGFzc3dvcmQpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnNpZ25Jbk1ldGhvZCA9PT0gXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm9tRW1haWxBbmRQYXNzd29yZChvYmouZW1haWwsIG9iai5wYXNzd29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZENvZGUob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQsIG9iai50ZW5hbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fSU5fV0lUSF9QQVNTV09SRCAqLywgc2lnbkluV2l0aFBhc3N3b3JkLCBcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKTtcbiAgICAgICAgICAgIGNhc2UgXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbkluV2l0aEVtYWlsTGluayQxKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgICAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgbGlua0VtYWlsUGFzc3dvcmQsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZyhhdXRoLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgb29iQ29kZTogdGhpcy5fcGFzc3dvcmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldElkVG9rZW5SZXNwb25zZShhdXRoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aElkcFwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9JRFAgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkkMSA9ICdodHRwOi8vbG9jYWxob3N0Jztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgT0F1dGggY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBsZW1lbnRhdGlvbnMgc3BlY2lmeSB0aGUgZGV0YWlscyBhYm91dCBlYWNoIGF1dGggcHJvdmlkZXIncyBjcmVkZW50aWFsIHJlcXVpcmVtZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE9BdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVG9rZW4gPSBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjcmVkID0gbmV3IE9BdXRoQ3JlZGVudGlhbChwYXJhbXMucHJvdmlkZXJJZCwgcGFyYW1zLnNpZ25Jbk1ldGhvZCk7XG4gICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIE9BdXRoIDIgYW5kIGVpdGhlciBJRCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAgICBpZiAocGFyYW1zLmlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLmlkVG9rZW4gPSBwYXJhbXMuaWRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG5vbmNlIGlmIGF2YWlsYWJsZSBhbmQgbm8gcGVuZGluZ1Rva2VuIGlzIHByZXNlbnQuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm5vbmNlICYmICFwYXJhbXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgY3JlZC5ub25jZSA9IHBhcmFtcy5ub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgY3JlZC5wZW5kaW5nVG9rZW4gPSBwYXJhbXMucGVuZGluZ1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5vYXV0aFRva2VuICYmIHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0KSB7XG4gICAgICAgICAgICAvLyBPQXV0aCAxIGFuZCBPQXV0aCB0b2tlbiB3aXRoIHRva2VuIHNlY3JldFxuICAgICAgICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5vYXV0aFRva2VuO1xuICAgICAgICAgICAgY3JlZC5zZWNyZXQgPSBwYXJhbXMub2F1dGhUb2tlblNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mYWlsKFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlZDtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkVG9rZW46IHRoaXMuaWRUb2tlbixcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlbixcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW5cbiAgICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqc29uIC0gSW5wdXQgY2FuIGJlIGVpdGhlciBPYmplY3Qgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCB9ID0gb2JqLCByZXN0ID0gdHNsaWIuX19yZXN0KG9iaiwgW1wicHJvdmlkZXJJZFwiLCBcInNpZ25Jbk1ldGhvZFwiXSk7XG4gICAgICAgIGlmICghcHJvdmlkZXJJZCB8fCAhc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkID0gbmV3IE9BdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBzaWduSW5NZXRob2QpO1xuICAgICAgICBjcmVkLmlkVG9rZW4gPSByZXN0LmlkVG9rZW4gfHwgdW5kZWZpbmVkO1xuICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcmVzdC5hY2Nlc3NUb2tlbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGNyZWQuc2VjcmV0ID0gcmVzdC5zZWNyZXQ7XG4gICAgICAgIGNyZWQubm9uY2UgPSByZXN0Lm5vbmNlO1xuICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHJlc3QucGVuZGluZ1Rva2VuIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBjcmVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIGJ1aWxkUmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmk6IElEUF9SRVFVRVNUX1VSSSQxLFxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdUb2tlbiA9IHRoaXMucGVuZGluZ1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zdEJvZHkgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnaWRfdG9rZW4nXSA9IHRoaXMuaWRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ2FjY2Vzc190b2tlbiddID0gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3JldCkge1xuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydvYXV0aF90b2tlbl9zZWNyZXQnXSA9IHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdEJvZHlbJ3Byb3ZpZGVySWQnXSA9IHRoaXMucHJvdmlkZXJJZDtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vbmNlICYmICF0aGlzLnBlbmRpbmdUb2tlbikge1xuICAgICAgICAgICAgICAgIHBvc3RCb2R5Wydub25jZSddID0gdGhpcy5ub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QucG9zdEJvZHkgPSB1dGlsLnF1ZXJ5c3RyaW5nKHBvc3RCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBob25lTnVtYmVyXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BIT05FX05VTUJFUiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbiAgICBpZiAocmVzcG9uc2UudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgdGhyb3cgX21ha2VUYWdnZWRFcnJvcihhdXRoLCBcImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLk5FRURfQ09ORklSTUFUSU9OICovLCByZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmNvbnN0IFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8gPSB7XG4gICAgW1wiVVNFUl9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5VU0VSX05PVF9GT1VORCAqL106IFwidXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqL1xufTtcbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgcmVxdWVzdCkge1xuICAgIGNvbnN0IGFwaVJlcXVlc3QgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpLCB7IG9wZXJhdGlvbjogJ1JFQVVUSCcgfSk7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCBhcGlSZXF1ZXN0KSwgVkVSSUZZX1BIT05FX05VTUJFUl9GT1JfRVhJU1RJTkdfRVJST1JfTUFQXyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGNyZWRlbnRpYWxzIHJldHVybmVkIGJ5IHtAbGluayBQaG9uZUF1dGhQcm92aWRlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQaG9uZUF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICBzdXBlcihcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLywgXCJwaG9uZVwiIC8qIFNpZ25Jbk1ldGhvZC5QSE9ORSAqLyk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tVmVyaWZpY2F0aW9uKHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tVG9rZW5SZXNwb25zZShwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHsgcGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoUGhvbmVOdW1iZXIkMShhdXRoLCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGxpbmtXaXRoUGhvbmVOdW1iZXIkMShhdXRoLCBPYmplY3QuYXNzaWduKHsgaWRUb2tlbiB9LCB0aGlzLl9tYWtlVmVyaWZpY2F0aW9uUmVxdWVzdCgpKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIHZlcmlmeVBob25lTnVtYmVyRm9yRXhpc3RpbmcoYXV0aCwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyLCB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9ID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIGlmICh0ZW1wb3JhcnlQcm9vZiAmJiBwaG9uZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdGVtcG9yYXJ5UHJvb2YsIHBob25lTnVtYmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlc3Npb25JbmZvOiB2ZXJpZmljYXRpb25JZCxcbiAgICAgICAgICAgIGNvZGU6IHZlcmlmaWNhdGlvbkNvZGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnBob25lTnVtYmVyKSB7XG4gICAgICAgICAgICBvYmoucGhvbmVOdW1iZXIgPSB0aGlzLnBhcmFtcy5waG9uZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudGVtcG9yYXJ5UHJvb2YpIHtcbiAgICAgICAgICAgIG9iai50ZW1wb3JhcnlQcm9vZiA9IHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlKSB7XG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uQ29kZSA9IHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbkNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnZlcmlmaWNhdGlvbklkKSB7XG4gICAgICAgICAgICBvYmoudmVyaWZpY2F0aW9uSWQgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKiogR2VuZXJhdGVzIGEgcGhvbmUgY3JlZGVudGlhbCBiYXNlZCBvbiBhIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nLiAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUsIHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9ID0ganNvbjtcbiAgICAgICAgaWYgKCF2ZXJpZmljYXRpb25Db2RlICYmXG4gICAgICAgICAgICAhdmVyaWZpY2F0aW9uSWQgJiZcbiAgICAgICAgICAgICFwaG9uZU51bWJlciAmJlxuICAgICAgICAgICAgIXRlbXBvcmFyeVByb29mKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoe1xuICAgICAgICAgICAgdmVyaWZpY2F0aW9uSWQsXG4gICAgICAgICAgICB2ZXJpZmljYXRpb25Db2RlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICB0ZW1wb3JhcnlQcm9vZlxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1hcHMgdGhlIG1vZGUgc3RyaW5nIGluIGFjdGlvbiBjb2RlIFVSTCB0byBBY3Rpb24gQ29kZSBJbmZvIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbW9kZVxuICovXG5mdW5jdGlvbiBwYXJzZU1vZGUobW9kZSkge1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdyZWNvdmVyRW1haWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiUkVDT1ZFUl9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVDT1ZFUl9FTUFJTCAqLztcbiAgICAgICAgY2FzZSAncmVzZXRQYXNzd29yZCc6XG4gICAgICAgICAgICByZXR1cm4gXCJQQVNTV09SRF9SRVNFVFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQgKi87XG4gICAgICAgIGNhc2UgJ3NpZ25Jbic6XG4gICAgICAgICAgICByZXR1cm4gXCJFTUFJTF9TSUdOSU5cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLkVNQUlMX1NJR05JTiAqLztcbiAgICAgICAgY2FzZSAndmVyaWZ5RW1haWwnOlxuICAgICAgICAgICAgcmV0dXJuIFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi87XG4gICAgICAgIGNhc2UgJ3ZlcmlmeUFuZENoYW5nZUVtYWlsJzpcbiAgICAgICAgICAgIHJldHVybiBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLztcbiAgICAgICAgY2FzZSAncmV2ZXJ0U2Vjb25kRmFjdG9yQWRkaXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIFwiUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT05cIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcGFyc2UgRkRMIGxpbmtzXG4gKlxuICogQHBhcmFtIHVybFxuICovXG5mdW5jdGlvbiBwYXJzZURlZXBMaW5rKHVybCkge1xuICAgIGNvbnN0IGxpbmsgPSB1dGlsLnF1ZXJ5c3RyaW5nRGVjb2RlKHV0aWwuZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkpWydsaW5rJ107XG4gICAgLy8gRG91YmxlIGxpbmsgY2FzZSAoYXV0b21hdGljIHJlZGlyZWN0KS5cbiAgICBjb25zdCBkb3VibGVEZWVwTGluayA9IGxpbmtcbiAgICAgICAgPyB1dGlsLnF1ZXJ5c3RyaW5nRGVjb2RlKHV0aWwuZXh0cmFjdFF1ZXJ5c3RyaW5nKGxpbmspKVsnZGVlcF9saW5rX2lkJ11cbiAgICAgICAgOiBudWxsO1xuICAgIC8vIGlPUyBjdXN0b20gc2NoZW1lIGxpbmtzLlxuICAgIGNvbnN0IGlPU0RlZXBMaW5rID0gdXRpbC5xdWVyeXN0cmluZ0RlY29kZSh1dGlsLmV4dHJhY3RRdWVyeXN0cmluZyh1cmwpKVsnZGVlcF9saW5rX2lkJ107XG4gICAgY29uc3QgaU9TRG91YmxlRGVlcExpbmsgPSBpT1NEZWVwTGlua1xuICAgICAgICA/IHV0aWwucXVlcnlzdHJpbmdEZWNvZGUodXRpbC5leHRyYWN0UXVlcnlzdHJpbmcoaU9TRGVlcExpbmspKVsnbGluayddXG4gICAgICAgIDogbnVsbDtcbiAgICByZXR1cm4gaU9TRG91YmxlRGVlcExpbmsgfHwgaU9TRGVlcExpbmsgfHwgZG91YmxlRGVlcExpbmsgfHwgbGluayB8fCB1cmw7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBwYXJzZSBlbWFpbCBhY3Rpb24gVVJMcyBzdWNoIGFzIHBhc3N3b3JkIHJlc2V0LCBlbWFpbCB2ZXJpZmljYXRpb24sXG4gKiBlbWFpbCBsaW5rIHNpZ24gaW4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEFjdGlvbkNvZGVVUkwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhY3Rpb25MaW5rIC0gVGhlIGxpbmsgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBVUkwuXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFjdGlvbkxpbmspIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHV0aWwucXVlcnlzdHJpbmdEZWNvZGUodXRpbC5leHRyYWN0UXVlcnlzdHJpbmcoYWN0aW9uTGluaykpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSAoX2EgPSBzZWFyY2hQYXJhbXNbXCJhcGlLZXlcIiAvKiBRdWVyeUZpZWxkLkFQSV9LRVkgKi9dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICBjb25zdCBjb2RlID0gKF9iID0gc2VhcmNoUGFyYW1zW1wib29iQ29kZVwiIC8qIFF1ZXJ5RmllbGQuQ09ERSAqL10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcnNlTW9kZSgoX2MgPSBzZWFyY2hQYXJhbXNbXCJtb2RlXCIgLyogUXVlcnlGaWVsZC5NT0RFICovXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCk7XG4gICAgICAgIC8vIFZhbGlkYXRlIEFQSSBrZXksIGNvZGUgYW5kIG1vZGUuXG4gICAgICAgIF9hc3NlcnQoYXBpS2V5ICYmIGNvZGUgJiYgb3BlcmF0aW9uLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jb250aW51ZVVybCA9IChfZCA9IHNlYXJjaFBhcmFtc1tcImNvbnRpbnVlVXJsXCIgLyogUXVlcnlGaWVsZC5DT05USU5VRV9VUkwgKi9dKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBudWxsO1xuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IChfZSA9IHNlYXJjaFBhcmFtc1tcImxhbmd1YWdlQ29kZVwiIC8qIFF1ZXJ5RmllbGQuTEFOR1VBR0VfQ09ERSAqL10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG51bGw7XG4gICAgICAgIHRoaXMudGVuYW50SWQgPSAoX2YgPSBzZWFyY2hQYXJhbXNbXCJ0ZW5hbnRJZFwiIC8qIFF1ZXJ5RmllbGQuVEVOQU5UX0lEICovXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmIHRoZSBsaW5rIGlzIHZhbGlkLFxuICAgICAqIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGluayAgLSBUaGUgZW1haWwgYWN0aW9uIGxpbmsgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gb2JqZWN0LCBvciBudWxsIGlmIHRoZSBsaW5rIGlzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlTGluayhsaW5rKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbkxpbmsgPSBwYXJzZURlZXBMaW5rKGxpbmspO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb25Db2RlVVJMKGFjdGlvbkxpbmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgZW1haWwgYWN0aW9uIGxpbmsgc3RyaW5nIGFuZCByZXR1cm5zIGFuIHtAbGluayBBY3Rpb25Db2RlVVJMfSBpZlxuICogdGhlIGxpbmsgaXMgdmFsaWQsIG90aGVyd2lzZSByZXR1cm5zIG51bGwuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZUFjdGlvbkNvZGVVUkwobGluaykge1xuICAgIHJldHVybiBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhsaW5rKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcge0BsaW5rIEVtYWlsQXV0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRW1haWxBdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBFbWFpbEF1dGhQcm92aWRlci5QUk9WSURFUl9JRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IHVzaW5nIGFuIGVtYWlsIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGNvbnN0IGF1dGhDcmVkZW50aWFsID0gRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpO1xuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aCwgYXV0aENyZWRlbnRpYWwpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGVtYWlsIC0gRW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBVc2VyIGFjY291bnQgcGFzc3dvcmQuXG4gICAgICogQHJldHVybnMgVGhlIGF1dGggcHJvdmlkZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIEVtYWlsQXV0aENyZWRlbnRpYWwuX2Zyb21FbWFpbEFuZFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSB1c2luZyBhbiBlbWFpbCBhbmQgYW4gZW1haWwgbGluayBhZnRlciBhIHNpZ24gaW4gd2l0aFxuICAgICAqIGVtYWlsIGxpbmsgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogY29uc3QgYXV0aENyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluayk7XG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBhd2FpdCBzZW5kU2lnbkluTGlua1RvRW1haWwoYXV0aCwgZW1haWwpO1xuICAgICAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB1c2VyLlxuICAgICAqIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgc2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSB1c2VkIHRvIHZlcmlmeSB0aGUgbGluay5cbiAgICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBlbWFpbExpbmsgLSBTaWduLWluIGVtYWlsIGxpbmsuXG4gICAgICogQHJldHVybnMgLSBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsV2l0aExpbmsoZW1haWwsIGVtYWlsTGluaykge1xuICAgICAgICBjb25zdCBhY3Rpb25Db2RlVXJsID0gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsoZW1haWxMaW5rKTtcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlVXJsLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiBFbWFpbEF1dGhDcmVkZW50aWFsLl9mcm9tRW1haWxBbmRDb2RlKGVtYWlsLCBhY3Rpb25Db2RlVXJsLmNvZGUsIGFjdGlvbkNvZGVVcmwudGVuYW50SWQpO1xuICAgIH1cbn1cbi8qKlxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uUEFTU1dPUkQsIGV2ZW4gZm9yIGVtYWlsIGxpbmsuXG4gKi9cbkVtYWlsQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJwYXNzd29yZFwiIC8qIFByb3ZpZGVySWQuUEFTU1dPUkQgKi87XG4vKipcbiAqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQuXG4gKi9cbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1NJR05fSU5fTUVUSE9EID0gXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLztcbi8qKlxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICovXG5FbWFpbEF1dGhQcm92aWRlci5FTUFJTF9MSU5LX1NJR05fSU5fTUVUSE9EID0gXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBGZWRlcmF0ZWQgcHJvdmlkZXJzIChPQXV0aCAoaW5jbHVkaW5nIE9JREMpLCBTQU1MKS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIG5vdCBtZWFudCB0byBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGZvciBnZW5lcmljIE9BdXRoIHByb3ZpZGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlcklkIC0gUHJvdmlkZXIgZm9yIHdoaWNoIGNyZWRlbnRpYWxzIHNob3VsZCBiZSBnZW5lcmF0ZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZCkge1xuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IG51bGw7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jdXN0b21QYXJhbWV0ZXJzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbGFuZ3VhZ2UgZ29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUNvZGUgLSBsYW5ndWFnZSBjb2RlXG4gICAgICovXG4gICAgc2V0RGVmYXVsdExhbmd1YWdlKGxhbmd1YWdlQ29kZSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRMYW5ndWFnZUNvZGUgPSBsYW5ndWFnZUNvZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE9BdXRoIGN1c3RvbSBwYXJhbWV0ZXJzIHRvIHBhc3MgaW4gYW4gT0F1dGggcmVxdWVzdCBmb3IgcG9wdXAgYW5kIHJlZGlyZWN0IHNpZ24taW5cbiAgICAgKiBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgYSBkZXRhaWxlZCBsaXN0LCBjaGVjayB0aGUgcmVzZXJ2ZWQgcmVxdWlyZWQgT0F1dGggMi4wIHBhcmFtZXRlcnMgc3VjaCBhcyBgY2xpZW50X2lkYCxcbiAgICAgKiBgcmVkaXJlY3RfdXJpYCwgYHNjb3BlYCwgYHJlc3BvbnNlX3R5cGVgLCBhbmQgYHN0YXRlYCBhcmUgbm90IGFsbG93ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXN0b21PQXV0aFBhcmFtZXRlcnMgLSBUaGUgY3VzdG9tIE9BdXRoIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiB0aGUgT0F1dGggcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZXRDdXN0b21QYXJhbWV0ZXJzKGN1c3RvbU9BdXRoUGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLmN1c3RvbVBhcmFtZXRlcnMgPSBjdXN0b21PQXV0aFBhcmFtZXRlcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBDdXN0b21QYXJhbWV0ZXJzfS5cbiAgICAgKi9cbiAgICBnZXRDdXN0b21QYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21QYXJhbWV0ZXJzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ29tbW9uIGNvZGUgdG8gYWxsIE9BdXRoIHByb3ZpZGVycy4gVGhpcyBpcyBzZXBhcmF0ZSBmcm9tIHRoZVxuICoge0BsaW5rIE9BdXRoUHJvdmlkZXJ9IHNvIHRoYXQgY2hpbGQgcHJvdmlkZXJzIChsaWtlXG4gKiB7QGxpbmsgR29vZ2xlQXV0aFByb3ZpZGVyfSkgZG9uJ3QgaW5oZXJpdCB0aGUgYGNyZWRlbnRpYWxgIGluc3RhbmNlIG1ldGhvZC5cbiAqIEluc3RlYWQsIHRoZXkgcmVseSBvbiBhIHN0YXRpYyBgY3JlZGVudGlhbGAgbWV0aG9kLlxuICovXG5jbGFzcyBCYXNlT0F1dGhQcm92aWRlciBleHRlbmRzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5zY29wZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIE9BdXRoIHNjb3BlIHRvIHRoZSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjb3BlIC0gUHJvdmlkZXIgT0F1dGggc2NvcGUgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZFNjb3BlKHNjb3BlKSB7XG4gICAgICAgIC8vIElmIG5vdCBhbHJlYWR5IGFkZGVkLCBhZGQgc2NvcGUgdG8gbGlzdC5cbiAgICAgICAgaWYgKCF0aGlzLnNjb3Blcy5pbmNsdWRlcyhzY29wZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudCBsaXN0IG9mIE9BdXRoIHNjb3Blcy5cbiAgICAgKi9cbiAgICBnZXRTY29wZXMoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zY29wZXNdO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgZ2VuZXJpYyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgT0F1dGggQWNjZXNzIFRva2VuIGZvciB0aGUgcHJvdmlkZXIuXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgT0F1dGggQWNjZXNzIFRva2VuIGZvciB0aGUgcHJvdmlkZXIuXG4gKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQoYXV0aCwgcmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBPQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIEpTT04gc3RyaW5nIG9yIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSBqc29uIC0gQSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICAgICAgX2Fzc2VydCgncHJvdmlkZXJJZCcgaW4gb2JqICYmICdzaWduSW5NZXRob2QnIGluIG9iaiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKG9iaik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgZ2VuZXJpYyBPQXV0aCBwcm92aWRlcidzIGFjY2VzcyB0b2tlbiBvciBJRCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIHJhdyBub25jZSBpcyByZXF1aXJlZCB3aGVuIGFuIElEIHRva2VuIHdpdGggYSBub25jZSBmaWVsZCBpcyBwcm92aWRlZC4gVGhlIFNIQS0yNTYgaGFzaCBvZlxuICAgICAqIHRoZSByYXcgbm9uY2UgbXVzdCBtYXRjaCB0aGUgbm9uY2UgZmllbGQgaW4gdGhlIElEIHRva2VuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogLy8gYGdvb2dsZVVzZXJgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cbiAgICAgKiAvLyBJbml0aWFsaXplIGEgZ2VuZXJhdGUgT0F1dGggcHJvdmlkZXIgd2l0aCBhIGBnb29nbGUuY29tYCBwcm92aWRlcklkLlxuICAgICAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IE9BdXRoUHJvdmlkZXIoJ2dvb2dsZS5jb20nKTtcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gcHJvdmlkZXIuY3JlZGVudGlhbCh7XG4gICAgICogICBpZFRva2VuOiBnb29nbGVVc2VyLmdldEF1dGhSZXNwb25zZSgpLmlkX3Rva2VuLFxuICAgICAqIH0pO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGNyZWRlbnRpYWwpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIEVpdGhlciB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgSUQgdG9rZW4sIGFjY2VzcyB0b2tlbiBhbmQgcmF3IG5vbmNlXG4gICAgICogb3IgdGhlIElEIHRva2VuIHN0cmluZy5cbiAgICAgKi9cbiAgICBjcmVkZW50aWFsKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JlZGVudGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgbm9uY2U6IHBhcmFtcy5yYXdOb25jZSB9KSk7XG4gICAgfVxuICAgIC8qKiBBbiBpbnRlcm5hbCBjcmVkZW50aWFsIG1ldGhvZCB0aGF0IGFjY2VwdHMgbW9yZSBwZXJtaXNzaXZlIG9wdGlvbnMgKi9cbiAgICBfY3JlZGVudGlhbChwYXJhbXMpIHtcbiAgICAgICAgX2Fzc2VydChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4sIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgLy8gRm9yIE9BdXRoQ3JlZGVudGlhbCwgc2lnbiBpbiBtZXRob2QgaXMgc2FtZSBhcyBwcm92aWRlcklkLlxuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBwcm92aWRlcklkOiB0aGlzLnByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZDogdGhpcy5wcm92aWRlcklkIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoUHJvdmlkZXIub2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgb2F1dGhDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCwgcGVuZGluZ1Rva2VuLCBub25jZSwgcHJvdmlkZXJJZCB9ID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuICYmXG4gICAgICAgICAgICAhb2F1dGhUb2tlblNlY3JldCAmJlxuICAgICAgICAgICAgIW9hdXRoSWRUb2tlbiAmJlxuICAgICAgICAgICAgIXBlbmRpbmdUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm92aWRlcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPQXV0aFByb3ZpZGVyKHByb3ZpZGVySWQpLl9jcmVkZW50aWFsKHtcbiAgICAgICAgICAgICAgICBpZFRva2VuOiBvYXV0aElkVG9rZW4sXG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IG9hdXRoQWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Rva2VuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgndXNlcl9iaXJ0aGRheScpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxuICogICBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEZhY2Vib29rQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgndXNlcl9iaXJ0aGRheScpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgRmFjZWJvb2sgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEZhY2Vib29rQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgRmFjZWJvb2suXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAvLyBgZXZlbnRgIGZyb20gdGhlIEZhY2Vib29rIGF1dGguYXV0aFJlc3BvbnNlQ2hhbmdlIGNhbGxiYWNrLlxuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsKGV2ZW50LmF1dGhSZXNwb25zZS5hY2Nlc3NUb2tlbik7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBGYWNlYm9vayBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBGYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUl9JRCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogRmFjZWJvb2tBdXRoUHJvdmlkZXIuRkFDRUJPT0tfU0lHTl9JTl9NRVRIT0QsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UgfHwgISgnb2F1dGhBY2Nlc3NUb2tlbicgaW4gdG9rZW5SZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRkFDRUJPT0suICovXG5GYWNlYm9va0F1dGhQcm92aWRlci5GQUNFQk9PS19TSUdOX0lOX01FVEhPRCA9IFwiZmFjZWJvb2suY29tXCIgLyogU2lnbkluTWV0aG9kLkZBQ0VCT09LICovO1xuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkZBQ0VCT09LLiAqL1xuRmFjZWJvb2tBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uR09PR0xFLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBHb29nbGVBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdwcm9maWxlJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgnZW1haWwnKTtcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEdvb2dsZSBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgR29vZ2xlQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImdvb2dsZS5jb21cIiAvKiBQcm92aWRlcklkLkdPT0dMRSAqLyk7XG4gICAgICAgIHRoaXMuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdvb2dsZS4gQXQgbGVhc3Qgb25lIG9mIElEIHRva2VuIGFuZCBhY2Nlc3MgdG9rZW4gaXMgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAvLyBcXGBnb29nbGVVc2VyXFxgIGZyb20gdGhlIG9uc3VjY2VzcyBHb29nbGUgU2lnbiBJbiBjYWxsYmFjay5cbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZ29vZ2xlVXNlci5nZXRBdXRoUmVzcG9uc2UoKS5pZF90b2tlbik7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRUb2tlbiAtIEdvb2dsZSBJRCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBHb29nbGUgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsKGlkVG9rZW4sIGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogR29vZ2xlQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBHb29nbGVBdXRoUHJvdmlkZXIuR09PR0xFX1NJR05fSU5fTUVUSE9ELFxuICAgICAgICAgICAgaWRUb2tlbixcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gR29vZ2xlQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbiB9ID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgaWYgKCFvYXV0aElkVG9rZW4gJiYgIW9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gb2F1dGggMSBjcmVkZW50aWFsIG9yIGEgcGhvbmUgY3JlZGVudGlhbFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChvYXV0aElkVG9rZW4sIG9hdXRoQWNjZXNzVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5HT09HTEUuICovXG5Hb29nbGVBdXRoUHJvdmlkZXIuR09PR0xFX1NJR05fSU5fTUVUSE9EID0gXCJnb29nbGUuY29tXCIgLyogU2lnbkluTWV0aG9kLkdPT0dMRSAqLztcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5HT09HTEUuICovXG5Hb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcImdvb2dsZS5jb21cIiAvKiBQcm92aWRlcklkLkdPT0dMRSAqLztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5HSVRIVUIuXG4gKlxuICogQHJlbWFya3NcbiAqIEdpdEh1YiByZXF1aXJlcyBhbiBPQXV0aCAyLjAgcmVkaXJlY3QsIHNvIHlvdSBjYW4gZWl0aGVyIGhhbmRsZSB0aGUgcmVkaXJlY3QgZGlyZWN0bHksIG9yIHVzZVxuICogdGhlIHtAbGluayBzaWduSW5XaXRoUG9wdXB9IGhhbmRsZXI6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdpdGh1YkF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3JlcG8nKTtcbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIEdpdEh1YiBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSBwb3B1cC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdpdGh1YkF1dGhQcm92aWRlcigpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3JlcG8nKTtcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBwcm92aWRlcik7XG4gKlxuICogLy8gVGhlIHNpZ25lZC1pbiB1c2VyIGluZm8uXG4gKiBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAvLyBUaGlzIGdpdmVzIHlvdSBhIEdpdEh1YiBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBgYGBcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgR2l0aHViQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBHaXRIdWIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNjZXNzVG9rZW4gLSBHaXRIdWIgYWNjZXNzIHRva2VuLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoe1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBHaXRodWJBdXRoUHJvdmlkZXIuR0lUSFVCX1NJR05fSU5fTUVUSE9ELFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UgfHwgISgnb2F1dGhBY2Nlc3NUb2tlbicgaW4gdG9rZW5SZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsKHRva2VuUmVzcG9uc2Uub2F1dGhBY2Nlc3NUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkdJVEhVQi4gKi9cbkdpdGh1YkF1dGhQcm92aWRlci5HSVRIVUJfU0lHTl9JTl9NRVRIT0QgPSBcImdpdGh1Yi5jb21cIiAvKiBTaWduSW5NZXRob2QuR0lUSFVCICovO1xuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi4gKi9cbkdpdGh1YkF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgSURQX1JFUVVFU1RfVVJJID0gJ2h0dHA6Ly9sb2NhbGhvc3QnO1xuLyoqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFNBTUxBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVySWQsIHByb3ZpZGVySWQpO1xuICAgICAgICB0aGlzLnBlbmRpbmdUb2tlbiA9IHBlbmRpbmdUb2tlbjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbGlua1RvSWRUb2tlbihhdXRoLCBpZFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0LmlkVG9rZW4gPSBpZFRva2VuO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5idWlsZFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5hdXRvQ3JlYXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiB0aGlzLnNpZ25Jbk1ldGhvZCxcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHBlbmRpbmdUb2tlbjogdGhpcy5wZW5kaW5nVG9rZW5cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW5cbiAgICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqc29uIC0gSW5wdXQgY2FuIGJlIGVpdGhlciBPYmplY3Qgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCwgcGVuZGluZ1Rva2VuIH0gPSBvYmo7XG4gICAgICAgIGlmICghcHJvdmlkZXJJZCB8fFxuICAgICAgICAgICAgIXNpZ25Jbk1ldGhvZCB8fFxuICAgICAgICAgICAgIXBlbmRpbmdUb2tlbiB8fFxuICAgICAgICAgICAgcHJvdmlkZXJJZCAhPT0gc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNBTUxBdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgc3RhdGljIG1ldGhvZCB0byBhdm9pZCBleHBvc2luZyB0aGUgY29uc3RydWN0b3IgdG8gZW5kIHVzZXJzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIF9jcmVhdGUocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKSB7XG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XG4gICAgfVxuICAgIGJ1aWxkUmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmk6IElEUF9SRVFVRVNUX1VSSSxcbiAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IFNBTUxfUFJPVklERVJfUFJFRklYID0gJ3NhbWwuJztcbi8qKlxuICogQW4ge0BsaW5rIEF1dGhQcm92aWRlcn0gZm9yIFNBTUwuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTQU1MQXV0aFByb3ZpZGVyIGV4dGVuZHMgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci4gVGhlIHByb3ZpZGVySWQgbXVzdCBzdGFydCB3aXRoIFwic2FtbC5cIlxuICAgICAqIEBwYXJhbSBwcm92aWRlcklkIC0gU0FNTCBwcm92aWRlciBJRC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkKSB7XG4gICAgICAgIF9hc3NlcnQocHJvdmlkZXJJZC5zdGFydHNXaXRoKFNBTUxfUFJPVklERVJfUFJFRklYKSwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBzdXBlcihwcm92aWRlcklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0gYWZ0ZXIgYVxuICAgICAqIHN1Y2Nlc3NmdWwgU0FNTCBmbG93IGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgdG8gZ2V0IGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0sIHlvdSBjb3VsZCB3cml0ZSB0aGVcbiAgICAgKiBmb2xsb3dpbmcgY29kZTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgc2FtbFByb3ZpZGVyKTtcbiAgICAgKiBjb25zdCBjcmVkZW50aWFsID0gU0FNTEF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gU0FNTEF1dGhQcm92aWRlci5zYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBTQU1MQXV0aFByb3ZpZGVyLnNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gZnJvbSBhIEpTT04gc3RyaW5nIG9yIGEgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSBqc29uIC0gQSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBjcmVkZW50aWFsID0gU0FNTEF1dGhDcmVkZW50aWFsLmZyb21KU09OKGpzb24pO1xuICAgICAgICBfYXNzZXJ0KGNyZWRlbnRpYWwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWw7XG4gICAgfVxuICAgIHN0YXRpYyBzYW1sQ3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwZW5kaW5nVG9rZW4sIHByb3ZpZGVySWQgfSA9IHRva2VuUmVzcG9uc2U7XG4gICAgICAgIGlmICghcGVuZGluZ1Rva2VuIHx8ICFwcm92aWRlcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFNBTUxBdXRoQ3JlZGVudGlhbC5fY3JlYXRlKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LlRXSVRURVIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IFR3aXR0ZXJBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIGF3YWl0IHNpZ25JbldpdGhSZWRpcmVjdChhdXRoLCBwcm92aWRlcik7XG4gKiAvLyBUaGlzIHdpbGwgdHJpZ2dlciBhIGZ1bGwgcGFnZSByZWRpcmVjdCBhd2F5IGZyb20geW91ciBhcHBcbiAqXG4gKiAvLyBBZnRlciByZXR1cm5pbmcgZnJvbSB0aGUgcmVkaXJlY3Qgd2hlbiB5b3VyIGFwcCBpbml0aWFsaXplcyB5b3UgY2FuIG9idGFpbiB0aGUgcmVzdWx0XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRSZWRpcmVjdFJlc3VsdChhdXRoKTtcbiAqIGlmIChyZXN1bHQpIHtcbiAqICAgLy8gVGhpcyBpcyB0aGUgc2lnbmVkLWluIHVzZXJcbiAqICAgY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogICAvLyBUaGlzIGdpdmVzIHlvdSBhIFR3aXR0ZXIgQWNjZXNzIFRva2VuIGFuZCBTZWNyZXQuXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqICAgY29uc3Qgc2VjcmV0ID0gY3JlZGVudGlhbC5zZWNyZXQ7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgVHdpdHRlckF1dGhQcm92aWRlcigpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHJlc3VsdCk7XG4gKiBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVHdpdHRlckF1dGhQcm92aWRlciBleHRlbmRzIEJhc2VPQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJ0d2l0dGVyLmNvbVwiIC8qIFByb3ZpZGVySWQuVFdJVFRFUiAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBUd2l0dGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIC0gVHdpdHRlciBhY2Nlc3MgdG9rZW4uXG4gICAgICogQHBhcmFtIHNlY3JldCAtIFR3aXR0ZXIgc2VjcmV0LlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsKHRva2VuLCBzZWNyZXQpIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBUd2l0dGVyQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBUd2l0dGVyQXV0aFByb3ZpZGVyLlRXSVRURVJfU0lHTl9JTl9NRVRIT0QsXG4gICAgICAgICAgICBvYXV0aFRva2VuOiB0b2tlbixcbiAgICAgICAgICAgIG9hdXRoVG9rZW5TZWNyZXQ6IHNlY3JldFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9hdXRoQWNjZXNzVG9rZW4sIG9hdXRoVG9rZW5TZWNyZXQgfSA9IHRva2VuUmVzcG9uc2U7XG4gICAgICAgIGlmICghb2F1dGhBY2Nlc3NUb2tlbiB8fCAhb2F1dGhUb2tlblNlY3JldCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBUd2l0dGVyQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwob2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LlRXSVRURVIuICovXG5Ud2l0dGVyQXV0aFByb3ZpZGVyLlRXSVRURVJfU0lHTl9JTl9NRVRIT0QgPSBcInR3aXR0ZXIuY29tXCIgLyogU2lnbkluTWV0aG9kLlRXSVRURVIgKi87XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uVFdJVFRFUi4gKi9cblR3aXR0ZXJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnblVwKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnblVwXCIgLyogRW5kcG9pbnQuU0lHTl9VUCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIFVzZXJDcmVkZW50aWFsSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHBhcmFtcy51c2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwYXJhbXMucHJvdmlkZXJJZDtcbiAgICAgICAgdGhpcy5fdG9rZW5SZXNwb25zZSA9IHBhcmFtcy5fdG9rZW5SZXNwb25zZTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25UeXBlID0gcGFyYW1zLm9wZXJhdGlvblR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBfZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBvcGVyYXRpb25UeXBlLCBpZFRva2VuUmVzcG9uc2UsIGlzQW5vbnltb3VzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXJJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMpO1xuICAgICAgICBjb25zdCBwcm92aWRlcklkID0gcHJvdmlkZXJJZEZvclJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IHVzZXJDcmVkID0gbmV3IFVzZXJDcmVkZW50aWFsSW1wbCh7XG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgICAgIF90b2tlblJlc3BvbnNlOiBpZFRva2VuUmVzcG9uc2UsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXNlckNyZWQ7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBfZm9yT3BlcmF0aW9uKHVzZXIsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIGF3YWl0IHVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCAvKiByZWxvYWQgKi8gdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gbmV3IFVzZXJDcmVkZW50aWFsSW1wbCh7XG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgcHJvdmlkZXJJZCxcbiAgICAgICAgICAgIF90b2tlblJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvdmlkZXJJZEZvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnByb3ZpZGVySWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnByb3ZpZGVySWQ7XG4gICAgfVxuICAgIGlmICgncGhvbmVOdW1iZXInIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBcInBob25lXCIgLyogUHJvdmlkZXJJZC5QSE9ORSAqLztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIGFzIGFuIGFub255bW91cyB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFub255bW91cyB1c2VyIHNpZ25lZCBpbiwgdGhhdCB1c2VyIHdpbGwgYmUgcmV0dXJuZWQ7IG90aGVyd2lzZSwgYVxuICogbmV3IGFub255bW91cyB1c2VyIGlkZW50aXR5IHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluQW5vbnltb3VzbHkoYXV0aCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYXBwLl9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgaWYgKChfYSA9IGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSB7XG4gICAgICAgIC8vIElmIGFuIGFub255bW91cyB1c2VyIGlzIGFscmVhZHkgc2lnbmVkIGluLCBubyBuZWVkIHRvIHNpZ24gdGhlbSBpbiBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyQ3JlZGVudGlhbEltcGwoe1xuICAgICAgICAgICAgdXNlcjogYXV0aEludGVybmFsLmN1cnJlbnRVc2VyLFxuICAgICAgICAgICAgcHJvdmlkZXJJZDogbnVsbCxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25VcChhdXRoSW50ZXJuYWwsIHtcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSwgdHJ1ZSk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNdWx0aUZhY3RvckVycm9yIGV4dGVuZHMgdXRpbC5GaXJlYmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBvcGVyYXRpb25UeXBlO1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTXVsdGlGYWN0b3JFcnJvci5wcm90b3R5cGUpO1xuICAgICAgICB0aGlzLmN1c3RvbURhdGEgPSB7XG4gICAgICAgICAgICBhcHBOYW1lOiBhdXRoLm5hbWUsXG4gICAgICAgICAgICB0ZW5hbnRJZDogKF9hID0gYXV0aC50ZW5hbnRJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgX3NlcnZlclJlc3BvbnNlOiBlcnJvci5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZSxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvckVycm9yKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCwgdXNlcikge1xuICAgIGNvbnN0IGlkVG9rZW5Qcm92aWRlciA9IG9wZXJhdGlvblR5cGUgPT09IFwicmVhdXRoZW50aWNhdGVcIiAvKiBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFICovXG4gICAgICAgID8gY3JlZGVudGlhbC5fZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpXG4gICAgICAgIDogY3JlZGVudGlhbC5fZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpO1xuICAgIHJldHVybiBpZFRva2VuUHJvdmlkZXIuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm11bHRpLWZhY3Rvci1hdXRoLXJlcXVpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfUkVRVUlSRUQgKi99YCkge1xuICAgICAgICAgICAgdGhyb3cgTXVsdGlGYWN0b3JFcnJvci5fZnJvbUVycm9yQW5kT3BlcmF0aW9uKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGFrZXMgYSBzZXQgb2YgVXNlckluZm8gcHJvdmlkZXIgZGF0YSBhbmQgY29udmVydHMgaXQgdG8gYSBzZXQgb2YgbmFtZXNcbiAqL1xuZnVuY3Rpb24gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlckRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNldChwcm92aWRlckRhdGFcbiAgICAgICAgLm1hcCgoeyBwcm92aWRlcklkIH0pID0+IHByb3ZpZGVySWQpXG4gICAgICAgIC5maWx0ZXIocGlkID0+ICEhcGlkKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVubGlua3MgYSBwcm92aWRlciBmcm9tIGEgdXNlciBhY2NvdW50LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvdmlkZXJJZCAtIFRoZSBwcm92aWRlciB0byB1bmxpbmsuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB1bmxpbmsodXNlciwgcHJvdmlkZXJJZCkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXModHJ1ZSwgdXNlckludGVybmFsLCBwcm92aWRlcklkKTtcbiAgICBjb25zdCB7IHByb3ZpZGVyVXNlckluZm8gfSA9IGF3YWl0IGRlbGV0ZUxpbmtlZEFjY291bnRzKHVzZXJJbnRlcm5hbC5hdXRoLCB7XG4gICAgICAgIGlkVG9rZW46IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCksXG4gICAgICAgIGRlbGV0ZVByb3ZpZGVyOiBbcHJvdmlkZXJJZF1cbiAgICB9KTtcbiAgICBjb25zdCBwcm92aWRlcnNMZWZ0ID0gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlclVzZXJJbmZvIHx8IFtdKTtcbiAgICB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maWx0ZXIocGQgPT4gcHJvdmlkZXJzTGVmdC5oYXMocGQucHJvdmlkZXJJZCkpO1xuICAgIGlmICghcHJvdmlkZXJzTGVmdC5oYXMoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8pKSB7XG4gICAgICAgIHVzZXJJbnRlcm5hbC5waG9uZU51bWJlciA9IG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICAgIHJldHVybiB1c2VySW50ZXJuYWw7XG59XG5hc3luYyBmdW5jdGlvbiBfbGluayh1c2VyLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgY3JlZGVudGlhbC5fbGlua1RvSWRUb2tlbih1c2VyLmF1dGgsIGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpKSwgYnlwYXNzQXV0aFN0YXRlKTtcbiAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgXCJsaW5rXCIgLyogT3BlcmF0aW9uVHlwZS5MSU5LICovLCByZXNwb25zZSk7XG59XG5hc3luYyBmdW5jdGlvbiBfYXNzZXJ0TGlua2VkU3RhdHVzKGV4cGVjdGVkLCB1c2VyLCBwcm92aWRlcikge1xuICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVySWRzID0gcHJvdmlkZXJEYXRhQXNOYW1lcyh1c2VyLnByb3ZpZGVyRGF0YSk7XG4gICAgY29uc3QgY29kZSA9IGV4cGVjdGVkID09PSBmYWxzZVxuICAgICAgICA/IFwicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBST1ZJREVSX0FMUkVBRFlfTElOS0VEICovXG4gICAgICAgIDogXCJuby1zdWNoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSICovO1xuICAgIF9hc3NlcnQocHJvdmlkZXJJZHMuaGFzKHByb3ZpZGVyKSA9PT0gZXhwZWN0ZWQsIHVzZXIuYXV0aCwgY29kZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGUodXNlciwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XG4gICAgaWYgKGFwcC5faXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3Qgb3BlcmF0aW9uVHlwZSA9IFwicmVhdXRoZW50aWNhdGVcIiAvKiBPcGVyYXRpb25UeXBlLlJFQVVUSEVOVElDQVRFICovO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgX3Byb2Nlc3NDcmVkZW50aWFsU2F2aW5nTWZhQ29udGV4dElmTmVjZXNzYXJ5KGF1dGgsIG9wZXJhdGlvblR5cGUsIGNyZWRlbnRpYWwsIHVzZXIpLCBieXBhc3NBdXRoU3RhdGUpO1xuICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLmlkVG9rZW4sIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlVG9rZW4ocmVzcG9uc2UuaWRUb2tlbik7XG4gICAgICAgIF9hc3NlcnQocGFyc2VkLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IHsgc3ViOiBsb2NhbElkIH0gPSBwYXJzZWQ7XG4gICAgICAgIF9hc3NlcnQodXNlci51aWQgPT09IGxvY2FsSWQsIGF1dGgsIFwidXNlci1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9NSVNNQVRDSCAqLyk7XG4gICAgICAgIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbih1c2VyLCBvcGVyYXRpb25UeXBlLCByZXNwb25zZSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIENvbnZlcnQgdXNlciBkZWxldGVkIGVycm9yIGludG8gdXNlciBtaXNtYXRjaFxuICAgICAgICBpZiAoKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5jb2RlKSA9PT0gYGF1dGgvJHtcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi99YCkge1xuICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9zaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xuICAgIGlmIChhcHAuX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdGlvblR5cGUgPSBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLztcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsKTtcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoLCBvcGVyYXRpb25UeXBlLCByZXNwb25zZSk7XG4gICAgaWYgKCFieXBhc3NBdXRoU3RhdGUpIHtcbiAgICAgICAgYXdhaXQgYXV0aC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gICAgfVxuICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjcmVkZW50aWFsIC0gVGhlIGF1dGggY3JlZGVudGlhbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gX3NpZ25JbldpdGhDcmVkZW50aWFsKF9jYXN0QXV0aChhdXRoKSwgY3JlZGVudGlhbCk7XG59XG4vKipcbiAqIExpbmtzIHRoZSB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuXG4gKlxuICogQHJlbWFya3NcbiAqIEFuIHtAbGluayBBdXRoUHJvdmlkZXJ9IGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBsaW5rV2l0aENyZWRlbnRpYWwodXNlciwgY3JlZGVudGlhbCkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXMoZmFsc2UsIHVzZXJJbnRlcm5hbCwgY3JlZGVudGlhbC5wcm92aWRlcklkKTtcbiAgICByZXR1cm4gX2xpbmsodXNlckludGVybmFsLCBjcmVkZW50aWFsKTtcbn1cbi8qKlxuICogUmUtYXV0aGVudGljYXRlcyBhIHVzZXIgdXNpbmcgYSBmcmVzaCBjcmVkZW50aWFsLlxuICpcbiAqIEByZW1hcmtzXG4gKiBVc2UgYmVmb3JlIG9wZXJhdGlvbnMgc3VjaCBhcyB7QGxpbmsgdXBkYXRlUGFzc3dvcmR9IHRoYXQgcmVxdWlyZSB0b2tlbnMgZnJvbSByZWNlbnQgc2lnbi1pblxuICogYXR0ZW1wdHMuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJlY292ZXIgZnJvbSBhIGBDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU5gIGVycm9yXG4gKiBvciBhIGBUT0tFTl9FWFBJUkVEYCBlcnJvci5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIGFueSB7QGxpbmsgVXNlcn0gc2lnbmVkIGluIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXNcbiAqIGNyZWF0ZWQgd2l0aCBhIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCh1c2VyLCBjcmVkZW50aWFsKSB7XG4gICAgcmV0dXJuIF9yZWF1dGhlbnRpY2F0ZSh1dGlsLmdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSwgY3JlZGVudGlhbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhDdXN0b21Ub2tlblwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9DVVNUT01fVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGEgY3VzdG9tIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBDdXN0b20gdG9rZW5zIGFyZSB1c2VkIHRvIGludGVncmF0ZSBGaXJlYmFzZSBBdXRoIHdpdGggZXhpc3RpbmcgYXV0aCBzeXN0ZW1zLCBhbmQgbXVzdFxuICogYmUgZ2VuZXJhdGVkIGJ5IGFuIGF1dGggYmFja2VuZCB1c2luZyB0aGVcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9yZWZlcmVuY2UvYWRtaW4vbm9kZS9hZG1pbi5hdXRoLkF1dGgjY3JlYXRlY3VzdG9tdG9rZW4gfCBjcmVhdGVDdXN0b21Ub2tlbn1cbiAqIG1ldGhvZCBpbiB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvYWRtaW4gfCBBZG1pbiBTREt9IC5cbiAqXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCBleHBpcmVkLCBvciBub3QgYWNjZXB0ZWQgYnkgdGhlIEZpcmViYXNlIEF1dGggc2VydmljZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY3VzdG9tVG9rZW4gLSBUaGUgY3VzdG9tIHRva2VuIHRvIHNpZ24gaW4gd2l0aC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbihhdXRoLCBjdXN0b21Ub2tlbikge1xuICAgIGlmIChhcHAuX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNpZ25JbldpdGhDdXN0b21Ub2tlbiQxKGF1dGhJbnRlcm5hbCwge1xuICAgICAgICB0b2tlbjogY3VzdG9tVG9rZW4sXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgY3JlZCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcihjcmVkLnVzZXIpO1xuICAgIHJldHVybiBjcmVkO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTXVsdGlGYWN0b3JJbmZvSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9ySWQsIHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuZmFjdG9ySWQgPSBmYWN0b3JJZDtcbiAgICAgICAgdGhpcy51aWQgPSByZXNwb25zZS5tZmFFbnJvbGxtZW50SWQ7XG4gICAgICAgIHRoaXMuZW5yb2xsbWVudFRpbWUgPSBuZXcgRGF0ZShyZXNwb25zZS5lbnJvbGxlZEF0KS50b1VUQ1N0cmluZygpO1xuICAgICAgICB0aGlzLmRpc3BsYXlOYW1lID0gcmVzcG9uc2UuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpIHtcbiAgICAgICAgaWYgKCdwaG9uZUluZm8nIGluIGVucm9sbG1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgndG90cEluZm8nIGluIGVucm9sbG1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBUb3RwTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgfVxufVxuY2xhc3MgUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsIGV4dGVuZHMgTXVsdGlGYWN0b3JJbmZvSW1wbCB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIoXCJwaG9uZVwiIC8qIEZhY3RvcklkLlBIT05FICovLCByZXNwb25zZSk7XG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSByZXNwb25zZS5waG9uZUluZm87XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKF9hdXRoLCBlbnJvbGxtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVNdWx0aUZhY3RvckluZm9JbXBsKGVucm9sbG1lbnQpO1xuICAgIH1cbn1cbmNsYXNzIFRvdHBNdWx0aUZhY3RvckluZm9JbXBsIGV4dGVuZHMgTXVsdGlGYWN0b3JJbmZvSW1wbCB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgc3VwZXIoXCJ0b3RwXCIgLyogRmFjdG9ySWQuVE9UUCAqLywgcmVzcG9uc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21TZXJ2ZXJSZXNwb25zZShfYXV0aCwgZW5yb2xsbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckluZm9JbXBsKGVucm9sbG1lbnQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoYXV0aCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgdmFyIF9hO1xuICAgIF9hc3NlcnQoKChfYSA9IGFjdGlvbkNvZGVTZXR0aW5ncy51cmwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpID4gMCwgYXV0aCwgXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT05USU5VRV9VUkkgKi8pO1xuICAgIF9hc3NlcnQodHlwZW9mIGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbiA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgYWN0aW9uQ29kZVNldHRpbmdzLmR5bmFtaWNMaW5rRG9tYWluLmxlbmd0aCA+IDAsIGF1dGgsIFwiaW52YWxpZC1keW5hbWljLWxpbmstZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU4gKi8pO1xuICAgIHJlcXVlc3QuY29udGludWVVcmwgPSBhY3Rpb25Db2RlU2V0dGluZ3MudXJsO1xuICAgIHJlcXVlc3QuZHluYW1pY0xpbmtEb21haW4gPSBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW47XG4gICAgcmVxdWVzdC5jYW5IYW5kbGVDb2RlSW5BcHAgPSBhY3Rpb25Db2RlU2V0dGluZ3MuaGFuZGxlQ29kZUluQXBwO1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TKSB7XG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVNldHRpbmdzLmlPUy5idW5kbGVJZC5sZW5ndGggPiAwLCBhdXRoLCBcIm1pc3NpbmctaW9zLWJ1bmRsZS1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19JT1NfQlVORExFX0lEICovKTtcbiAgICAgICAgcmVxdWVzdC5pT1NCdW5kbGVJZCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5pT1MuYnVuZGxlSWQ7XG4gICAgfVxuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZCkge1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLnBhY2thZ2VOYW1lLmxlbmd0aCA+IDAsIGF1dGgsIFwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovKTtcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkSW5zdGFsbEFwcCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLmluc3RhbGxBcHA7XG4gICAgICAgIHJlcXVlc3QuYW5kcm9pZE1pbmltdW1WZXJzaW9uQ29kZSA9XG4gICAgICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5taW5pbXVtVmVyc2lvbjtcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkUGFja2FnZU5hbWUgPSBhY3Rpb25Db2RlU2V0dGluZ3MuYW5kcm9pZC5wYWNrYWdlTmFtZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBhc3N3b3JkIHBvbGljeSBjYWNoZWQgaW4gdGhlIHtAbGluayBBdXRofSBpbnN0YW5jZSBpZiBhIHBvbGljeSBpcyBhbHJlYWR5XG4gKiBjYWNoZWQgZm9yIHRoZSBwcm9qZWN0IG9yIHRlbmFudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogV2Ugb25seSBmZXRjaCB0aGUgcGFzc3dvcmQgcG9saWN5IGlmIHRoZSBwYXNzd29yZCBkaWQgbm90IG1lZXQgcG9saWN5IHJlcXVpcmVtZW50cyBhbmRcbiAqIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHBvbGljeSBjYWNoZWQuIEEgZGV2ZWxvcGVyIG11c3QgY2FsbCB2YWxpZGF0ZVBhc3N3b3JkIGF0IGxlYXN0XG4gKiBvbmNlIGZvciB0aGUgY2FjaGUgdG8gYmUgYXV0b21hdGljYWxseSB1cGRhdGVkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYyBmdW5jdGlvbiByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCkge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBpZiAoYXV0aEludGVybmFsLl9nZXRQYXNzd29yZFBvbGljeUludGVybmFsKCkpIHtcbiAgICAgICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVQYXNzd29yZFBvbGljeSgpO1xuICAgIH1cbn1cbi8qKlxuICogU2VuZHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlblxuICogdGhlcmUncyBubyB1c2VyIGFjY291bnQgd2l0aCB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcyBhbmRcbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cbiAqIGlzIGVuYWJsZWQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRvIGNvbXBsZXRlIHRoZSBwYXNzd29yZCByZXNldCwgY2FsbCB7QGxpbmsgY29uZmlybVBhc3N3b3JkUmVzZXR9IHdpdGggdGhlIGNvZGUgc3VwcGxpZWQgaW5cbiAqIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLCBhbG9uZyB3aXRoIHRoZSBuZXcgcGFzc3dvcmQgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRQYXNzd29yZFJlc2V0RW1haWwoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGNvZGUgZnJvbSB1c2VyLlxuICogYXdhaXQgY29uZmlybVBhc3N3b3JkUmVzZXQoJ3VzZXJAZXhhbXBsZS5jb20nLCBjb2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzZW5kUGFzc3dvcmRSZXNldEVtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgIH07XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICB9XG4gICAgYXdhaXQgaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovLCBzZW5kUGFzc3dvcmRSZXNldEVtYWlsJDEsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xufVxuLyoqXG4gKiBDb21wbGV0ZXMgdGhlIHBhc3N3b3JkIHJlc2V0IHByb2Nlc3MsIGdpdmVuIGEgY29uZmlybWF0aW9uIGNvZGUgYW5kIG5ldyBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgY29uZmlybWF0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBjb25maXJtUGFzc3dvcmRSZXNldChhdXRoLCBvb2JDb2RlLCBuZXdQYXNzd29yZCkge1xuICAgIGF3YWl0IHJlc2V0UGFzc3dvcmQodXRpbC5nZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHtcbiAgICAgICAgb29iQ29kZSxcbiAgICAgICAgbmV3UGFzc3dvcmRcbiAgICB9KVxuICAgICAgICAuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PVxuICAgICAgICAgICAgYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICAvLyBEbyBub3QgcmV0dXJuIHRoZSBlbWFpbC5cbn1cbi8qKlxuICogQXBwbGllcyBhIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlKGF1dGgsIG9vYkNvZGUpIHtcbiAgICBhd2FpdCBhcHBseUFjdGlvbkNvZGUkMSh1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgeyBvb2JDb2RlIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgYSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyIGJ5IGVtYWlsIG9yIG90aGVyIG91dC1vZi1iYW5kIG1lY2hhbmlzbS5cbiAqXG4gKiBAcmV0dXJucyBtZXRhZGF0YSBhYm91dCB0aGUgY29kZS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gb29iQ29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrQWN0aW9uQ29kZShhdXRoLCBvb2JDb2RlKSB7XG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc2V0UGFzc3dvcmQoYXV0aE1vZHVsYXIsIHsgb29iQ29kZSB9KTtcbiAgICAvLyBFbWFpbCBjb3VsZCBiZSBlbXB0eSBvbmx5IGlmIHRoZSByZXF1ZXN0IHR5cGUgaXMgRU1BSUxfU0lHTklOIG9yXG4gICAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXG4gICAgLy8gTmV3IGVtYWlsIHNob3VsZCBub3QgYmUgZW1wdHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpc1xuICAgIC8vIFZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMLlxuICAgIC8vIE11bHRpLWZhY3RvciBpbmZvIGNvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXG4gICAgLy8gUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04uXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gcmVzcG9uc2UucmVxdWVzdFR5cGU7XG4gICAgX2Fzc2VydChvcGVyYXRpb24sIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgc3dpdGNoIChvcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi86XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLm5ld0VtYWlsLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUkVWRVJUX1NFQ09ORF9GQUNUT1JfQURESVRJT04gKi86XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLm1mYUluZm8sIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgX2Fzc2VydChyZXNwb25zZS5lbWFpbCwgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICB9XG4gICAgLy8gVGhlIG11bHRpLWZhY3RvciBpbmZvIGZvciByZXZlcnQgc2Vjb25kIGZhY3RvciBhZGRpdGlvblxuICAgIGxldCBtdWx0aUZhY3RvckluZm8gPSBudWxsO1xuICAgIGlmIChyZXNwb25zZS5tZmFJbmZvKSB7XG4gICAgICAgIG11bHRpRmFjdG9ySW5mbyA9IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShfY2FzdEF1dGgoYXV0aE1vZHVsYXIpLCByZXNwb25zZS5tZmFJbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgZW1haWw6IChyZXNwb25zZS5yZXF1ZXN0VHlwZSA9PT0gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi9cbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLm5ld0VtYWlsXG4gICAgICAgICAgICAgICAgOiByZXNwb25zZS5lbWFpbCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHByZXZpb3VzRW1haWw6IChyZXNwb25zZS5yZXF1ZXN0VHlwZSA9PT0gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi9cbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmVtYWlsXG4gICAgICAgICAgICAgICAgOiByZXNwb25zZS5uZXdFbWFpbCkgfHwgbnVsbCxcbiAgICAgICAgICAgIG11bHRpRmFjdG9ySW5mb1xuICAgICAgICB9LFxuICAgICAgICBvcGVyYXRpb25cbiAgICB9O1xufVxuLyoqXG4gKiBDaGVja3MgYSBwYXNzd29yZCByZXNldCBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEByZXR1cm5zIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcyBpZiB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY29kZSAtIEEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlKGF1dGgsIGNvZGUpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGNoZWNrQWN0aW9uQ29kZSh1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgY29kZSk7XG4gICAgLy8gRW1haWwgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IHNpbmNlIGEgY29kZSB3YXMgc2VudCB0byBpdFxuICAgIHJldHVybiBkYXRhLmVtYWlsO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHVzZXIgYWNjb3VudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogT24gc3VjY2Vzc2Z1bCBjcmVhdGlvbiBvZiB0aGUgdXNlciBhY2NvdW50LCB0aGlzIHVzZXIgd2lsbCBhbHNvIGJlIHNpZ25lZCBpbiB0byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIFVzZXIgYWNjb3VudCBjcmVhdGlvbiBjYW4gZmFpbCBpZiB0aGUgYWNjb3VudCBhbHJlYWR5IGV4aXN0cyBvciB0aGUgcGFzc3dvcmQgaXMgaW52YWxpZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBOb3RlOiBUaGUgZW1haWwgYWRkcmVzcyBhY3RzIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB1c2VyIGFuZCBlbmFibGVzIGFuIGVtYWlsLWJhc2VkXG4gKiBwYXNzd29yZCByZXNldC4gVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyB1c2VyIGFjY291bnQgYW5kIHNldCB0aGUgaW5pdGlhbCB1c2VyIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgY2hvc2VuIHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkKGF1dGgsIGVtYWlsLCBwYXNzd29yZCkge1xuICAgIGlmIChhcHAuX2lzRmlyZWJhc2VTZXJ2ZXJBcHAoYXV0aC5hcHApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcihhdXRoKSk7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZSxcbiAgICAgICAgZW1haWwsXG4gICAgICAgIHBhc3N3b3JkLFxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgfTtcbiAgICBjb25zdCBzaWduVXBSZXNwb25zZSA9IGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEludGVybmFsLCByZXF1ZXN0LCBcInNpZ25VcFBhc3N3b3JkXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5TSUdOX1VQX1BBU1NXT1JEICovLCBzaWduVXAsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnblVwUmVzcG9uc2UuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IFVzZXJDcmVkZW50aWFsSW1wbC5fZnJvbUlkVG9rZW5SZXNwb25zZShhdXRoSW50ZXJuYWwsIFwic2lnbkluXCIgLyogT3BlcmF0aW9uVHlwZS5TSUdOX0lOICovLCByZXNwb25zZSk7XG4gICAgYXdhaXQgYXV0aEludGVybmFsLl91cGRhdGVDdXJyZW50VXNlcih1c2VyQ3JlZGVudGlhbC51c2VyKTtcbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGFuIGVtYWlsIGFuZCBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgZW1haWwgYWRkcmVzcyBhbmQgcGFzc3dvcmQgZG8gbm90IG1hdGNoLiBXaGVuXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XG4gKiBpcyBlbmFibGVkLCB0aGlzIG1ldGhvZCBmYWlscyB3aXRoIFwiYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWxcIiBpbiBjYXNlIG9mIGFuIGludmFsaWRcbiAqIGVtYWlsL3Bhc3N3b3JkLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24ge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIE5vdGU6IFRoZSB1c2VyJ3MgcGFzc3dvcmQgaXMgTk9UIHRoZSBwYXNzd29yZCB1c2VkIHRvIGFjY2VzcyB0aGUgdXNlcidzIGVtYWlsIGFjY291bnQuIFRoZVxuICogZW1haWwgYWRkcmVzcyBzZXJ2ZXMgYXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHVzZXIsIGFuZCB0aGUgcGFzc3dvcmQgaXMgdXNlZCB0byBhY2Nlc3NcbiAqIHRoZSB1c2VyJ3MgYWNjb3VudCBpbiB5b3VyIEZpcmViYXNlIHByb2plY3QuIFNlZSBhbHNvOiB7QGxpbmsgY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkfS5cbiAqXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXJzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgdXNlcnMgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzaWduSW5XaXRoRW1haWxBbmRQYXNzd29yZChhdXRoLCBlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBpZiAoYXBwLl9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gc2lnbkluV2l0aENyZWRlbnRpYWwodXRpbC5nZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkKSkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovfWApIHtcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTZW5kcyBhIHNpZ24taW4gZW1haWwgbGluayB0byB0aGUgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQgZW1haWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBzaWduLWluIG9wZXJhdGlvbiBoYXMgdG8gYWx3YXlzIGJlIGNvbXBsZXRlZCBpbiB0aGUgYXBwIHVubGlrZSBvdGhlciBvdXQgb2YgYmFuZCBlbWFpbFxuICogYWN0aW9ucyAocGFzc3dvcmQgcmVzZXQgYW5kIGVtYWlsIHZlcmlmaWNhdGlvbnMpLiBUaGlzIGlzIGJlY2F1c2UsIGF0IHRoZSBlbmQgb2YgdGhlIGZsb3csXG4gKiB0aGUgdXNlciBpcyBleHBlY3RlZCB0byBiZSBzaWduZWQgaW4gYW5kIHRoZWlyIEF1dGggc3RhdGUgcGVyc2lzdGVkIHdpdGhpbiB0aGUgYXBwLlxuICpcbiAqIFRvIGNvbXBsZXRlIHNpZ24gaW4gd2l0aCB0aGUgZW1haWwgbGluaywgY2FsbCB7QGxpbmsgc2lnbkluV2l0aEVtYWlsTGlua30gd2l0aCB0aGUgZW1haWxcbiAqIGFkZHJlc3MgYW5kIHRoZSBlbWFpbCBsaW5rIHN1cHBsaWVkIGluIHRoZSBlbWFpbCBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoSW50ZXJuYWwgLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2V0QWN0aW9uQ29kZVNldHRpbmdzKHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVTZXR0aW5ncy5oYW5kbGVDb2RlSW5BcHAsIGF1dGhJbnRlcm5hbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRBY3Rpb25Db2RlU2V0dGluZ3MocmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRTaWduSW5MaW5rVG9FbWFpbCQxLCBcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGluY29taW5nIGxpbmsgaXMgYSBzaWduLWluIHdpdGggZW1haWwgbGluayBzdWl0YWJsZSBmb3Ige0BsaW5rIHNpZ25JbldpdGhFbWFpbExpbmt9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspIHtcbiAgICBjb25zdCBhY3Rpb25Db2RlVXJsID0gQWN0aW9uQ29kZVVSTC5wYXJzZUxpbmsoZW1haWxMaW5rKTtcbiAgICByZXR1cm4gKGFjdGlvbkNvZGVVcmwgPT09IG51bGwgfHwgYWN0aW9uQ29kZVVybCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9uQ29kZVVybC5vcGVyYXRpb24pID09PSBcIkVNQUlMX1NJR05JTlwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uRU1BSUxfU0lHTklOICovO1xufVxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzaWducyBpbiB1c2luZyBhbiBlbWFpbCBhbmQgc2lnbi1pbiBlbWFpbCBsaW5rLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiBubyBsaW5rIGlzIHBhc3NlZCwgdGhlIGxpbmsgaXMgaW5mZXJyZWQgZnJvbSB0aGUgY3VycmVudCBVUkwuXG4gKlxuICogRmFpbHMgd2l0aCBhbiBlcnJvciBpZiB0aGUgZW1haWwgYWRkcmVzcyBpcyBpbnZhbGlkIG9yIE9UUCBpbiBlbWFpbCBsaW5rIGV4cGlyZXMuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogTm90ZTogQ29uZmlybSB0aGUgbGluayBpcyBhIHNpZ24taW4gZW1haWwgbGluayBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCBmaXJlYmFzZS5hdXRoLkF1dGguaXNTaWduSW5XaXRoRW1haWxMaW5rLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gZW1haWxMaW5rIGZyb20gdGhlIHVzZXIuXG4gKiBpZihpc1NpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWxMaW5rKSkge1xuICogICBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgZW1haWxMaW5rKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gZW1haWxMaW5rIC0gVGhlIGxpbmsgc2VudCB0byB0aGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspIHtcbiAgICBpZiAoYXBwLl9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoTW9kdWxhciA9IHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xuICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsV2l0aExpbmsoZW1haWwsIGVtYWlsTGluayB8fCBfZ2V0Q3VycmVudFVybCgpKTtcbiAgICAvLyBDaGVjayBpZiB0aGUgdGVuYW50IElEIGluIHRoZSBlbWFpbCBsaW5rIG1hdGNoZXMgdGhlIHRlbmFudCBJRCBvbiBBdXRoXG4gICAgLy8gaW5zdGFuY2UuXG4gICAgX2Fzc2VydChjcmVkZW50aWFsLl90ZW5hbnRJZCA9PT0gKGF1dGhNb2R1bGFyLnRlbmFudElkIHx8IG51bGwpLCBhdXRoTW9kdWxhciwgXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqLyk7XG4gICAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGhNb2R1bGFyLCBjcmVkZW50aWFsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUF1dGhVcmkoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpjcmVhdGVBdXRoVXJpXCIgLyogRW5kcG9pbnQuQ1JFQVRFX0FVVEhfVVJJICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IG9mIHBvc3NpYmxlIHNpZ24gaW4gbWV0aG9kcyBmb3IgdGhlIGdpdmVuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHJldHVybnMgYW5cbiAqIGVtcHR5IGxpc3Qgd2hlblxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxuICogaXMgZW5hYmxlZCwgaXJyZXNwZWN0aXZlIG9mIHRoZSBudW1iZXIgb2YgYXV0aGVudGljYXRpb24gbWV0aG9kcyBhdmFpbGFibGUgZm9yIHRoZSBnaXZlbiBlbWFpbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyB1c2VmdWwgdG8gZGlmZmVyZW50aWF0ZSBtZXRob2RzIG9mIHNpZ24taW4gZm9yIHRoZSBzYW1lIHByb3ZpZGVyLCBlZy5cbiAqIHtAbGluayBFbWFpbEF1dGhQcm92aWRlcn0gd2hpY2ggaGFzIDIgbWV0aG9kcyBvZiBzaWduLWluLFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQgYW5kXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9MSU5LLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBEZXByZWNhdGVkLiBNaWdyYXRpbmcgb2ZmIG9mIHRoaXMgbWV0aG9kIGlzIHJlY29tbWVuZGVkIGFzIGEgc2VjdXJpdHkgYmVzdC1wcmFjdGljZS5cbiAqIExlYXJuIG1vcmUgaW4gdGhlIElkZW50aXR5IFBsYXRmb3JtIGRvY3VtZW50YXRpb24gZm9yXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259LlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbChhdXRoLCBlbWFpbCkge1xuICAgIC8vIGNyZWF0ZUF1dGhVcmkgcmV0dXJucyBhbiBlcnJvciBpZiBjb250aW51ZSBVUkkgaXMgbm90IGh0dHAgb3IgaHR0cHMuXG4gICAgLy8gRm9yIGVudmlyb25tZW50cyBsaWtlIENvcmRvdmEsIENocm9tZSBleHRlbnNpb25zLCBuYXRpdmUgZnJhbWV3b3JrcywgZmlsZVxuICAgIC8vIHN5c3RlbXMsIGV0YywgdXNlIGh0dHA6Ly9sb2NhbGhvc3QgYXMgY29udGludWUgVVJMLlxuICAgIGNvbnN0IGNvbnRpbnVlVXJpID0gX2lzSHR0cE9ySHR0cHMoKSA/IF9nZXRDdXJyZW50VXJsKCkgOiAnaHR0cDovL2xvY2FsaG9zdCc7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgaWRlbnRpZmllcjogZW1haWwsXG4gICAgICAgIGNvbnRpbnVlVXJpXG4gICAgfTtcbiAgICBjb25zdCB7IHNpZ25pbk1ldGhvZHMgfSA9IGF3YWl0IGNyZWF0ZUF1dGhVcmkodXRpbC5nZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHJlcXVlc3QpO1xuICAgIHJldHVybiBzaWduaW5NZXRob2RzIHx8IFtdO1xufVxuLyoqXG4gKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byBhIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBpcyBjb21wbGV0ZWQgYnkgY2FsbGluZyB7QGxpbmsgYXBwbHlBY3Rpb25Db2RlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24odXNlciwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdGhlIHVzZXIuXG4gKiBhd2FpdCBhcHBseUFjdGlvbkNvZGUoYXV0aCwgY29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbih1c2VyLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiVkVSSUZZX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfRU1BSUwgKi8sXG4gICAgICAgIGlkVG9rZW5cbiAgICB9O1xuICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAgICB9XG4gICAgY29uc3QgeyBlbWFpbCB9ID0gYXdhaXQgc2VuZEVtYWlsVmVyaWZpY2F0aW9uJDEodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QpO1xuICAgIGlmIChlbWFpbCAhPT0gdXNlci5lbWFpbCkge1xuICAgICAgICBhd2FpdCB1c2VyLnJlbG9hZCgpO1xuICAgIH1cbn1cbi8qKlxuICogU2VuZHMgYSB2ZXJpZmljYXRpb24gZW1haWwgdG8gYSBuZXcgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHVzZXIncyBlbWFpbCB3aWxsIGJlIHVwZGF0ZWQgdG8gdGhlIG5ldyBvbmUgYWZ0ZXIgYmVpbmcgdmVyaWZpZWQuXG4gKlxuICogSWYgeW91IGhhdmUgYSBjdXN0b20gZW1haWwgYWN0aW9uIGhhbmRsZXIsIHlvdSBjYW4gY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzIGJ5IGNhbGxpbmdcbiAqIHtAbGluayBhcHBseUFjdGlvbkNvZGV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhY3Rpb25Db2RlU2V0dGluZ3MgPSB7XG4gKiAgIHVybDogJ2h0dHBzOi8vd3d3LmV4YW1wbGUuY29tLz9lbWFpbD11c2VyQGV4YW1wbGUuY29tJyxcbiAqICAgaU9TOiB7XG4gKiAgICAgIGJ1bmRsZUlkOiAnY29tLmV4YW1wbGUuaW9zJ1xuICogICB9LFxuICogICBhbmRyb2lkOiB7XG4gKiAgICAgcGFja2FnZU5hbWU6ICdjb20uZXhhbXBsZS5hbmRyb2lkJyxcbiAqICAgICBpbnN0YWxsQXBwOiB0cnVlLFxuICogICAgIG1pbmltdW1WZXJzaW9uOiAnMTInXG4gKiAgIH0sXG4gKiAgIGhhbmRsZUNvZGVJbkFwcDogdHJ1ZVxuICogfTtcbiAqIGF3YWl0IHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsKHVzZXIsICduZXdlbWFpbEBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHRoZSB1c2VyLlxuICogYXdhaXQgYXBwbHlBY3Rpb25Db2RlKGF1dGgsIGNvZGUpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdFbWFpbCAtIFRoZSBuZXcgZW1haWwgYWRkcmVzcyB0byBiZSB2ZXJpZmllZCBiZWZvcmUgdXBkYXRlLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsKHVzZXIsIG5ld0VtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdXNlci5nZXRJZFRva2VuKCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiVkVSSUZZX0FORF9DSEFOR0VfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMICovLFxuICAgICAgICBpZFRva2VuLFxuICAgICAgICBuZXdFbWFpbFxuICAgIH07XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgICAgICBfc2V0QWN0aW9uQ29kZVNldHRpbmdzT25SZXF1ZXN0KHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIH1cbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhd2FpdCB2ZXJpZnlBbmRDaGFuZ2VFbWFpbCh1c2VySW50ZXJuYWwuYXV0aCwgcmVxdWVzdCk7XG4gICAgaWYgKGVtYWlsICE9PSB1c2VyLmVtYWlsKSB7XG4gICAgICAgIC8vIElmIHRoZSBsb2NhbCBjb3B5IG9mIHRoZSBlbWFpbCBvbiB1c2VyIGlzIG91dGRhdGVkLCByZWxvYWQgdGhlXG4gICAgICAgIC8vIHVzZXIuXG4gICAgICAgIGF3YWl0IHVzZXIucmVsb2FkKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUHJvZmlsZSQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6dXBkYXRlXCIgLyogRW5kcG9pbnQuU0VUX0FDQ09VTlRfSU5GTyAqLywgcmVxdWVzdCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVwZGF0ZXMgYSB1c2VyJ3MgcHJvZmlsZSBkYXRhLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gcHJvZmlsZSAtIFRoZSBwcm9maWxlJ3MgYGRpc3BsYXlOYW1lYCBhbmQgYHBob3RvVVJMYCB0byB1cGRhdGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVQcm9maWxlKHVzZXIsIHsgZGlzcGxheU5hbWUsIHBob3RvVVJMOiBwaG90b1VybCB9KSB7XG4gICAgaWYgKGRpc3BsYXlOYW1lID09PSB1bmRlZmluZWQgJiYgcGhvdG9VcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHByb2ZpbGVSZXF1ZXN0ID0ge1xuICAgICAgICBpZFRva2VuLFxuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgcGhvdG9VcmwsXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXJJbnRlcm5hbCwgdXBkYXRlUHJvZmlsZSQxKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm9maWxlUmVxdWVzdCkpO1xuICAgIHVzZXJJbnRlcm5hbC5kaXNwbGF5TmFtZSA9IHJlc3BvbnNlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgdXNlckludGVybmFsLnBob3RvVVJMID0gcmVzcG9uc2UucGhvdG9VcmwgfHwgbnVsbDtcbiAgICAvLyBVcGRhdGUgdGhlIHBhc3N3b3JkIHByb3ZpZGVyIGFzIHdlbGxcbiAgICBjb25zdCBwYXNzd29yZFByb3ZpZGVyID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maW5kKCh7IHByb3ZpZGVySWQgfSkgPT4gcHJvdmlkZXJJZCA9PT0gXCJwYXNzd29yZFwiIC8qIFByb3ZpZGVySWQuUEFTU1dPUkQgKi8pO1xuICAgIGlmIChwYXNzd29yZFByb3ZpZGVyKSB7XG4gICAgICAgIHBhc3N3b3JkUHJvdmlkZXIuZGlzcGxheU5hbWUgPSB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWU7XG4gICAgICAgIHBhc3N3b3JkUHJvdmlkZXIucGhvdG9VUkwgPSB1c2VySW50ZXJuYWwucGhvdG9VUkw7XG4gICAgfVxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogQW4gZW1haWwgd2lsbCBiZSBzZW50IHRvIHRoZSBvcmlnaW5hbCBlbWFpbCBhZGRyZXNzIChpZiBpdCB3YXMgc2V0KSB0aGF0IGFsbG93cyB0byByZXZva2UgdGhlXG4gKiBlbWFpbCBhZGRyZXNzIGNoYW5nZSwgaW4gb3JkZXIgdG8gcHJvdGVjdCB0aGVtIGZyb20gYWNjb3VudCBoaWphY2tpbmcuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiBhbnkge0BsaW5rIFVzZXJ9IHNpZ25lZCBpbiBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzXG4gKiBjcmVhdGVkIHdpdGggYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXG4gKiBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MuXG4gKlxuICogVGhyb3dzIFwiYXV0aC9vcGVyYXRpb24tbm90LWFsbG93ZWRcIiBlcnJvciB3aGVuXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XG4gKiBpcyBlbmFibGVkLlxuICogRGVwcmVjYXRlZCAtIFVzZSB7QGxpbmsgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWx9IGluc3RlYWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1cGRhdGVFbWFpbCh1c2VyLCBuZXdFbWFpbCkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGlmIChhcHAuX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodXNlckludGVybmFsLmF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodXNlckludGVybmFsLmF1dGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZUVtYWlsT3JQYXNzd29yZCh1c2VySW50ZXJuYWwsIG5ld0VtYWlsLCBudWxsKTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgdXNlcidzIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1cGRhdGVQYXNzd29yZCh1c2VyLCBuZXdQYXNzd29yZCkge1xuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQodXRpbC5nZXRNb2R1bGFySW5zdGFuY2UodXNlciksIG51bGwsIG5ld1Bhc3N3b3JkKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUVtYWlsT3JQYXNzd29yZCh1c2VyLCBlbWFpbCwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGlkVG9rZW4sXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfTtcbiAgICBpZiAoZW1haWwpIHtcbiAgICAgICAgcmVxdWVzdC5lbWFpbCA9IGVtYWlsO1xuICAgIH1cbiAgICBpZiAocGFzc3dvcmQpIHtcbiAgICAgICAgcmVxdWVzdC5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIHVwZGF0ZUVtYWlsUGFzc3dvcmQoYXV0aCwgcmVxdWVzdCkpO1xuICAgIGF3YWl0IHVzZXIuX3VwZGF0ZVRva2Vuc0lmTmVjZXNzYXJ5KHJlc3BvbnNlLCAvKiByZWxvYWQgKi8gdHJ1ZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFBhcnNlIHRoZSBgQWRkaXRpb25hbFVzZXJJbmZvYCBmcm9tIHRoZSBJRCB0b2tlbiByZXNwb25zZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIF9mcm9tSWRUb2tlblJlc3BvbnNlKGlkVG9rZW5SZXNwb25zZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFpZFRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgcHJvdmlkZXJJZCB9ID0gaWRUb2tlblJlc3BvbnNlO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBpZFRva2VuUmVzcG9uc2UucmF3VXNlckluZm9cbiAgICAgICAgPyBKU09OLnBhcnNlKGlkVG9rZW5SZXNwb25zZS5yYXdVc2VySW5mbylcbiAgICAgICAgOiB7fTtcbiAgICBjb25zdCBpc05ld1VzZXIgPSBpZFRva2VuUmVzcG9uc2UuaXNOZXdVc2VyIHx8XG4gICAgICAgIGlkVG9rZW5SZXNwb25zZS5raW5kID09PSBcImlkZW50aXR5dG9vbGtpdCNTaWdudXBOZXdVc2VyUmVzcG9uc2VcIiAvKiBJZFRva2VuUmVzcG9uc2VLaW5kLlNpZ251cE5ld1VzZXIgKi87XG4gICAgaWYgKCFwcm92aWRlcklkICYmIChpZFRva2VuUmVzcG9uc2UgPT09IG51bGwgfHwgaWRUb2tlblJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZFRva2VuUmVzcG9uc2UuaWRUb2tlbikpIHtcbiAgICAgICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSAoX2IgPSAoX2EgPSBfcGFyc2VUb2tlbihpZFRva2VuUmVzcG9uc2UuaWRUb2tlbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maXJlYmFzZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWydzaWduX2luX3Byb3ZpZGVyJ107XG4gICAgICAgIGlmIChzaWduSW5Qcm92aWRlcikge1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQcm92aWRlcklkID0gc2lnbkluUHJvdmlkZXIgIT09IFwiYW5vbnltb3VzXCIgLyogUHJvdmlkZXJJZC5BTk9OWU1PVVMgKi8gJiZcbiAgICAgICAgICAgICAgICBzaWduSW5Qcm92aWRlciAhPT0gXCJjdXN0b21cIiAvKiBQcm92aWRlcklkLkNVU1RPTSAqL1xuICAgICAgICAgICAgICAgID8gc2lnbkluUHJvdmlkZXJcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAvLyBVc2VzIGdlbmVyaWMgY2xhc3MgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBsZWdhY3kgU0RLLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgZmlsdGVyZWRQcm92aWRlcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXByb3ZpZGVySWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN3aXRjaCAocHJvdmlkZXJJZCkge1xuICAgICAgICBjYXNlIFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmFjZWJvb2tBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICAgICAgY2FzZSBcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgICAgIGNhc2UgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdvb2dsZUFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xuICAgICAgICBjYXNlIFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlLCBpZFRva2VuUmVzcG9uc2Uuc2NyZWVuTmFtZSB8fCBudWxsKTtcbiAgICAgICAgY2FzZSBcImN1c3RvbVwiIC8qIFByb3ZpZGVySWQuQ1VTVE9NICovOlxuICAgICAgICBjYXNlIFwiYW5vbnltb3VzXCIgLyogUHJvdmlkZXJJZC5BTk9OWU1PVVMgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBudWxsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUpO1xuICAgIH1cbn1cbmNsYXNzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSA9IHt9KSB7XG4gICAgICAgIHRoaXMuaXNOZXdVc2VyID0gaXNOZXdVc2VyO1xuICAgICAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xuICAgIH1cbn1cbmNsYXNzIEZlZGVyYXRlZEFkZGl0aW9uYWxVc2VySW5mb1dpdGhVc2VybmFtZSBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSwgdXNlcm5hbWUpIHtcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXJuYW1lO1xuICAgIH1cbn1cbmNsYXNzIEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJmYWNlYm9vay5jb21cIiAvKiBQcm92aWRlcklkLkZBQ0VCT09LICovLCBwcm9maWxlKTtcbiAgICB9XG59XG5jbGFzcyBHaXRodWJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovLCBwcm9maWxlLCB0eXBlb2YgKHByb2ZpbGUgPT09IG51bGwgfHwgcHJvZmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZmlsZS5sb2dpbikgPT09ICdzdHJpbmcnID8gcHJvZmlsZSA9PT0gbnVsbCB8fCBwcm9maWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9maWxlLmxvZ2luIDogbnVsbCk7XG4gICAgfVxufVxuY2xhc3MgR29vZ2xlQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyB7XG4gICAgY29uc3RydWN0b3IoaXNOZXdVc2VyLCBwcm9maWxlKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgXCJnb29nbGUuY29tXCIgLyogUHJvdmlkZXJJZC5HT09HTEUgKi8sIHByb2ZpbGUpO1xuICAgIH1cbn1cbmNsYXNzIFR3aXR0ZXJBZGRpdGlvbmFsVXNlckluZm8gZXh0ZW5kcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSwgc2NyZWVuTmFtZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi8sIHByb2ZpbGUsIHNjcmVlbk5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgcHJvdmlkZXIgc3BlY2lmaWMge0BsaW5rIEFkZGl0aW9uYWxVc2VySW5mb30gZm9yIHRoZSBnaXZlbiBjcmVkZW50aWFsLlxuICpcbiAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRBZGRpdGlvbmFsVXNlckluZm8odXNlckNyZWRlbnRpYWwpIHtcbiAgICBjb25zdCB7IHVzZXIsIF90b2tlblJlc3BvbnNlIH0gPSB1c2VyQ3JlZGVudGlhbDtcbiAgICBpZiAodXNlci5pc0Fub255bW91cyAmJiAhX3Rva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgc2lnbkluQW5vbnltb3VzbHkoKSBnZXRzIGNhbGxlZCB0d2ljZS5cbiAgICAgICAgLy8gTm8gbmV0d29yayBjYWxsIGlzIG1hZGUgc28gdGhlcmUncyBub3RoaW5nIHRvIGFjdHVhbGx5IGZpbGwgdGhpcyBpblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogbnVsbCxcbiAgICAgICAgICAgIGlzTmV3VXNlcjogZmFsc2UsXG4gICAgICAgICAgICBwcm9maWxlOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfZnJvbUlkVG9rZW5SZXNwb25zZShfdG9rZW5SZXNwb25zZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBOb24tb3B0aW9uYWwgYXV0aCBtZXRob2RzLlxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB0eXBlIG9mIHBlcnNpc3RlbmNlIG9uIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50bHkgc2F2ZWRcbiAqIGBBdXRoYCBzZXNzaW9uIGFuZCBhcHBsaWVzIHRoaXMgdHlwZSBvZiBwZXJzaXN0ZW5jZSBmb3IgZnV0dXJlIHNpZ24taW4gcmVxdWVzdHMsIGluY2x1ZGluZ1xuICogc2lnbi1pbiB3aXRoIHJlZGlyZWN0IHJlcXVlc3RzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG1ha2VzIGl0IGVhc3kgZm9yIGEgdXNlciBzaWduaW5nIGluIHRvIHNwZWNpZnkgd2hldGhlciB0aGVpciBzZXNzaW9uIHNob3VsZCBiZVxuICogcmVtZW1iZXJlZCBvciBub3QuIEl0IGFsc28gbWFrZXMgaXQgZWFzaWVyIHRvIG5ldmVyIHBlcnNpc3QgdGhlIGBBdXRoYCBzdGF0ZSBmb3IgYXBwbGljYXRpb25zXG4gKiB0aGF0IGFyZSBzaGFyZWQgYnkgb3RoZXIgdXNlcnMgb3IgaGF2ZSBzZW5zaXRpdmUgZGF0YS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudCBvciB3aXRoIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogc2V0UGVyc2lzdGVuY2UoYXV0aCwgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGVyc2lzdGVuY2UgLSBUaGUge0BsaW5rIFBlcnNpc3RlbmNlfSB0byB1c2UuXG4gKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHBlcnNpc3RlbmNlIGNoYW5nZSBoYXMgY29tcGxldGVkXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRQZXJzaXN0ZW5jZShhdXRoLCBwZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybiB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5zZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSk7XG59XG4vKipcbiAqIExvYWRzIHRoZSByZUNBUFRDSEEgY29uZmlndXJhdGlvbiBpbnRvIHRoZSBgQXV0aGAgaW5zdGFuY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgd2lsbCBsb2FkIHRoZSByZUNBUFRDSEEgY29uZmlnLCB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVDQVBUQ0hBXG4gKiB2ZXJpZmljYXRpb24gZmxvdyBzaG91bGQgYmUgdHJpZ2dlcmVkIGZvciBlYWNoIGF1dGggcHJvdmlkZXIsIGludG8gdGhlXG4gKiBjdXJyZW50IEF1dGggc2Vzc2lvbi5cbiAqXG4gKiBJZiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKCkgaXMgbm90IGludm9rZWQsIHRoZSBhdXRoIGZsb3cgd2lsbCBhbHdheXMgc3RhcnRcbiAqIHdpdGhvdXQgcmVDQVBUQ0hBIHZlcmlmaWNhdGlvbi4gSWYgdGhlIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWQgdG8gcmVxdWlyZSByZUNBUFRDSEFcbiAqIHZlcmlmaWNhdGlvbiwgdGhlIFNESyB3aWxsIHRyYW5zcGFyZW50bHkgbG9hZCB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBhbmQgcmVzdGFydCB0aGVcbiAqIGF1dGggZmxvd3MuXG4gKlxuICogVGh1cywgYnkgY2FsbGluZyB0aGlzIG9wdGlvbmFsIG1ldGhvZCwgeW91IHdpbGwgcmVkdWNlIHRoZSBsYXRlbmN5IG9mIGZ1dHVyZSBhdXRoIGZsb3dzLlxuICogTG9hZGluZyB0aGUgcmVDQVBUQ0hBIGNvbmZpZyBlYXJseSB3aWxsIGFsc28gZW5oYW5jZSB0aGUgc2lnbmFsIGNvbGxlY3RlZCBieSByZUNBUFRDSEEuXG4gKlxuICogVGhpcyBtZXRob2QgZG9lcyBub3Qgd29yayBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpIHtcbiAgICByZXR1cm4gX2luaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGUgcGFzc3dvcmQgYWdhaW5zdCB0aGUgcGFzc3dvcmQgcG9saWN5IGNvbmZpZ3VyZWQgZm9yIHRoZSBwcm9qZWN0IG9yIHRlbmFudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogSWYgbm8gdGVuYW50IElEIGlzIHNldCBvbiB0aGUgYEF1dGhgIGluc3RhbmNlLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBwYXNzd29yZFxuICogcG9saWN5IGNvbmZpZ3VyZWQgZm9yIHRoZSBwcm9qZWN0LiBPdGhlcndpc2UsIHRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBwb2xpY3kgY29uZmlndXJlZFxuICogZm9yIHRoZSB0ZW5hbnQuIElmIGEgcGFzc3dvcmQgcG9saWN5IGhhcyBub3QgYmVlbiBjb25maWd1cmVkLCB0aGVuIHRoZSBkZWZhdWx0IHBvbGljeVxuICogY29uZmlndXJlZCBmb3IgYWxsIHByb2plY3RzIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBJZiBhbiBhdXRoIGZsb3cgZmFpbHMgYmVjYXVzZSBhIHN1Ym1pdHRlZCBwYXNzd29yZCBkb2VzIG5vdCBtZWV0IHRoZSBwYXNzd29yZCBwb2xpY3lcbiAqIHJlcXVpcmVtZW50cyBhbmQgdGhpcyBtZXRob2QgaGFzIHByZXZpb3VzbHkgYmVlbiBjYWxsZWQsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlXG4gKiBtb3N0IHJlY2VudCBwb2xpY3kgYXZhaWxhYmxlIHdoZW4gY2FsbGVkIGFnYWluLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YWxpZGF0ZVBhc3N3b3JkKGF1dGgsICdzb21lLXBhc3N3b3JkJyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aCBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byB2YWxpZGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgcmV0dXJuIGF1dGhJbnRlcm5hbC52YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKTtcbn1cbi8qKlxuICogQWRkcyBhbiBvYnNlcnZlciBmb3IgY2hhbmdlcyB0byB0aGUgc2lnbmVkLWluIHVzZXIncyBJRCB0b2tlbi5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpbmNsdWRlcyBzaWduLWluLCBzaWduLW91dCwgYW5kIHRva2VuIHJlZnJlc2ggZXZlbnRzLlxuICogVGhpcyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB1cG9uIElEIHRva2VuIGV4cGlyYXRpb24uIFVzZSB7QGxpbmsgVXNlci5nZXRJZFRva2VufSB0byByZWZyZXNoIHRoZSBJRCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xuICogb24gc2lnbmluZyBpbi9vdXQgY2FuIGJlIGNhdWdodCBpbiBwcm9taXNlcyByZXR1cm5lZCBmcm9tXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG9uSWRUb2tlbkNoYW5nZWQoYXV0aCwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICByZXR1cm4gdXRpbC5nZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkub25JZFRva2VuQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG59XG4vKipcbiAqIEFkZHMgYSBibG9ja2luZyBjYWxsYmFjayB0aGF0IHJ1bnMgYmVmb3JlIGFuIGF1dGggc3RhdGUgY2hhbmdlXG4gKiBzZXRzIGEgbmV3IHVzZXIuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGJlZm9yZSBuZXcgdXNlciB2YWx1ZSBpcyBzZXQuXG4gKiAgIElmIHRoaXMgdGhyb3dzLCBpdCBibG9ja3MgdGhlIHVzZXIgZnJvbSBiZWluZyBzZXQuXG4gKiBAcGFyYW0gb25BYm9ydCAtIGNhbGxiYWNrIHRyaWdnZXJlZCBpZiBhIGxhdGVyIGBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKClgXG4gKiAgIGNhbGxiYWNrIHRocm93cywgYWxsb3dpbmcgeW91IHRvIHVuZG8gYW55IHNpZGUgZWZmZWN0cy5cbiAqL1xuZnVuY3Rpb24gYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChhdXRoLCBjYWxsYmFjaywgb25BYm9ydCkge1xuICAgIHJldHVybiB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5iZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKGNhbGxiYWNrLCBvbkFib3J0KTtcbn1cbi8qKlxuICogQWRkcyBhbiBvYnNlcnZlciBmb3IgY2hhbmdlcyB0byB0aGUgdXNlcidzIHNpZ24taW4gc3RhdGUuXG4gKlxuICogQHJlbWFya3NcbiAqIFRvIGtlZXAgdGhlIG9sZCBiZWhhdmlvciwgc2VlIHtAbGluayBvbklkVG9rZW5DaGFuZ2VkfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gbmV4dE9yT2JzZXJ2ZXIgLSBjYWxsYmFjayB0cmlnZ2VyZWQgb24gY2hhbmdlLlxuICogQHBhcmFtIGVycm9yIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuIEVycm9yc1xuICogb24gc2lnbmluZyBpbi9vdXQgY2FuIGJlIGNhdWdodCBpbiBwcm9taXNlcyByZXR1cm5lZCBmcm9tXG4gKiBzaWduLWluL3NpZ24tb3V0IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBjb21wbGV0ZWQgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG9uQXV0aFN0YXRlQ2hhbmdlZChhdXRoLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgIHJldHVybiB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS5vbkF1dGhTdGF0ZUNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IGxhbmd1YWdlIHRvIHRoZSBkZWZhdWx0IGRldmljZS9icm93c2VyIHByZWZlcmVuY2UuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlRGV2aWNlTGFuZ3VhZ2UoYXV0aCkge1xuICAgIHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVzZURldmljZUxhbmd1YWdlKCk7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNldHMgdGhlIHByb3ZpZGVkIHVzZXIgYXMge0BsaW5rIEF1dGguY3VycmVudFVzZXJ9IG9uIHRoZVxuICoge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBIG5ldyBpbnN0YW5jZSBjb3B5IG9mIHRoZSB1c2VyIHByb3ZpZGVkIHdpbGwgYmUgbWFkZSBhbmQgc2V0IGFzIGN1cnJlbnRVc2VyLlxuICpcbiAqIFRoaXMgd2lsbCB0cmlnZ2VyIHtAbGluayBvbkF1dGhTdGF0ZUNoYW5nZWR9IGFuZCB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0gbGlzdGVuZXJzXG4gKiBsaWtlIG90aGVyIHNpZ24gaW4gbWV0aG9kcy5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIGZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIHVzZXIgdG8gYmUgdXBkYXRlZCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IEZpcmViYXNlXG4gKiBwcm9qZWN0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB1c2VyIC0gVGhlIG5ldyB7QGxpbmsgVXNlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50VXNlcihhdXRoLCB1c2VyKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVwZGF0ZUN1cnJlbnRVc2VyKHVzZXIpO1xufVxuLyoqXG4gKiBTaWducyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2lnbk91dChhdXRoKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnNpZ25PdXQoKTtcbn1cbi8qKlxuICogUmV2b2tlcyB0aGUgZ2l2ZW4gYWNjZXNzIHRva2VuLiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB0b2tlbiAtIFRoZSBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW4uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZXZva2VBY2Nlc3NUb2tlbihhdXRoLCB0b2tlbikge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICByZXR1cm4gYXV0aEludGVybmFsLnJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKTtcbn1cbi8qKlxuICogRGVsZXRlcyBhbmQgc2lnbnMgb3V0IHRoZSB1c2VyLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eS1zZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseVxuICogc2lnbmVkIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXIodXNlcikge1xuICAgIHJldHVybiB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5kZWxldGUoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNyZWRlbnRpYWwsIHVzZXIpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsID0gY3JlZGVudGlhbDtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tSWR0b2tlbihpZFRva2VuLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovLCBpZFRva2VuLCB1c2VyKTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tTWZhUGVuZGluZ0NyZWRlbnRpYWwobWZhUGVuZGluZ0NyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFwic2lnbmluXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOICovLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy50eXBlID09PSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovXG4gICAgICAgICAgICA/ICdpZFRva2VuJ1xuICAgICAgICAgICAgOiAncGVuZGluZ0NyZWRlbnRpYWwnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXVsdGlGYWN0b3JTZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgW2tleV06IHRoaXMuY3JlZGVudGlhbFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04ob2JqKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubXVsdGlGYWN0b3JTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlbmRpbmdDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChvYmoubXVsdGlGYWN0b3JTZXNzaW9uLnBlbmRpbmdDcmVkZW50aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9iai5tdWx0aUZhY3RvclNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKG9iai5tdWx0aUZhY3RvclNlc3Npb24uaWRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb24sIGhpbnRzLCBzaWduSW5SZXNvbHZlcikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmhpbnRzID0gaGludHM7XG4gICAgICAgIHRoaXMuc2lnbkluUmVzb2x2ZXIgPSBzaWduSW5SZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVycm9yKGF1dGhFeHRlcm4sIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGhpbnRzID0gKHNlcnZlclJlc3BvbnNlLm1mYUluZm8gfHwgW10pLm1hcChlbnJvbGxtZW50ID0+IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KSk7XG4gICAgICAgIF9hc3NlcnQoc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbCk7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwoc2Vzc2lvbiwgaGludHMsIGFzeW5jIChhc3NlcnRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1mYVJlc3BvbnNlID0gYXdhaXQgYXNzZXJ0aW9uLl9wcm9jZXNzKGF1dGgsIHNlc3Npb24pO1xuICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSB1bm5lZWRlZCBmaWVsZHMgZnJvbSB0aGUgb2xkIGxvZ2luIHJlc3BvbnNlXG4gICAgICAgICAgICBkZWxldGUgc2VydmVyUmVzcG9uc2UubWZhSW5mbztcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbDtcbiAgICAgICAgICAgIC8vIFVzZSBpbiB0aGUgbmV3IHRva2VuICYgcmVmcmVzaCB0b2tlbiBpbiB0aGUgb2xkIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBpZFRva2VuUmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcnZlclJlc3BvbnNlKSwgeyBpZFRva2VuOiBtZmFSZXNwb25zZS5pZFRva2VuLCByZWZyZXNoVG9rZW46IG1mYVJlc3BvbnNlLnJlZnJlc2hUb2tlbiB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBjb2xsYXBzZSB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbiBhbmQgaGF2ZSBpdCBzdXBwb3J0IHRoZSBTSUdOX0lOIGNhc2VcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyb3Iub3BlcmF0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi86XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGVycm9yLm9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqLzpcbiAgICAgICAgICAgICAgICAgICAgX2Fzc2VydChlcnJvci51c2VyLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbihlcnJvci51c2VyLCBlcnJvci5vcGVyYXRpb25UeXBlLCBpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVTaWduSW4oYXNzZXJ0aW9uRXh0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkluUmVzb2x2ZXIoYXNzZXJ0aW9uKTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVzIGEge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXJ9IHN1aXRhYmxlIGZvciBjb21wbGV0aW9uIG9mIGFcbiAqIG11bHRpLWZhY3RvciBmbG93LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JFcnJvcn0gcmFpc2VkIGR1cmluZyBhIHNpZ24taW4sIG9yXG4gKiByZWF1dGhlbnRpY2F0aW9uIG9wZXJhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIoYXV0aCwgZXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSB1dGlsLmdldE1vZHVsYXJJbnN0YW5jZShhdXRoKTtcbiAgICBjb25zdCBlcnJvckludGVybmFsID0gZXJyb3I7XG4gICAgX2Fzc2VydChlcnJvci5jdXN0b21EYXRhLm9wZXJhdGlvblR5cGUsIGF1dGhNb2R1bGFyLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgX2Fzc2VydCgoX2EgPSBlcnJvckludGVybmFsLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGhNb2R1bGFyLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgcmV0dXJuIE11bHRpRmFjdG9yUmVzb2x2ZXJJbXBsLl9mcm9tRXJyb3IoYXV0aE1vZHVsYXIsIGVycm9ySW50ZXJuYWwpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gc3RhcnRFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpzdGFydFwiIC8qIEVuZHBvaW50LlNUQVJUX01GQV9FTlJPTExNRU5UICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuZnVuY3Rpb24gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDpmaW5hbGl6ZVwiIC8qIEVuZHBvaW50LkZJTkFMSVpFX01GQV9FTlJPTExNRU5UICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuZnVuY3Rpb24gd2l0aGRyYXdNZmEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFFbnJvbGxtZW50OndpdGhkcmF3XCIgLyogRW5kcG9pbnQuV0lUSERSQVdfTUZBICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG5jbGFzcyBNdWx0aUZhY3RvclVzZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih1c2VyKSB7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gW107XG4gICAgICAgIHVzZXIuX29uUmVsb2FkKHVzZXJJbmZvID0+IHtcbiAgICAgICAgICAgIGlmICh1c2VySW5mby5tZmFJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnJvbGxlZEZhY3RvcnMgPSB1c2VySW5mby5tZmFJbmZvLm1hcChlbnJvbGxtZW50ID0+IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZSh1c2VyLmF1dGgsIGVucm9sbG1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVVzZXIodXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yVXNlckltcGwodXNlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiBNdWx0aUZhY3RvclNlc3Npb25JbXBsLl9mcm9tSWR0b2tlbihhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbigpLCB0aGlzLnVzZXIpO1xuICAgIH1cbiAgICBhc3luYyBlbnJvbGwoYXNzZXJ0aW9uRXh0ZXJuLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICBjb25zdCBhc3NlcnRpb24gPSBhc3NlcnRpb25FeHRlcm47XG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSAoYXdhaXQgdGhpcy5nZXRTZXNzaW9uKCkpO1xuICAgICAgICBjb25zdCBmaW5hbGl6ZU1mYVJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCBhc3NlcnRpb24uX3Byb2Nlc3ModGhpcy51c2VyLmF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSk7XG4gICAgICAgIC8vIE5ldyB0b2tlbnMgd2lsbCBiZSBpc3N1ZWQgYWZ0ZXIgZW5yb2xsbWVudCBvZiB0aGUgbmV3IHNlY29uZCBmYWN0b3JzLlxuICAgICAgICAvLyBUaGV5IG5lZWQgdG8gYmUgdXBkYXRlZCBvbiB0aGUgdXNlci5cbiAgICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShmaW5hbGl6ZU1mYVJlc3BvbnNlKTtcbiAgICAgICAgLy8gVGhlIHVzZXIgbmVlZHMgdG8gYmUgcmVsb2FkZWQgdG8gZ2V0IHRoZSBuZXcgbXVsdGktZmFjdG9yIGluZm9ybWF0aW9uXG4gICAgICAgIC8vIGZyb20gc2VydmVyLiBVU0VSX1JFTE9BREVEIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIGFuZCBgZW5yb2xsZWRGYWN0b3JzYFxuICAgICAgICAvLyB3aWxsIGJlIHVwZGF0ZWQuXG4gICAgICAgIHJldHVybiB0aGlzLnVzZXIucmVsb2FkKCk7XG4gICAgfVxuICAgIGFzeW5jIHVuZW5yb2xsKGluZm9PclVpZCkge1xuICAgICAgICBjb25zdCBtZmFFbnJvbGxtZW50SWQgPSB0eXBlb2YgaW5mb09yVWlkID09PSAnc3RyaW5nJyA/IGluZm9PclVpZCA6IGluZm9PclVpZC51aWQ7XG4gICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlblJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcy51c2VyLCB3aXRoZHJhd01mYSh0aGlzLnVzZXIuYXV0aCwge1xuICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgbWZhRW5yb2xsbWVudElkXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlY29uZCBmYWN0b3IgZnJvbSB0aGUgdXNlcidzIGxpc3QuXG4gICAgICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IHRoaXMuZW5yb2xsZWRGYWN0b3JzLmZpbHRlcigoeyB1aWQgfSkgPT4gdWlkICE9PSBtZmFFbnJvbGxtZW50SWQpO1xuICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGJhY2tlbmQgZGVjaWRlZCB0byByZXZva2UgdGhlIHVzZXIncyBzZXNzaW9uLFxuICAgICAgICAgICAgLy8gdGhlIHRva2VuUmVzcG9uc2UgbWF5IGJlIGVtcHR5LiBJZiB0aGUgdG9rZW5zIHdlcmUgbm90IHVwZGF0ZWQgKGFuZCB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgbm93IGludmFsaWQpLCByZWxvYWRpbmcgdGhlIHVzZXIgd2lsbCBkaXNjb3ZlciB0aGlzIGFuZCBpbnZhbGlkYXRlXG4gICAgICAgICAgICAvLyB0aGUgdXNlcidzIHN0YXRlIGFjY29yZGluZ2x5LlxuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgbXVsdGlGYWN0b3JVc2VyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGUge0BsaW5rIE11bHRpRmFjdG9yVXNlcn0gY29ycmVzcG9uZGluZyB0byB0aGUgdXNlci5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyB1c2VkIHRvIGFjY2VzcyBhbGwgbXVsdGktZmFjdG9yIHByb3BlcnRpZXMgYW5kIG9wZXJhdGlvbnMgcmVsYXRlZCB0byB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbXVsdGlGYWN0b3IodXNlcikge1xuICAgIGNvbnN0IHVzZXJNb2R1bGFyID0gdXRpbC5nZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgaWYgKCFtdWx0aUZhY3RvclVzZXJDYWNoZS5oYXModXNlck1vZHVsYXIpKSB7XG4gICAgICAgIG11bHRpRmFjdG9yVXNlckNhY2hlLnNldCh1c2VyTW9kdWxhciwgTXVsdGlGYWN0b3JVc2VySW1wbC5fZnJvbVVzZXIodXNlck1vZHVsYXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG11bHRpRmFjdG9yVXNlckNhY2hlLmdldCh1c2VyTW9kdWxhcik7XG59XG5cbnZhciBuYW1lID0gXCJAZmlyZWJhc2UvYXV0aFwiO1xudmFyIHZlcnNpb24gPSBcIjEuOC4xXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBBdXRoSW50ZXJvcCB7XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXRVaWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuYXV0aC5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICAgIGlmICghdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuYXV0aC5jdXJyZW50VXNlci5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG4gICAgICAgIHJldHVybiB7IGFjY2Vzc1Rva2VuIH07XG4gICAgfVxuICAgIGFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuaGFzKGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5hdXRoLm9uSWRUb2tlbkNoYW5nZWQodXNlciA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcigodXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLnN0c1Rva2VuTWFuYWdlci5hY2Nlc3NUb2tlbikgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdW5zdWJzY3JpYmUpO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICB9XG4gICAgcmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgfVxuICAgIGFzc2VydEF1dGhDb25maWd1cmVkKCkge1xuICAgICAgICBfYXNzZXJ0KHRoaXMuYXV0aC5faW5pdGlhbGl6YXRpb25Qcm9taXNlLCBcImRlcGVuZGVudC1zZGstaW5pdGlhbGl6ZWQtYmVmb3JlLWF1dGhcIiAvKiBBdXRoRXJyb3JDb2RlLkRFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSCAqLyk7XG4gICAgfVxuICAgIHVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVybmFsTGlzdGVuZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGguX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hdXRoLl9zdG9wUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmVyc2lvbkZvclBsYXRmb3JtKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgc3dpdGNoIChjbGllbnRQbGF0Zm9ybSkge1xuICAgICAgICBjYXNlIFwiTm9kZVwiIC8qIENsaWVudFBsYXRmb3JtLk5PREUgKi86XG4gICAgICAgICAgICByZXR1cm4gJ25vZGUnO1xuICAgICAgICBjYXNlIFwiUmVhY3ROYXRpdmVcIiAvKiBDbGllbnRQbGF0Zm9ybS5SRUFDVF9OQVRJVkUgKi86XG4gICAgICAgICAgICByZXR1cm4gJ3JuJztcbiAgICAgICAgY2FzZSBcIldvcmtlclwiIC8qIENsaWVudFBsYXRmb3JtLldPUktFUiAqLzpcbiAgICAgICAgICAgIHJldHVybiAnd2Vid29ya2VyJztcbiAgICAgICAgY2FzZSBcIkNvcmRvdmFcIiAvKiBDbGllbnRQbGF0Zm9ybS5DT1JET1ZBICovOlxuICAgICAgICAgICAgcmV0dXJuICdjb3Jkb3ZhJztcbiAgICAgICAgY2FzZSBcIldlYkV4dGVuc2lvblwiIC8qIENsaWVudFBsYXRmb3JtLldFQl9FWFRFTlNJT04gKi86XG4gICAgICAgICAgICByZXR1cm4gJ3dlYi1leHRlbnNpb24nO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiByZWdpc3RlckF1dGgoY2xpZW50UGxhdGZvcm0pIHtcbiAgICBhcHAuX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBjb21wb25lbnQuQ29tcG9uZW50KFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8sIChjb250YWluZXIsIHsgb3B0aW9uczogZGVwcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignaGVhcnRiZWF0Jyk7XG4gICAgICAgIGNvbnN0IGFwcENoZWNrU2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcbiAgICAgICAgY29uc3QgeyBhcGlLZXksIGF1dGhEb21haW4gfSA9IGFwcC5vcHRpb25zO1xuICAgICAgICBfYXNzZXJ0KGFwaUtleSAmJiAhYXBpS2V5LmluY2x1ZGVzKCc6JyksIFwiaW52YWxpZC1hcGkta2V5XCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQSV9LRVkgKi8sIHsgYXBwTmFtZTogYXBwLm5hbWUgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgIGF1dGhEb21haW4sXG4gICAgICAgICAgICBjbGllbnRQbGF0Zm9ybSxcbiAgICAgICAgICAgIGFwaUhvc3Q6IFwiaWRlbnRpdHl0b29sa2l0Lmdvb2dsZWFwaXMuY29tXCIgLyogRGVmYXVsdENvbmZpZy5BUElfSE9TVCAqLyxcbiAgICAgICAgICAgIHRva2VuQXBpSG9zdDogXCJzZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbVwiIC8qIERlZmF1bHRDb25maWcuVE9LRU5fQVBJX0hPU1QgKi8sXG4gICAgICAgICAgICBhcGlTY2hlbWU6IFwiaHR0cHNcIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9TQ0hFTUUgKi8sXG4gICAgICAgICAgICBzZGtDbGllbnRWZXJzaW9uOiBfZ2V0Q2xpZW50VmVyc2lvbihjbGllbnRQbGF0Zm9ybSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXV0aEluc3RhbmNlID0gbmV3IEF1dGhJbXBsKGFwcCwgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciwgY29uZmlnKTtcbiAgICAgICAgX2luaXRpYWxpemVBdXRoSW5zdGFuY2UoYXV0aEluc3RhbmNlLCBkZXBzKTtcbiAgICAgICAgcmV0dXJuIGF1dGhJbnN0YW5jZTtcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKVxuICAgICAgICAvKipcbiAgICAgICAgICogQXV0aCBjYW4gb25seSBiZSBpbml0aWFsaXplZCBieSBleHBsaWNpdGx5IGNhbGxpbmcgZ2V0QXV0aCgpIG9yIGluaXRpYWxpemVBdXRoKClcbiAgICAgICAgICogRm9yIHdoeSB3ZSBkbyB0aGlzLCBTZWUgZ28vZmlyZWJhc2UtbmV4dC1hdXRoLWluaXRcbiAgICAgICAgICovXG4gICAgICAgIC5zZXRJbnN0YW50aWF0aW9uTW9kZShcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWNhdXNlIGFsbCBmaXJlYmFzZSBwcm9kdWN0cyB0aGF0IGRlcGVuZCBvbiBhdXRoIGRlcGVuZCBvbiBhdXRoLWludGVybmFsIGRpcmVjdGx5LFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGluaXRpYWxpemUgYXV0aC1pbnRlcm5hbCBhZnRlciBhdXRoIGlzIGluaXRpYWxpemVkIHRvIG1ha2UgaXQgYXZhaWxhYmxlIHRvIG90aGVyIGZpcmViYXNlIHByb2R1Y3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgLnNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKChjb250YWluZXIsIF9pbnN0YW5jZUlkZW50aWZpZXIsIF9pbnN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBhdXRoSW50ZXJuYWxQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcihcImF1dGgtaW50ZXJuYWxcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIX0lOVEVSTkFMICovKTtcbiAgICAgICAgYXV0aEludGVybmFsUHJvdmlkZXIuaW5pdGlhbGl6ZSgpO1xuICAgIH0pKTtcbiAgICBhcHAuX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBjb21wb25lbnQuQ29tcG9uZW50KFwiYXV0aC1pbnRlcm5hbFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEhfSU5URVJOQUwgKi8sIGNvbnRhaW5lciA9PiB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoY29udGFpbmVyLmdldFByb3ZpZGVyKFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8pLmdldEltbWVkaWF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIChhdXRoID0+IG5ldyBBdXRoSW50ZXJvcChhdXRoKSkoYXV0aCk7XG4gICAgfSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKS5zZXRJbnN0YW50aWF0aW9uTW9kZShcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pKTtcbiAgICBhcHAucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkpO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTIwMTcsIGNqczIwMTcsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gICAgYXBwLnJlZ2lzdGVyVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCAnY2pzMjAxNycpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gSW5pdGlhbGl6ZSB0aGUgZmV0Y2ggcG9seWZpbGwsIHRoZSB0eXBlcyBhcmUgc2xpZ2h0bHkgb2ZmIHNvIGp1c3QgY2FzdCBhbmQgaG9wZSBmb3IgdGhlIGJlc3RcbkZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZShmZXRjaCwgSGVhZGVycywgUmVzcG9uc2UpO1xuLy8gRmlyc3QsIHdlIHNldCB1cCB0aGUgdmFyaW91cyBwbGF0Zm9ybS1zcGVjaWZpYyBmZWF0dXJlcyBmb3IgTm9kZSAocmVnaXN0ZXJcbi8vIHRoZSB2ZXJzaW9uIGFuZCBkZWNsYXJlIHRoZSBOb2RlIGdldEF1dGggZnVuY3Rpb24pXG5mdW5jdGlvbiBnZXRBdXRoKGFwcCQxID0gYXBwLmdldEFwcCgpKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhcHAuX2dldFByb3ZpZGVyKGFwcCQxLCAnYXV0aCcpO1xuICAgIGlmIChwcm92aWRlci5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCBhdXRoID0gaW5pdGlhbGl6ZUF1dGgoYXBwJDEpO1xuICAgIGNvbnN0IGF1dGhFbXVsYXRvckhvc3QgPSB1dGlsLmdldERlZmF1bHRFbXVsYXRvckhvc3QoJ2F1dGgnKTtcbiAgICBpZiAoYXV0aEVtdWxhdG9ySG9zdCkge1xuICAgICAgICBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIGBodHRwOi8vJHthdXRoRW11bGF0b3JIb3N0fWApO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aDtcbn1cbnJlZ2lzdGVyQXV0aChcIk5vZGVcIiAvKiBDbGllbnRQbGF0Zm9ybS5OT0RFICovKTtcbi8vIFRoZSByZXN0IG9mIHRoaXMgZmlsZSBjb250YWlucyBuby1vcHMgYW5kIGVycm9ycyBmb3IgYnJvd3Nlci1zcGVjaWZpY1xuLy8gbWV0aG9kcy4gV2Uga2VlcCB0aGUgYnJvd3NlciBhbmQgTm9kZSBlbnRyeSBwb2ludHMgdGhlIHNhbWUsIGJ1dCBmZWF0dXJlc1xuLy8gdGhhdCBvbmx5IHdvcmsgaW4gYnJvd3NlcnMgYXJlIHNldCB0byBlaXRoZXIgZG8gbm90aGluZyAoc2V0UGVyc2lzdGVuY2UpIG9yXG4vLyB0byByZWplY3Qgd2l0aCBhbiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgZXJyb3IuXG4vLyBUaGUgYmVsb3cgZXhwb3J0cyBhcmUgcHVsbGVkIGludG8gdGhlIG1haW4gZW50cnkgcG9pbnQgYnkgYSByb2xsdXAgYWxpYXNcbi8vIHBsdWdpbiAob3ZlcndyaXRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBpbXBvcnRzKS5cbi8qKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgKi9cbmNvbnN0IE5PVF9BVkFJTEFCTEVfRVJST1IgPSBfY3JlYXRlRXJyb3IoXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqLyk7XG4vKiogUmVqZWN0IHdpdGggYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXG5hc3luYyBmdW5jdGlvbiBmYWlsKCkge1xuICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG59XG4vKipcbiAqIEEgY2xhc3Mgd2hpY2ggd2lsbCB0aHJvdyB3aXRoXG4gKiBhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQgaWYgaW5zdGFudGlhdGVkXG4gKi9cbmNsYXNzIEZhaWxDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG4gICAgfVxufVxuY29uc3QgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xuY29uc3QgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XG5jb25zdCBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlID0gaW5NZW1vcnlQZXJzaXN0ZW5jZTtcbmNvbnN0IGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBOT1RfQVZBSUxBQkxFX0VSUk9SO1xuY29uc3QgUGhvbmVBdXRoUHJvdmlkZXIgPSBGYWlsQ2xhc3M7XG5jb25zdCBzaWduSW5XaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3QgbGlua1dpdGhQaG9uZU51bWJlciA9IGZhaWw7XG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciA9IGZhaWw7XG5jb25zdCB1cGRhdGVQaG9uZU51bWJlciA9IGZhaWw7XG5jb25zdCBzaWduSW5XaXRoUG9wdXAgPSBmYWlsO1xuY29uc3QgbGlua1dpdGhQb3B1cCA9IGZhaWw7XG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCA9IGZhaWw7XG5jb25zdCBzaWduSW5XaXRoUmVkaXJlY3QgPSBmYWlsO1xuY29uc3QgbGlua1dpdGhSZWRpcmVjdCA9IGZhaWw7XG5jb25zdCByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCA9IGZhaWw7XG5jb25zdCBnZXRSZWRpcmVjdFJlc3VsdCA9IGZhaWw7XG5jb25zdCBSZWNhcHRjaGFWZXJpZmllciA9IEZhaWxDbGFzcztcbmNsYXNzIFBob25lTXVsdGlGYWN0b3JHZW5lcmF0b3Ige1xuICAgIHN0YXRpYyBhc3NlcnRpb24oKSB7XG4gICAgICAgIHRocm93IE5PVF9BVkFJTEFCTEVfRVJST1I7XG4gICAgfVxufVxuLy8gU2V0IHBlcnNpc3RlbmNlIHNob3VsZCBuby1vcCBpbnN0ZWFkIG9mIGZhaWwuIENoYW5naW5nIHRoZSBwcm90b3R5cGUgd2lsbFxuLy8gbWFrZSBzdXJlIGJvdGggc2V0UGVyc2lzdGVuY2UoYXV0aCwgcGVyc2lzdGVuY2UpIGFuZFxuLy8gYXV0aC5zZXRQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZSkgYXJlIGNvdmVyZWQuXG5BdXRoSW1wbC5wcm90b3R5cGUuc2V0UGVyc2lzdGVuY2UgPSBhc3luYyAoKSA9PiB7IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBmaW5hbGl6ZVNpZ25JblRvdHBNZmEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50cy9tZmFTaWduSW46ZmluYWxpemVcIiAvKiBFbmRwb2ludC5GSU5BTElaRV9NRkFfU0lHTl9JTiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCkge1xuICAgICAgICB0aGlzLmZhY3RvcklkID0gZmFjdG9ySWQ7XG4gICAgfVxuICAgIF9wcm9jZXNzKGF1dGgsIHNlc3Npb24sIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHN3aXRjaCAoc2Vzc2lvbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZW5yb2xsXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5FTlJPTEwgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplRW5yb2xsKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCwgZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInNpZ25pblwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuU0lHTl9JTiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVTaWduSW4oYXV0aCwgc2Vzc2lvbi5jcmVkZW50aWFsKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgndW5leHBlY3RlZCBNdWx0aUZhY3RvclNlc3Npb25UeXBlJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB0byBjb25maXJtIG93bmVyc2hpcCBvZlxuICAgICAqIHRoZSBUT1RQICh0aW1lLWJhc2VkIG9uZS10aW1lIHBhc3N3b3JkKSBzZWNvbmQgZmFjdG9yLlxuICAgICAqIFRoaXMgYXNzZXJ0aW9uIGlzIHVzZWQgdG8gY29tcGxldGUgZW5yb2xsbWVudCBpbiBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VjcmV0IEEge0BsaW5rIFRvdHBTZWNyZXR9IGNvbnRhaW5pbmcgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBvdGhlciBUT1RQIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIHtAbGluayBNdWx0aUZhY3RvclVzZXIuZW5yb2xsfS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXNzZXJ0aW9uRm9yRW5yb2xsbWVudChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbVNlY3JldChzZWNyZXQsIG9uZVRpbWVQYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2YgdGhlIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIHNpZ25JbiB3aXRoIFRPVFAgYXMgdGhlIHNlY29uZCBmYWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5yb2xsbWVudElkIGlkZW50aWZpZXMgdGhlIGVucm9sbGVkIFRPVFAgc2Vjb25kIGZhY3Rvci5cbiAgICAgKiBAcGFyYW0gb25lVGltZVBhc3N3b3JkIE9uZS10aW1lIHBhc3N3b3JkIGZyb20gVE9UUCBBcHAuXG4gICAgICogQHJldHVybnMgQSB7QGxpbmsgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9ufSB3aGljaCBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICoge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXIucmVzb2x2ZVNpZ25Jbn0uXG4gICAgICovXG4gICAgc3RhdGljIGFzc2VydGlvbkZvclNpZ25JbihlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbC5fZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG9uZVRpbWVQYXNzd29yZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRvIHtAbGluayBUb3RwU2VjcmV0fSB3aGljaCBjb250YWlucyB0aGUgVE9UUCBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycy5cbiAgICAgKiBDcmVhdGVzIGEgVE9UUCBzZWNyZXQgYXMgcGFydCBvZiBlbnJvbGxpbmcgYSBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICogVXNlZCBmb3IgZ2VuZXJhdGluZyBhIFFSIGNvZGUgVVJMIG9yIGlucHV0dGluZyBpbnRvIGEgVE9UUCBhcHAuXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgYXV0aCBpbnN0YW5jZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB1c2VyIGluIHRoZSBtdWx0aUZhY3RvclNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiBUaGUge0BsaW5rIE11bHRpRmFjdG9yU2Vzc2lvbn0gdGhhdCB0aGUgdXNlciBpcyBwYXJ0IG9mLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0byB7QGxpbmsgVG90cFNlY3JldH0uXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlU2VjcmV0KHNlc3Npb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZmFTZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgKChfYSA9IG1mYVNlc3Npb24udXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dGgpICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0YXJ0RW5yb2xsVG90cE1mYShtZmFTZXNzaW9uLnVzZXIuYXV0aCwge1xuICAgICAgICAgICAgaWRUb2tlbjogbWZhU2Vzc2lvbi5jcmVkZW50aWFsLFxuICAgICAgICAgICAgdG90cEVucm9sbG1lbnRJbmZvOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFRvdHBTZWNyZXQuX2Zyb21TdGFydFRvdHBNZmFFbnJvbGxtZW50UmVzcG9uc2UocmVzcG9uc2UsIG1mYVNlc3Npb24udXNlci5hdXRoKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBUT1RQIHNlY29uZCBmYWN0b3I6IGB0b3RwYC5cbiAqL1xuVG90cE11bHRpRmFjdG9yR2VuZXJhdG9yLkZBQ1RPUl9JRCA9IFwidG90cFwiIC8qIEZhY3RvcklkLlRPVFAgKi87XG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIGV4dGVuZHMgTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvdHAsIGVucm9sbG1lbnRJZCwgc2VjcmV0KSB7XG4gICAgICAgIHN1cGVyKFwidG90cFwiIC8qIEZhY3RvcklkLlRPVFAgKi8pO1xuICAgICAgICB0aGlzLm90cCA9IG90cDtcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50SWQgPSBlbnJvbGxtZW50SWQ7XG4gICAgICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tU2VjcmV0KHNlY3JldCwgb3RwKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbChvdHAsIHVuZGVmaW5lZCwgc2VjcmV0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVucm9sbG1lbnRJZChlbnJvbGxtZW50SWQsIG90cCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCBlbnJvbGxtZW50SWQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZpbmFsaXplRW5yb2xsKGF1dGgsIGlkVG9rZW4sIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIHRoaXMuc2VjcmV0ICE9PSAndW5kZWZpbmVkJywgYXV0aCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gZmluYWxpemVFbnJvbGxUb3RwTWZhKGF1dGgsIHtcbiAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIHRvdHBWZXJpZmljYXRpb25JbmZvOiB0aGlzLnNlY3JldC5fbWFrZVRvdHBWZXJpZmljYXRpb25JbmZvKHRoaXMub3RwKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9maW5hbGl6ZVNpZ25JbihhdXRoLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCkge1xuICAgICAgICBfYXNzZXJ0KHRoaXMuZW5yb2xsbWVudElkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vdHAgIT09IHVuZGVmaW5lZCwgYXV0aCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCB0b3RwVmVyaWZpY2F0aW9uSW5mbyA9IHsgdmVyaWZpY2F0aW9uQ29kZTogdGhpcy5vdHAgfTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplU2lnbkluVG90cE1mYShhdXRoLCB7XG4gICAgICAgICAgICBtZmFQZW5kaW5nQ3JlZGVudGlhbCxcbiAgICAgICAgICAgIG1mYUVucm9sbG1lbnRJZDogdGhpcy5lbnJvbGxtZW50SWQsXG4gICAgICAgICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mb1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogU3RvcmVzIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgcGFyYW1ldGVycyB0byBnZW5lcmF0ZSB0aW1lLWJhc2VkIE9UUHMuXG4gKiBJbXBsZW1lbnRzIG1ldGhvZHMgdG8gcmV0cmlldmUgdGhlIHNoYXJlZCBzZWNyZXQga2V5IGFuZCBnZW5lcmF0ZSBhIFFSIGNvZGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUb3RwU2VjcmV0IHtcbiAgICAvLyBUaGUgcHVibGljIG1lbWJlcnMgYXJlIGRlY2xhcmVkIG91dHNpZGUgdGhlIGNvbnN0cnVjdG9yIHNvIHRoZSBkb2NzIGNhbiBiZSBnZW5lcmF0ZWQuXG4gICAgY29uc3RydWN0b3Ioc2VjcmV0S2V5LCBoYXNoaW5nQWxnb3JpdGhtLCBjb2RlTGVuZ3RoLCBjb2RlSW50ZXJ2YWxTZWNvbmRzLCBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lLCBzZXNzaW9uSW5mbywgYXV0aCkge1xuICAgICAgICB0aGlzLnNlc3Npb25JbmZvID0gc2Vzc2lvbkluZm87XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMuc2VjcmV0S2V5ID0gc2VjcmV0S2V5O1xuICAgICAgICB0aGlzLmhhc2hpbmdBbGdvcml0aG0gPSBoYXNoaW5nQWxnb3JpdGhtO1xuICAgICAgICB0aGlzLmNvZGVMZW5ndGggPSBjb2RlTGVuZ3RoO1xuICAgICAgICB0aGlzLmNvZGVJbnRlcnZhbFNlY29uZHMgPSBjb2RlSW50ZXJ2YWxTZWNvbmRzO1xuICAgICAgICB0aGlzLmVucm9sbG1lbnRDb21wbGV0aW9uRGVhZGxpbmUgPSBlbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBhdXRoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG90cFNlY3JldChyZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2hhcmVkU2VjcmV0S2V5LCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uaGFzaGluZ0FsZ29yaXRobSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnZlcmlmaWNhdGlvbkNvZGVMZW5ndGgsIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5wZXJpb2RTZWMsIG5ldyBEYXRlKHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby5maW5hbGl6ZUVucm9sbG1lbnRUaW1lKS50b1VUQ1N0cmluZygpLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uc2Vzc2lvbkluZm8sIGF1dGgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyhvdHApIHtcbiAgICAgICAgcmV0dXJuIHsgc2Vzc2lvbkluZm86IHRoaXMuc2Vzc2lvbkluZm8sIHZlcmlmaWNhdGlvbkNvZGU6IG90cCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUVIgY29kZSBVUkwgYXMgZGVzY3JpYmVkIGluXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9nb29nbGUtYXV0aGVudGljYXRvci93aWtpL0tleS1VcmktRm9ybWF0XG4gICAgICogVGhpcyBjYW4gYmUgZGlzcGxheWVkIHRvIHRoZSB1c2VyIGFzIGEgUVIgY29kZSB0byBiZSBzY2FubmVkIGludG8gYSBUT1RQIGFwcCBsaWtlIEdvb2dsZSBBdXRoZW50aWNhdG9yLlxuICAgICAqIElmIHRoZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSB1bnNwZWNpZmllZCwgYW4gYWNjb3VudE5hbWUgb2YgPHVzZXJFbWFpbD4gYW5kIGlzc3VlciBvZiA8ZmlyZWJhc2VBcHBOYW1lPiBhcmUgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2NvdW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgYWNjb3VudC9hcHAgYWxvbmcgd2l0aCBhIHVzZXIgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gaXNzdWVyIGlzc3VlciBvZiB0aGUgVE9UUCAobGlrZWx5IHRoZSBhcHAgbmFtZSkuXG4gICAgICogQHJldHVybnMgQSBRUiBjb2RlIFVSTCBzdHJpbmcuXG4gICAgICovXG4gICAgZ2VuZXJhdGVRckNvZGVVcmwoYWNjb3VudE5hbWUsIGlzc3Vlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB1c2VEZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpIHx8IF9pc0VtcHR5U3RyaW5nKGlzc3VlcikpIHtcbiAgICAgICAgICAgIHVzZURlZmF1bHRzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhhY2NvdW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50TmFtZSA9ICgoX2EgPSB0aGlzLmF1dGguY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbWFpbCkgfHwgJ3Vua25vd251c2VyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XG4gICAgICAgICAgICAgICAgaXNzdWVyID0gdGhpcy5hdXRoLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBvdHBhdXRoOi8vdG90cC8ke2lzc3Vlcn06JHthY2NvdW50TmFtZX0/c2VjcmV0PSR7dGhpcy5zZWNyZXRLZXl9Jmlzc3Vlcj0ke2lzc3Vlcn0mYWxnb3JpdGhtPSR7dGhpcy5oYXNoaW5nQWxnb3JpdGhtfSZkaWdpdHM9JHt0aGlzLmNvZGVMZW5ndGh9YDtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBfaXNFbXB0eVN0cmluZyhpbnB1dCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IChpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQubGVuZ3RoKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5BVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFkgPSBBVVRIX0VSUk9SX0NPREVTX01BUF9ET19OT1RfVVNFX0lOVEVSTkFMTFk7XG5leHBvcnRzLkFjdGlvbkNvZGVPcGVyYXRpb24gPSBBY3Rpb25Db2RlT3BlcmF0aW9uO1xuZXhwb3J0cy5BY3Rpb25Db2RlVVJMID0gQWN0aW9uQ29kZVVSTDtcbmV4cG9ydHMuQXV0aENyZWRlbnRpYWwgPSBBdXRoQ3JlZGVudGlhbDtcbmV4cG9ydHMuQXV0aEltcGwgPSBBdXRoSW1wbDtcbmV4cG9ydHMuQmFzZU9BdXRoUHJvdmlkZXIgPSBCYXNlT0F1dGhQcm92aWRlcjtcbmV4cG9ydHMuRW1haWxBdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLkVtYWlsQXV0aFByb3ZpZGVyID0gRW1haWxBdXRoUHJvdmlkZXI7XG5leHBvcnRzLkZhY2Vib29rQXV0aFByb3ZpZGVyID0gRmFjZWJvb2tBdXRoUHJvdmlkZXI7XG5leHBvcnRzLkZhY3RvcklkID0gRmFjdG9ySWQ7XG5leHBvcnRzLkZlZGVyYXRlZEF1dGhQcm92aWRlciA9IEZlZGVyYXRlZEF1dGhQcm92aWRlcjtcbmV4cG9ydHMuRmV0Y2hQcm92aWRlciA9IEZldGNoUHJvdmlkZXI7XG5leHBvcnRzLkdpdGh1YkF1dGhQcm92aWRlciA9IEdpdGh1YkF1dGhQcm92aWRlcjtcbmV4cG9ydHMuR29vZ2xlQXV0aFByb3ZpZGVyID0gR29vZ2xlQXV0aFByb3ZpZGVyO1xuZXhwb3J0cy5PQXV0aENyZWRlbnRpYWwgPSBPQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLk9BdXRoUHJvdmlkZXIgPSBPQXV0aFByb3ZpZGVyO1xuZXhwb3J0cy5PcGVyYXRpb25UeXBlID0gT3BlcmF0aW9uVHlwZTtcbmV4cG9ydHMuUGhvbmVBdXRoQ3JlZGVudGlhbCA9IFBob25lQXV0aENyZWRlbnRpYWw7XG5leHBvcnRzLlBob25lQXV0aFByb3ZpZGVyID0gUGhvbmVBdXRoUHJvdmlkZXI7XG5leHBvcnRzLlBob25lTXVsdGlGYWN0b3JHZW5lcmF0b3IgPSBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yO1xuZXhwb3J0cy5Qcm92aWRlcklkID0gUHJvdmlkZXJJZDtcbmV4cG9ydHMuUmVjYXB0Y2hhVmVyaWZpZXIgPSBSZWNhcHRjaGFWZXJpZmllcjtcbmV4cG9ydHMuU0FNTEF1dGhDcmVkZW50aWFsID0gU0FNTEF1dGhDcmVkZW50aWFsO1xuZXhwb3J0cy5TQU1MQXV0aFByb3ZpZGVyID0gU0FNTEF1dGhQcm92aWRlcjtcbmV4cG9ydHMuU2lnbkluTWV0aG9kID0gU2lnbkluTWV0aG9kO1xuZXhwb3J0cy5Ub3RwTXVsdGlGYWN0b3JHZW5lcmF0b3IgPSBUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3I7XG5leHBvcnRzLlRvdHBTZWNyZXQgPSBUb3RwU2VjcmV0O1xuZXhwb3J0cy5Ud2l0dGVyQXV0aFByb3ZpZGVyID0gVHdpdHRlckF1dGhQcm92aWRlcjtcbmV4cG9ydHMuVXNlckltcGwgPSBVc2VySW1wbDtcbmV4cG9ydHMuX2Fzc2VydCA9IF9hc3NlcnQ7XG5leHBvcnRzLl9jYXN0QXV0aCA9IF9jYXN0QXV0aDtcbmV4cG9ydHMuX2NyZWF0ZUVycm9yID0gX2NyZWF0ZUVycm9yO1xuZXhwb3J0cy5fZW11bGF0b3JVcmwgPSBfZW11bGF0b3JVcmw7XG5leHBvcnRzLl9mYWlsID0gX2ZhaWw7XG5leHBvcnRzLl9nZXRDbGllbnRWZXJzaW9uID0gX2dldENsaWVudFZlcnNpb247XG5leHBvcnRzLl9nZXRJbnN0YW5jZSA9IF9nZXRJbnN0YW5jZTtcbmV4cG9ydHMuX2lzQW5kcm9pZCA9IF9pc0FuZHJvaWQ7XG5leHBvcnRzLl9pc0lFMTAgPSBfaXNJRTEwO1xuZXhwb3J0cy5faXNJT1MgPSBfaXNJT1M7XG5leHBvcnRzLl9pc0lPUzdPcjggPSBfaXNJT1M3T3I4O1xuZXhwb3J0cy5faXNNb2JpbGVCcm93c2VyID0gX2lzTW9iaWxlQnJvd3NlcjtcbmV4cG9ydHMuX2xpbmsgPSBfbGluaztcbmV4cG9ydHMuX3BlcmZvcm1BcGlSZXF1ZXN0ID0gX3BlcmZvcm1BcGlSZXF1ZXN0O1xuZXhwb3J0cy5fcGVyc2lzdGVuY2VLZXlOYW1lID0gX3BlcnNpc3RlbmNlS2V5TmFtZTtcbmV4cG9ydHMuX3JlYXV0aGVudGljYXRlID0gX3JlYXV0aGVudGljYXRlO1xuZXhwb3J0cy5fc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvciA9IF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yO1xuZXhwb3J0cy5fc2lnbkluV2l0aENyZWRlbnRpYWwgPSBfc2lnbkluV2l0aENyZWRlbnRpYWw7XG5leHBvcnRzLmFwcGx5QWN0aW9uQ29kZSA9IGFwcGx5QWN0aW9uQ29kZTtcbmV4cG9ydHMuYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCA9IGJlZm9yZUF1dGhTdGF0ZUNoYW5nZWQ7XG5leHBvcnRzLmJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlID0gYnJvd3NlckxvY2FsUGVyc2lzdGVuY2U7XG5leHBvcnRzLmJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyO1xuZXhwb3J0cy5icm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlID0gYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZTtcbmV4cG9ydHMuY2hlY2tBY3Rpb25Db2RlID0gY2hlY2tBY3Rpb25Db2RlO1xuZXhwb3J0cy5jb25maXJtUGFzc3dvcmRSZXNldCA9IGNvbmZpcm1QYXNzd29yZFJlc2V0O1xuZXhwb3J0cy5jb25uZWN0QXV0aEVtdWxhdG9yID0gY29ubmVjdEF1dGhFbXVsYXRvcjtcbmV4cG9ydHMuY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkID0gY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkO1xuZXhwb3J0cy5kZWJ1Z0Fzc2VydCA9IGRlYnVnQXNzZXJ0O1xuZXhwb3J0cy5kZWJ1Z0Vycm9yTWFwID0gZGVidWdFcnJvck1hcDtcbmV4cG9ydHMuZGVsZXRlVXNlciA9IGRlbGV0ZVVzZXI7XG5leHBvcnRzLmZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsID0gZmV0Y2hTaWduSW5NZXRob2RzRm9yRW1haWw7XG5leHBvcnRzLmdldEFkZGl0aW9uYWxVc2VySW5mbyA9IGdldEFkZGl0aW9uYWxVc2VySW5mbztcbmV4cG9ydHMuZ2V0QXV0aCA9IGdldEF1dGg7XG5leHBvcnRzLmdldElkVG9rZW4gPSBnZXRJZFRva2VuO1xuZXhwb3J0cy5nZXRJZFRva2VuUmVzdWx0ID0gZ2V0SWRUb2tlblJlc3VsdDtcbmV4cG9ydHMuZ2V0TXVsdGlGYWN0b3JSZXNvbHZlciA9IGdldE11bHRpRmFjdG9yUmVzb2x2ZXI7XG5leHBvcnRzLmdldFJlZGlyZWN0UmVzdWx0ID0gZ2V0UmVkaXJlY3RSZXN1bHQ7XG5leHBvcnRzLmluTWVtb3J5UGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xuZXhwb3J0cy5pbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlID0gaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZTtcbmV4cG9ydHMuaW5pdGlhbGl6ZUF1dGggPSBpbml0aWFsaXplQXV0aDtcbmV4cG9ydHMuaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyA9IGluaXRpYWxpemVSZWNhcHRjaGFDb25maWc7XG5leHBvcnRzLmlzU2lnbkluV2l0aEVtYWlsTGluayA9IGlzU2lnbkluV2l0aEVtYWlsTGluaztcbmV4cG9ydHMubGlua1dpdGhDcmVkZW50aWFsID0gbGlua1dpdGhDcmVkZW50aWFsO1xuZXhwb3J0cy5saW5rV2l0aFBob25lTnVtYmVyID0gbGlua1dpdGhQaG9uZU51bWJlcjtcbmV4cG9ydHMubGlua1dpdGhQb3B1cCA9IGxpbmtXaXRoUG9wdXA7XG5leHBvcnRzLmxpbmtXaXRoUmVkaXJlY3QgPSBsaW5rV2l0aFJlZGlyZWN0O1xuZXhwb3J0cy5tdWx0aUZhY3RvciA9IG11bHRpRmFjdG9yO1xuZXhwb3J0cy5vbkF1dGhTdGF0ZUNoYW5nZWQgPSBvbkF1dGhTdGF0ZUNoYW5nZWQ7XG5leHBvcnRzLm9uSWRUb2tlbkNoYW5nZWQgPSBvbklkVG9rZW5DaGFuZ2VkO1xuZXhwb3J0cy5wYXJzZUFjdGlvbkNvZGVVUkwgPSBwYXJzZUFjdGlvbkNvZGVVUkw7XG5leHBvcnRzLnByb2RFcnJvck1hcCA9IHByb2RFcnJvck1hcDtcbmV4cG9ydHMucmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCA9IHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWw7XG5leHBvcnRzLnJlYXV0aGVudGljYXRlV2l0aFBob25lTnVtYmVyID0gcmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXI7XG5leHBvcnRzLnJlYXV0aGVudGljYXRlV2l0aFBvcHVwID0gcmVhdXRoZW50aWNhdGVXaXRoUG9wdXA7XG5leHBvcnRzLnJlYXV0aGVudGljYXRlV2l0aFJlZGlyZWN0ID0gcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3Q7XG5leHBvcnRzLnJlbG9hZCA9IHJlbG9hZDtcbmV4cG9ydHMucmV2b2tlQWNjZXNzVG9rZW4gPSByZXZva2VBY2Nlc3NUb2tlbjtcbmV4cG9ydHMuc2VuZEVtYWlsVmVyaWZpY2F0aW9uID0gc2VuZEVtYWlsVmVyaWZpY2F0aW9uO1xuZXhwb3J0cy5zZW5kUGFzc3dvcmRSZXNldEVtYWlsID0gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbDtcbmV4cG9ydHMuc2VuZFNpZ25JbkxpbmtUb0VtYWlsID0gc2VuZFNpZ25JbkxpbmtUb0VtYWlsO1xuZXhwb3J0cy5zZXRQZXJzaXN0ZW5jZSA9IHNldFBlcnNpc3RlbmNlO1xuZXhwb3J0cy5zaWduSW5Bbm9ueW1vdXNseSA9IHNpZ25JbkFub255bW91c2x5O1xuZXhwb3J0cy5zaWduSW5XaXRoQ3JlZGVudGlhbCA9IHNpZ25JbldpdGhDcmVkZW50aWFsO1xuZXhwb3J0cy5zaWduSW5XaXRoQ3VzdG9tVG9rZW4gPSBzaWduSW5XaXRoQ3VzdG9tVG9rZW47XG5leHBvcnRzLnNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkID0gc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQ7XG5leHBvcnRzLnNpZ25JbldpdGhFbWFpbExpbmsgPSBzaWduSW5XaXRoRW1haWxMaW5rO1xuZXhwb3J0cy5zaWduSW5XaXRoSWRwID0gc2lnbkluV2l0aElkcDtcbmV4cG9ydHMuc2lnbkluV2l0aFBob25lTnVtYmVyID0gc2lnbkluV2l0aFBob25lTnVtYmVyO1xuZXhwb3J0cy5zaWduSW5XaXRoUG9wdXAgPSBzaWduSW5XaXRoUG9wdXA7XG5leHBvcnRzLnNpZ25JbldpdGhSZWRpcmVjdCA9IHNpZ25JbldpdGhSZWRpcmVjdDtcbmV4cG9ydHMuc2lnbk91dCA9IHNpZ25PdXQ7XG5leHBvcnRzLnVubGluayA9IHVubGluaztcbmV4cG9ydHMudXBkYXRlQ3VycmVudFVzZXIgPSB1cGRhdGVDdXJyZW50VXNlcjtcbmV4cG9ydHMudXBkYXRlRW1haWwgPSB1cGRhdGVFbWFpbDtcbmV4cG9ydHMudXBkYXRlUGFzc3dvcmQgPSB1cGRhdGVQYXNzd29yZDtcbmV4cG9ydHMudXBkYXRlUGhvbmVOdW1iZXIgPSB1cGRhdGVQaG9uZU51bWJlcjtcbmV4cG9ydHMudXBkYXRlUHJvZmlsZSA9IHVwZGF0ZVByb2ZpbGU7XG5leHBvcnRzLnVzZURldmljZUxhbmd1YWdlID0gdXNlRGV2aWNlTGFuZ3VhZ2U7XG5leHBvcnRzLnZhbGlkYXRlUGFzc3dvcmQgPSB2YWxpZGF0ZVBhc3N3b3JkO1xuZXhwb3J0cy52ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCA9IHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsO1xuZXhwb3J0cy52ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSA9IHZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG90cC03MTk1YzIwNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node/totp-7195c207.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/index.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/index.cjs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar util = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/index.node.cjs.js\");\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new util.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch (_a) {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch (_a) {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\nexports.Component = Component;\nexports.ComponentContainer = ComponentContainer;\nexports.Provider = Provider;\n//# sourceMappingURL=index.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELFdBQVcsbUJBQU8sQ0FBQyxrRkFBZ0I7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQkFBZ0IsZUFBZSxVQUFVO0FBQzFGO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQixVQUFVLEdBQUcscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLG1DQUFtQyxVQUFVO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvaG9tZS9yZ3RlY2gwMDgvYWNhZGVtaWMtY29ubmVjdC1wcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvaW5kZXguY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCdAZmlyZWJhc2UvdXRpbCcpO1xuXG4vKipcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcbiAqL1xuY2xhc3MgQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBwdWJsaWMgc2VydmljZSBuYW1lLCBlLmcuIGFwcCwgYXV0aCwgZmlyZXN0b3JlLCBkYXRhYmFzZVxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxuICAgICAqIEBwYXJhbSB0eXBlIHdoZXRoZXIgdGhlIHNlcnZpY2UgcHJvdmlkZWQgYnkgdGhlIGNvbXBvbmVudCBpcyBwdWJsaWMgb3IgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluc3RhbmNlRmFjdG9yeSA9IGluc3RhbmNlRmFjdG9yeTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0ge307XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gbnVsbDtcbiAgICB9XG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xuICAgICAgICB0aGlzLmluc3RhbnRpYXRpb25Nb2RlID0gbW9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE11bHRpcGxlSW5zdGFuY2VzKG11bHRpcGxlSW5zdGFuY2VzKSB7XG4gICAgICAgIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgPSBtdWx0aXBsZUluc3RhbmNlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFNlcnZpY2VQcm9wcyhwcm9wcykge1xuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vbkluc3RhbmNlQ3JlYXRlZCA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGluc3RhbmNlIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiAnYXV0aCcsICdhdXRoLWludGVybmFsJ1xuICogTmFtZVNlcnZpY2VNYXBwaW5nW1RdIGlzIGFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2VcbiAqL1xuY2xhc3MgUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXG4gICAgICogaWYgdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBnZXQoaWRlbnRpZmllcikge1xuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgdXRpbC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2VydmljZSBpZiBpdCBjYW4gYmUgYXV0by1pbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKS5wcm9taXNlO1xuICAgIH1cbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvcHRpb25hbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIGEgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCBhbmQgc2hvdWxkL2Nhbm5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCBmb3IgJHt0aGlzLm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuICAgICAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24sIGl0IHNob3VsZCBub3QgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpKSxcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuX2RlbGV0ZSgpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnRTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xuICAgIH1cbiAgICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucyhpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRzLmluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkICBhZnRlciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYnkgY2FsbGluZyBwcm92aWRlci5pbml0aWFsaXplKCkuXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBbiBvcHRpb25hbCBpbnN0YW5jZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uSW5pdChjYWxsYmFjaywgaWRlbnRpZmllcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FsbGJhY2tzID0gKF9hID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGV4aXN0aW5nQ2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhleGlzdGluZ0luc3RhbmNlLCBub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXG4gICAgICovXG4gICAgaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZUZhY3RvcnkodGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxuICAgICAgICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3JkZXIgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxuICAgICAgICAgICAgICogbWFrZXMgYGlzSW5pdGlhbGl6ZWQoKWAgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKHRoaXMuY29udGFpbmVyLCBpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQXV0b0luaXRpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiAoISF0aGlzLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XG4gICAgfVxufVxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gXCJFQUdFUlwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSICovO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyBwcm92aWRlciBmcm9tIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiByZWdpc3RlciB0aGUgbmV3IGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGNvbXBvbmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXG4gICAgICogcHJlc2VudCBpbiBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXG4gICAgICogdGhlbXNlbHZlcy5cbiAgICAgKi9cbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuYW1lLCBwcm92aWRlcik7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0UHJvdmlkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgfVxufVxuXG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuQ29tcG9uZW50Q29udGFpbmVyID0gQ29tcG9uZW50Q29udGFpbmVyO1xuZXhwb3J0cy5Qcm92aWRlciA9IFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/index.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/index.cjs.js":
/*!*********************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/index.cjs.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nconst instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nexports.LogLevel = void 0;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(exports.LogLevel || (exports.LogLevel = {}));\nconst levelStringToEnum = {\n    'debug': exports.LogLevel.DEBUG,\n    'verbose': exports.LogLevel.VERBOSE,\n    'info': exports.LogLevel.INFO,\n    'warn': exports.LogLevel.WARN,\n    'error': exports.LogLevel.ERROR,\n    'silent': exports.LogLevel.SILENT\n};\n/**\n * The default log level\n */\nconst defaultLogLevel = exports.LogLevel.INFO;\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n    [exports.LogLevel.DEBUG]: 'log',\n    [exports.LogLevel.VERBOSE]: 'log',\n    [exports.LogLevel.INFO]: 'info',\n    [exports.LogLevel.WARN]: 'warn',\n    [exports.LogLevel.ERROR]: 'error'\n};\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler = (instance, logType, ...args) => {\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    }\n    else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    constructor(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The main (internal) log handler for the Logger instance.\n         * Can be set to a new function in internal package code but not by user.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * The optional, additional, user-defined log handler for the Logger instance.\n         */\n        this._userLogHandler = null;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in exports.LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== 'function') {\n            throw new TypeError('Value assigned to `logHandler` must be a function');\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.DEBUG, ...args);\n        this._logHandler(this, exports.LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler &&\n            this._userLogHandler(this, exports.LogLevel.VERBOSE, ...args);\n        this._logHandler(this, exports.LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.INFO, ...args);\n        this._logHandler(this, exports.LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.WARN, ...args);\n        this._logHandler(this, exports.LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.ERROR, ...args);\n        this._logHandler(this, exports.LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach(inst => {\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances) {\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        }\n        else {\n            instance.userLogHandler = (instance, level, ...args) => {\n                const message = args\n                    .map(arg => {\n                    if (arg == null) {\n                        return null;\n                    }\n                    else if (typeof arg === 'string') {\n                        return arg;\n                    }\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\n                        return arg.toString();\n                    }\n                    else if (arg instanceof Error) {\n                        return arg.message;\n                    }\n                    else {\n                        try {\n                            return JSON.stringify(arg);\n                        }\n                        catch (ignored) {\n                            return null;\n                        }\n                    }\n                })\n                    .filter(arg => arg)\n                    .join(' ');\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: exports.LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n\nexports.Logger = Logger;\nexports.setLogLevel = setLogLevel;\nexports.setUserLogHandler = setUserLogHandler;\n//# sourceMappingURL=index.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2luZGV4LmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsZ0JBQWdCLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxLQUFLLGNBQWM7QUFDbkQ7QUFDQTtBQUNBLHNGQUFzRixRQUFRO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9ob21lL3JndGVjaDAwOC9hY2FkZW1pYy1jb25uZWN0LXByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9pbmRleC5janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXG4gKi9cbmNvbnN0IGluc3RhbmNlcyA9IFtdO1xuLyoqXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXG4gKiBzaWxlbmNlIHRoZSBsb2dzIGFsdG9nZXRoZXIuXG4gKlxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcbiAqIERFQlVHIDwgVkVSQk9TRSA8IElORk8gPCBXQVJOIDwgRVJST1JcbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBJTkZPYCwgZXJyb3JzIHdpbGwgc3RpbGwgYmUgbG9nZ2VkLCBidXQgYERFQlVHYCBhbmRcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxuICovXG5leHBvcnRzLkxvZ0xldmVsID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSU5GT1wiXSA9IDJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXQVJOXCJdID0gM10gPSBcIldBUk5cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJTSUxFTlRcIl0gPSA1XSA9IFwiU0lMRU5UXCI7XG59KShleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbmNvbnN0IGxldmVsU3RyaW5nVG9FbnVtID0ge1xuICAgICdkZWJ1Zyc6IGV4cG9ydHMuTG9nTGV2ZWwuREVCVUcsXG4gICAgJ3ZlcmJvc2UnOiBleHBvcnRzLkxvZ0xldmVsLlZFUkJPU0UsXG4gICAgJ2luZm8nOiBleHBvcnRzLkxvZ0xldmVsLklORk8sXG4gICAgJ3dhcm4nOiBleHBvcnRzLkxvZ0xldmVsLldBUk4sXG4gICAgJ2Vycm9yJzogZXhwb3J0cy5Mb2dMZXZlbC5FUlJPUixcbiAgICAnc2lsZW50JzogZXhwb3J0cy5Mb2dMZXZlbC5TSUxFTlRcbn07XG4vKipcbiAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbFxuICovXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsLklORk87XG4vKipcbiAqIEJ5IGRlZmF1bHQsIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgZGlzcGxheWVkIGluIHRoZSBkZXZlbG9wZXIgY29uc29sZSAoaW5cbiAqIGNocm9tZSkuIFRvIGF2b2lkIGZvcmNpbmcgdXNlcnMgdG8gaGF2ZSB0byBvcHQtaW4gdG8gdGhlc2UgbG9ncyB0d2ljZVxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxuICogbG9ncyB0byB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbi5cbiAqL1xuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcbiAgICBbZXhwb3J0cy5Mb2dMZXZlbC5ERUJVR106ICdsb2cnLFxuICAgIFtleHBvcnRzLkxvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcbiAgICBbZXhwb3J0cy5Mb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxuICAgIFtleHBvcnRzLkxvZ0xldmVsLldBUk5dOiAnd2FybicsXG4gICAgW2V4cG9ydHMuTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxuICogbWVzc2FnZXMgb24gdG8gdGhlaXIgY29ycmVzcG9uZGluZyBjb25zb2xlIGNvdW50ZXJwYXJ0cyAoaWYgdGhlIGxvZyBtZXRob2RcbiAqIGlzIHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCBsb2cgbGV2ZWwpXG4gKi9cbmNvbnN0IGRlZmF1bHRMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsb2dUeXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKGxvZ1R5cGUgPCBpbnN0YW5jZS5sb2dMZXZlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgY29uc29sZVttZXRob2RdKGBbJHtub3d9XSAgJHtpbnN0YW5jZS5uYW1lfTpgLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0ZW1wdGVkIHRvIGxvZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbnZhbGlkIGxvZ1R5cGUgKHZhbHVlOiAke2xvZ1R5cGV9KWApO1xuICAgIH1cbn07XG5jbGFzcyBMb2dnZXIge1xuICAgIC8qKlxuICAgICAqIEdpdmVzIHlvdSBhbiBpbnN0YW5jZSBvZiBhIExvZ2dlciB0byBjYXB0dXJlIG1lc3NhZ2VzIGFjY29yZGluZyB0b1xuICAgICAqIEZpcmViYXNlJ3MgbG9nZ2luZyBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSB0aGF0IHRoZSBsb2dzIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSBkZWZhdWx0TG9nTGV2ZWw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFpbiAoaW50ZXJuYWwpIGxvZyBoYW5kbGVyIGZvciB0aGUgTG9nZ2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBDYW4gYmUgc2V0IHRvIGEgbmV3IGZ1bmN0aW9uIGluIGludGVybmFsIHBhY2thZ2UgY29kZSBidXQgbm90IGJ5IHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyID0gZGVmYXVsdExvZ0hhbmRsZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcHR1cmUgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGxhdGVyIHVzZVxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgfVxuICAgIGdldCBsb2dMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xuICAgIH1cbiAgICBzZXQgbG9nTGV2ZWwodmFsKSB7XG4gICAgICAgIGlmICghKHZhbCBpbiBleHBvcnRzLkxvZ0xldmVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB2YWw7XG4gICAgfVxuICAgIC8vIFdvcmthcm91bmQgZm9yIHNldHRlci9nZXR0ZXIgaGF2aW5nIHRvIGJlIHRoZSBzYW1lIHR5cGUuXG4gICAgc2V0TG9nTGV2ZWwodmFsKSB7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xuICAgIH1cbiAgICBnZXQgbG9nSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XG4gICAgfVxuICAgIHNldCBsb2dIYW5kbGVyKHZhbCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgYXNzaWduZWQgdG8gYGxvZ0hhbmRsZXJgIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XG4gICAgfVxuICAgIGdldCB1c2VyTG9nSGFuZGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xuICAgIH1cbiAgICBzZXQgdXNlckxvZ0hhbmRsZXIodmFsKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIGV4cG9ydHMuTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIGV4cG9ydHMuTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBsb2coLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJlxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgZXhwb3J0cy5Mb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBleHBvcnRzLkxvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgZXhwb3J0cy5Mb2dMZXZlbC5JTkZPLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBleHBvcnRzLkxvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgZXhwb3J0cy5Mb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBleHBvcnRzLkxvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIGV4cG9ydHMuTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIGV4cG9ydHMuTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICBjdXN0b21Mb2dMZXZlbCA9IGxldmVsU3RyaW5nVG9FbnVtW29wdGlvbnMubGV2ZWxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYXJnID0+IGFyZylcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogZXhwb3J0cy5Mb2dMZXZlbFtsZXZlbF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogaW5zdGFuY2UubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBzZXRMb2dMZXZlbDtcbmV4cG9ydHMuc2V0VXNlckxvZ0hhbmRsZXIgPSBzZXRVc2VyTG9nSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/index.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/index.node.cjs.js":
/*!************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/index.node.cjs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\nconst CONSTANTS = {\n    /**\n     * @define {boolean} Whether this is the client Node.js SDK.\n     */\n    NODE_CLIENT: false,\n    /**\n     * @define {boolean} Whether this is the Admin Node.js SDK.\n     */\n    NODE_ADMIN: false,\n    /**\n     * Firebase SDK Version\n     */\n    SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws an error if the provided assertion is falsy\n */\nconst assert = function (assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\n * Returns an Error object suitable for throwing.\n */\nconst assertionError = function (message) {\n    return new Error('Firebase Database (' +\n        CONSTANTS.SDK_VERSION +\n        ') INTERNAL ASSERT FAILED: ' +\n        message);\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst stringToByteArray$1 = function (str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if ((c & 0xfc00) === 0xd800 &&\n            i + 1 < str.length &&\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function (bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while (pos < bytes.length) {\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        }\n        else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n        }\n        else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n                0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        }\n        else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        }\n    }\n    return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n// TODO(dlarocque): Define this as a class, since we no longer target ES5.\nconst base64 = {\n    /**\n     * Maps bytes to characters.\n     */\n    byteToCharMap_: null,\n    /**\n     * Maps characters to bytes.\n     */\n    charToByteMap_: null,\n    /**\n     * Maps bytes to websafe characters.\n     * @private\n     */\n    byteToCharMapWebSafe_: null,\n    /**\n     * Maps websafe characters to bytes.\n     * @private\n     */\n    charToByteMapWebSafe_: null,\n    /**\n     * Our default alphabet, shared between\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n     */\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n    /**\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n     */\n    get ENCODED_VALS() {\n        return this.ENCODED_VALS_BASE + '+/=';\n    },\n    /**\n     * Our websafe alphabet.\n     */\n    get ENCODED_VALS_WEBSAFE() {\n        return this.ENCODED_VALS_BASE + '-_.';\n    },\n    /**\n     * Whether this browser supports the atob and btoa functions. This extension\n     * started at Mozilla but is now implemented by many browsers. We use the\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\n     * but still allowing the standard per-browser compilations.\n     *\n     */\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\n    /**\n     * Base64-encode an array of bytes.\n     *\n     * @param input An array of bytes (numbers with\n     *     value in [0, 255]) to encode.\n     * @param webSafe Boolean indicating we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeByteArray(input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error('encodeByteArray takes an array as a parameter');\n        }\n        this.init_();\n        const byteToCharMap = webSafe\n            ? this.byteToCharMapWebSafe_\n            : this.byteToCharMap_;\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    },\n    /**\n     * Base64-encode a string.\n     *\n     * @param input A string to encode.\n     * @param webSafe If true, we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * @param input to decode.\n     * @param webSafe True if we should use the\n     *     alternative alphabet.\n     * @return string representing the decoded value.\n     */\n    decodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * In base-64 decoding, groups of four characters are converted into three\n     * bytes.  If the encoder did not apply padding, the input length may not\n     * be a multiple of 4.\n     *\n     * In this case, the last group will have fewer than 4 characters, and\n     * padding will be inferred.  If the group has one or two characters, it decodes\n     * to one byte.  If the group has three characters, it decodes to two bytes.\n     *\n     * @param input Input to decode.\n     * @param webSafe True if we should use the web-safe alphabet.\n     * @return bytes representing the decoded value.\n     */\n    decodeStringToByteArray(input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe\n            ? this.charToByteMapWebSafe_\n            : this.charToByteMap_;\n        const output = [];\n        for (let i = 0; i < input.length;) {\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\n     * Lazy static initialization function. Called before\n     * accessing any of the static map variables.\n     * @private\n     */\n    init_() {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\n * An error encountered while decoding base64 string.\n */\nclass DecodeBase64StringError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DecodeBase64StringError';\n    }\n}\n/**\n * URL-safe base64 encoding\n */\nconst base64Encode = function (str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 encoding (without \".\" padding in the end).\n * e.g. Used in JSON Web Token (JWT) parts.\n */\nconst base64urlEncodeWithoutPadding = function (str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, '');\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nconst base64Decode = function (str) {\n    try {\n        return base64.decodeString(str, true);\n    }\n    catch (e) {\n        console.error('base64Decode failed: ', e);\n    }\n    return null;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n *\n * Note: we don't merge __proto__ to prevent prototype pollution\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (const prop in source) {\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== '__proto__';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Polyfill for `globalThis` object.\n * @returns the `globalThis` object for the given environment.\n * @public\n */\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unable to locate global object.');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\n/**\n * Attempt to read defaults from a JSON string provided to\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\n * The dots are in parens because certain compilers (Vite?) cannot\n * handle seeing that variable in comments.\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\n */\nconst getDefaultsFromEnvVariable = () => {\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = () => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    }\n    catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\n * (1) if such an object exists as a property of `globalThis`\n * (2) if such an object was provided on a shell environment variable\n * (3) if such an object exists in a cookie\n * @public\n */\nconst getDefaults = () => {\n    try {\n        return (getDefaultsFromGlobal() ||\n            getDefaultsFromEnvVariable() ||\n            getDefaultsFromCookie());\n    }\n    catch (e) {\n        /**\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\n         * to any environment case we have not accounted for. Log to\n         * info instead of swallowing so we can find these unknown cases\n         * and add paths for them if needed.\n         */\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\n * @public\n */\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\n/**\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\n * @public\n */\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === '[') {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [host.substring(1, separatorIndex - 1), port];\n    }\n    else {\n        return [host.substring(0, separatorIndex), port];\n    }\n};\n/**\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\n * @public\n */\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\n/**\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\n * prefixed by \"_\")\n * @public\n */\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.reject = () => { };\n        this.resolve = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     */\n    wrapCallback(callback) {\n        return (error, value) => {\n            if (error) {\n                this.reject(error);\n            }\n            else {\n                this.resolve(value);\n            }\n            if (typeof callback === 'function') {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(() => { });\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                }\n                else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: 'none',\n        type: 'JWT'\n    };\n    const project = projectId || 'demo-project';\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({ \n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\n            sign_in_provider: 'custom',\n            identities: {}\n        } }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = '';\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join('.');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nfunction getUA() {\n    if (typeof navigator !== 'undefined' &&\n        typeof navigator['userAgent'] === 'string') {\n        return navigator['userAgent'];\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nfunction isMobileCordova() {\n    return (typeof window !== 'undefined' &&\n        // @ts-ignore Setting up an broadly applicable index signature for Window\n        // just to deal with this case would probably be a bad idea.\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\n}\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected or specified.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === 'node') {\n        return true;\n    }\n    else if (forceEnvironment === 'browser') {\n        return false;\n    }\n    try {\n        return (Object.prototype.toString.call(global.process) === '[object process]');\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Detect Browser Environment.\n * Note: This will return true for certain test frameworks that are incompletely\n * mimicking a browser, and should not lead to assuming all browser APIs are\n * available.\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined' || isWebWorker();\n}\n/**\n * Detect Web Worker context.\n */\nfunction isWebWorker() {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        typeof self !== 'undefined' &&\n        self instanceof WorkerGlobalScope);\n}\n/**\n * Detect Cloudflare Worker context.\n */\nfunction isCloudflareWorker() {\n    return (typeof navigator !== 'undefined' &&\n        navigator.userAgent === 'Cloudflare-Workers');\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === 'object'\n        ? chrome.runtime\n        : typeof browser === 'object'\n            ? browser.runtime\n            : undefined;\n    return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nfunction isReactNative() {\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n    return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n    const ua = getUA();\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n    return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nfunction isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n    return (!isNode() &&\n        !!navigator.userAgent &&\n        navigator.userAgent.includes('Safari') &&\n        !navigator.userAgent.includes('Chrome'));\n}\n/**\n * This method checks if indexedDB is supported by current browser/service worker context\n * @return true if indexedDB is supported by current browser/service worker context\n */\nfunction isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === 'object';\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\n * if errors occur during the database open operation.\n *\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\n * private browsing)\n */\nfunction validateIndexedDBOpenable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = () => {\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = () => {\n                preExist = false;\n            };\n            request.onerror = () => {\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n *\n * This method checks whether cookie is enabled within current browser\n * @return true if cookie is enabled within current browser\n */\nfunction areCookiesEnabled() {\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // TypeScript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nconst ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(\n    /** The error code for this error. */\n    code, message, \n    /** Custom data for this error. */\n    customData) {\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */\n        this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        // TODO(dlarocque): Replace this with `new.target`: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n        //                   which we can now use since we no longer target ES5.\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : 'Error';\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key) => {\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nfunction jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data JavaScript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nfunction stringify(data) {\n    return JSON.stringify(data);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst decode = function (token) {\n    let header = {}, claims = {}, data = {}, signature = '';\n    try {\n        const parts = token.split('.');\n        header = jsonEval(base64Decode(parts[0]) || '');\n        claims = jsonEval(base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidTimestamp = function (token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (!!now &&\n        !!validSince &&\n        !!validUntil &&\n        now >= validSince &&\n        now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst issuedAtTime = function (token) {\n    const claims = decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidFormat = function (token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isAdmin = function (token) {\n    const claims = decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\n * Deep equal two objects. Support Arrays and Objects.\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys) {\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        }\n        else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys) {\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === 'object';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\n * @internal\n */\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nfunction querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)) {\n        if (Array.isArray(value)) {\n            value.forEach(arrayVal => {\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n            });\n        }\n        else {\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        }\n    }\n    return params.length ? '&' + params.join('&') : '';\n}\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nfunction querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, '').split('&');\n    tokens.forEach(token => {\n        if (token) {\n            const [key, value] = token.split('=');\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\n * Extract the query string part of a URL, including the leading question mark (if present).\n */\nfunction extractQuerystring(url) {\n    const queryStart = url.indexOf('?');\n    if (!queryStart) {\n        return '';\n    }\n    const fragmentStart = url.indexOf('#', queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nclass Sha1 {\n    constructor() {\n        /**\n         * Holds the previous values of accumulated variables a-e in the compress_\n         * function.\n         * @private\n         */\n        this.chain_ = [];\n        /**\n         * A buffer holding the partially computed hash result.\n         * @private\n         */\n        this.buf_ = [];\n        /**\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n         * as the message schedule in the docs.\n         * @private\n         */\n        this.W_ = [];\n        /**\n         * Contains data needed to pad messages less than 64 bytes.\n         * @private\n         */\n        this.pad_ = [];\n        /**\n         * @private {number}\n         */\n        this.inbuf_ = 0;\n        /**\n         * @private {number}\n         */\n        this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for (let i = 1; i < this.blockSize; ++i) {\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\n     * Internal compress helper function.\n     * @param buf Block to compress.\n     * @param offset Offset of the block in the buffer.\n     * @private\n     */\n    compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === 'string') {\n            for (let i = 0; i < 16; i++) {\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] =\n                    (buf.charCodeAt(offset) << 24) |\n                        (buf.charCodeAt(offset + 1) << 16) |\n                        (buf.charCodeAt(offset + 2) << 8) |\n                        buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        }\n        else {\n            for (let i = 0; i < 16; i++) {\n                W[i] =\n                    (buf[offset] << 24) |\n                        (buf[offset + 1] << 16) |\n                        (buf[offset + 2] << 8) |\n                        buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for (let i = 16; i < 80; i++) {\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for (let i = 0; i < 80; i++) {\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ (b & (c ^ d));\n                    k = 0x5a827999;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            }\n            else {\n                if (i < 60) {\n                    f = (b & c) | (d & (b | c));\n                    k = 0x8f1bbcdc;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n            e = d;\n            d = c;\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while (n < length) {\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while (n <= lengthMinusBlock) {\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === 'string') {\n                while (n < length) {\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n            else {\n                while (n < length) {\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */\n    digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        }\n        else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for (let i = this.blockSize - 1; i >= 56; i--) {\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for (let i = 0; i < 5; i++) {\n            for (let j = 24; j >= 0; j -= 8) {\n                digest[n] = (this.chain_[i] >> j) & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    constructor(executor, onNoObservers) {\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(() => {\n            executor(this);\n        })\n            .catch(e => {\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber synchronously to their\n     *   call to subscribe().\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            'next',\n            'error',\n            'complete'\n        ])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(() => {\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args) => {\n        Promise.resolve(true)\n            .then(() => {\n            fn(...args);\n        })\n            .catch((error) => {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (const method of methods) {\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = 'at least ' + minCount;\n    }\n    else if (argCount > maxCount) {\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n    }\n    if (argError) {\n        const error = fnName +\n            ' failed: Was called with ' +\n            argCount +\n            (argCount === 1 ? ' argument.' : ' arguments.') +\n            ' Expects ' +\n            argError +\n            '.';\n        throw new Error(error);\n    }\n};\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argName The name of the argument\n * @return The prefix to add to the error thrown for validation.\n */\nfunction errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nfunction validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== 'string') {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n    }\n}\nfunction validateCallback(fnName, argumentName, \n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== 'function') {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== 'object' || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in JavaScript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\n * @param {string} str\n * @return {Array}\n */\nconst stringToByteArray = function (str) {\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if (c < 65536) {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nconst stringLength = function (str) {\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        }\n        else if (c < 2048) {\n            p += 2;\n        }\n        else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        }\n        else {\n            p += 3;\n        }\n    }\n    return p;\n};\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copied from https://stackoverflow.com/a/2117523\n * Generates a new uuid.\n * @public\n */\nconst uuidv4 = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The amount of milliseconds to exponentially increase.\n */\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\n * The factor to backoff by.\n * Should be a number greater than 1.\n */\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\n * The maximum milliseconds to increase to.\n *\n * <p>Visible for testing\n */\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\n * The percentage of backoff time to randomize by.\n * See\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\n * for context.\n *\n * <p>Visible for testing\n */\nconst RANDOM_FACTOR = 0.5;\n/**\n * Based on the backoff method from\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\n */\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(\n    // A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR *\n        currBaseValue *\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n        // if we add or subtract.\n        (Math.random() - 0.5) *\n        2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provide English ordinal letters after a number\n */\nfunction ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return 'th';\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return 'st';\n    }\n    if (dec === 2) {\n        return 'nd';\n    }\n    if (dec === 3) {\n        return 'rd';\n    }\n    return 'th';\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    }\n    else {\n        return service;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n\nexports.CONSTANTS = CONSTANTS;\nexports.DecodeBase64StringError = DecodeBase64StringError;\nexports.Deferred = Deferred;\nexports.ErrorFactory = ErrorFactory;\nexports.FirebaseError = FirebaseError;\nexports.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS;\nexports.RANDOM_FACTOR = RANDOM_FACTOR;\nexports.Sha1 = Sha1;\nexports.areCookiesEnabled = areCookiesEnabled;\nexports.assert = assert;\nexports.assertionError = assertionError;\nexports.async = async;\nexports.base64 = base64;\nexports.base64Decode = base64Decode;\nexports.base64Encode = base64Encode;\nexports.base64urlEncodeWithoutPadding = base64urlEncodeWithoutPadding;\nexports.calculateBackoffMillis = calculateBackoffMillis;\nexports.contains = contains;\nexports.createMockUserToken = createMockUserToken;\nexports.createSubscribe = createSubscribe;\nexports.decode = decode;\nexports.deepCopy = deepCopy;\nexports.deepEqual = deepEqual;\nexports.deepExtend = deepExtend;\nexports.errorPrefix = errorPrefix;\nexports.extractQuerystring = extractQuerystring;\nexports.getDefaultAppConfig = getDefaultAppConfig;\nexports.getDefaultEmulatorHost = getDefaultEmulatorHost;\nexports.getDefaultEmulatorHostnameAndPort = getDefaultEmulatorHostnameAndPort;\nexports.getDefaults = getDefaults;\nexports.getExperimentalSetting = getExperimentalSetting;\nexports.getGlobal = getGlobal;\nexports.getModularInstance = getModularInstance;\nexports.getUA = getUA;\nexports.isAdmin = isAdmin;\nexports.isBrowser = isBrowser;\nexports.isBrowserExtension = isBrowserExtension;\nexports.isCloudflareWorker = isCloudflareWorker;\nexports.isElectron = isElectron;\nexports.isEmpty = isEmpty;\nexports.isIE = isIE;\nexports.isIndexedDBAvailable = isIndexedDBAvailable;\nexports.isMobileCordova = isMobileCordova;\nexports.isNode = isNode;\nexports.isNodeSdk = isNodeSdk;\nexports.isReactNative = isReactNative;\nexports.isSafari = isSafari;\nexports.isUWP = isUWP;\nexports.isValidFormat = isValidFormat;\nexports.isValidTimestamp = isValidTimestamp;\nexports.isWebWorker = isWebWorker;\nexports.issuedAtTime = issuedAtTime;\nexports.jsonEval = jsonEval;\nexports.map = map;\nexports.ordinal = ordinal;\nexports.promiseWithTimeout = promiseWithTimeout;\nexports.querystring = querystring;\nexports.querystringDecode = querystringDecode;\nexports.safeGet = safeGet;\nexports.stringLength = stringLength;\nexports.stringToByteArray = stringToByteArray;\nexports.stringify = stringify;\nexports.uuidv4 = uuidv4;\nexports.validateArgCount = validateArgCount;\nexports.validateCallback = validateCallback;\nexports.validateContextObject = validateContextObject;\nexports.validateIndexedDBOpenable = validateIndexedDBOpenable;\nexports.validateNamespace = validateNamespace;\n//# sourceMappingURL=index.node.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9pbmRleC5ub2RlLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSx3RUFBd0UsS0FBSzs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixJQUFJLFNBQVMsR0FBRyxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxVQUFVLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsK0JBQStCO0FBQy9CLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsWUFBWTtBQUNaLHlCQUF5QjtBQUN6QixjQUFjO0FBQ2Qsc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYixjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixxQ0FBcUM7QUFDckMsOEJBQThCO0FBQzlCLGdCQUFnQjtBQUNoQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIseUNBQXlDO0FBQ3pDLG1CQUFtQjtBQUNuQiw4QkFBOEI7QUFDOUIsaUJBQWlCO0FBQ2pCLDBCQUEwQjtBQUMxQixhQUFhO0FBQ2IsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsWUFBWTtBQUNaLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixxQkFBcUI7QUFDckIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLFdBQVc7QUFDWCxlQUFlO0FBQ2YsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvaG9tZS9yZ3RlY2gwMDgvYWNhZGVtaWMtY29ubmVjdC1wcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2luZGV4Lm5vZGUuY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBGaXJlYmFzZSBjb25zdGFudHMuICBTb21lIG9mIHRoZXNlIChAZGVmaW5lcykgY2FuIGJlIG92ZXJyaWRkZW4gYXQgY29tcGlsZS10aW1lLlxuICovXG5jb25zdCBDT05TVEFOVFMgPSB7XG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBjbGllbnQgTm9kZS5qcyBTREsuXG4gICAgICovXG4gICAgTk9ERV9DTElFTlQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgQWRtaW4gTm9kZS5qcyBTREsuXG4gICAgICovXG4gICAgTk9ERV9BRE1JTjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRmlyZWJhc2UgU0RLIFZlcnNpb25cbiAgICAgKi9cbiAgICBTREtfVkVSU0lPTjogJyR7SlNDT1JFX1ZFUlNJT059J1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCBhc3NlcnRpb24gaXMgZmFsc3lcbiAqL1xuY29uc3QgYXNzZXJ0ID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgYW4gRXJyb3Igb2JqZWN0IHN1aXRhYmxlIGZvciB0aHJvd2luZy5cbiAqL1xuY29uc3QgYXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZpcmViYXNlIERhdGFiYXNlICgnICtcbiAgICAgICAgQ09OU1RBTlRTLlNES19WRVJTSU9OICtcbiAgICAgICAgJykgSU5URVJOQUwgQVNTRVJUIEZBSUxFRDogJyArXG4gICAgICAgIG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHN0cmluZ1RvQnl0ZUFycmF5JDEgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiZcbiAgICAgICAgICAgIGkgKyAxIDwgc3RyLmxlbmd0aCAmJlxuICAgICAgICAgICAgKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM2ZmKSA8PCAxMCkgKyAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNmZik7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBudW1iZXJzIGludG8gdGhlIHN0cmluZyBnaXZlbiBieSB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAqIGNoYXJhY3RlcnMgdG8gd2hpY2ggdGhlIG51bWJlcnMgY29ycmVzcG9uZC5cbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxuICogQHJldHVybiBTdHJpbmdpZmljYXRpb24gb2YgdGhlIGFycmF5LlxuICovXG5jb25zdCBieXRlQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIC8vIFRPRE8odXNlcik6IFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb25zIGlmL3doZW4gYXZhaWxhYmxlXG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IHBvcyA9IDAsIGMgPSAwO1xuICAgIHdoaWxlIChwb3MgPCBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYzEgPSBieXRlc1twb3MrK107XG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjMSA+IDE5MSAmJiBjMSA8IDIyNCkge1xuICAgICAgICAgICAgY29uc3QgYzIgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDMxKSA8PCA2KSB8IChjMiAmIDYzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYzEgPiAyMzkgJiYgYzEgPCAzNjUpIHtcbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzQgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCB1ID0gKCgoYzEgJiA3KSA8PCAxOCkgfCAoKGMyICYgNjMpIDw8IDEyKSB8ICgoYzMgJiA2MykgPDwgNikgfCAoYzQgJiA2MykpIC1cbiAgICAgICAgICAgICAgICAweDEwMDAwO1xuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgwMCArICh1ID4+IDEwKSk7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkYzAwICsgKHUgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGMzID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAxNSkgPDwgMTIpIHwgKChjMiAmIDYzKSA8PCA2KSB8IChjMyAmIDYzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dC5qb2luKCcnKTtcbn07XG4vLyBXZSBkZWZpbmUgaXQgYXMgYW4gb2JqZWN0IGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNsYXNzIGJlY2F1c2UgYSBjbGFzcyBjb21waWxlZCBkb3duIHRvIGVzNSBjYW4ndFxuLy8gYmUgdHJlZXNoYWtlZC4gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE2OTFcbi8vIFN0YXRpYyBsb29rdXAgbWFwcywgbGF6aWx5IHBvcHVsYXRlZCBieSBpbml0XygpXG4vLyBUT0RPKGRsYXJvY3F1ZSk6IERlZmluZSB0aGlzIGFzIGEgY2xhc3MsIHNpbmNlIHdlIG5vIGxvbmdlciB0YXJnZXQgRVM1LlxuY29uc3QgYmFzZTY0ID0ge1xuICAgIC8qKlxuICAgICAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICBieXRlVG9DaGFyTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXG4gICAgICovXG4gICAgY2hhclRvQnl0ZU1hcF86IG51bGwsXG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byB3ZWJzYWZlIGNoYXJhY3RlcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBieXRlVG9DaGFyTWFwV2ViU2FmZV86IG51bGwsXG4gICAgLyoqXG4gICAgICogTWFwcyB3ZWJzYWZlIGNoYXJhY3RlcnMgdG8gYnl0ZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXG4gICAgLyoqXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxuICAgICAqL1xuICAgIEVOQ09ERURfVkFMU19CQVNFOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonICsgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyArICcwMTIzNDU2Nzg5JyxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJysvPSc7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cbiAgICAgKi9cbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJy1fLic7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXG4gICAgICogc3RhcnRlZCBhdCBNb3ppbGxhIGJ1dCBpcyBub3cgaW1wbGVtZW50ZWQgYnkgbWFueSBicm93c2Vycy4gV2UgdXNlIHRoZVxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxuICAgICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgSEFTX05BVElWRV9TVVBQT1JUOiB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBCb29sZWFuIGluZGljYXRpbmcgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZUJ5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0XygpO1xuICAgICAgICBjb25zdCBieXRlVG9DaGFyTWFwID0gd2ViU2FmZVxuICAgICAgICAgICAgPyB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1xuICAgICAgICAgICAgOiB0aGlzLmJ5dGVUb0NoYXJNYXBfO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSArIDIgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGlucHV0W2kgKyAyXSA6IDA7XG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTEgJiAweDAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcbiAgICAgICAgICAgIGxldCBvdXRCeXRlMyA9ICgoYnl0ZTIgJiAweDBmKSA8PCAyKSB8IChieXRlMyA+PiA2KTtcbiAgICAgICAgICAgIGxldCBvdXRCeXRlNCA9IGJ5dGUzICYgMHgzZjtcbiAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUzKSB7XG4gICAgICAgICAgICAgICAgb3V0Qnl0ZTQgPSA2NDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhdmVCeXRlMikge1xuICAgICAgICAgICAgICAgICAgICBvdXRCeXRlMyA9IDY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTFdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUyXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlM10sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWVuY29kZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBBIHN0cmluZyB0byBlbmNvZGUuXG4gICAgICogQHBhcmFtIHdlYlNhZmUgSWYgdHJ1ZSwgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuY29kZUJ5dGVBcnJheShzdHJpbmdUb0J5dGVBcnJheSQxKGlucHV0KSwgd2ViU2FmZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkZWNvZGVTdHJpbmcoaW5wdXQsIHdlYlNhZmUpIHtcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiBhdG9iKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5VG9TdHJpbmcodGhpcy5kZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXG4gICAgICogYnl0ZXMuICBJZiB0aGUgZW5jb2RlciBkaWQgbm90IGFwcGx5IHBhZGRpbmcsIHRoZSBpbnB1dCBsZW5ndGggbWF5IG5vdFxuICAgICAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgZ3JvdXAgd2lsbCBoYXZlIGZld2VyIHRoYW4gNCBjaGFyYWN0ZXJzLCBhbmRcbiAgICAgKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBkZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIGNvbnN0IGNoYXJUb0J5dGVNYXAgPSB3ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF87XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTIgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiAwO1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTQgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUJhc2U2NFN0cmluZ0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcbiAgICAgICAgICAgIGlmIChieXRlMyAhPT0gNjQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweGYwKSB8IChieXRlMyA+PiAyKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGU0ICE9PSA2NCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweGMwKSB8IGJ5dGU0O1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxuICAgICAqIGFjY2Vzc2luZyBhbnkgb2YgdGhlIHN0YXRpYyBtYXAgdmFyaWFibGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdF8oKSB7XG4gICAgICAgIGlmICghdGhpcy5ieXRlVG9DaGFyTWFwXykge1xuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfID0ge307XG4gICAgICAgICAgICAvLyBXZSB3YW50IHF1aWNrIG1hcHBpbmdzIGJhY2sgYW5kIGZvcnRoLCBzbyB3ZSBwcmVjb21wdXRlIHR3byBtYXBzLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkVOQ09ERURfVkFMUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF9baV0gPSB0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLmJ5dGVUb0NoYXJNYXBfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwV2ViU2FmZV9baV0gPSB0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXV0gPSBpO1xuICAgICAgICAgICAgICAgIC8vIEJlIGZvcmdpdmluZyB3aGVuIGRlY29kaW5nIGFuZCBjb3JyZWN0bHkgZGVjb2RlIGJvdGggZW5jb2RpbmdzLlxuICAgICAgICAgICAgICAgIGlmIChpID49IHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9bdGhpcy5FTkNPREVEX1ZBTFMuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQW4gZXJyb3IgZW5jb3VudGVyZWQgd2hpbGUgZGVjb2RpbmcgYmFzZTY0IHN0cmluZy5cbiAqL1xuY2xhc3MgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcbiAqL1xuY29uc3QgYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5JDEoc3RyKTtcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheSh1dGY4Qnl0ZXMsIHRydWUpO1xufTtcbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nICh3aXRob3V0IFwiLlwiIHBhZGRpbmcgaW4gdGhlIGVuZCkuXG4gKiBlLmcuIFVzZWQgaW4gSlNPTiBXZWIgVG9rZW4gKEpXVCkgcGFydHMuXG4gKi9cbmNvbnN0IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIC8vIFVzZSBiYXNlNjR1cmwgZW5jb2RpbmcgYW5kIHJlbW92ZSBwYWRkaW5nIGluIHRoZSBlbmQgKGRvdCBjaGFyYWN0ZXJzKS5cbiAgICByZXR1cm4gYmFzZTY0RW5jb2RlKHN0cikucmVwbGFjZSgvXFwuL2csICcnKTtcbn07XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBkZWNvZGluZ1xuICpcbiAqIE5PVEU6IERPIE5PVCB1c2UgdGhlIGdsb2JhbCBhdG9iKCkgZnVuY3Rpb24gLSBpdCBkb2VzIE5PVCBzdXBwb3J0IHRoZVxuICogYmFzZTY0VXJsIHZhcmlhbnQgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHN0ciBUbyBiZSBkZWNvZGVkXG4gKiBAcmV0dXJuIERlY29kZWQgcmVzdWx0LCBpZiBwb3NzaWJsZVxuICovXG5jb25zdCBiYXNlNjREZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYmFzZTY0RGVjb2RlIGZhaWxlZDogJywgZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRG8gYSBkZWVwLWNvcHkgb2YgYmFzaWMgSmF2YVNjcmlwdCBPYmplY3RzIG9yIEFycmF5cy5cbiAqL1xuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgICByZXR1cm4gZGVlcEV4dGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcbn1cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gc291cmNlIHRvIHRhcmdldCAocmVjdXJzaXZlbHkgYWxsb3dzIGV4dGVuc2lvblxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxuICogSWYgdGFyZ2V0IGlzIHVuZGVmaW5lZCwgYW4gb2JqZWN0IG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlIHdpbGwgYmUgY3JlYXRlZFxuICogKGFuZCByZXR1cm5lZCkuXG4gKlxuICogV2UgcmVjdXJzaXZlbHkgY29weSBhbGwgY2hpbGQgcHJvcGVydGllcyBvZiBwbGFpbiBPYmplY3RzIGluIHRoZSBzb3VyY2UtIHNvXG4gKiB0aGF0IG5hbWVzcGFjZS0gbGlrZSBkaWN0aW9uYXJpZXMgYXJlIG1lcmdlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHRhcmdldCBjYW4gYmUgYSBmdW5jdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgcHJvcGVydGllcyBpblxuICogdGhlIHNvdXJjZSBPYmplY3QgYXJlIGNvcGllZCBvbnRvIGl0IGFzIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBGdW5jdGlvbi5cbiAqXG4gKiBOb3RlOiB3ZSBkb24ndCBtZXJnZSBfX3Byb3RvX18gdG8gcHJldmVudCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuICAgIHN3aXRjaCAoc291cmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICAgIC8vIFRyZWF0IERhdGVzIGxpa2Ugc2NhbGFyczsgaWYgdGhlIHRhcmdldCBkYXRlIG9iamVjdCBoYWQgYW55IGNoaWxkXG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIC0gdGhleSB3aWxsIGJlIGxvc3QhXG4gICAgICAgICAgICBjb25zdCBkYXRlVmFsdWUgPSBzb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVZhbHVlLmdldFRpbWUoKSk7XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjb3B5IHRoZSBhcnJheSBzb3VyY2UgYW5kIG92ZXJ3cml0ZSB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgdGFyZ2V0ID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIE5vdCBhIHBsYWluIE9iamVjdCAtIHRyZWF0IGl0IGFzIGEgc2NhbGFyLlxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAvLyB1c2UgaXNWYWxpZEtleSB0byBndWFyZCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb24uIFNlZSBodHRwczovL3NueWsuaW8vdnVsbi9TTllLLUpTLUxPREFTSC00NTAyMDJcbiAgICAgICAgaWYgKCFzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgIWlzVmFsaWRLZXkocHJvcCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGRlZXBFeHRlbmQodGFyZ2V0W3Byb3BdLCBzb3VyY2VbcHJvcF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUG9seWZpbGwgZm9yIGBnbG9iYWxUaGlzYCBvYmplY3QuXG4gKiBAcmV0dXJucyB0aGUgYGdsb2JhbFRoaXNgIG9iamVjdCBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdC4nKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGdldERlZmF1bHRzRnJvbUdsb2JhbCA9ICgpID0+IGdldEdsb2JhbCgpLl9fRklSRUJBU0VfREVGQVVMVFNfXztcbi8qKlxuICogQXR0ZW1wdCB0byByZWFkIGRlZmF1bHRzIGZyb20gYSBKU09OIHN0cmluZyBwcm92aWRlZCB0b1xuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfXyBvciBhIEpTT04gZmlsZSB3aG9zZSBwYXRoIGlzIGluXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19QQVRIX19cbiAqIFRoZSBkb3RzIGFyZSBpbiBwYXJlbnMgYmVjYXVzZSBjZXJ0YWluIGNvbXBpbGVycyAoVml0ZT8pIGNhbm5vdFxuICogaGFuZGxlIHNlZWluZyB0aGF0IHZhcmlhYmxlIGluIGNvbW1lbnRzLlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maXJlYmFzZS9maXJlYmFzZS1qcy1zZGsvaXNzdWVzLzY4MzhcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5lbnYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdHNKc29uU3RyaW5nID0gcHJvY2Vzcy5lbnYuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuICAgIGlmIChkZWZhdWx0c0pzb25TdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVmYXVsdHNKc29uU3RyaW5nKTtcbiAgICB9XG59O1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tQ29va2llID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1hdGNoO1xuICAgIHRyeSB7XG4gICAgICAgIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKC9fX0ZJUkVCQVNFX0RFRkFVTFRTX189KFteO10rKS8pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTb21lIGVudmlyb25tZW50cyBzdWNoIGFzIEFuZ3VsYXIgVW5pdmVyc2FsIFNTUiBoYXZlIGFcbiAgICAgICAgLy8gYGRvY3VtZW50YCBvYmplY3QgYnV0IGVycm9yIG9uIGFjY2Vzc2luZyBgZG9jdW1lbnQuY29va2llYC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVkID0gbWF0Y2ggJiYgYmFzZTY0RGVjb2RlKG1hdGNoWzFdKTtcbiAgICByZXR1cm4gZGVjb2RlZCAmJiBKU09OLnBhcnNlKGRlY29kZWQpO1xufTtcbi8qKlxuICogR2V0IHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LiBJdCBjaGVja3MgaW4gb3JkZXI6XG4gKiAoMSkgaWYgc3VjaCBhbiBvYmplY3QgZXhpc3RzIGFzIGEgcHJvcGVydHkgb2YgYGdsb2JhbFRoaXNgXG4gKiAoMikgaWYgc3VjaCBhbiBvYmplY3Qgd2FzIHByb3ZpZGVkIG9uIGEgc2hlbGwgZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqICgzKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgaW4gYSBjb29raWVcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHMgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChnZXREZWZhdWx0c0Zyb21HbG9iYWwoKSB8fFxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUoKSB8fFxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tQ29va2llKCkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2F0Y2gtYWxsIGZvciBiZWluZyB1bmFibGUgdG8gZ2V0IF9fRklSRUJBU0VfREVGQVVMVFNfXyBkdWVcbiAgICAgICAgICogdG8gYW55IGVudmlyb25tZW50IGNhc2Ugd2UgaGF2ZSBub3QgYWNjb3VudGVkIGZvci4gTG9nIHRvXG4gICAgICAgICAqIGluZm8gaW5zdGVhZCBvZiBzd2FsbG93aW5nIHNvIHdlIGNhbiBmaW5kIHRoZXNlIHVua25vd24gY2FzZXNcbiAgICAgICAgICogYW5kIGFkZCBwYXRocyBmb3IgdGhlbSBpZiBuZWVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zb2xlLmluZm8oYFVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZSB0bzogJHtlfWApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxuICogQHJldHVybnMgYSBVUkwgaG9zdCBmb3JtYXR0ZWQgbGlrZSBgMTI3LjAuMC4xOjk5OTlgIG9yIGBbOjoxXTo0MDAwYCBpZiBhdmFpbGFibGVcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCA9IChwcm9kdWN0TmFtZSkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtdWxhdG9ySG9zdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcm9kdWN0TmFtZV07IH07XG4vKipcbiAqIFJldHVybnMgZW11bGF0b3IgaG9zdG5hbWUgYW5kIHBvcnQgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIHBhaXIgb2YgaG9zdG5hbWUgYW5kIHBvcnQgbGlrZSBgW1wiOjoxXCIsIDQwMDBdYCBpZiBhdmFpbGFibGVcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0ID0gKHByb2R1Y3ROYW1lKSA9PiB7XG4gICAgY29uc3QgaG9zdCA9IGdldERlZmF1bHRFbXVsYXRvckhvc3QocHJvZHVjdE5hbWUpO1xuICAgIGlmICghaG9zdCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IGhvc3QubGFzdEluZGV4T2YoJzonKTsgLy8gRmluZGluZyB0aGUgbGFzdCBzaW5jZSBJUHY2IGFkZHIgYWxzbyBoYXMgY29sb25zLlxuICAgIGlmIChzZXBhcmF0b3JJbmRleCA8PSAwIHx8IHNlcGFyYXRvckluZGV4ICsgMSA9PT0gaG9zdC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhvc3QgJHtob3N0fSB3aXRoIG5vIHNlcGFyYXRlIGhvc3RuYW1lIGFuZCBwb3J0IWApO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgY29uc3QgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKHNlcGFyYXRvckluZGV4ICsgMSksIDEwKTtcbiAgICBpZiAoaG9zdFswXSA9PT0gJ1snKSB7XG4gICAgICAgIC8vIEJyYWNrZXQtcXVvdGVkIGBbaXB2NmFkZHJdOnBvcnRgID0+IHJldHVybiBcImlwdjZhZGRyXCIgKHdpdGhvdXQgYnJhY2tldHMpLlxuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDEsIHNlcGFyYXRvckluZGV4IC0gMSksIHBvcnRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtob3N0LnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCksIHBvcnRdO1xuICAgIH1cbn07XG4vKipcbiAqIFJldHVybnMgRmlyZWJhc2UgYXBwIGNvbmZpZyBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldERlZmF1bHRBcHBDb25maWcgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25maWc7IH07XG4vKipcbiAqIFJldHVybnMgYW4gZXhwZXJpbWVudGFsIHNldHRpbmcgb24gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QgKHByb3BlcnRpZXNcbiAqIHByZWZpeGVkIGJ5IFwiX1wiKVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXRFeHBlcmltZW50YWxTZXR0aW5nID0gKG5hbWUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2BfJHtuYW1lfWBdOyB9O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlamVjdCA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXIgQVBJIGludGVybmFscyBhcmUgbm90IHByb21pc2lmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXG4gICAgICogaW52b2tpbmcgcHJvbWlzZXMgaW5saW5lLCB3aGljaCBQcm9taXNlcyBhcmUgZm9yYmlkZGVuIHRvIGRvLiBUaGlzIG1ldGhvZCBhY2NlcHRzIGFuIG9wdGlvbmFsIG5vZGUtc3R5bGUgY2FsbGJhY2tcbiAgICAgKiBhbmQgcmV0dXJucyBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgd2hpY2ggd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgRGVmZXJyZWQncyBwcm9taXNlLlxuICAgICAqL1xuICAgIHdyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gKGVycm9yLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9taXNlLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBvZiBvdXIgY2FsbGJhY2tzIGRvbid0IGV4cGVjdCBhIHZhbHVlIGFuZCBvdXIgb3duIHRlc3RzXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0IHRoYXQgdGhlIHBhcmFtZXRlciBsZW5ndGggaXMgMVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9ja1VzZXJUb2tlbih0b2tlbiwgcHJvamVjdElkKSB7XG4gICAgaWYgKHRva2VuLnVpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcInVpZFwiIGZpZWxkIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYnkgbW9ja1VzZXJUb2tlbi4gUGxlYXNlIHVzZSBcInN1YlwiIGluc3RlYWQgZm9yIEZpcmViYXNlIEF1dGggVXNlciBJRC4nKTtcbiAgICB9XG4gICAgLy8gVW5zZWN1cmVkIEpXVHMgdXNlIFwibm9uZVwiIGFzIHRoZSBhbGdvcml0aG0uXG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgICBhbGc6ICdub25lJyxcbiAgICAgICAgdHlwZTogJ0pXVCdcbiAgICB9O1xuICAgIGNvbnN0IHByb2plY3QgPSBwcm9qZWN0SWQgfHwgJ2RlbW8tcHJvamVjdCc7XG4gICAgY29uc3QgaWF0ID0gdG9rZW4uaWF0IHx8IDA7XG4gICAgY29uc3Qgc3ViID0gdG9rZW4uc3ViIHx8IHRva2VuLnVzZXJfaWQ7XG4gICAgaWYgKCFzdWIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9ja1VzZXJUb2tlbiBtdXN0IGNvbnRhaW4gJ3N1Yicgb3IgJ3VzZXJfaWQnIGZpZWxkIVwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oeyBcbiAgICAgICAgLy8gU2V0IGFsbCByZXF1aXJlZCBmaWVsZHMgdG8gZGVjZW50IGRlZmF1bHRzXG4gICAgICAgIGlzczogYGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS8ke3Byb2plY3R9YCwgYXVkOiBwcm9qZWN0LCBpYXQsIGV4cDogaWF0ICsgMzYwMCwgYXV0aF90aW1lOiBpYXQsIHN1YiwgdXNlcl9pZDogc3ViLCBmaXJlYmFzZToge1xuICAgICAgICAgICAgc2lnbl9pbl9wcm92aWRlcjogJ2N1c3RvbScsXG4gICAgICAgICAgICBpZGVudGl0aWVzOiB7fVxuICAgICAgICB9IH0sIHRva2VuKTtcbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgdGhlIGVtcHR5IHN0cmluZyBhcyBhIHNpZ25hdHVyZS5cbiAgICBjb25zdCBzaWduYXR1cmUgPSAnJztcbiAgICByZXR1cm4gW1xuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShoZWFkZXIpKSxcbiAgICAgICAgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLFxuICAgICAgICBzaWduYXR1cmVcbiAgICBdLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBuYXZpZ2F0b3IudXNlckFnZW50IHN0cmluZyBvciAnJyBpZiBpdCdzIG5vdCBkZWZpbmVkLlxuICogQHJldHVybiB1c2VyIGFnZW50IHN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXRVQSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZWN0IENvcmRvdmEgLyBQaG9uZUdhcCAvIElvbmljIGZyYW1ld29ya3Mgb24gYSBtb2JpbGUgZGV2aWNlLlxuICpcbiAqIERlbGliZXJhdGVseSBkb2VzIG5vdCByZWx5IG9uIGNoZWNraW5nIGBmaWxlOi8vYCBVUkxzIChhcyB0aGlzIGZhaWxzIFBob25lR2FwXG4gKiBpbiB0aGUgUmlwcGxlIGVtdWxhdG9yKSBub3IgQ29yZG92YSBgb25EZXZpY2VSZWFkeWAsIHdoaWNoIHdvdWxkIG5vcm1hbGx5XG4gKiB3YWl0IGZvciBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBpc01vYmlsZUNvcmRvdmEoKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlIFNldHRpbmcgdXAgYW4gYnJvYWRseSBhcHBsaWNhYmxlIGluZGV4IHNpZ25hdHVyZSBmb3IgV2luZG93XG4gICAgICAgIC8vIGp1c3QgdG8gZGVhbCB3aXRoIHRoaXMgY2FzZSB3b3VsZCBwcm9iYWJseSBiZSBhIGJhZCBpZGVhLlxuICAgICAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxuICAgICAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChnZXRVQSgpKSk7XG59XG4vKipcbiAqIERldGVjdCBOb2RlLmpzLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBOb2RlLmpzIGVudmlyb25tZW50IGlzIGRldGVjdGVkIG9yIHNwZWNpZmllZC5cbiAqL1xuLy8gTm9kZSBkZXRlY3Rpb24gbG9naWMgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2lsaWFrYW4vZGV0ZWN0LW5vZGUvXG5mdW5jdGlvbiBpc05vZGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZvcmNlRW52aXJvbm1lbnQgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yY2VFbnZpcm9ubWVudDtcbiAgICBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ25vZGUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnYnJvd3NlcicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIERldGVjdCBCcm93c2VyIEVudmlyb25tZW50LlxuICogTm90ZTogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBjZXJ0YWluIHRlc3QgZnJhbWV3b3JrcyB0aGF0IGFyZSBpbmNvbXBsZXRlbHlcbiAqIG1pbWlja2luZyBhIGJyb3dzZXIsIGFuZCBzaG91bGQgbm90IGxlYWQgdG8gYXNzdW1pbmcgYWxsIGJyb3dzZXIgQVBJcyBhcmVcbiAqIGF2YWlsYWJsZS5cbiAqL1xuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyB8fCBpc1dlYldvcmtlcigpO1xufVxuLyoqXG4gKiBEZXRlY3QgV2ViIFdvcmtlciBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBpc1dlYldvcmtlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSk7XG59XG4vKipcbiAqIERldGVjdCBDbG91ZGZsYXJlIFdvcmtlciBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBpc0Nsb3VkZmxhcmVXb3JrZXIoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnQ2xvdWRmbGFyZS1Xb3JrZXJzJyk7XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJFeHRlbnNpb24oKSB7XG4gICAgY29uc3QgcnVudGltZSA9IHR5cGVvZiBjaHJvbWUgPT09ICdvYmplY3QnXG4gICAgICAgID8gY2hyb21lLnJ1bnRpbWVcbiAgICAgICAgOiB0eXBlb2YgYnJvd3NlciA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gYnJvd3Nlci5ydW50aW1lXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdHlwZW9mIHJ1bnRpbWUgPT09ICdvYmplY3QnICYmIHJ1bnRpbWUuaWQgIT09IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRGV0ZWN0IFJlYWN0IE5hdGl2ZS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3JbJ3Byb2R1Y3QnXSA9PT0gJ1JlYWN0TmF0aXZlJyk7XG59XG4vKiogRGV0ZWN0cyBFbGVjdHJvbiBhcHBzLiAqL1xuZnVuY3Rpb24gaXNFbGVjdHJvbigpIHtcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdFbGVjdHJvbi8nKSA+PSAwO1xufVxuLyoqIERldGVjdHMgSW50ZXJuZXQgRXhwbG9yZXIuICovXG5mdW5jdGlvbiBpc0lFKCkge1xuICAgIGNvbnN0IHVhID0gZ2V0VUEoKTtcbiAgICByZXR1cm4gdWEuaW5kZXhPZignTVNJRSAnKSA+PSAwIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgPj0gMDtcbn1cbi8qKiBEZXRlY3RzIFVuaXZlcnNhbCBXaW5kb3dzIFBsYXRmb3JtIGFwcHMuICovXG5mdW5jdGlvbiBpc1VXUCgpIHtcbiAgICByZXR1cm4gZ2V0VUEoKS5pbmRleE9mKCdNU0FwcEhvc3QvJykgPj0gMDtcbn1cbi8qKlxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgU0RLIGJ1aWxkIGlzIHRoZSBOb2RlIHZlcnNpb24uXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGl0J3MgdGhlIE5vZGUgU0RLIGJ1aWxkLlxuICovXG5mdW5jdGlvbiBpc05vZGVTZGsoKSB7XG4gICAgcmV0dXJuIENPTlNUQU5UUy5OT0RFX0NMSUVOVCA9PT0gdHJ1ZSB8fCBDT05TVEFOVFMuTk9ERV9BRE1JTiA9PT0gdHJ1ZTtcbn1cbi8qKiBSZXR1cm5zIHRydWUgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gU2FmYXJpLiAqL1xuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuICghaXNOb2RlKCkgJiZcbiAgICAgICAgISFuYXZpZ2F0b3IudXNlckFnZW50ICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ1NhZmFyaScpICYmXG4gICAgICAgICFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSk7XG59XG4vKipcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKiBAcmV0dXJuIHRydWUgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxuICovXG5mdW5jdGlvbiBpc0luZGV4ZWREQkF2YWlsYWJsZSgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGluZGV4ZWREQiA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgbWV0aG9kIHZhbGlkYXRlcyBicm93c2VyL3N3IGNvbnRleHQgZm9yIGluZGV4ZWREQiBieSBvcGVuaW5nIGEgZHVtbXkgaW5kZXhlZERCIGRhdGFiYXNlIGFuZCByZWplY3RcbiAqIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIGRhdGFiYXNlIG9wZW4gb3BlcmF0aW9uLlxuICpcbiAqIEB0aHJvd3MgZXhjZXB0aW9uIGlmIGN1cnJlbnQgYnJvd3Nlci9zdyBjb250ZXh0IGNhbid0IHJ1biBpZGIub3BlbiAoZXg6IFNhZmFyaSBpZnJhbWUsIEZpcmVmb3hcbiAqIHByaXZhdGUgYnJvd3NpbmcpXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBwcmVFeGlzdCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBEQl9DSEVDS19OQU1FID0gJ3ZhbGlkYXRlLWJyb3dzZXItY29udGV4dC1mb3ItaW5kZXhlZGRiLWFuYWx5dGljcy1tb2R1bGUnO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHNlbGYuaW5kZXhlZERCLm9wZW4oREJfQ0hFQ0tfTkFNRSk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBkYXRhYmFzZSBvbmx5IHdoZW4gaXQgZG9lc24ndCBwcmUtZXhpc3RcbiAgICAgICAgICAgICAgICBpZiAoIXByZUV4aXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX0NIRUNLX05BTUUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHByZUV4aXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZWplY3QoKChfYSA9IHJlcXVlc3QuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICogQHJldHVybiB0cnVlIGlmIGNvb2tpZSBpcyBlbmFibGVkIHdpdGhpbiBjdXJyZW50IGJyb3dzZXJcbiAqL1xuZnVuY3Rpb24gYXJlQ29va2llc0VuYWJsZWQoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuY29va2llRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFN0YW5kYXJkaXplZCBGaXJlYmFzZSBFcnJvci5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgIC8vIFR5cGVTY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcbiAqICAgdHlwZSBFcnIgPVxuICogICAgICd1bmtub3duJyB8XG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXG4gKiAgICAgO1xuICpcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcbiAqICAgLy8gYXQtZW51bSB7c3RyaW5nfVxuICogICB2YXIgRXJyID0ge1xuICogICAgIFVOS05PV046ICd1bmtub3duJyxcbiAqICAgICBPQkpFQ1RfTk9UX0ZPVU5EOiAnb2JqZWN0LW5vdC1mb3VuZCcsXG4gKiAgIH1cbiAqXG4gKiAgIGxldCBlcnJvcnM6IE1hcDxFcnIsIHN0cmluZz4gPSB7XG4gKiAgICAgJ2dlbmVyaWMtZXJyb3InOiBcIlVua25vd24gZXJyb3JcIixcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcbiAqICAgfTtcbiAqXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXG4gKiAgIGxldCBlcnJvciA9IG5ldyBFcnJvckZhY3Rvcnk8RXJyPignc2VydmljZScsICdTZXJ2aWNlJywgZXJyb3JzKTtcbiAqXG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkdFTkVSSUMpO1xuICogICAuLi5cbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcbiAqICAgLi4uXG4gKiAgIC8vIFNlcnZpY2U6IENvdWxkIG5vdCBmaWxlIGZpbGU6IGZvby50eHQgKHNlcnZpY2UvZmlsZS1ub3QtZm91bmQpLlxuICpcbiAqICAgY2F0Y2ggKGUpIHtcbiAqICAgICBhc3NlcnQoZS5tZXNzYWdlID09PSBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IGZvby50eHQuXCIpO1xuICogICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ3NlcnZpY2UvZmlsZS1ub3QtZm91bmQnKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCByZWFkIGZpbGU6IFwiICsgZVsnZmlsZSddKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqL1xuY29uc3QgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcbi8vIEJhc2VkIG9uIGNvZGUgZnJvbTpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0N1c3RvbV9FcnJvcl9UeXBlc1xuY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIGVycm9yIGNvZGUgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgY29kZSwgbWVzc2FnZSwgXG4gICAgLyoqIEN1c3RvbSBkYXRhIGZvciB0aGlzIGVycm9yLiAqL1xuICAgIGN1c3RvbURhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IGN1c3RvbURhdGE7XG4gICAgICAgIC8qKiBUaGUgY3VzdG9tIG5hbWUgZm9yIGFsbCBGaXJlYmFzZUVycm9ycy4gKi9cbiAgICAgICAgdGhpcy5uYW1lID0gRVJST1JfTkFNRTtcbiAgICAgICAgLy8gRml4IEZvciBFUzVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0LXdpa2kvYmxvYi9tYXN0ZXIvQnJlYWtpbmctQ2hhbmdlcy5tZCNleHRlbmRpbmctYnVpbHQtaW5zLWxpa2UtZXJyb3ItYXJyYXktYW5kLW1hcC1tYXktbm8tbG9uZ2VyLXdvcmtcbiAgICAgICAgLy8gVE9ETyhkbGFyb2NxdWUpOiBSZXBsYWNlIHRoaXMgd2l0aCBgbmV3LnRhcmdldGA6IGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTIuaHRtbCNzdXBwb3J0LWZvci1uZXd0YXJnZXRcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgd2hpY2ggd2UgY2FuIG5vdyB1c2Ugc2luY2Ugd2Ugbm8gbG9uZ2VyIHRhcmdldCBFUzUuXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBGaXJlYmFzZUVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duLlxuICAgICAgICAvLyBPbmx5IGF2YWlsYWJsZSBvbiBWOC5cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFcnJvckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2UsIHNlcnZpY2VOYW1lLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgY3JlYXRlKGNvZGUsIC4uLmRhdGEpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tRGF0YSA9IGRhdGFbMF0gfHwge307XG4gICAgICAgIGNvbnN0IGZ1bGxDb2RlID0gYCR7dGhpcy5zZXJ2aWNlfS8ke2NvZGV9YDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmVycm9yc1tjb2RlXTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRlbXBsYXRlID8gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBjdXN0b21EYXRhKSA6ICdFcnJvcic7XG4gICAgICAgIC8vIFNlcnZpY2UgTmFtZTogRXJyb3IgbWVzc2FnZSAoc2VydmljZS9jb2RlKS5cbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEZpcmViYXNlRXJyb3IoZnVsbENvZGUsIGZ1bGxNZXNzYWdlLCBjdXN0b21EYXRhKTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgZGF0YSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFBBVFRFUk4sIChfLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gU3RyaW5nKHZhbHVlKSA6IGA8JHtrZXl9Pz5gO1xuICAgIH0pO1xufVxuY29uc3QgUEFUVEVSTiA9IC9cXHtcXCQoW159XSspfS9nO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAqL1xuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbn1cbi8qKlxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFTY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBsZXQgaGVhZGVyID0ge30sIGNsYWltcyA9IHt9LCBkYXRhID0ge30sIHNpZ25hdHVyZSA9ICcnO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICAgICAgaGVhZGVyID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzBdKSB8fCAnJyk7XG4gICAgICAgIGNsYWltcyA9IGpzb25FdmFsKGJhc2U2NERlY29kZShwYXJ0c1sxXSkgfHwgJycpO1xuICAgICAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcbiAgICAgICAgZGF0YSA9IGNsYWltc1snZCddIHx8IHt9O1xuICAgICAgICBkZWxldGUgY2xhaW1zWydkJ107XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXIsXG4gICAgICAgIGNsYWltcyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgdGltZS1iYXNlZCBjbGFpbXMuIFdpbGwgcmV0dXJuIHRydWUgaWYgdGhlXG4gKiB0b2tlbiBpcyB3aXRoaW4gdGhlIHRpbWUgd2luZG93IGF1dGhvcml6ZWQgYnkgdGhlICduYmYnIChub3QtYmVmb3JlKSBhbmQgJ2lhdCcgKGlzc3VlZC1hdCkgY2xhaW1zLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc1ZhbGlkVGltZXN0YW1wID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIGxldCB2YWxpZFNpbmNlID0gMCwgdmFsaWRVbnRpbCA9IDA7XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ25iZicpKSB7XG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWyduYmYnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgICAgICAgICB2YWxpZFNpbmNlID0gY2xhaW1zWydpYXQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdleHAnKSkge1xuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IGNsYWltc1snZXhwJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0b2tlbiB3aWxsIGV4cGlyZSBhZnRlciAyNGggYnkgZGVmYXVsdFxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IHZhbGlkU2luY2UgKyA4NjQwMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCEhbm93ICYmXG4gICAgICAgICEhdmFsaWRTaW5jZSAmJlxuICAgICAgICAhIXZhbGlkVW50aWwgJiZcbiAgICAgICAgbm93ID49IHZhbGlkU2luY2UgJiZcbiAgICAgICAgbm93IDw9IHZhbGlkVW50aWwpO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCByZXR1cm5zIGl0cyBpc3N1ZWQgYXQgdGltZSBpZiB2YWxpZCwgbnVsbCBvdGhlcndpc2UuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gbnVsbCBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzc3VlZEF0VGltZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XG4gICAgICAgIHJldHVybiBjbGFpbXNbJ2lhdCddO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzVmFsaWRGb3JtYXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKHRva2VuKSwgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XG4gICAgcmV0dXJuICEhY2xhaW1zICYmIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0Jyk7XG59O1xuLyoqXG4gKiBBdHRlbXB0cyB0byBwZWVyIGludG8gYW4gYXV0aCB0b2tlbiBhbmQgZGV0ZXJtaW5lIGlmIGl0J3MgYW4gYWRtaW4gYXV0aCB0b2tlbiBieSBsb29raW5nIGF0IHRoZSBjbGFpbXMgcG9ydGlvbi5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnMob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmZ1bmN0aW9uIHNhZmVHZXQob2JqLCBrZXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXAob2JqLCBmbiwgY29udGV4dE9iaikge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgcmVzW2tleV0gPSBmbi5jYWxsKGNvbnRleHRPYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogRGVlcCBlcXVhbCB0d28gb2JqZWN0cy4gU3VwcG9ydCBBcnJheXMgYW5kIE9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgYUtleXMpIHtcbiAgICAgICAgaWYgKCFiS2V5cy5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFQcm9wID0gYVtrXTtcbiAgICAgICAgY29uc3QgYlByb3AgPSBiW2tdO1xuICAgICAgICBpZiAoaXNPYmplY3QoYVByb3ApICYmIGlzT2JqZWN0KGJQcm9wKSkge1xuICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWwoYVByb3AsIGJQcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhUHJvcCAhPT0gYlByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGsgb2YgYktleXMpIHtcbiAgICAgICAgaWYgKCFhS2V5cy5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmVqZWN0cyBpZiB0aGUgZ2l2ZW4gcHJvbWlzZSBkb2Vzbid0IHJlc29sdmUgaW4gdGltZUluTVMgbWlsbGlzZWNvbmRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dChwcm9taXNlLCB0aW1lSW5NUyA9IDIwMDApIHtcbiAgICBjb25zdCBkZWZlcnJlZFByb21pc2UgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IGRlZmVycmVkUHJvbWlzZS5yZWplY3QoJ3RpbWVvdXQhJyksIHRpbWVJbk1TKTtcbiAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWRQcm9taXNlLnJlc29sdmUsIGRlZmVycmVkUHJvbWlzZS5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZFByb21pc2UucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIHF1ZXJ5c3RyaW5nLWZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJmFyZz12YWwmYXJnMj12YWwyKSBmcm9tIGFcbiAqIHBhcmFtcyBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnlzdHJpbmdQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeXN0cmluZ1BhcmFtcykpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGFycmF5VmFsID0+IHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChhcnJheVZhbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoID8gJyYnICsgcGFyYW1zLmpvaW4oJyYnKSA6ICcnO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgcXVlcnlzdHJpbmcgKGUuZy4gP2FyZz12YWwmYXJnMj12YWwyKSBpbnRvIGEgcGFyYW1zIG9iamVjdFxuICogKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nRGVjb2RlKHF1ZXJ5c3RyaW5nKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG4gICAgY29uc3QgdG9rZW5zID0gcXVlcnlzdHJpbmcucmVwbGFjZSgvXlxcPy8sICcnKS5zcGxpdCgnJicpO1xuICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSB0b2tlbi5zcGxpdCgnPScpO1xuICAgICAgICAgICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBFeHRyYWN0IHRoZSBxdWVyeSBzdHJpbmcgcGFydCBvZiBhIFVSTCwgaW5jbHVkaW5nIHRoZSBsZWFkaW5nIHF1ZXN0aW9uIG1hcmsgKGlmIHByZXNlbnQpLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UXVlcnlzdHJpbmcodXJsKSB7XG4gICAgY29uc3QgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKCFxdWVyeVN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgZnJhZ21lbnRTdGFydCA9IHVybC5pbmRleE9mKCcjJywgcXVlcnlTdGFydCk7XG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcocXVlcnlTdGFydCwgZnJhZ21lbnRTdGFydCA+IDAgPyBmcmFnbWVudFN0YXJ0IDogdW5kZWZpbmVkKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2guXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXG4gKlxuICogVXNhZ2U6XG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcbiAqICAgc2hhMS51cGRhdGUoYnl0ZXMpO1xuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XG4gKlxuICogUGVyZm9ybWFuY2U6XG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcbiAqXG4gKi9cbi8qKlxuICogU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqL1xuY2xhc3MgU2hhMSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGFjY3VtdWxhdGVkIHZhcmlhYmxlcyBhLWUgaW4gdGhlIGNvbXByZXNzX1xuICAgICAgICAgKiBmdW5jdGlvbi5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hhaW5fID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJ1ZmZlciBob2xkaW5nIHRoZSBwYXJ0aWFsbHkgY29tcHV0ZWQgaGFzaCByZXN1bHQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJ1Zl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9mIDgwIGJ5dGVzLCBlYWNoIGEgcGFydCBvZiB0aGUgbWVzc2FnZSB0byBiZSBoYXNoZWQuICBSZWZlcnJlZCB0b1xuICAgICAgICAgKiBhcyB0aGUgbWVzc2FnZSBzY2hlZHVsZSBpbiB0aGUgZG9jcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuV18gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRhaW5zIGRhdGEgbmVlZGVkIHRvIHBhZCBtZXNzYWdlcyBsZXNzIHRoYW4gNjQgYnl0ZXMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZF8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IDUxMiAvIDg7XG4gICAgICAgIHRoaXMucGFkX1swXSA9IDEyODtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnBhZF9baV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAweGVmY2RhYjg5O1xuICAgICAgICB0aGlzLmNoYWluX1syXSA9IDB4OThiYWRjZmU7XG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAweGMzZDJlMWYwO1xuICAgICAgICB0aGlzLmluYnVmXyA9IDA7XG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBidWYgQmxvY2sgdG8gY29tcHJlc3MuXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgdGhlIGJsb2NrIGluIHRoZSBidWZmZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb21wcmVzc18oYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgVyA9IHRoaXMuV187XG4gICAgICAgIC8vIGdldCAxNiBiaWcgZW5kaWFuIHdvcmRzXG4gICAgICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyh1c2VyKTogW2J1ZyA4MTQwMTIyXSBSZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpIGZvciBNYWMgT1MgYW5kIGlPU1xuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBidWcgdGhhdCB0dXJucyB0aGUgcG9zdC1pbmNyZW1lbnQgKysgb3BlcmF0b3IgaW50byBwcmUtaW5jcmVtZW50XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0bmVzcyBhbmQgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBidWcsIHNvIEkndmUgcmVtb3ZlZCBhbGwgdXNlc1xuICAgICAgICAgICAgICAgIC8vIG9mIHBvc3QtaW5jcmVtZW50ICsrIGluIHdoaWNoIHRoZSByZXN1bHQgdmFsdWUgaXMgdXNlZC4gIFdlIGNhbiByZXZlcnRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXG4gICAgICAgICAgICAgICAgLy8gKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDkwMzYpIGhhcyBiZWVuIGZpeGVkIGFuZFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgY2xpZW50cyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDMpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgV1tpXSA9XG4gICAgICAgICAgICAgICAgICAgIChidWZbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZbb2Zmc2V0ICsgM107XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuICAgICAgICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYSA9IHRoaXMuY2hhaW5fWzBdO1xuICAgICAgICBsZXQgYiA9IHRoaXMuY2hhaW5fWzFdO1xuICAgICAgICBsZXQgYyA9IHRoaXMuY2hhaW5fWzJdO1xuICAgICAgICBsZXQgZCA9IHRoaXMuY2hhaW5fWzNdO1xuICAgICAgICBsZXQgZSA9IHRoaXMuY2hhaW5fWzRdO1xuICAgICAgICBsZXQgZiwgaztcbiAgICAgICAgLy8gVE9ETyh1c2VyKTogVHJ5IHRvIHVucm9sbCB0aGlzIGxvb3AgdG8gc3BlZWQgdXAgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg2ZWQ5ZWJhMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGQgJiAoYiB8IGMpKTtcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4OGYxYmJjZGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHhjYTYyYzFkNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgIGEgPSB0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gKHRoaXMuY2hhaW5fWzBdICsgYSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9ICh0aGlzLmNoYWluX1sxXSArIGIpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gKHRoaXMuY2hhaW5fWzNdICsgZCkgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9ICh0aGlzLmNoYWluX1s0XSArIGUpICYgMHhmZmZmZmZmZjtcbiAgICB9XG4gICAgdXBkYXRlKGJ5dGVzLCBsZW5ndGgpIHtcbiAgICAgICAgLy8gVE9ETyhqb2hubGVueik6IHRpZ2h0ZW4gdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBhbmQgcmVtb3ZlIHRoaXMgY2hlY2tcbiAgICAgICAgaWYgKGJ5dGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgLy8gVXNpbmcgbG9jYWwgaW5zdGVhZCBvZiBtZW1iZXIgdmFyaWFibGVzIGdpdmVzIH41JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcbiAgICAgICAgbGV0IGluYnVmID0gdGhpcy5pbmJ1Zl87XG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgbm8gZGF0YSBpbiB0aGUgYmxvY2sgdG8gdG9wIHVwLCB3ZSBjYW4gZGlyZWN0bHkgcHJvY2VzcyB0aGVcbiAgICAgICAgICAgIC8vIGlucHV0IGJ1ZmZlciAoYXNzdW1pbmcgaXQgY29udGFpbnMgc3VmZmljaWVudCBkYXRhKS4gVGhpcyBnaXZlcyB+MjUlXG4gICAgICAgICAgICAvLyBzcGVlZHVwIG9uIENocm9tZSAyMyBhbmQgfjE1JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYsIGJ1dCByZXF1aXJlcyB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgZGF0YSBpcyBwcm92aWRlZCBpbiBsYXJnZSBjaHVua3MgKG9yIGluIG11bHRpcGxlcyBvZiA2NCBieXRlcykuXG4gICAgICAgICAgICBpZiAoaW5idWYgPT09IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ5dGVzLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlcy5jaGFyQ29kZUF0KG4pO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltpbmJ1Zl0gPSBieXRlc1tuXTtcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcbiAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcbiAgICAgICAgdGhpcy50b3RhbF8gKz0gbGVuZ3RoO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBbXTtcbiAgICAgICAgbGV0IHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcbiAgICAgICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxuICAgICAgICBpZiAodGhpcy5pbmJ1Zl8gPCA1Nikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCAjIGJpdHMuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xuICAgICAgICAgICAgdG90YWxCaXRzIC89IDI1NjsgLy8gRG9uJ3QgdXNlIGJpdC1zaGlmdGluZyBoZXJlIVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgICAgICAgICAgICBkaWdlc3Rbbl0gPSAodGhpcy5jaGFpbl9baV0gPj4gaikgJiAyNTU7XG4gICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWdlc3Q7XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byBtYWtlIGEgU3Vic2NyaWJlIGZ1bmN0aW9uIChqdXN0IGxpa2UgUHJvbWlzZSBoZWxwcyBtYWtlIGFcbiAqIFRoZW5hYmxlKS5cbiAqXG4gKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAqICAgICBhcyBhIHByb3h5LlxuICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmUoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICBjb25zdCBwcm94eSA9IG5ldyBPYnNlcnZlclByb3h5KGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKTtcbiAgICByZXR1cm4gcHJveHkuc3Vic2NyaWJlLmJpbmQocHJveHkpO1xufVxuLyoqXG4gKiBJbXBsZW1lbnQgZmFuLW91dCBmb3IgYW55IG51bWJlciBvZiBPYnNlcnZlcnMgYXR0YWNoZWQgdmlhIGEgc3Vic2NyaWJlXG4gKiBmdW5jdGlvbi5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXJQcm94eSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gICAgICogICAgIGFzIGEgcHJveHkuXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVzID0gW107XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XG4gICAgICAgIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxuICAgICAgICB0aGlzLnRhc2sgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcbiAgICAgICAgLy8gQ2FsbCB0aGUgZXhlY3V0b3IgYXN5bmNocm9ub3VzbHkgc28gc3Vic2NyaWJlcnMgdGhhdCBhcmUgY2FsbGVkXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cbiAgICAgICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cbiAgICAgICAgdGhpcy50YXNrXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBleGVjdXRvcih0aGlzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cbiAgICAgKlxuICAgICAqIC0gV2UgcmVxdWlyZSB0aGF0IG5vIGV2ZW50IGlzIHNlbnQgdG8gYSBzdWJzY3JpYmVyIHN5bmNocm9ub3VzbHkgdG8gdGhlaXJcbiAgICAgKiAgIGNhbGwgdG8gc3Vic2NyaWJlKCkuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgbGV0IG9ic2VydmVyO1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc2VtYmxlIGFuIE9ic2VydmVyIG9iamVjdCB3aGVuIHBhc3NlZCBhcyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgW1xuICAgICAgICAgICAgJ25leHQnLFxuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdjb21wbGV0ZSdcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0T3JPYnNlcnZlcixcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5zdWIgPSB0aGlzLnVuc3Vic2NyaWJlT25lLmJpbmQodGhpcywgdGhpcy5vYnNlcnZlcnMubGVuZ3RoKTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBzdWJzY3JpYmUgdG8gYSB0ZXJtaW5hdGVkIE9ic2VydmFibGUgLSB3ZVxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXG4gICAgICAgIC8vIGV2ZW50LlxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcih0aGlzLmZpbmFsRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gdW5zdWI7XG4gICAgfVxuICAgIC8vIFVuc3Vic2NyaWJlIGlzIHN5bmNocm9ub3VzIC0gd2UgZ3VhcmFudGVlIHRoYXQgbm8gZXZlbnRzIGFyZSBzZW50IHRvXG4gICAgLy8gYW55IHVuc3Vic2NyaWJlZCBPYnNlcnZlci5cbiAgICB1bnN1YnNjcmliZU9uZShpKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMub2JzZXJ2ZXJzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbaV07XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnModGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaE9ic2VydmVyKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBjbG9zZWQgYnkgcHJldmlvdXMgZXZlbnQuLi4uanVzdCBlYXQgdGhlIGFkZGl0aW9uYWwgdmFsdWVzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHNlbmRPbmUgY2FsbHMgYXN5bmNocm9ub3VzbHkgLSB0aGVyZSBpcyBubyBjaGFuY2UgdGhhdFxuICAgICAgICAvLyB0aGlzLm9ic2VydmVycyB3aWxsIGJlY29tZSB1bmRlZmluZWQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xuICAgIC8vIGNvbmZpcm0gdGhhdCB0aGUgb2JzZXJ2ZSBoYXMgbm90IGJlZW4gdW5zdWJzY3JpYmVkIHNpbmNlIHRoaXMgYXN5bmNocm9ub3VzXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxuICAgIHNlbmRPbmUoaSwgZm4pIHtcbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9ic2VydmVyc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxuICAgICAgICAgICAgICAgICAgICAvLyBPYnNlcnZlci5cbiAgICAgICAgICAgICAgICAgICAgLy8gTG9nIGVycm9yIHRvIGNvbnNvbGUuIGIvMzE0MDQ4MDZcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2UoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsRXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJveHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIGdhcmJhZ2UgY29sbGVjdCByZWZlcmVuY2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUdXJuIHN5bmNocm9ub3VzIGZ1bmN0aW9uIGludG8gb25lIGNhbGxlZCBhc3luY2hyb25vdXNseS4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG5mdW5jdGlvbiBhc3luYyhmbiwgb25FcnJvcikge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgIGlmIChtZXRob2QgaW4gb2JqICYmIHR5cGVvZiBvYmpbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBkbyBub3RoaW5nXG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICpcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSBhcmdDb3VudCBUaGUgYWN0dWFsIG51bWJlciBvZiBhcmd1bWVudHMgcHJvdmlkZWQuXG4gKi9cbmNvbnN0IHZhbGlkYXRlQXJnQ291bnQgPSBmdW5jdGlvbiAoZm5OYW1lLCBtaW5Db3VudCwgbWF4Q291bnQsIGFyZ0NvdW50KSB7XG4gICAgbGV0IGFyZ0Vycm9yO1xuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xuICAgICAgICBhcmdFcnJvciA9IG1heENvdW50ID09PSAwID8gJ25vbmUnIDogJ25vIG1vcmUgdGhhbiAnICsgbWF4Q291bnQ7XG4gICAgfVxuICAgIGlmIChhcmdFcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvciA9IGZuTmFtZSArXG4gICAgICAgICAgICAnIGZhaWxlZDogV2FzIGNhbGxlZCB3aXRoICcgK1xuICAgICAgICAgICAgYXJnQ291bnQgK1xuICAgICAgICAgICAgKGFyZ0NvdW50ID09PSAxID8gJyBhcmd1bWVudC4nIDogJyBhcmd1bWVudHMuJykgK1xuICAgICAgICAgICAgJyBFeHBlY3RzICcgK1xuICAgICAgICAgICAgYXJnRXJyb3IgK1xuICAgICAgICAgICAgJy4nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIH1cbn07XG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxuICpcbiAqIEBwYXJhbSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWVcbiAqIEBwYXJhbSBhcmdOYW1lIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgdGhyb3duIGZvciB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWUsIGFyZ05hbWUpIHtcbiAgICByZXR1cm4gYCR7Zm5OYW1lfSBmYWlsZWQ6ICR7YXJnTmFtZX0gYXJndW1lbnQgYDtcbn1cbi8qKlxuICogQHBhcmFtIGZuTmFtZVxuICogQHBhcmFtIGFyZ3VtZW50TnVtYmVyXG4gKiBAcGFyYW0gbmFtZXNwYWNlXG4gKiBAcGFyYW0gb3B0aW9uYWxcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBuYW1lc3BhY2UsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9UT0RPOiBJIHNob3VsZCBkbyBtb3JlIHZhbGlkYXRpb24gaGVyZS4gV2Ugb25seSBhbGxvdyBjZXJ0YWluIGNoYXJzIGluIG5hbWVzcGFjZXMuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICduYW1lc3BhY2UnKSArICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCBhcmd1bWVudE5hbWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmNhbGxiYWNrLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgKyAnbXVzdCBiZSBhIHZhbGlkIGZ1bmN0aW9uLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dE9iamVjdChmbk5hbWUsIGFyZ3VtZW50TmFtZSwgY29udGV4dCwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnIHx8IGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XG4vLyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkICdcXHJcXG4nIHdpdGggJ1xcbicsIGFuZCB0aGV5IGRpZG4ndCBoYW5kbGUgc3Vycm9nYXRlIHBhaXJzLFxuLy8gc28gaXQncyBiZWVuIG1vZGlmaWVkLlxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXG4vLyBmcm9tQ2hhckNvZGUgcmV0dXJucyB0aGUgVVRGLTE2IGVuY29kaW5nIG9mIGEgY2hhcmFjdGVyIC0gc28gc29tZSBVbmljb2RlIGNoYXJhY3RlcnNcbi8vIHVzZSAyIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdC4gIEFsbCA0LWJ5dGUgVVRGLTggY2hhcmFjdGVycyBiZWdpbiB3aXRoIGEgZmlyc3Rcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxuLy8gcGFpcikuXG4vLyBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjEuM1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IHAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XG4gICAgICAgIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IGMgLSAweGQ4MDA7IC8vIHRoZSBoaWdoIDEwIGJpdHMuXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBhc3NlcnQoaSA8IHN0ci5sZW5ndGgsICdTdXJyb2dhdGUgcGFpciBtaXNzaW5nIHRyYWlsIHN1cnJvZ2F0ZS4nKTtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgNjU1MzYpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3Qgc3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBwKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIHAgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cbiAgICAgICAgICAgIHAgKz0gNDtcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb3BpZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjExNzUyM1xuICogR2VuZXJhdGVzIGEgbmV3IHV1aWQuXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHV1aWR2NCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cG9uZW50aWFsbHkgaW5jcmVhc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcbi8qKlxuICogVGhlIGZhY3RvciB0byBiYWNrb2ZmIGJ5LlxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxuICovXG5jb25zdCBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SID0gMjtcbi8qKlxuICogVGhlIG1heGltdW0gbWlsbGlzZWNvbmRzIHRvIGluY3JlYXNlIHRvLlxuICpcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcbiAqL1xuY29uc3QgTUFYX1ZBTFVFX01JTExJUyA9IDQgKiA2MCAqIDYwICogMTAwMDsgLy8gRm91ciBob3VycywgbGlrZSBpT1MgYW5kIEFuZHJvaWQuXG4vKipcbiAqIFRoZSBwZXJjZW50YWdlIG9mIGJhY2tvZmYgdGltZSB0byByYW5kb21pemUgYnkuXG4gKiBTZWVcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xuICogZm9yIGNvbnRleHQuXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5jb25zdCBSQU5ET01fRkFDVE9SID0gMC41O1xuLyoqXG4gKiBCYXNlZCBvbiB0aGUgYmFja29mZiBtZXRob2QgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvY2xvc3VyZS9nb29nL21hdGgvZXhwb25lbnRpYWxiYWNrb2ZmLmpzLlxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVCYWNrb2ZmTWlsbGlzKGJhY2tvZmZDb3VudCwgaW50ZXJ2YWxNaWxsaXMgPSBERUZBVUxUX0lOVEVSVkFMX01JTExJUywgYmFja29mZkZhY3RvciA9IERFRkFVTFRfQkFDS09GRl9GQUNUT1IpIHtcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cbiAgICAvLyBEZXZpYXRpb246IGNhbGN1bGF0ZXMgdmFsdWUgZnJvbSBjb3VudCBhbmQgYSBjb25zdGFudCBpbnRlcnZhbCwgc28gd2Ugb25seSBuZWVkIHRvIHNhdmUgdmFsdWVcbiAgICAvLyBhbmQgY291bnQgdG8gcmVzdG9yZSBzdGF0ZS5cbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xuICAgIC8vIEEgcmFuZG9tIFwiZnV6elwiIHRvIGF2b2lkIHdhdmVzIG9mIHJldHJpZXMuXG4gICAgLy8gRGV2aWF0aW9uOiByYW5kb21GYWN0b3IgaXMgcmVxdWlyZWQuXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXG4gICAgLy8gQSBmcmFjdGlvbiBvZiB0aGUgYmFja29mZiB2YWx1ZSB0byBhZGQvc3VidHJhY3QuXG4gICAgLy8gRGV2aWF0aW9uOiBjaGFuZ2VzIG11bHRpcGxpY2F0aW9uIG9yZGVyIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkuXG4gICAgUkFORE9NX0ZBQ1RPUiAqXG4gICAgICAgIGN1cnJCYXNlVmFsdWUgKlxuICAgICAgICAvLyBBIHJhbmRvbSBmbG9hdCAocm91bmRlZCB0byBpbnQgYnkgTWF0aC5yb3VuZCBhYm92ZSkgaW4gdGhlIHJhbmdlIFstMSwgMV0uIERldGVybWluZXNcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxuICAgICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKlxuICAgICAgICAyKTtcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXG4gICAgcmV0dXJuIE1hdGgubWluKE1BWF9WQUxVRV9NSUxMSVMsIGN1cnJCYXNlVmFsdWUgKyByYW5kb21XYWl0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZSBFbmdsaXNoIG9yZGluYWwgbGV0dGVycyBhZnRlciBhIG51bWJlclxuICovXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpKSkge1xuICAgICAgICByZXR1cm4gYCR7aX1gO1xuICAgIH1cbiAgICByZXR1cm4gaSArIGluZGljYXRvcihpKTtcbn1cbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XG4gICAgaSA9IE1hdGguYWJzKGkpO1xuICAgIGNvbnN0IGNlbnQgPSBpICUgMTAwO1xuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcbiAgICAgICAgcmV0dXJuICd0aCc7XG4gICAgfVxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcbiAgICBpZiAoZGVjID09PSAxKSB7XG4gICAgICAgIHJldHVybiAnc3QnO1xuICAgIH1cbiAgICBpZiAoZGVjID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnbmQnO1xuICAgIH1cbiAgICBpZiAoZGVjID09PSAzKSB7XG4gICAgICAgIHJldHVybiAncmQnO1xuICAgIH1cbiAgICByZXR1cm4gJ3RoJztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XG4gICAgaWYgKHNlcnZpY2UgJiYgc2VydmljZS5fZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2UuX2RlbGVnYXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gT3ZlcnJpZGluZyB0aGUgY29uc3RhbnQgKHdlIHNob3VsZCBiZSB0aGUgb25seSBvbmVzIGRvaW5nIHRoaXMpXG5DT05TVEFOVFMuTk9ERV9DTElFTlQgPSB0cnVlO1xuXG5leHBvcnRzLkNPTlNUQU5UUyA9IENPTlNUQU5UUztcbmV4cG9ydHMuRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IgPSBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcjtcbmV4cG9ydHMuRGVmZXJyZWQgPSBEZWZlcnJlZDtcbmV4cG9ydHMuRXJyb3JGYWN0b3J5ID0gRXJyb3JGYWN0b3J5O1xuZXhwb3J0cy5GaXJlYmFzZUVycm9yID0gRmlyZWJhc2VFcnJvcjtcbmV4cG9ydHMuTUFYX1ZBTFVFX01JTExJUyA9IE1BWF9WQUxVRV9NSUxMSVM7XG5leHBvcnRzLlJBTkRPTV9GQUNUT1IgPSBSQU5ET01fRkFDVE9SO1xuZXhwb3J0cy5TaGExID0gU2hhMTtcbmV4cG9ydHMuYXJlQ29va2llc0VuYWJsZWQgPSBhcmVDb29raWVzRW5hYmxlZDtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5hc3NlcnRpb25FcnJvciA9IGFzc2VydGlvbkVycm9yO1xuZXhwb3J0cy5hc3luYyA9IGFzeW5jO1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG5leHBvcnRzLmJhc2U2NERlY29kZSA9IGJhc2U2NERlY29kZTtcbmV4cG9ydHMuYmFzZTY0RW5jb2RlID0gYmFzZTY0RW5jb2RlO1xuZXhwb3J0cy5iYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyA9IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nO1xuZXhwb3J0cy5jYWxjdWxhdGVCYWNrb2ZmTWlsbGlzID0gY2FsY3VsYXRlQmFja29mZk1pbGxpcztcbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcbmV4cG9ydHMuY3JlYXRlTW9ja1VzZXJUb2tlbiA9IGNyZWF0ZU1vY2tVc2VyVG9rZW47XG5leHBvcnRzLmNyZWF0ZVN1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmliZTtcbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xuZXhwb3J0cy5kZWVwRXF1YWwgPSBkZWVwRXF1YWw7XG5leHBvcnRzLmRlZXBFeHRlbmQgPSBkZWVwRXh0ZW5kO1xuZXhwb3J0cy5lcnJvclByZWZpeCA9IGVycm9yUHJlZml4O1xuZXhwb3J0cy5leHRyYWN0UXVlcnlzdHJpbmcgPSBleHRyYWN0UXVlcnlzdHJpbmc7XG5leHBvcnRzLmdldERlZmF1bHRBcHBDb25maWcgPSBnZXREZWZhdWx0QXBwQ29uZmlnO1xuZXhwb3J0cy5nZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdDtcbmV4cG9ydHMuZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0O1xuZXhwb3J0cy5nZXREZWZhdWx0cyA9IGdldERlZmF1bHRzO1xuZXhwb3J0cy5nZXRFeHBlcmltZW50YWxTZXR0aW5nID0gZ2V0RXhwZXJpbWVudGFsU2V0dGluZztcbmV4cG9ydHMuZ2V0R2xvYmFsID0gZ2V0R2xvYmFsO1xuZXhwb3J0cy5nZXRNb2R1bGFySW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2U7XG5leHBvcnRzLmdldFVBID0gZ2V0VUE7XG5leHBvcnRzLmlzQWRtaW4gPSBpc0FkbWluO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLmlzQnJvd3NlckV4dGVuc2lvbiA9IGlzQnJvd3NlckV4dGVuc2lvbjtcbmV4cG9ydHMuaXNDbG91ZGZsYXJlV29ya2VyID0gaXNDbG91ZGZsYXJlV29ya2VyO1xuZXhwb3J0cy5pc0VsZWN0cm9uID0gaXNFbGVjdHJvbjtcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLmlzSUUgPSBpc0lFO1xuZXhwb3J0cy5pc0luZGV4ZWREQkF2YWlsYWJsZSA9IGlzSW5kZXhlZERCQXZhaWxhYmxlO1xuZXhwb3J0cy5pc01vYmlsZUNvcmRvdmEgPSBpc01vYmlsZUNvcmRvdmE7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmV4cG9ydHMuaXNOb2RlU2RrID0gaXNOb2RlU2RrO1xuZXhwb3J0cy5pc1JlYWN0TmF0aXZlID0gaXNSZWFjdE5hdGl2ZTtcbmV4cG9ydHMuaXNTYWZhcmkgPSBpc1NhZmFyaTtcbmV4cG9ydHMuaXNVV1AgPSBpc1VXUDtcbmV4cG9ydHMuaXNWYWxpZEZvcm1hdCA9IGlzVmFsaWRGb3JtYXQ7XG5leHBvcnRzLmlzVmFsaWRUaW1lc3RhbXAgPSBpc1ZhbGlkVGltZXN0YW1wO1xuZXhwb3J0cy5pc1dlYldvcmtlciA9IGlzV2ViV29ya2VyO1xuZXhwb3J0cy5pc3N1ZWRBdFRpbWUgPSBpc3N1ZWRBdFRpbWU7XG5leHBvcnRzLmpzb25FdmFsID0ganNvbkV2YWw7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMub3JkaW5hbCA9IG9yZGluYWw7XG5leHBvcnRzLnByb21pc2VXaXRoVGltZW91dCA9IHByb21pc2VXaXRoVGltZW91dDtcbmV4cG9ydHMucXVlcnlzdHJpbmcgPSBxdWVyeXN0cmluZztcbmV4cG9ydHMucXVlcnlzdHJpbmdEZWNvZGUgPSBxdWVyeXN0cmluZ0RlY29kZTtcbmV4cG9ydHMuc2FmZUdldCA9IHNhZmVHZXQ7XG5leHBvcnRzLnN0cmluZ0xlbmd0aCA9IHN0cmluZ0xlbmd0aDtcbmV4cG9ydHMuc3RyaW5nVG9CeXRlQXJyYXkgPSBzdHJpbmdUb0J5dGVBcnJheTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZXhwb3J0cy51dWlkdjQgPSB1dWlkdjQ7XG5leHBvcnRzLnZhbGlkYXRlQXJnQ291bnQgPSB2YWxpZGF0ZUFyZ0NvdW50O1xuZXhwb3J0cy52YWxpZGF0ZUNhbGxiYWNrID0gdmFsaWRhdGVDYWxsYmFjaztcbmV4cG9ydHMudmFsaWRhdGVDb250ZXh0T2JqZWN0ID0gdmFsaWRhdGVDb250ZXh0T2JqZWN0O1xuZXhwb3J0cy52YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlID0gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZTtcbmV4cG9ydHMudmFsaWRhdGVOYW1lc3BhY2UgPSB2YWxpZGF0ZU5hbWVzcGFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuY2pzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/index.node.cjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js":
/*!**************************************************************!*\
  !*** ./node_modules/@firebase/app/dist/esm/index.esm2017.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: () => (/* reexport safe */ _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError),\n/* harmony export */   SDK_VERSION: () => (/* binding */ SDK_VERSION),\n/* harmony export */   _DEFAULT_ENTRY_NAME: () => (/* binding */ DEFAULT_ENTRY_NAME),\n/* harmony export */   _addComponent: () => (/* binding */ _addComponent),\n/* harmony export */   _addOrOverwriteComponent: () => (/* binding */ _addOrOverwriteComponent),\n/* harmony export */   _apps: () => (/* binding */ _apps),\n/* harmony export */   _clearComponents: () => (/* binding */ _clearComponents),\n/* harmony export */   _components: () => (/* binding */ _components),\n/* harmony export */   _getProvider: () => (/* binding */ _getProvider),\n/* harmony export */   _isFirebaseApp: () => (/* binding */ _isFirebaseApp),\n/* harmony export */   _isFirebaseServerApp: () => (/* binding */ _isFirebaseServerApp),\n/* harmony export */   _registerComponent: () => (/* binding */ _registerComponent),\n/* harmony export */   _removeServiceInstance: () => (/* binding */ _removeServiceInstance),\n/* harmony export */   _serverApps: () => (/* binding */ _serverApps),\n/* harmony export */   deleteApp: () => (/* binding */ deleteApp),\n/* harmony export */   getApp: () => (/* binding */ getApp),\n/* harmony export */   getApps: () => (/* binding */ getApps),\n/* harmony export */   initializeApp: () => (/* binding */ initializeApp),\n/* harmony export */   initializeServerApp: () => (/* binding */ initializeServerApp),\n/* harmony export */   onLog: () => (/* binding */ onLog),\n/* harmony export */   registerVersion: () => (/* binding */ registerVersion),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(ssr)/./node_modules/idb/build/index.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass PlatformLoggerServiceImpl {\n    constructor(container) {\n        this.container = container;\n    }\n    // In initial implementation, this will be called by installations on\n    // auth token refresh, and installations will send this string.\n    getPlatformInfoString() {\n        const providers = this.container.getProviders();\n        // Loop through providers and get library/version pairs from any that are\n        // version components.\n        return providers\n            .map(provider => {\n            if (isVersionServiceProvider(provider)) {\n                const service = provider.getImmediate();\n                return `${service.library}/${service.version}`;\n            }\n            else {\n                return null;\n            }\n        })\n            .filter(logString => logString)\n            .join(' ');\n    }\n}\n/**\n *\n * @param provider check if this provider provides a VersionService\n *\n * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider\n * provides VersionService. The provider is not necessarily a 'app-version'\n * provider.\n */\nfunction isVersionServiceProvider(provider) {\n    const component = provider.getComponent();\n    return (component === null || component === void 0 ? void 0 : component.type) === \"VERSION\" /* ComponentType.VERSION */;\n}\n\nconst name$q = \"@firebase/app\";\nconst version$1 = \"0.10.17\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger('@firebase/app');\n\nconst name$p = \"@firebase/app-compat\";\n\nconst name$o = \"@firebase/analytics-compat\";\n\nconst name$n = \"@firebase/analytics\";\n\nconst name$m = \"@firebase/app-check-compat\";\n\nconst name$l = \"@firebase/app-check\";\n\nconst name$k = \"@firebase/auth\";\n\nconst name$j = \"@firebase/auth-compat\";\n\nconst name$i = \"@firebase/database\";\n\nconst name$h = \"@firebase/data-connect\";\n\nconst name$g = \"@firebase/database-compat\";\n\nconst name$f = \"@firebase/functions\";\n\nconst name$e = \"@firebase/functions-compat\";\n\nconst name$d = \"@firebase/installations\";\n\nconst name$c = \"@firebase/installations-compat\";\n\nconst name$b = \"@firebase/messaging\";\n\nconst name$a = \"@firebase/messaging-compat\";\n\nconst name$9 = \"@firebase/performance\";\n\nconst name$8 = \"@firebase/performance-compat\";\n\nconst name$7 = \"@firebase/remote-config\";\n\nconst name$6 = \"@firebase/remote-config-compat\";\n\nconst name$5 = \"@firebase/storage\";\n\nconst name$4 = \"@firebase/storage-compat\";\n\nconst name$3 = \"@firebase/firestore\";\n\nconst name$2 = \"@firebase/vertexai\";\n\nconst name$1 = \"@firebase/firestore-compat\";\n\nconst name = \"firebase\";\nconst version = \"11.1.0\";\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default app name\n *\n * @internal\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\nconst PLATFORM_LOG_STRING = {\n    [name$q]: 'fire-core',\n    [name$p]: 'fire-core-compat',\n    [name$n]: 'fire-analytics',\n    [name$o]: 'fire-analytics-compat',\n    [name$l]: 'fire-app-check',\n    [name$m]: 'fire-app-check-compat',\n    [name$k]: 'fire-auth',\n    [name$j]: 'fire-auth-compat',\n    [name$i]: 'fire-rtdb',\n    [name$h]: 'fire-data-connect',\n    [name$g]: 'fire-rtdb-compat',\n    [name$f]: 'fire-fn',\n    [name$e]: 'fire-fn-compat',\n    [name$d]: 'fire-iid',\n    [name$c]: 'fire-iid-compat',\n    [name$b]: 'fire-fcm',\n    [name$a]: 'fire-fcm-compat',\n    [name$9]: 'fire-perf',\n    [name$8]: 'fire-perf-compat',\n    [name$7]: 'fire-rc',\n    [name$6]: 'fire-rc-compat',\n    [name$5]: 'fire-gcs',\n    [name$4]: 'fire-gcs-compat',\n    [name$3]: 'fire-fst',\n    [name$1]: 'fire-fst-compat',\n    [name$2]: 'fire-vertex',\n    'fire-js': 'fire-js', // Platform identifier for JS SDK.\n    [name]: 'fire-js-all'\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @internal\n */\nconst _apps = new Map();\n/**\n * @internal\n */\nconst _serverApps = new Map();\n/**\n * Registered components.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _components = new Map();\n/**\n * @param component - the component being added to this app's container\n *\n * @internal\n */\nfunction _addComponent(app, component) {\n    try {\n        app.container.addComponent(component);\n    }\n    catch (e) {\n        logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);\n    }\n}\n/**\n *\n * @internal\n */\nfunction _addOrOverwriteComponent(app, component) {\n    app.container.addOrOverwriteComponent(component);\n}\n/**\n *\n * @param component - the component to register\n * @returns whether or not the component is registered successfully\n *\n * @internal\n */\nfunction _registerComponent(component) {\n    const componentName = component.name;\n    if (_components.has(componentName)) {\n        logger.debug(`There were multiple attempts to register component ${componentName}.`);\n        return false;\n    }\n    _components.set(componentName, component);\n    // add the component to existing app instances\n    for (const app of _apps.values()) {\n        _addComponent(app, component);\n    }\n    for (const serverApp of _serverApps.values()) {\n        _addComponent(serverApp, component);\n    }\n    return true;\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n *\n * @returns the provider for the service with the matching name\n *\n * @internal\n */\nfunction _getProvider(app, name) {\n    const heartbeatController = app.container\n        .getProvider('heartbeat')\n        .getImmediate({ optional: true });\n    if (heartbeatController) {\n        void heartbeatController.triggerHeartbeat();\n    }\n    return app.container.getProvider(name);\n}\n/**\n *\n * @param app - FirebaseApp instance\n * @param name - service name\n * @param instanceIdentifier - service instance identifier in case the service supports multiple instances\n *\n * @internal\n */\nfunction _removeServiceInstance(app, name, instanceIdentifier = DEFAULT_ENTRY_NAME) {\n    _getProvider(app, name).clearInstance(instanceIdentifier);\n}\n/**\n *\n * @param obj - an object of type FirebaseApp or FirebaseOptions.\n *\n * @returns true if the provide object is of type FirebaseApp.\n *\n * @internal\n */\nfunction _isFirebaseApp(obj) {\n    return obj.options !== undefined;\n}\n/**\n *\n * @param obj - an object of type FirebaseApp.\n *\n * @returns true if the provided object is of type FirebaseServerAppImpl.\n *\n * @internal\n */\nfunction _isFirebaseServerApp(obj) {\n    return obj.settings !== undefined;\n}\n/**\n * Test only\n *\n * @internal\n */\nfunction _clearComponents() {\n    _components.clear();\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"no-app\" /* AppError.NO_APP */]: \"No Firebase App '{$appName}' has been created - \" +\n        'call initializeApp() first',\n    [\"bad-app-name\" /* AppError.BAD_APP_NAME */]: \"Illegal App name: '{$appName}'\",\n    [\"duplicate-app\" /* AppError.DUPLICATE_APP */]: \"Firebase App named '{$appName}' already exists with different options or config\",\n    [\"app-deleted\" /* AppError.APP_DELETED */]: \"Firebase App named '{$appName}' already deleted\",\n    [\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */]: 'Firebase Server App has been deleted',\n    [\"no-options\" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',\n    [\"invalid-app-argument\" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +\n        'Firebase App instance.',\n    [\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',\n    [\"idb-open\" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-get\" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-set\" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"idb-delete\" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',\n    [\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */]: 'FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.',\n    [\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */]: 'FirebaseServerApp is not for use in browser environments.'\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory('app', 'Firebase', ERRORS);\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseAppImpl {\n    constructor(options, config, container) {\n        this._isDeleted = false;\n        this._options = Object.assign({}, options);\n        this._config = Object.assign({}, config);\n        this._name = config.name;\n        this._automaticDataCollectionEnabled =\n            config.automaticDataCollectionEnabled;\n        this._container = container;\n        this.container.addComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('app', () => this, \"PUBLIC\" /* ComponentType.PUBLIC */));\n    }\n    get automaticDataCollectionEnabled() {\n        this.checkDestroyed();\n        return this._automaticDataCollectionEnabled;\n    }\n    set automaticDataCollectionEnabled(val) {\n        this.checkDestroyed();\n        this._automaticDataCollectionEnabled = val;\n    }\n    get name() {\n        this.checkDestroyed();\n        return this._name;\n    }\n    get options() {\n        this.checkDestroyed();\n        return this._options;\n    }\n    get config() {\n        this.checkDestroyed();\n        return this._config;\n    }\n    get container() {\n        return this._container;\n    }\n    get isDeleted() {\n        return this._isDeleted;\n    }\n    set isDeleted(val) {\n        this._isDeleted = val;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"app-deleted\" /* AppError.APP_DELETED */, { appName: this._name });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FirebaseServerAppImpl extends FirebaseAppImpl {\n    constructor(options, serverConfig, name, container) {\n        // Build configuration parameters for the FirebaseAppImpl base class.\n        const automaticDataCollectionEnabled = serverConfig.automaticDataCollectionEnabled !== undefined\n            ? serverConfig.automaticDataCollectionEnabled\n            : false;\n        // Create the FirebaseAppSettings object for the FirebaseAppImp constructor.\n        const config = {\n            name,\n            automaticDataCollectionEnabled\n        };\n        if (options.apiKey !== undefined) {\n            // Construct the parent FirebaseAppImp object.\n            super(options, config, container);\n        }\n        else {\n            const appImpl = options;\n            super(appImpl.options, config, container);\n        }\n        // Now construct the data for the FirebaseServerAppImpl.\n        this._serverConfig = Object.assign({ automaticDataCollectionEnabled }, serverConfig);\n        this._finalizationRegistry = null;\n        if (typeof FinalizationRegistry !== 'undefined') {\n            this._finalizationRegistry = new FinalizationRegistry(() => {\n                this.automaticCleanup();\n            });\n        }\n        this._refCount = 0;\n        this.incRefCount(this._serverConfig.releaseOnDeref);\n        // Do not retain a hard reference to the dref object, otherwise the FinalizationRegistry\n        // will never trigger.\n        this._serverConfig.releaseOnDeref = undefined;\n        serverConfig.releaseOnDeref = undefined;\n        registerVersion(name$q, version$1, 'serverapp');\n    }\n    toJSON() {\n        return undefined;\n    }\n    get refCount() {\n        return this._refCount;\n    }\n    // Increment the reference count of this server app. If an object is provided, register it\n    // with the finalization registry.\n    incRefCount(obj) {\n        if (this.isDeleted) {\n            return;\n        }\n        this._refCount++;\n        if (obj !== undefined && this._finalizationRegistry !== null) {\n            this._finalizationRegistry.register(obj, this);\n        }\n    }\n    // Decrement the reference count.\n    decRefCount() {\n        if (this.isDeleted) {\n            return 0;\n        }\n        return --this._refCount;\n    }\n    // Invoked by the FinalizationRegistry callback to note that this app should go through its\n    // reference counts and delete itself if no reference count remain. The coordinating logic that\n    // handles this is in deleteApp(...).\n    automaticCleanup() {\n        void deleteApp(this);\n    }\n    get settings() {\n        this.checkDestroyed();\n        return this._serverConfig;\n    }\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    checkDestroyed() {\n        if (this.isDeleted) {\n            throw ERROR_FACTORY.create(\"server-app-deleted\" /* AppError.SERVER_APP_DELETED */);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The current SDK version.\n *\n * @public\n */\nconst SDK_VERSION = version;\nfunction initializeApp(_options, rawConfig = {}) {\n    let options = _options;\n    if (typeof rawConfig !== 'object') {\n        const name = rawConfig;\n        rawConfig = { name };\n    }\n    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);\n    const name = config.name;\n    if (typeof name !== 'string' || !name) {\n        throw ERROR_FACTORY.create(\"bad-app-name\" /* AppError.BAD_APP_NAME */, {\n            appName: String(name)\n        });\n    }\n    options || (options = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)());\n    if (!options) {\n        throw ERROR_FACTORY.create(\"no-options\" /* AppError.NO_OPTIONS */);\n    }\n    const existingApp = _apps.get(name);\n    if (existingApp) {\n        // return the existing app if options and config deep equal the ones in the existing app.\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, existingApp.options) &&\n            (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(config, existingApp.config)) {\n            return existingApp;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"duplicate-app\" /* AppError.DUPLICATE_APP */, { appName: name });\n        }\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(name);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseAppImpl(options, config, container);\n    _apps.set(name, newApp);\n    return newApp;\n}\nfunction initializeServerApp(_options, _serverAppConfig) {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && !(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isWebWorker)()) {\n        // FirebaseServerApp isn't designed to be run in browsers.\n        throw ERROR_FACTORY.create(\"invalid-server-app-environment\" /* AppError.INVALID_SERVER_APP_ENVIRONMENT */);\n    }\n    if (_serverAppConfig.automaticDataCollectionEnabled === undefined) {\n        _serverAppConfig.automaticDataCollectionEnabled = false;\n    }\n    let appOptions;\n    if (_isFirebaseApp(_options)) {\n        appOptions = _options.options;\n    }\n    else {\n        appOptions = _options;\n    }\n    // Build an app name based on a hash of the configuration options.\n    const nameObj = Object.assign(Object.assign({}, _serverAppConfig), appOptions);\n    // However, Do not mangle the name based on releaseOnDeref, since it will vary between the\n    // construction of FirebaseServerApp instances. For example, if the object is the request headers.\n    if (nameObj.releaseOnDeref !== undefined) {\n        delete nameObj.releaseOnDeref;\n    }\n    const hashCode = (s) => {\n        return [...s].reduce((hash, c) => (Math.imul(31, hash) + c.charCodeAt(0)) | 0, 0);\n    };\n    if (_serverAppConfig.releaseOnDeref !== undefined) {\n        if (typeof FinalizationRegistry === 'undefined') {\n            throw ERROR_FACTORY.create(\"finalization-registry-not-supported\" /* AppError.FINALIZATION_REGISTRY_NOT_SUPPORTED */, {});\n        }\n    }\n    const nameString = '' + hashCode(JSON.stringify(nameObj));\n    const existingApp = _serverApps.get(nameString);\n    if (existingApp) {\n        existingApp.incRefCount(_serverAppConfig.releaseOnDeref);\n        return existingApp;\n    }\n    const container = new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.ComponentContainer(nameString);\n    for (const component of _components.values()) {\n        container.addComponent(component);\n    }\n    const newApp = new FirebaseServerAppImpl(appOptions, _serverAppConfig, nameString, container);\n    _serverApps.set(nameString, newApp);\n    return newApp;\n}\n/**\n * Retrieves a {@link @firebase/app#FirebaseApp} instance.\n *\n * When called with no arguments, the default app is returned. When an app name\n * is provided, the app corresponding to that name is returned.\n *\n * An exception is thrown if the app being retrieved has not yet been\n * initialized.\n *\n * @example\n * ```javascript\n * // Return the default app\n * const app = getApp();\n * ```\n *\n * @example\n * ```javascript\n * // Return a named app\n * const otherApp = getApp(\"otherApp\");\n * ```\n *\n * @param name - Optional name of the app to return. If no name is\n *   provided, the default is `\"[DEFAULT]\"`.\n *\n * @returns The app corresponding to the provided app name.\n *   If no app name is provided, the default app is returned.\n *\n * @public\n */\nfunction getApp(name = DEFAULT_ENTRY_NAME) {\n    const app = _apps.get(name);\n    if (!app && name === DEFAULT_ENTRY_NAME && (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getDefaultAppConfig)()) {\n        return initializeApp();\n    }\n    if (!app) {\n        throw ERROR_FACTORY.create(\"no-app\" /* AppError.NO_APP */, { appName: name });\n    }\n    return app;\n}\n/**\n * A (read-only) array of all initialized apps.\n * @public\n */\nfunction getApps() {\n    return Array.from(_apps.values());\n}\n/**\n * Renders this app unusable and frees the resources of all associated\n * services.\n *\n * @example\n * ```javascript\n * deleteApp(app)\n *   .then(function() {\n *     console.log(\"App deleted successfully\");\n *   })\n *   .catch(function(error) {\n *     console.log(\"Error deleting app:\", error);\n *   });\n * ```\n *\n * @public\n */\nasync function deleteApp(app) {\n    let cleanupProviders = false;\n    const name = app.name;\n    if (_apps.has(name)) {\n        cleanupProviders = true;\n        _apps.delete(name);\n    }\n    else if (_serverApps.has(name)) {\n        const firebaseServerApp = app;\n        if (firebaseServerApp.decRefCount() <= 0) {\n            _serverApps.delete(name);\n            cleanupProviders = true;\n        }\n    }\n    if (cleanupProviders) {\n        await Promise.all(app.container\n            .getProviders()\n            .map(provider => provider.delete()));\n        app.isDeleted = true;\n    }\n}\n/**\n * Registers a library's name and version for platform logging purposes.\n * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)\n * @param version - Current version of that library.\n * @param variant - Bundle variant, e.g., node, rn, etc.\n *\n * @public\n */\nfunction registerVersion(libraryKeyOrName, version, variant) {\n    var _a;\n    // TODO: We can use this check to whitelist strings when/if we set up\n    // a good whitelist system.\n    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;\n    if (variant) {\n        library += `-${variant}`;\n    }\n    const libraryMismatch = library.match(/\\s|\\//);\n    const versionMismatch = version.match(/\\s|\\//);\n    if (libraryMismatch || versionMismatch) {\n        const warning = [\n            `Unable to register library \"${library}\" with version \"${version}\":`\n        ];\n        if (libraryMismatch) {\n            warning.push(`library name \"${library}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        if (libraryMismatch && versionMismatch) {\n            warning.push('and');\n        }\n        if (versionMismatch) {\n            warning.push(`version name \"${version}\" contains illegal characters (whitespace or \"/\")`);\n        }\n        logger.warn(warning.join(' '));\n        return;\n    }\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component(`${library}-version`, () => ({ library, version }), \"VERSION\" /* ComponentType.VERSION */));\n}\n/**\n * Sets log handler for all Firebase SDKs.\n * @param logCallback - An optional custom log handler that executes user code whenever\n * the Firebase SDK makes a logging call.\n *\n * @public\n */\nfunction onLog(logCallback, options) {\n    if (logCallback !== null && typeof logCallback !== 'function') {\n        throw ERROR_FACTORY.create(\"invalid-log-argument\" /* AppError.INVALID_LOG_ARGUMENT */);\n    }\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setUserLogHandler)(logCallback, options);\n}\n/**\n * Sets log level for all Firebase SDKs.\n *\n * All of the log types above the current log level are captured (i.e. if\n * you set the log level to `info`, errors are logged, but `debug` and\n * `verbose` logs are not).\n *\n * @public\n */\nfunction setLogLevel(logLevel) {\n    (0,_firebase_logger__WEBPACK_IMPORTED_MODULE_1__.setLogLevel)(logLevel);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-heartbeat-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-heartbeat-store';\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n            upgrade: (db, oldVersion) => {\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (oldVersion) {\n                    case 0:\n                        try {\n                            db.createObjectStore(STORE_NAME);\n                        }\n                        catch (e) {\n                            // Safari/iOS browsers throw occasional exceptions on\n                            // db.createObjectStore() that may be a bug. Avoid blocking\n                            // the rest of the app functionality.\n                            console.warn(e);\n                        }\n                }\n            }\n        }).catch(e => {\n            throw ERROR_FACTORY.create(\"idb-open\" /* AppError.IDB_OPEN */, {\n                originalErrorMessage: e.message\n            });\n        });\n    }\n    return dbPromise;\n}\nasync function readHeartbeatsFromIndexedDB(app) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME);\n        const result = await tx.objectStore(STORE_NAME).get(computeKey(app));\n        // We already have the value but tx.done can throw,\n        // so we need to await it here to catch errors\n        await tx.done;\n        return result;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-get\" /* AppError.IDB_GET */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nasync function writeHeartbeatsToIndexedDB(app, heartbeatObject) {\n    try {\n        const db = await getDbPromise();\n        const tx = db.transaction(STORE_NAME, 'readwrite');\n        const objectStore = tx.objectStore(STORE_NAME);\n        await objectStore.put(heartbeatObject, computeKey(app));\n        await tx.done;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) {\n            logger.warn(e.message);\n        }\n        else {\n            const idbGetError = ERROR_FACTORY.create(\"idb-set\" /* AppError.IDB_WRITE */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n            logger.warn(idbGetError.message);\n        }\n    }\n}\nfunction computeKey(app) {\n    return `${app.name}!${app.options.appId}`;\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst MAX_HEADER_BYTES = 1024;\n// 30 days\nconst STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;\nclass HeartbeatServiceImpl {\n    constructor(container) {\n        this.container = container;\n        /**\n         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate\n         * the header string.\n         * Stores one record per date. This will be consolidated into the standard\n         * format of one record per user agent string before being sent as a header.\n         * Populated from indexedDB when the controller is instantiated and should\n         * be kept in sync with indexedDB.\n         * Leave public for easier testing.\n         */\n        this._heartbeatsCache = null;\n        const app = this.container.getProvider('app').getImmediate();\n        this._storage = new HeartbeatStorageImpl(app);\n        this._heartbeatsCachePromise = this._storage.read().then(result => {\n            this._heartbeatsCache = result;\n            return result;\n        });\n    }\n    /**\n     * Called to report a heartbeat. The function will generate\n     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it\n     * to IndexedDB.\n     * Note that we only store one heartbeat per day. So if a heartbeat for today is\n     * already logged, subsequent calls to this function in the same day will be ignored.\n     */\n    async triggerHeartbeat() {\n        var _a, _b;\n        try {\n            const platformLogger = this.container\n                .getProvider('platform-logger')\n                .getImmediate();\n            // This is the \"Firebase user agent\" string from the platform logger\n            // service, not the browser user agent.\n            const agent = platformLogger.getPlatformInfoString();\n            const date = getUTCDateString();\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null) {\n                this._heartbeatsCache = await this._heartbeatsCachePromise;\n                // If we failed to construct a heartbeats cache, then return immediately.\n                if (((_b = this._heartbeatsCache) === null || _b === void 0 ? void 0 : _b.heartbeats) == null) {\n                    return;\n                }\n            }\n            // Do not store a heartbeat if one is already stored for this day\n            // or if a header has already been sent today.\n            if (this._heartbeatsCache.lastSentHeartbeatDate === date ||\n                this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {\n                return;\n            }\n            else {\n                // There is no entry for this date. Create one.\n                this._heartbeatsCache.heartbeats.push({ date, agent });\n            }\n            // Remove entries older than 30 days.\n            this._heartbeatsCache.heartbeats =\n                this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {\n                    const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();\n                    const now = Date.now();\n                    return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;\n                });\n            return this._storage.overwrite(this._heartbeatsCache);\n        }\n        catch (e) {\n            logger.warn(e);\n        }\n    }\n    /**\n     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.\n     * It also clears all heartbeats from memory as well as in IndexedDB.\n     *\n     * NOTE: Consuming product SDKs should not send the header if this method\n     * returns an empty string.\n     */\n    async getHeartbeatsHeader() {\n        var _a;\n        try {\n            if (this._heartbeatsCache === null) {\n                await this._heartbeatsCachePromise;\n            }\n            // If it's still null or the array is empty, there is no data to send.\n            if (((_a = this._heartbeatsCache) === null || _a === void 0 ? void 0 : _a.heartbeats) == null ||\n                this._heartbeatsCache.heartbeats.length === 0) {\n                return '';\n            }\n            const date = getUTCDateString();\n            // Extract as many heartbeats from the cache as will fit under the size limit.\n            const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);\n            const headerString = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));\n            // Store last sent date to prevent another being logged/sent for the same day.\n            this._heartbeatsCache.lastSentHeartbeatDate = date;\n            if (unsentEntries.length > 0) {\n                // Store any unsent entries if they exist.\n                this._heartbeatsCache.heartbeats = unsentEntries;\n                // This seems more likely than emptying the array (below) to lead to some odd state\n                // since the cache isn't empty and this will be called again on the next request,\n                // and is probably safest if we await it.\n                await this._storage.overwrite(this._heartbeatsCache);\n            }\n            else {\n                this._heartbeatsCache.heartbeats = [];\n                // Do not wait for this, to reduce latency.\n                void this._storage.overwrite(this._heartbeatsCache);\n            }\n            return headerString;\n        }\n        catch (e) {\n            logger.warn(e);\n            return '';\n        }\n    }\n}\nfunction getUTCDateString() {\n    const today = new Date();\n    // Returns date format 'YYYY-MM-DD'\n    return today.toISOString().substring(0, 10);\n}\nfunction extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {\n    // Heartbeats grouped by user agent in the standard format to be sent in\n    // the header.\n    const heartbeatsToSend = [];\n    // Single date format heartbeats that are not sent.\n    let unsentEntries = heartbeatsCache.slice();\n    for (const singleDateHeartbeat of heartbeatsCache) {\n        // Look for an existing entry with the same user agent.\n        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);\n        if (!heartbeatEntry) {\n            // If no entry for this user agent exists, create one.\n            heartbeatsToSend.push({\n                agent: singleDateHeartbeat.agent,\n                dates: [singleDateHeartbeat.date]\n            });\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                // If the header would exceed max size, remove the added heartbeat\n                // entry and stop adding to the header.\n                heartbeatsToSend.pop();\n                break;\n            }\n        }\n        else {\n            heartbeatEntry.dates.push(singleDateHeartbeat.date);\n            // If the header would exceed max size, remove the added date\n            // and stop adding to the header.\n            if (countBytes(heartbeatsToSend) > maxSize) {\n                heartbeatEntry.dates.pop();\n                break;\n            }\n        }\n        // Pop unsent entry from queue. (Skipped if adding the entry exceeded\n        // quota and the loop breaks early.)\n        unsentEntries = unsentEntries.slice(1);\n    }\n    return {\n        heartbeatsToSend,\n        unsentEntries\n    };\n}\nclass HeartbeatStorageImpl {\n    constructor(app) {\n        this.app = app;\n        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();\n    }\n    async runIndexedDBEnvironmentCheck() {\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n            return false;\n        }\n        else {\n            return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)()\n                .then(() => true)\n                .catch(() => false);\n        }\n    }\n    /**\n     * Read all heartbeats.\n     */\n    async read() {\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return { heartbeats: [] };\n        }\n        else {\n            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);\n            if (idbHeartbeatObject === null || idbHeartbeatObject === void 0 ? void 0 : idbHeartbeatObject.heartbeats) {\n                return idbHeartbeatObject;\n            }\n            else {\n                return { heartbeats: [] };\n            }\n        }\n    }\n    // overwrite the storage with the provided heartbeats\n    async overwrite(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: heartbeatsObject.heartbeats\n            });\n        }\n    }\n    // add heartbeats\n    async add(heartbeatsObject) {\n        var _a;\n        const canUseIndexedDB = await this._canUseIndexedDBPromise;\n        if (!canUseIndexedDB) {\n            return;\n        }\n        else {\n            const existingHeartbeatsObject = await this.read();\n            return writeHeartbeatsToIndexedDB(this.app, {\n                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,\n                heartbeats: [\n                    ...existingHeartbeatsObject.heartbeats,\n                    ...heartbeatsObject.heartbeats\n                ]\n            });\n        }\n    }\n}\n/**\n * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped\n * in a platform logging header JSON object, stringified, and converted\n * to base 64.\n */\nfunction countBytes(heartbeatsCache) {\n    // base64 has a restricted set of characters, all of which should be 1 byte.\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.base64urlEncodeWithoutPadding)(\n    // heartbeatsCache wrapper properties\n    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerCoreComponents(variant) {\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('platform-logger', container => new PlatformLoggerServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    _registerComponent(new _firebase_component__WEBPACK_IMPORTED_MODULE_0__.Component('heartbeat', container => new HeartbeatServiceImpl(container), \"PRIVATE\" /* ComponentType.PRIVATE */));\n    // Register `app` package.\n    registerVersion(name$q, version$1, variant);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    registerVersion(name$q, version$1, 'esm2017');\n    // Register platform SDK identifier (no version).\n    registerVersion('fire-js', '');\n}\n\n/**\n * Firebase App\n *\n * @remarks This package coordinates the communication between the different Firebase components\n * @packageDocumentation\n */\nregisterCoreComponents('');\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9FO0FBQ3VCO0FBQzBHO0FBQ3RKO0FBQ2xCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU07O0FBRXpCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0Isc0NBQXNDLFNBQVM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsY0FBYztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBLHVFQUF1RSxTQUFTO0FBQ2hGLDBFQUEwRSxTQUFTO0FBQ25GLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQSw2RUFBNkUsU0FBUztBQUN0RjtBQUNBO0FBQ0EsaUdBQWlHLHNCQUFzQjtBQUN2SCxvR0FBb0csc0JBQXNCO0FBQzFILG9HQUFvRyxzQkFBc0I7QUFDMUgsMkdBQTJHLHNCQUFzQjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0RBQVk7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwREFBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYscUJBQXFCO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsbUNBQW1DLGlFQUFpRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQixtRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQixZQUFZLHlEQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixlQUFlO0FBQ3RHO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFTLE9BQU8sMkRBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1JQUFtSTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1FQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1FQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrQkFBa0IsUUFBUTtBQUM3RTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBEQUFTLElBQUksUUFBUSxvQkFBb0Isa0JBQWtCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUVBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFhO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseURBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVMsR0FBRyxrQkFBa0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQ0FBa0M7QUFDdEQsaUNBQWlDLDZFQUE2QixrQkFBa0IsMENBQTBDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0VBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5RUFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZFQUE2QjtBQUN4QztBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBUztBQUNwQywyQkFBMkIsMERBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1XO0FBQ25XIiwic291cmNlcyI6WyIvaG9tZS9yZ3RlY2gwMDgvYWNhZGVtaWMtY29ubmVjdC1wcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDb250YWluZXIgfSBmcm9tICdAZmlyZWJhc2UvY29tcG9uZW50JztcbmltcG9ydCB7IExvZ2dlciwgc2V0VXNlckxvZ0hhbmRsZXIsIHNldExvZ0xldmVsIGFzIHNldExvZ0xldmVsJDEgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgZ2V0RGVmYXVsdEFwcENvbmZpZywgZGVlcEVxdWFsLCBpc0Jyb3dzZXIsIGlzV2ViV29ya2VyLCBGaXJlYmFzZUVycm9yLCBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZywgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5leHBvcnQgeyBGaXJlYmFzZUVycm9yIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgb3BlbkRCIH0gZnJvbSAnaWRiJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLy8gSW4gaW5pdGlhbCBpbXBsZW1lbnRhdGlvbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBieSBpbnN0YWxsYXRpb25zIG9uXG4gICAgLy8gYXV0aCB0b2tlbiByZWZyZXNoLCBhbmQgaW5zdGFsbGF0aW9ucyB3aWxsIHNlbmQgdGhpcyBzdHJpbmcuXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlcnMgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcnMoKTtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHByb3ZpZGVycyBhbmQgZ2V0IGxpYnJhcnkvdmVyc2lvbiBwYWlycyBmcm9tIGFueSB0aGF0IGFyZVxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXG4gICAgICAgIHJldHVybiBwcm92aWRlcnNcbiAgICAgICAgICAgIC5tYXAocHJvdmlkZXIgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2aWNlID0gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NlcnZpY2UubGlicmFyeX0vJHtzZXJ2aWNlLnZlcnNpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcihsb2dTdHJpbmcgPT4gbG9nU3RyaW5nKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgY2hlY2sgaWYgdGhpcyBwcm92aWRlciBwcm92aWRlcyBhIFZlcnNpb25TZXJ2aWNlXG4gKlxuICogTk9URTogVXNpbmcgUHJvdmlkZXI8J2FwcC12ZXJzaW9uJz4gaXMgYSBoYWNrIHRvIGluZGljYXRlIHRoYXQgdGhlIHByb3ZpZGVyXG4gKiBwcm92aWRlcyBWZXJzaW9uU2VydmljZS4gVGhlIHByb3ZpZGVyIGlzIG5vdCBuZWNlc3NhcmlseSBhICdhcHAtdmVyc2lvbidcbiAqIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBpc1ZlcnNpb25TZXJ2aWNlUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcbiAgICByZXR1cm4gKGNvbXBvbmVudCA9PT0gbnVsbCB8fCBjb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudC50eXBlKSA9PT0gXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovO1xufVxuXG5jb25zdCBuYW1lJHEgPSBcIkBmaXJlYmFzZS9hcHBcIjtcbmNvbnN0IHZlcnNpb24kMSA9IFwiMC4xMC4xN1wiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FwcCcpO1xuXG5jb25zdCBuYW1lJHAgPSBcIkBmaXJlYmFzZS9hcHAtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbyA9IFwiQGZpcmViYXNlL2FuYWx5dGljcy1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRuID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzXCI7XG5cbmNvbnN0IG5hbWUkbSA9IFwiQGZpcmViYXNlL2FwcC1jaGVjay1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRsID0gXCJAZmlyZWJhc2UvYXBwLWNoZWNrXCI7XG5cbmNvbnN0IG5hbWUkayA9IFwiQGZpcmViYXNlL2F1dGhcIjtcblxuY29uc3QgbmFtZSRqID0gXCJAZmlyZWJhc2UvYXV0aC1jb21wYXRcIjtcblxuY29uc3QgbmFtZSRpID0gXCJAZmlyZWJhc2UvZGF0YWJhc2VcIjtcblxuY29uc3QgbmFtZSRoID0gXCJAZmlyZWJhc2UvZGF0YS1jb25uZWN0XCI7XG5cbmNvbnN0IG5hbWUkZyA9IFwiQGZpcmViYXNlL2RhdGFiYXNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGYgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnNcIjtcblxuY29uc3QgbmFtZSRlID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGQgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zXCI7XG5cbmNvbnN0IG5hbWUkYyA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYiA9IFwiQGZpcmViYXNlL21lc3NhZ2luZ1wiO1xuXG5jb25zdCBuYW1lJGEgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkOSA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlXCI7XG5cbmNvbnN0IG5hbWUkOCA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDcgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnXCI7XG5cbmNvbnN0IG5hbWUkNiA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNSA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcblxuY29uc3QgbmFtZSQ0ID0gXCJAZmlyZWJhc2Uvc3RvcmFnZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQzID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5cbmNvbnN0IG5hbWUkMiA9IFwiQGZpcmViYXNlL3ZlcnRleGFpXCI7XG5cbmNvbnN0IG5hbWUkMSA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjExLjEuMFwiO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBhcHAgbmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcbmNvbnN0IFBMQVRGT1JNX0xPR19TVFJJTkcgPSB7XG4gICAgW25hbWUkcV06ICdmaXJlLWNvcmUnLFxuICAgIFtuYW1lJHBdOiAnZmlyZS1jb3JlLWNvbXBhdCcsXG4gICAgW25hbWUkbl06ICdmaXJlLWFuYWx5dGljcycsXG4gICAgW25hbWUkb106ICdmaXJlLWFuYWx5dGljcy1jb21wYXQnLFxuICAgIFtuYW1lJGxdOiAnZmlyZS1hcHAtY2hlY2snLFxuICAgIFtuYW1lJG1dOiAnZmlyZS1hcHAtY2hlY2stY29tcGF0JyxcbiAgICBbbmFtZSRrXTogJ2ZpcmUtYXV0aCcsXG4gICAgW25hbWUkal06ICdmaXJlLWF1dGgtY29tcGF0JyxcbiAgICBbbmFtZSRpXTogJ2ZpcmUtcnRkYicsXG4gICAgW25hbWUkaF06ICdmaXJlLWRhdGEtY29ubmVjdCcsXG4gICAgW25hbWUkZ106ICdmaXJlLXJ0ZGItY29tcGF0JyxcbiAgICBbbmFtZSRmXTogJ2ZpcmUtZm4nLFxuICAgIFtuYW1lJGVdOiAnZmlyZS1mbi1jb21wYXQnLFxuICAgIFtuYW1lJGRdOiAnZmlyZS1paWQnLFxuICAgIFtuYW1lJGNdOiAnZmlyZS1paWQtY29tcGF0JyxcbiAgICBbbmFtZSRiXTogJ2ZpcmUtZmNtJyxcbiAgICBbbmFtZSRhXTogJ2ZpcmUtZmNtLWNvbXBhdCcsXG4gICAgW25hbWUkOV06ICdmaXJlLXBlcmYnLFxuICAgIFtuYW1lJDhdOiAnZmlyZS1wZXJmLWNvbXBhdCcsXG4gICAgW25hbWUkN106ICdmaXJlLXJjJyxcbiAgICBbbmFtZSQ2XTogJ2ZpcmUtcmMtY29tcGF0JyxcbiAgICBbbmFtZSQ1XTogJ2ZpcmUtZ2NzJyxcbiAgICBbbmFtZSQ0XTogJ2ZpcmUtZ2NzLWNvbXBhdCcsXG4gICAgW25hbWUkM106ICdmaXJlLWZzdCcsXG4gICAgW25hbWUkMV06ICdmaXJlLWZzdC1jb21wYXQnLFxuICAgIFtuYW1lJDJdOiAnZmlyZS12ZXJ0ZXgnLFxuICAgICdmaXJlLWpzJzogJ2ZpcmUtanMnLCAvLyBQbGF0Zm9ybSBpZGVudGlmaWVyIGZvciBKUyBTREsuXG4gICAgW25hbWVdOiAnZmlyZS1qcy1hbGwnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgX2FwcHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBfc2VydmVyQXBwcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogUmVnaXN0ZXJlZCBjb21wb25lbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgX2NvbXBvbmVudHMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9hZGRDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoYXBwLCBjb21wb25lbnQpIHtcbiAgICBhcHAuY29udGFpbmVyLmFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxuICogQHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xuICAgIGlmIChfY29tcG9uZW50cy5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGVyZSB3ZXJlIG11bHRpcGxlIGF0dGVtcHRzIHRvIHJlZ2lzdGVyIGNvbXBvbmVudCAke2NvbXBvbmVudE5hbWV9LmApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9jb21wb25lbnRzLnNldChjb21wb25lbnROYW1lLCBjb21wb25lbnQpO1xuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcbiAgICBmb3IgKGNvbnN0IGFwcCBvZiBfYXBwcy52YWx1ZXMoKSkge1xuICAgICAgICBfYWRkQ29tcG9uZW50KGFwcCwgY29tcG9uZW50KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZXJ2ZXJBcHAgb2YgX3NlcnZlckFwcHMudmFsdWVzKCkpIHtcbiAgICAgICAgX2FkZENvbXBvbmVudChzZXJ2ZXJBcHAsIGNvbXBvbmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXG4gKiBAcGFyYW0gbmFtZSAtIHNlcnZpY2UgbmFtZVxuICpcbiAqIEByZXR1cm5zIHRoZSBwcm92aWRlciBmb3IgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKSB7XG4gICAgY29uc3QgaGVhcnRiZWF0Q29udHJvbGxlciA9IGFwcC5jb250YWluZXJcbiAgICAgICAgLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKVxuICAgICAgICAuZ2V0SW1tZWRpYXRlKHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgaWYgKGhlYXJ0YmVhdENvbnRyb2xsZXIpIHtcbiAgICAgICAgdm9pZCBoZWFydGJlYXRDb250cm9sbGVyLnRyaWdnZXJIZWFydGJlYXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcC5jb250YWluZXIuZ2V0UHJvdmlkZXIobmFtZSk7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXG4gKiBAcGFyYW0gaW5zdGFuY2VJZGVudGlmaWVyIC0gc2VydmljZSBpbnN0YW5jZSBpZGVudGlmaWVyIGluIGNhc2UgdGhlIHNlcnZpY2Ugc3VwcG9ydHMgbXVsdGlwbGUgaW5zdGFuY2VzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoYXBwLCBuYW1lLCBpbnN0YW5jZUlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICBfZ2V0UHJvdmlkZXIoYXBwLCBuYW1lKS5jbGVhckluc3RhbmNlKGluc3RhbmNlSWRlbnRpZmllcik7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb2JqIC0gYW4gb2JqZWN0IG9mIHR5cGUgRmlyZWJhc2VBcHAgb3IgRmlyZWJhc2VPcHRpb25zLlxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGUgb2JqZWN0IGlzIG9mIHR5cGUgRmlyZWJhc2VBcHAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIF9pc0ZpcmViYXNlQXBwKG9iaikge1xuICAgIHJldHVybiBvYmoub3B0aW9ucyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKlxuICogQHBhcmFtIG9iaiAtIGFuIG9iamVjdCBvZiB0eXBlIEZpcmViYXNlQXBwLlxuICpcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBvZiB0eXBlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2lzRmlyZWJhc2VTZXJ2ZXJBcHAob2JqKSB7XG4gICAgcmV0dXJuIG9iai5zZXR0aW5ncyAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBUZXN0IG9ubHlcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gX2NsZWFyQ29tcG9uZW50cygpIHtcbiAgICBfY29tcG9uZW50cy5jbGVhcigpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgRVJST1JTID0ge1xuICAgIFtcIm5vLWFwcFwiIC8qIEFwcEVycm9yLk5PX0FQUCAqL106IFwiTm8gRmlyZWJhc2UgQXBwICd7JGFwcE5hbWV9JyBoYXMgYmVlbiBjcmVhdGVkIC0gXCIgK1xuICAgICAgICAnY2FsbCBpbml0aWFsaXplQXBwKCkgZmlyc3QnLFxuICAgIFtcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqL106IFwiSWxsZWdhbCBBcHAgbmFtZTogJ3skYXBwTmFtZX0nXCIsXG4gICAgW1wiZHVwbGljYXRlLWFwcFwiIC8qIEFwcEVycm9yLkRVUExJQ0FURV9BUFAgKi9dOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRhcHBOYW1lfScgYWxyZWFkeSBleGlzdHMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyBvciBjb25maWdcIixcbiAgICBbXCJhcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLkFQUF9ERUxFVEVEICovXTogXCJGaXJlYmFzZSBBcHAgbmFtZWQgJ3skYXBwTmFtZX0nIGFscmVhZHkgZGVsZXRlZFwiLFxuICAgIFtcInNlcnZlci1hcHAtZGVsZXRlZFwiIC8qIEFwcEVycm9yLlNFUlZFUl9BUFBfREVMRVRFRCAqL106ICdGaXJlYmFzZSBTZXJ2ZXIgQXBwIGhhcyBiZWVuIGRlbGV0ZWQnLFxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcbiAgICBbXCJpbnZhbGlkLWFwcC1hcmd1bWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfQVBQX0FSR1VNRU5UICovXTogJ2ZpcmViYXNlLnskYXBwTmFtZX0oKSB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnQgb3IgYSAnICtcbiAgICAgICAgJ0ZpcmViYXNlIEFwcCBpbnN0YW5jZS4nLFxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxuICAgIFtcImlkYi1vcGVuXCIgLyogQXBwRXJyb3IuSURCX09QRU4gKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gb3BlbmluZyBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1nZXRcIiAvKiBBcHBFcnJvci5JREJfR0VUICovXTogJ0Vycm9yIHRocm93biB3aGVuIHJlYWRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxuICAgIFtcImlkYi1kZWxldGVcIiAvKiBBcHBFcnJvci5JREJfREVMRVRFICovXTogJ0Vycm9yIHRocm93biB3aGVuIGRlbGV0aW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcbiAgICBbXCJmaW5hbGl6YXRpb24tcmVnaXN0cnktbm90LXN1cHBvcnRlZFwiIC8qIEFwcEVycm9yLkZJTkFMSVpBVElPTl9SRUdJU1RSWV9OT1RfU1VQUE9SVEVEICovXTogJ0ZpcmViYXNlU2VydmVyQXBwIGRlbGV0ZU9uRGVyZWYgZmllbGQgZGVmaW5lZCBidXQgdGhlIEpTIHJ1bnRpbWUgZG9lcyBub3Qgc3VwcG9ydCBGaW5hbGl6YXRpb25SZWdpc3RyeS4nLFxuICAgIFtcImludmFsaWQtc2VydmVyLWFwcC1lbnZpcm9ubWVudFwiIC8qIEFwcEVycm9yLklOVkFMSURfU0VSVkVSX0FQUF9FTlZJUk9OTUVOVCAqL106ICdGaXJlYmFzZVNlcnZlckFwcCBpcyBub3QgZm9yIHVzZSBpbiBicm93c2VyIGVudmlyb25tZW50cy4nXG59O1xuY29uc3QgRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2FwcCcsICdGaXJlYmFzZScsIEVSUk9SUyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBjb25maWcubmFtZTtcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cbiAgICAgICAgICAgIGNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcbiAgICB9XG4gICAgZ2V0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkO1xuICAgIH1cbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHRoaXMuX2F1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuICAgIGdldCBjb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuICAgIGdldCBpc0RlbGV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlbGV0ZWQ7XG4gICAgfVxuICAgIHNldCBpc0RlbGV0ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuX2lzRGVsZXRlZCA9IHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yIGlmIHRoZSBBcHAgaGFzIGFscmVhZHkgYmVlbiBkZWxldGVkIC1cbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cbiAgICAgKi9cbiAgICBjaGVja0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFwcC1kZWxldGVkXCIgLyogQXBwRXJyb3IuQVBQX0RFTEVURUQgKi8sIHsgYXBwTmFtZTogdGhpcy5fbmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEZpcmViYXNlU2VydmVyQXBwSW1wbCBleHRlbmRzIEZpcmViYXNlQXBwSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2VydmVyQ29uZmlnLCBuYW1lLCBjb250YWluZXIpIHtcbiAgICAgICAgLy8gQnVpbGQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGUgRmlyZWJhc2VBcHBJbXBsIGJhc2UgY2xhc3MuXG4gICAgICAgIGNvbnN0IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IHNlcnZlckNvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBzZXJ2ZXJDb25maWcuYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIEZpcmViYXNlQXBwU2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgRmlyZWJhc2VBcHBJbXAgY29uc3RydWN0b3IuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgcGFyZW50IEZpcmViYXNlQXBwSW1wIG9iamVjdC5cbiAgICAgICAgICAgIHN1cGVyKG9wdGlvbnMsIGNvbmZpZywgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFwcEltcGwgPSBvcHRpb25zO1xuICAgICAgICAgICAgc3VwZXIoYXBwSW1wbC5vcHRpb25zLCBjb25maWcsIGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGNvbnN0cnVjdCB0aGUgZGF0YSBmb3IgdGhlIEZpcmViYXNlU2VydmVyQXBwSW1wbC5cbiAgICAgICAgdGhpcy5fc2VydmVyQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7IGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCB9LCBzZXJ2ZXJDb25maWcpO1xuICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6YXRpb25SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvbWF0aWNDbGVhbnVwKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaW5jUmVmQ291bnQodGhpcy5fc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmKTtcbiAgICAgICAgLy8gRG8gbm90IHJldGFpbiBhIGhhcmQgcmVmZXJlbmNlIHRvIHRoZSBkcmVmIG9iamVjdCwgb3RoZXJ3aXNlIHRoZSBGaW5hbGl6YXRpb25SZWdpc3RyeVxuICAgICAgICAvLyB3aWxsIG5ldmVyIHRyaWdnZXIuXG4gICAgICAgIHRoaXMuX3NlcnZlckNvbmZpZy5yZWxlYXNlT25EZXJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VydmVyQ29uZmlnLnJlbGVhc2VPbkRlcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdzZXJ2ZXJhcHAnKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgcmVmQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZDb3VudDtcbiAgICB9XG4gICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQgb2YgdGhpcyBzZXJ2ZXIgYXBwLiBJZiBhbiBvYmplY3QgaXMgcHJvdmlkZWQsIHJlZ2lzdGVyIGl0XG4gICAgLy8gd2l0aCB0aGUgZmluYWxpemF0aW9uIHJlZ2lzdHJ5LlxuICAgIGluY1JlZkNvdW50KG9iaikge1xuICAgICAgICBpZiAodGhpcy5pc0RlbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZmluYWxpemF0aW9uUmVnaXN0cnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXphdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKG9iaiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGVjcmVtZW50IHRoZSByZWZlcmVuY2UgY291bnQuXG4gICAgZGVjUmVmQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0tdGhpcy5fcmVmQ291bnQ7XG4gICAgfVxuICAgIC8vIEludm9rZWQgYnkgdGhlIEZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbGxiYWNrIHRvIG5vdGUgdGhhdCB0aGlzIGFwcCBzaG91bGQgZ28gdGhyb3VnaCBpdHNcbiAgICAvLyByZWZlcmVuY2UgY291bnRzIGFuZCBkZWxldGUgaXRzZWxmIGlmIG5vIHJlZmVyZW5jZSBjb3VudCByZW1haW4uIFRoZSBjb29yZGluYXRpbmcgbG9naWMgdGhhdFxuICAgIC8vIGhhbmRsZXMgdGhpcyBpcyBpbiBkZWxldGVBcHAoLi4uKS5cbiAgICBhdXRvbWF0aWNDbGVhbnVwKCkge1xuICAgICAgICB2b2lkIGRlbGV0ZUFwcCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJDb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXG4gICAgICovXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJzZXJ2ZXItYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5TRVJWRVJfQVBQX0RFTEVURUQgKi8pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgY3VycmVudCBTREsgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcbmZ1bmN0aW9uIGluaXRpYWxpemVBcHAoX29wdGlvbnMsIHJhd0NvbmZpZyA9IHt9KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBfb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHJhd0NvbmZpZztcbiAgICAgICAgcmF3Q29uZmlnID0geyBuYW1lIH07XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBuYW1lOiBERUZBVUxUX0VOVFJZX05BTUUsIGF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDogZmFsc2UgfSwgcmF3Q29uZmlnKTtcbiAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWU7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImJhZC1hcHAtbmFtZVwiIC8qIEFwcEVycm9yLkJBRF9BUFBfTkFNRSAqLywge1xuICAgICAgICAgICAgYXBwTmFtZTogU3RyaW5nKG5hbWUpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0gZ2V0RGVmYXVsdEFwcENvbmZpZygpKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1vcHRpb25zXCIgLyogQXBwRXJyb3IuTk9fT1BUSU9OUyAqLyk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICAgIGlmIChleGlzdGluZ0FwcCkge1xuICAgICAgICAvLyByZXR1cm4gdGhlIGV4aXN0aW5nIGFwcCBpZiBvcHRpb25zIGFuZCBjb25maWcgZGVlcCBlcXVhbCB0aGUgb25lcyBpbiB0aGUgZXhpc3RpbmcgYXBwLlxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXG4gICAgICAgICAgICBkZWVwRXF1YWwoY29uZmlnLCBleGlzdGluZ0FwcC5jb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBcHA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImR1cGxpY2F0ZS1hcHBcIiAvKiBBcHBFcnJvci5EVVBMSUNBVEVfQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xuICAgIF9hcHBzLnNldChuYW1lLCBuZXdBcHApO1xuICAgIHJldHVybiBuZXdBcHA7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplU2VydmVyQXBwKF9vcHRpb25zLCBfc2VydmVyQXBwQ29uZmlnKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIC8vIEZpcmViYXNlU2VydmVyQXBwIGlzbid0IGRlc2lnbmVkIHRvIGJlIHJ1biBpbiBicm93c2Vycy5cbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpbnZhbGlkLXNlcnZlci1hcHAtZW52aXJvbm1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX1NFUlZFUl9BUFBfRU5WSVJPTk1FTlQgKi8pO1xuICAgIH1cbiAgICBpZiAoX3NlcnZlckFwcENvbmZpZy5hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfc2VydmVyQXBwQ29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYXBwT3B0aW9ucztcbiAgICBpZiAoX2lzRmlyZWJhc2VBcHAoX29wdGlvbnMpKSB7XG4gICAgICAgIGFwcE9wdGlvbnMgPSBfb3B0aW9ucy5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwT3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvLyBCdWlsZCBhbiBhcHAgbmFtZSBiYXNlZCBvbiBhIGhhc2ggb2YgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICBjb25zdCBuYW1lT2JqID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfc2VydmVyQXBwQ29uZmlnKSwgYXBwT3B0aW9ucyk7XG4gICAgLy8gSG93ZXZlciwgRG8gbm90IG1hbmdsZSB0aGUgbmFtZSBiYXNlZCBvbiByZWxlYXNlT25EZXJlZiwgc2luY2UgaXQgd2lsbCB2YXJ5IGJldHdlZW4gdGhlXG4gICAgLy8gY29uc3RydWN0aW9uIG9mIEZpcmViYXNlU2VydmVyQXBwIGluc3RhbmNlcy4gRm9yIGV4YW1wbGUsIGlmIHRoZSBvYmplY3QgaXMgdGhlIHJlcXVlc3QgaGVhZGVycy5cbiAgICBpZiAobmFtZU9iai5yZWxlYXNlT25EZXJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lT2JqLnJlbGVhc2VPbkRlcmVmO1xuICAgIH1cbiAgICBjb25zdCBoYXNoQ29kZSA9IChzKSA9PiB7XG4gICAgICAgIHJldHVybiBbLi4uc10ucmVkdWNlKChoYXNoLCBjKSA9PiAoTWF0aC5pbXVsKDMxLCBoYXNoKSArIGMuY2hhckNvZGVBdCgwKSkgfCAwLCAwKTtcbiAgICB9O1xuICAgIGlmIChfc2VydmVyQXBwQ29uZmlnLnJlbGVhc2VPbkRlcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZmluYWxpemF0aW9uLXJlZ2lzdHJ5LW5vdC1zdXBwb3J0ZWRcIiAvKiBBcHBFcnJvci5GSU5BTElaQVRJT05fUkVHSVNUUllfTk9UX1NVUFBPUlRFRCAqLywge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSAnJyArIGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KG5hbWVPYmopKTtcbiAgICBjb25zdCBleGlzdGluZ0FwcCA9IF9zZXJ2ZXJBcHBzLmdldChuYW1lU3RyaW5nKTtcbiAgICBpZiAoZXhpc3RpbmdBcHApIHtcbiAgICAgICAgZXhpc3RpbmdBcHAuaW5jUmVmQ291bnQoX3NlcnZlckFwcENvbmZpZy5yZWxlYXNlT25EZXJlZik7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0FwcDtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbXBvbmVudENvbnRhaW5lcihuYW1lU3RyaW5nKTtcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xuICAgICAgICBjb250YWluZXIuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZVNlcnZlckFwcEltcGwoYXBwT3B0aW9ucywgX3NlcnZlckFwcENvbmZpZywgbmFtZVN0cmluZywgY29udGFpbmVyKTtcbiAgICBfc2VydmVyQXBwcy5zZXQobmFtZVN0cmluZywgbmV3QXBwKTtcbiAgICByZXR1cm4gbmV3QXBwO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC4gV2hlbiBhbiBhcHAgbmFtZVxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGUgYXBwIGJlaW5nIHJldHJpZXZlZCBoYXMgbm90IHlldCBiZWVuXG4gKiBpbml0aWFsaXplZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIHRoZSBkZWZhdWx0IGFwcFxuICogY29uc3QgYXBwID0gZ2V0QXBwKCk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gUmV0dXJuIGEgbmFtZWQgYXBwXG4gKiBjb25zdCBvdGhlckFwcCA9IGdldEFwcChcIm90aGVyQXBwXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBPcHRpb25hbCBuYW1lIG9mIHRoZSBhcHAgdG8gcmV0dXJuLiBJZiBubyBuYW1lIGlzXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXG4gKlxuICogQHJldHVybnMgVGhlIGFwcCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBhcHAgbmFtZS5cbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEFwcChuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgY29uc3QgYXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xuICAgIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSAmJiBnZXREZWZhdWx0QXBwQ29uZmlnKCkpIHtcbiAgICAgICAgcmV0dXJuIGluaXRpYWxpemVBcHAoKTtcbiAgICB9XG4gICAgaWYgKCFhcHApIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcHBcIiAvKiBBcHBFcnJvci5OT19BUFAgKi8sIHsgYXBwTmFtZTogbmFtZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFwcDtcbn1cbi8qKlxuICogQSAocmVhZC1vbmx5KSBhcnJheSBvZiBhbGwgaW5pdGlhbGl6ZWQgYXBwcy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QXBwcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShfYXBwcy52YWx1ZXMoKSk7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhpcyBhcHAgdW51c2FibGUgYW5kIGZyZWVzIHRoZSByZXNvdXJjZXMgb2YgYWxsIGFzc29jaWF0ZWRcbiAqIHNlcnZpY2VzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBkZWxldGVBcHAoYXBwKVxuICogICAudGhlbihmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcbiAqICAgfSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcbiAgICBsZXQgY2xlYW51cFByb3ZpZGVycyA9IGZhbHNlO1xuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcbiAgICBpZiAoX2FwcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNsZWFudXBQcm92aWRlcnMgPSB0cnVlO1xuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9zZXJ2ZXJBcHBzLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zdCBmaXJlYmFzZVNlcnZlckFwcCA9IGFwcDtcbiAgICAgICAgaWYgKGZpcmViYXNlU2VydmVyQXBwLmRlY1JlZkNvdW50KCkgPD0gMCkge1xuICAgICAgICAgICAgX3NlcnZlckFwcHMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgY2xlYW51cFByb3ZpZGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsZWFudXBQcm92aWRlcnMpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxuICAgICAgICAgICAgLmdldFByb3ZpZGVycygpXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyLmRlbGV0ZSgpKSk7XG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgbGlicmFyeSdzIG5hbWUgYW5kIHZlcnNpb24gZm9yIHBsYXRmb3JtIGxvZ2dpbmcgcHVycG9zZXMuXG4gKiBAcGFyYW0gbGlicmFyeSAtIE5hbWUgb2YgMXAgb3IgM3AgbGlicmFyeSAoZS5nLiBmaXJlc3RvcmUsIGFuZ3VsYXJmaXJlKVxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxuICogQHBhcmFtIHZhcmlhbnQgLSBCdW5kbGUgdmFyaWFudCwgZS5nLiwgbm9kZSwgcm4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVmVyc2lvbihsaWJyYXJ5S2V5T3JOYW1lLCB2ZXJzaW9uLCB2YXJpYW50KSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFRPRE86IFdlIGNhbiB1c2UgdGhpcyBjaGVjayB0byB3aGl0ZWxpc3Qgc3RyaW5ncyB3aGVuL2lmIHdlIHNldCB1cFxuICAgIC8vIGEgZ29vZCB3aGl0ZWxpc3Qgc3lzdGVtLlxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcbiAgICBpZiAodmFyaWFudCkge1xuICAgICAgICBsaWJyYXJ5ICs9IGAtJHt2YXJpYW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGxpYnJhcnlNaXNtYXRjaCA9IGxpYnJhcnkubWF0Y2goL1xcc3xcXC8vKTtcbiAgICBjb25zdCB2ZXJzaW9uTWlzbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKC9cXHN8XFwvLyk7XG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZyA9IFtcbiAgICAgICAgICAgIGBVbmFibGUgdG8gcmVnaXN0ZXIgbGlicmFyeSBcIiR7bGlicmFyeX1cIiB3aXRoIHZlcnNpb24gXCIke3ZlcnNpb259XCI6YFxuICAgICAgICBdO1xuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoKSB7XG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goYGxpYnJhcnkgbmFtZSBcIiR7bGlicmFyeX1cIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMgKHdoaXRlc3BhY2Ugb3IgXCIvXCIpYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpYnJhcnlNaXNtYXRjaCAmJiB2ZXJzaW9uTWlzbWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaCgnYW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnNpb25NaXNtYXRjaCkge1xuICAgICAgICAgICAgd2FybmluZy5wdXNoKGB2ZXJzaW9uIG5hbWUgXCIke3ZlcnNpb259XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci53YXJuKHdhcm5pbmcuam9pbignICcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChgJHtsaWJyYXJ5fS12ZXJzaW9uYCwgKCkgPT4gKHsgbGlicmFyeSwgdmVyc2lvbiB9KSwgXCJWRVJTSU9OXCIgLyogQ29tcG9uZW50VHlwZS5WRVJTSU9OICovKSk7XG59XG4vKipcbiAqIFNldHMgbG9nIGhhbmRsZXIgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICogQHBhcmFtIGxvZ0NhbGxiYWNrIC0gQW4gb3B0aW9uYWwgY3VzdG9tIGxvZyBoYW5kbGVyIHRoYXQgZXhlY3V0ZXMgdXNlciBjb2RlIHdoZW5ldmVyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb25Mb2cobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBpZiAobG9nQ2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGxvZ0NhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XG4gICAgfVxuICAgIHNldFVzZXJMb2dIYW5kbGVyKGxvZ0NhbGxiYWNrLCBvcHRpb25zKTtcbn1cbi8qKlxuICogU2V0cyBsb2cgbGV2ZWwgZm9yIGFsbCBGaXJlYmFzZSBTREtzLlxuICpcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBhcmUgY2FwdHVyZWQgKGkuZS4gaWZcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgaW5mb2AsIGVycm9ycyBhcmUgbG9nZ2VkLCBidXQgYGRlYnVnYCBhbmRcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICBzZXRMb2dMZXZlbCQxKGxvZ0xldmVsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERCX05BTUUgPSAnZmlyZWJhc2UtaGVhcnRiZWF0LWRhdGFiYXNlJztcbmNvbnN0IERCX1ZFUlNJT04gPSAxO1xuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xubGV0IGRiUHJvbWlzZSA9IG51bGw7XG5mdW5jdGlvbiBnZXREYlByb21pc2UoKSB7XG4gICAgaWYgKCFkYlByb21pc2UpIHtcbiAgICAgICAgZGJQcm9taXNlID0gb3BlbkRCKERCX05BTUUsIERCX1ZFUlNJT04sIHtcbiAgICAgICAgICAgIHVwZ3JhZGU6IChkYiwgb2xkVmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIGJlaGF2aW9yIGlzIHdoYXQgd2Ugd2FudCwgYmVjYXVzZSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgdmVyc2lvbnMgYmV0d2VlblxuICAgICAgICAgICAgICAgIC8vIHRoZSBvbGQgdmVyc2lvbiBhbmQgdGhlIGN1cnJlbnQgdmVyc2lvbiwgd2Ugd2FudCBBTEwgdGhlIG1pZ3JhdGlvbnNcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICAgICAgICAgIHN3aXRjaCAob2xkVmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkvaU9TIGJyb3dzZXJzIHRocm93IG9jY2FzaW9uYWwgZXhjZXB0aW9ucyBvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCkgdGhhdCBtYXkgYmUgYSBidWcuIEF2b2lkIGJsb2NraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlIGFwcCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItb3BlblwiIC8qIEFwcEVycm9yLklEQl9PUEVOICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGJQcm9taXNlO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpLmdldChjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgdGhlIHZhbHVlIGJ1dCB0eC5kb25lIGNhbiB0aHJvdyxcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBhd2FpdCBpdCBoZXJlIHRvIGNhdGNoIGVycm9yc1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQihhcHAsIGhlYXJ0YmVhdE9iamVjdCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICBjb25zdCBvYmplY3RTdG9yZSA9IHR4Lm9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLXNldFwiIC8qIEFwcEVycm9yLklEQl9XUklURSAqLywge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihpZGJHZXRFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVLZXkoYXBwKSB7XG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBNQVhfSEVBREVSX0JZVEVTID0gMTAyNDtcbi8vIDMwIGRheXNcbmNvbnN0IFNUT1JFRF9IRUFSVEJFQVRfUkVURU5USU9OX01BWF9NSUxMSVMgPSAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDA7XG5jbGFzcyBIZWFydGJlYXRTZXJ2aWNlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxuICAgICAgICAgKiB0aGUgaGVhZGVyIHN0cmluZy5cbiAgICAgICAgICogU3RvcmVzIG9uZSByZWNvcmQgcGVyIGRhdGUuIFRoaXMgd2lsbCBiZSBjb25zb2xpZGF0ZWQgaW50byB0aGUgc3RhbmRhcmRcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxuICAgICAgICAgKiBQb3B1bGF0ZWQgZnJvbSBpbmRleGVkREIgd2hlbiB0aGUgY29udHJvbGxlciBpcyBpbnN0YW50aWF0ZWQgYW5kIHNob3VsZFxuICAgICAgICAgKiBiZSBrZXB0IGluIHN5bmMgd2l0aCBpbmRleGVkREIuXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPSBudWxsO1xuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIHRoaXMuX3N0b3JhZ2UgPSBuZXcgSGVhcnRiZWF0U3RvcmFnZUltcGwoYXBwKTtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZSA9IHRoaXMuX3N0b3JhZ2UucmVhZCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gcmVwb3J0IGEgaGVhcnRiZWF0LiBUaGUgZnVuY3Rpb24gd2lsbCBnZW5lcmF0ZVxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcbiAgICAgKiB0byBJbmRleGVkREIuXG4gICAgICogTm90ZSB0aGF0IHdlIG9ubHkgc3RvcmUgb25lIGhlYXJ0YmVhdCBwZXIgZGF5LiBTbyBpZiBhIGhlYXJ0YmVhdCBmb3IgdG9kYXkgaXNcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgYXN5bmMgdHJpZ2dlckhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBsYXRmb3JtTG9nZ2VyID0gdGhpcy5jb250YWluZXJcbiAgICAgICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgXCJGaXJlYmFzZSB1c2VyIGFnZW50XCIgc3RyaW5nIGZyb20gdGhlIHBsYXRmb3JtIGxvZ2dlclxuICAgICAgICAgICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXG4gICAgICAgICAgICBjb25zdCBhZ2VudCA9IHBsYXRmb3JtTG9nZ2VyLmdldFBsYXRmb3JtSW5mb1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IGF3YWl0IHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2U7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGNvbnN0cnVjdCBhIGhlYXJ0YmVhdHMgY2FjaGUsIHRoZW4gcmV0dXJuIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIGlmICgoKF9iID0gdGhpcy5faGVhcnRiZWF0c0NhY2hlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhcnRiZWF0cykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcbiAgICAgICAgICAgIC8vIG9yIGlmIGEgaGVhZGVyIGhhcyBhbHJlYWR5IGJlZW4gc2VudCB0b2RheS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID09PSBkYXRlIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBlbnRyeSBmb3IgdGhpcyBkYXRlLiBDcmVhdGUgb25lLlxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzLnB1c2goeyBkYXRlLCBhZ2VudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbnRyaWVzIG9sZGVyIHRoYW4gMzAgZGF5cy5cbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID1cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5maWx0ZXIoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgd2hpY2ggY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBoZWFydGJlYXQtc3BlY2lmaWMgaGVhZGVyIGRpcmVjdGx5LlxuICAgICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxuICAgICAqXG4gICAgICogTk9URTogQ29uc3VtaW5nIHByb2R1Y3QgU0RLcyBzaG91bGQgbm90IHNlbmQgdGhlIGhlYWRlciBpZiB0aGlzIG1ldGhvZFxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9oZWFydGJlYXRzQ2FjaGVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBudWxsIG9yIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gZGF0YSB0byBzZW5kLlxuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWFydGJlYXRzKSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgYXMgbWFueSBoZWFydGJlYXRzIGZyb20gdGhlIGNhY2hlIGFzIHdpbGwgZml0IHVuZGVyIHRoZSBzaXplIGxpbWl0LlxuICAgICAgICAgICAgY29uc3QgeyBoZWFydGJlYXRzVG9TZW5kLCB1bnNlbnRFbnRyaWVzIH0gPSBleHRyYWN0SGVhcnRiZWF0c0ZvckhlYWRlcih0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xuICAgICAgICAgICAgLy8gU3RvcmUgbGFzdCBzZW50IGRhdGUgdG8gcHJldmVudCBhbm90aGVyIGJlaW5nIGxvZ2dlZC9zZW50IGZvciB0aGUgc2FtZSBkYXkuXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUubGFzdFNlbnRIZWFydGJlYXREYXRlID0gZGF0ZTtcbiAgICAgICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBhbnkgdW5zZW50IGVudHJpZXMgaWYgdGhleSBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IHVuc2VudEVudHJpZXM7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgY2FjaGUgaXNuJ3QgZW1wdHkgYW5kIHRoaXMgd2lsbCBiZSBjYWxsZWQgYWdhaW4gb24gdGhlIG5leHQgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXMgcHJvYmFibHkgc2FmZXN0IGlmIHdlIGF3YWl0IGl0LlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzLCB0byByZWR1Y2UgbGF0ZW5jeS5cbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhZGVyU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFVUQ0RhdGVTdHJpbmcoKSB7XG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIFJldHVybnMgZGF0ZSBmb3JtYXQgJ1lZWVktTU0tREQnXG4gICAgcmV0dXJuIHRvZGF5LnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKGhlYXJ0YmVhdHNDYWNoZSwgbWF4U2l6ZSA9IE1BWF9IRUFERVJfQllURVMpIHtcbiAgICAvLyBIZWFydGJlYXRzIGdyb3VwZWQgYnkgdXNlciBhZ2VudCBpbiB0aGUgc3RhbmRhcmQgZm9ybWF0IHRvIGJlIHNlbnQgaW5cbiAgICAvLyB0aGUgaGVhZGVyLlxuICAgIGNvbnN0IGhlYXJ0YmVhdHNUb1NlbmQgPSBbXTtcbiAgICAvLyBTaW5nbGUgZGF0ZSBmb3JtYXQgaGVhcnRiZWF0cyB0aGF0IGFyZSBub3Qgc2VudC5cbiAgICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xuICAgIGZvciAoY29uc3Qgc2luZ2xlRGF0ZUhlYXJ0YmVhdCBvZiBoZWFydGJlYXRzQ2FjaGUpIHtcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gZXhpc3RpbmcgZW50cnkgd2l0aCB0aGUgc2FtZSB1c2VyIGFnZW50LlxuICAgICAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChoYiA9PiBoYi5hZ2VudCA9PT0gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCk7XG4gICAgICAgIGlmICghaGVhcnRiZWF0RW50cnkpIHtcbiAgICAgICAgICAgIC8vIElmIG5vIGVudHJ5IGZvciB0aGlzIHVzZXIgYWdlbnQgZXhpc3RzLCBjcmVhdGUgb25lLlxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBhZ2VudDogc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCxcbiAgICAgICAgICAgICAgICBkYXRlczogW3NpbmdsZURhdGVIZWFydGJlYXQuZGF0ZV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgaGVhcnRiZWF0XG4gICAgICAgICAgICAgICAgLy8gZW50cnkgYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wb3AoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGRhdGVcbiAgICAgICAgICAgIC8vIGFuZCBzdG9wIGFkZGluZyB0byB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0RW50cnkuZGF0ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wIHVuc2VudCBlbnRyeSBmcm9tIHF1ZXVlLiAoU2tpcHBlZCBpZiBhZGRpbmcgdGhlIGVudHJ5IGV4Y2VlZGVkXG4gICAgICAgIC8vIHF1b3RhIGFuZCB0aGUgbG9vcCBicmVha3MgZWFybHkuKVxuICAgICAgICB1bnNlbnRFbnRyaWVzID0gdW5zZW50RW50cmllcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhcnRiZWF0c1RvU2VuZCxcbiAgICAgICAgdW5zZW50RW50cmllc1xuICAgIH07XG59XG5jbGFzcyBIZWFydGJlYXRTdG9yYWdlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlID0gdGhpcy5ydW5JbmRleGVkREJFbnZpcm9ubWVudENoZWNrKCk7XG4gICAgfVxuICAgIGFzeW5jIHJ1bkluZGV4ZWREQkVudmlyb25tZW50Q2hlY2soKSB7XG4gICAgICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRydWUpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkIGFsbCBoZWFydGJlYXRzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWQoKSB7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWRiSGVhcnRiZWF0T2JqZWN0ID0gYXdhaXQgcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKHRoaXMuYXBwKTtcbiAgICAgICAgICAgIGlmIChpZGJIZWFydGJlYXRPYmplY3QgPT09IG51bGwgfHwgaWRiSGVhcnRiZWF0T2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpZGJIZWFydGJlYXRPYmplY3QuaGVhcnRiZWF0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZGJIZWFydGJlYXRPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBoZWFydGJlYXRzOiBbXSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXG4gICAgYXN5bmMgb3ZlcndyaXRlKGhlYXJ0YmVhdHNPYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xuICAgICAgICBpZiAoIWNhblVzZUluZGV4ZWREQikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcbiAgICAgICAgICAgICAgICBsYXN0U2VudEhlYXJ0YmVhdERhdGU6IChfYSA9IGhlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QubGFzdFNlbnRIZWFydGJlYXREYXRlLFxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcbiAgICBhc3luYyBhZGQoaGVhcnRiZWF0c09iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QgPSBhd2FpdCB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0czogW1xuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcbiAgICAgICAgICAgICAgICAgICAgLi4uaGVhcnRiZWF0c09iamVjdC5oZWFydGJlYXRzXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENhbGN1bGF0ZSBieXRlcyBvZiBhIEhlYXJ0YmVhdHNCeVVzZXJBZ2VudCBhcnJheSBhZnRlciBiZWluZyB3cmFwcGVkXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxuICogdG8gYmFzZSA2NC5cbiAqL1xuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcbiAgICAvLyBiYXNlNjQgaGFzIGEgcmVzdHJpY3RlZCBzZXQgb2YgY2hhcmFjdGVycywgYWxsIG9mIHdoaWNoIHNob3VsZCBiZSAxIGJ5dGUuXG4gICAgcmV0dXJuIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKFxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcbiAgICBKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNDYWNoZSB9KSkubGVuZ3RoO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ3BsYXRmb3JtLWxvZ2dlcicsIGNvbnRhaW5lciA9PiBuZXcgUGxhdGZvcm1Mb2dnZXJTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgnaGVhcnRiZWF0JywgY29udGFpbmVyID0+IG5ldyBIZWFydGJlYXRTZXJ2aWNlSW1wbChjb250YWluZXIpLCBcIlBSSVZBVEVcIiAvKiBDb21wb25lbnRUeXBlLlBSSVZBVEUgKi8pKTtcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxuICAgIHJlZ2lzdGVyVmVyc2lvbihuYW1lJHEsIHZlcnNpb24kMSwgdmFyaWFudCk7XG4gICAgLy8gQlVJTERfVEFSR0VUIHdpbGwgYmUgcmVwbGFjZWQgYnkgdmFsdWVzIGxpa2UgZXNtMjAxNywgY2pzMjAxNywgZXRjIGR1cmluZyB0aGUgY29tcGlsYXRpb25cbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRxLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XG4gICAgLy8gUmVnaXN0ZXIgcGxhdGZvcm0gU0RLIGlkZW50aWZpZXIgKG5vIHZlcnNpb24pLlxuICAgIHJlZ2lzdGVyVmVyc2lvbignZmlyZS1qcycsICcnKTtcbn1cblxuLyoqXG4gKiBGaXJlYmFzZSBBcHBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfaXNGaXJlYmFzZUFwcCwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgX3JlbW92ZVNlcnZpY2VJbnN0YW5jZSwgX3NlcnZlckFwcHMsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBpbml0aWFsaXplU2VydmVyQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionCodeOperation: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   ActionCodeURL: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   AuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   AuthErrorCodes: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   EmailAuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   EmailAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   FacebookAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   FactorId: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   GithubAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   GoogleAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   OAuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   OAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   OperationType: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   PhoneAuthCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   PhoneAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PhoneMultiFactorGenerator: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   ProviderId: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   RecaptchaVerifier: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SAMLAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   SignInMethod: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   TotpMultiFactorGenerator: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TotpSecret: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   TwitterAuthProvider: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   applyActionCode: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a7),\n/* harmony export */   beforeAuthStateChanged: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   browserLocalPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   browserPopupRedirectResolver: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   browserSessionPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   checkActionCode: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   confirmPasswordReset: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   connectAuthEmulator: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   createUserWithEmailAndPassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   debugErrorMap: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   deleteUser: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   fetchSignInMethodsForEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   getAdditionalUserInfo: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   getAuth: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getIdToken: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   getIdTokenResult: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   getMultiFactorResolver: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   getRedirectResult: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   inMemoryPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.U),\n/* harmony export */   indexedDBLocalPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   initializeAuth: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   initializeRecaptchaConfig: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   isSignInWithEmailLink: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   linkWithCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   linkWithPhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   linkWithPopup: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   linkWithRedirect: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   multiFactor: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   onAuthStateChanged: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   onIdTokenChanged: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   parseActionCodeURL: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   prodErrorMap: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   reauthenticateWithCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   reauthenticateWithPhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   reauthenticateWithPopup: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   reauthenticateWithRedirect: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   reload: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   revokeAccessToken: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   sendEmailVerification: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   sendPasswordResetEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   sendSignInLinkToEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   setPersistence: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   signInAnonymously: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   signInWithCredential: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   signInWithCustomToken: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   signInWithEmailAndPassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   signInWithEmailLink: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   signInWithPhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   signInWithPopup: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   signInWithRedirect: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   signOut: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   unlink: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   updateCurrentUser: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   updateEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   updatePassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   updatePhoneNumber: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   updateProfile: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   useDeviceLanguage: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   validatePassword: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   verifyBeforeUpdateEmail: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   verifyPasswordResetCode: () => (/* reexport safe */ _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__.a9)\n/* harmony export */ });\n/* harmony import */ var _totp_3df2f5f9_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp-3df2f5f9.js */ \"(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js\");\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3bEU7QUFDamtFO0FBQ0M7QUFDVDtBQUNjO0FBQ0g7QUFDMUIiLCJzb3VyY2VzIjpbIi9ob21lL3JndGVjaDAwOC9hY2FkZW1pYy1jb25uZWN0LXByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQSBhcyBBY3Rpb25Db2RlT3BlcmF0aW9uLCBhaSBhcyBBY3Rpb25Db2RlVVJMLCBMIGFzIEF1dGhDcmVkZW50aWFsLCBJIGFzIEF1dGhFcnJvckNvZGVzLCBNIGFzIEVtYWlsQXV0aENyZWRlbnRpYWwsIFYgYXMgRW1haWxBdXRoUHJvdmlkZXIsIFcgYXMgRmFjZWJvb2tBdXRoUHJvdmlkZXIsIEYgYXMgRmFjdG9ySWQsIFkgYXMgR2l0aHViQXV0aFByb3ZpZGVyLCBYIGFzIEdvb2dsZUF1dGhQcm92aWRlciwgTiBhcyBPQXV0aENyZWRlbnRpYWwsIFogYXMgT0F1dGhQcm92aWRlciwgTyBhcyBPcGVyYXRpb25UeXBlLCBRIGFzIFBob25lQXV0aENyZWRlbnRpYWwsIFAgYXMgUGhvbmVBdXRoUHJvdmlkZXIsIG0gYXMgUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciwgcCBhcyBQcm92aWRlcklkLCBSIGFzIFJlY2FwdGNoYVZlcmlmaWVyLCBfIGFzIFNBTUxBdXRoUHJvdmlkZXIsIFMgYXMgU2lnbkluTWV0aG9kLCBUIGFzIFRvdHBNdWx0aUZhY3RvckdlbmVyYXRvciwgbiBhcyBUb3RwU2VjcmV0LCAkIGFzIFR3aXR0ZXJBdXRoUHJvdmlkZXIsIGE3IGFzIGFwcGx5QWN0aW9uQ29kZSwgeCBhcyBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkLCBiIGFzIGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlLCBrIGFzIGJyb3dzZXJQb3B1cFJlZGlyZWN0UmVzb2x2ZXIsIGEgYXMgYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSwgYTggYXMgY2hlY2tBY3Rpb25Db2RlLCBhNiBhcyBjb25maXJtUGFzc3dvcmRSZXNldCwgSyBhcyBjb25uZWN0QXV0aEVtdWxhdG9yLCBhYSBhcyBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmQsIEcgYXMgZGVidWdFcnJvck1hcCwgRSBhcyBkZWxldGVVc2VyLCBhZiBhcyBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbCwgYXEgYXMgZ2V0QWRkaXRpb25hbFVzZXJJbmZvLCBvIGFzIGdldEF1dGgsIGFuIGFzIGdldElkVG9rZW4sIGFvIGFzIGdldElkVG9rZW5SZXN1bHQsIGFzIGFzIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIsIGogYXMgZ2V0UmVkaXJlY3RSZXN1bHQsIFUgYXMgaW5NZW1vcnlQZXJzaXN0ZW5jZSwgaSBhcyBpbmRleGVkREJMb2NhbFBlcnNpc3RlbmNlLCBKIGFzIGluaXRpYWxpemVBdXRoLCB0IGFzIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcsIGFkIGFzIGlzU2lnbkluV2l0aEVtYWlsTGluaywgYTIgYXMgbGlua1dpdGhDcmVkZW50aWFsLCBsIGFzIGxpbmtXaXRoUGhvbmVOdW1iZXIsIGQgYXMgbGlua1dpdGhQb3B1cCwgZyBhcyBsaW5rV2l0aFJlZGlyZWN0LCBhdCBhcyBtdWx0aUZhY3RvciwgeSBhcyBvbkF1dGhTdGF0ZUNoYW5nZWQsIHcgYXMgb25JZFRva2VuQ2hhbmdlZCwgYWogYXMgcGFyc2VBY3Rpb25Db2RlVVJMLCBIIGFzIHByb2RFcnJvck1hcCwgYTMgYXMgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbCwgciBhcyByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciwgZSBhcyByZWF1dGhlbnRpY2F0ZVdpdGhQb3B1cCwgaCBhcyByZWF1dGhlbnRpY2F0ZVdpdGhSZWRpcmVjdCwgYXIgYXMgcmVsb2FkLCBEIGFzIHJldm9rZUFjY2Vzc1Rva2VuLCBhZyBhcyBzZW5kRW1haWxWZXJpZmljYXRpb24sIGE1IGFzIHNlbmRQYXNzd29yZFJlc2V0RW1haWwsIGFjIGFzIHNlbmRTaWduSW5MaW5rVG9FbWFpbCwgcSBhcyBzZXRQZXJzaXN0ZW5jZSwgYTAgYXMgc2lnbkluQW5vbnltb3VzbHksIGExIGFzIHNpZ25JbldpdGhDcmVkZW50aWFsLCBhNCBhcyBzaWduSW5XaXRoQ3VzdG9tVG9rZW4sIGFiIGFzIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkLCBhZSBhcyBzaWduSW5XaXRoRW1haWxMaW5rLCBzIGFzIHNpZ25JbldpdGhQaG9uZU51bWJlciwgYyBhcyBzaWduSW5XaXRoUG9wdXAsIGYgYXMgc2lnbkluV2l0aFJlZGlyZWN0LCBDIGFzIHNpZ25PdXQsIGFwIGFzIHVubGluaywgQiBhcyB1cGRhdGVDdXJyZW50VXNlciwgYWwgYXMgdXBkYXRlRW1haWwsIGFtIGFzIHVwZGF0ZVBhc3N3b3JkLCB1IGFzIHVwZGF0ZVBob25lTnVtYmVyLCBhayBhcyB1cGRhdGVQcm9maWxlLCB6IGFzIHVzZURldmljZUxhbmd1YWdlLCB2IGFzIHZhbGlkYXRlUGFzc3dvcmQsIGFoIGFzIHZlcmlmeUJlZm9yZVVwZGF0ZUVtYWlsLCBhOSBhcyB2ZXJpZnlQYXNzd29yZFJlc2V0Q29kZSB9IGZyb20gJy4vdG90cC0zZGYyZjVmOS5qcyc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0ICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgJ3RzbGliJztcbmltcG9ydCAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9sb2dnZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ TwitterAuthProvider),\n/* harmony export */   A: () => (/* binding */ ActionCodeOperation),\n/* harmony export */   B: () => (/* binding */ updateCurrentUser),\n/* harmony export */   C: () => (/* binding */ signOut),\n/* harmony export */   D: () => (/* binding */ revokeAccessToken),\n/* harmony export */   E: () => (/* binding */ deleteUser),\n/* harmony export */   F: () => (/* binding */ FactorId),\n/* harmony export */   G: () => (/* binding */ debugErrorMap),\n/* harmony export */   H: () => (/* binding */ prodErrorMap),\n/* harmony export */   I: () => (/* binding */ AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY),\n/* harmony export */   J: () => (/* binding */ initializeAuth),\n/* harmony export */   K: () => (/* binding */ connectAuthEmulator),\n/* harmony export */   L: () => (/* binding */ AuthCredential),\n/* harmony export */   M: () => (/* binding */ EmailAuthCredential),\n/* harmony export */   N: () => (/* binding */ OAuthCredential),\n/* harmony export */   O: () => (/* binding */ OperationType),\n/* harmony export */   P: () => (/* binding */ PhoneAuthProvider),\n/* harmony export */   Q: () => (/* binding */ PhoneAuthCredential),\n/* harmony export */   R: () => (/* binding */ RecaptchaVerifier),\n/* harmony export */   S: () => (/* binding */ SignInMethod),\n/* harmony export */   T: () => (/* binding */ TotpMultiFactorGenerator),\n/* harmony export */   U: () => (/* binding */ inMemoryPersistence),\n/* harmony export */   V: () => (/* binding */ EmailAuthProvider),\n/* harmony export */   W: () => (/* binding */ FacebookAuthProvider),\n/* harmony export */   X: () => (/* binding */ GoogleAuthProvider),\n/* harmony export */   Y: () => (/* binding */ GithubAuthProvider),\n/* harmony export */   Z: () => (/* binding */ OAuthProvider),\n/* harmony export */   _: () => (/* binding */ SAMLAuthProvider),\n/* harmony export */   a: () => (/* binding */ browserSessionPersistence),\n/* harmony export */   a0: () => (/* binding */ signInAnonymously),\n/* harmony export */   a1: () => (/* binding */ signInWithCredential),\n/* harmony export */   a2: () => (/* binding */ linkWithCredential),\n/* harmony export */   a3: () => (/* binding */ reauthenticateWithCredential),\n/* harmony export */   a4: () => (/* binding */ signInWithCustomToken),\n/* harmony export */   a5: () => (/* binding */ sendPasswordResetEmail),\n/* harmony export */   a6: () => (/* binding */ confirmPasswordReset),\n/* harmony export */   a7: () => (/* binding */ applyActionCode),\n/* harmony export */   a8: () => (/* binding */ checkActionCode),\n/* harmony export */   a9: () => (/* binding */ verifyPasswordResetCode),\n/* harmony export */   aA: () => (/* binding */ _fail),\n/* harmony export */   aB: () => (/* binding */ debugAssert),\n/* harmony export */   aC: () => (/* binding */ _persistenceKeyName),\n/* harmony export */   aD: () => (/* binding */ _serverAppCurrentUserOperationNotSupportedError),\n/* harmony export */   aE: () => (/* binding */ _castAuth),\n/* harmony export */   aF: () => (/* binding */ FederatedAuthProvider),\n/* harmony export */   aG: () => (/* binding */ BaseOAuthProvider),\n/* harmony export */   aH: () => (/* binding */ _emulatorUrl),\n/* harmony export */   aI: () => (/* binding */ _performApiRequest),\n/* harmony export */   aJ: () => (/* binding */ _isIOS),\n/* harmony export */   aK: () => (/* binding */ _isAndroid),\n/* harmony export */   aL: () => (/* binding */ _isIOS7Or8),\n/* harmony export */   aM: () => (/* binding */ _createError),\n/* harmony export */   aN: () => (/* binding */ _isMobileBrowser),\n/* harmony export */   aO: () => (/* binding */ _isIE10),\n/* harmony export */   aP: () => (/* binding */ UserImpl),\n/* harmony export */   aQ: () => (/* binding */ AuthImpl),\n/* harmony export */   aR: () => (/* binding */ _getClientVersion),\n/* harmony export */   aS: () => (/* binding */ FetchProvider),\n/* harmony export */   aT: () => (/* binding */ SAMLAuthCredential),\n/* harmony export */   aa: () => (/* binding */ createUserWithEmailAndPassword),\n/* harmony export */   ab: () => (/* binding */ signInWithEmailAndPassword),\n/* harmony export */   ac: () => (/* binding */ sendSignInLinkToEmail),\n/* harmony export */   ad: () => (/* binding */ isSignInWithEmailLink),\n/* harmony export */   ae: () => (/* binding */ signInWithEmailLink),\n/* harmony export */   af: () => (/* binding */ fetchSignInMethodsForEmail),\n/* harmony export */   ag: () => (/* binding */ sendEmailVerification),\n/* harmony export */   ah: () => (/* binding */ verifyBeforeUpdateEmail),\n/* harmony export */   ai: () => (/* binding */ ActionCodeURL),\n/* harmony export */   aj: () => (/* binding */ parseActionCodeURL),\n/* harmony export */   ak: () => (/* binding */ updateProfile),\n/* harmony export */   al: () => (/* binding */ updateEmail),\n/* harmony export */   am: () => (/* binding */ updatePassword),\n/* harmony export */   an: () => (/* binding */ getIdToken),\n/* harmony export */   ao: () => (/* binding */ getIdTokenResult),\n/* harmony export */   ap: () => (/* binding */ unlink),\n/* harmony export */   aq: () => (/* binding */ getAdditionalUserInfo),\n/* harmony export */   ar: () => (/* binding */ reload),\n/* harmony export */   as: () => (/* binding */ getMultiFactorResolver),\n/* harmony export */   at: () => (/* binding */ multiFactor),\n/* harmony export */   au: () => (/* binding */ _getInstance),\n/* harmony export */   av: () => (/* binding */ _assert),\n/* harmony export */   aw: () => (/* binding */ _signInWithCredential),\n/* harmony export */   ax: () => (/* binding */ _reauthenticate),\n/* harmony export */   ay: () => (/* binding */ _link),\n/* harmony export */   az: () => (/* binding */ signInWithIdp),\n/* harmony export */   b: () => (/* binding */ browserLocalPersistence),\n/* harmony export */   c: () => (/* binding */ signInWithPopup),\n/* harmony export */   d: () => (/* binding */ linkWithPopup),\n/* harmony export */   e: () => (/* binding */ reauthenticateWithPopup),\n/* harmony export */   f: () => (/* binding */ signInWithRedirect),\n/* harmony export */   g: () => (/* binding */ linkWithRedirect),\n/* harmony export */   h: () => (/* binding */ reauthenticateWithRedirect),\n/* harmony export */   i: () => (/* binding */ indexedDBLocalPersistence),\n/* harmony export */   j: () => (/* binding */ getRedirectResult),\n/* harmony export */   k: () => (/* binding */ browserPopupRedirectResolver),\n/* harmony export */   l: () => (/* binding */ linkWithPhoneNumber),\n/* harmony export */   m: () => (/* binding */ PhoneMultiFactorGenerator),\n/* harmony export */   n: () => (/* binding */ TotpSecret),\n/* harmony export */   o: () => (/* binding */ getAuth),\n/* harmony export */   p: () => (/* binding */ ProviderId),\n/* harmony export */   q: () => (/* binding */ setPersistence),\n/* harmony export */   r: () => (/* binding */ reauthenticateWithPhoneNumber),\n/* harmony export */   s: () => (/* binding */ signInWithPhoneNumber),\n/* harmony export */   t: () => (/* binding */ initializeRecaptchaConfig),\n/* harmony export */   u: () => (/* binding */ updatePhoneNumber),\n/* harmony export */   v: () => (/* binding */ validatePassword),\n/* harmony export */   w: () => (/* binding */ onIdTokenChanged),\n/* harmony export */   x: () => (/* binding */ beforeAuthStateChanged),\n/* harmony export */   y: () => (/* binding */ onAuthStateChanged),\n/* harmony export */   z: () => (/* binding */ useDeviceLanguage)\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(ssr)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/component */ \"(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/logger */ \"(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * An enum of factors that may be used for multifactor authentication.\n *\n * @public\n */\nconst FactorId = {\n    /** Phone as second factor */\n    PHONE: 'phone',\n    TOTP: 'totp'\n};\n/**\n * Enumeration of supported providers.\n *\n * @public\n */\nconst ProviderId = {\n    /** Facebook provider ID */\n    FACEBOOK: 'facebook.com',\n    /** GitHub provider ID */\n    GITHUB: 'github.com',\n    /** Google provider ID */\n    GOOGLE: 'google.com',\n    /** Password provider */\n    PASSWORD: 'password',\n    /** Phone provider */\n    PHONE: 'phone',\n    /** Twitter provider ID */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported sign-in methods.\n *\n * @public\n */\nconst SignInMethod = {\n    /** Email link sign in method */\n    EMAIL_LINK: 'emailLink',\n    /** Email/password sign in method */\n    EMAIL_PASSWORD: 'password',\n    /** Facebook sign in method */\n    FACEBOOK: 'facebook.com',\n    /** GitHub sign in method */\n    GITHUB: 'github.com',\n    /** Google sign in method */\n    GOOGLE: 'google.com',\n    /** Phone sign in method */\n    PHONE: 'phone',\n    /** Twitter sign in method */\n    TWITTER: 'twitter.com'\n};\n/**\n * Enumeration of supported operation types.\n *\n * @public\n */\nconst OperationType = {\n    /** Operation involving linking an additional provider to an already signed-in user. */\n    LINK: 'link',\n    /** Operation involving using a provider to reauthenticate an already signed-in user. */\n    REAUTHENTICATE: 'reauthenticate',\n    /** Operation involving signing in a user. */\n    SIGN_IN: 'signIn'\n};\n/**\n * An enumeration of the possible email action types.\n *\n * @public\n */\nconst ActionCodeOperation = {\n    /** The email link sign-in action. */\n    EMAIL_SIGNIN: 'EMAIL_SIGNIN',\n    /** The password reset action. */\n    PASSWORD_RESET: 'PASSWORD_RESET',\n    /** The email revocation action. */\n    RECOVER_EMAIL: 'RECOVER_EMAIL',\n    /** The revert second factor addition email action. */\n    REVERT_SECOND_FACTOR_ADDITION: 'REVERT_SECOND_FACTOR_ADDITION',\n    /** The revert second factor addition email action. */\n    VERIFY_AND_CHANGE_EMAIL: 'VERIFY_AND_CHANGE_EMAIL',\n    /** The email verification action. */\n    VERIFY_EMAIL: 'VERIFY_EMAIL'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _debugErrorMap() {\n    return {\n        [\"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */]: 'This operation is restricted to administrators only.',\n        [\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */]: '',\n        [\"app-not-authorized\" /* AuthErrorCode.APP_NOT_AUTHORIZED */]: \"This app, identified by the domain where it's hosted, is not \" +\n            'authorized to use Firebase Authentication with the provided API key. ' +\n            'Review your key configuration in the Google API console.',\n        [\"app-not-installed\" /* AuthErrorCode.APP_NOT_INSTALLED */]: 'The requested mobile application corresponding to the identifier (' +\n            'Android package name or iOS bundle ID) provided is not installed on ' +\n            'this device.',\n        [\"captcha-check-failed\" /* AuthErrorCode.CAPTCHA_CHECK_FAILED */]: 'The reCAPTCHA response token provided is either invalid, expired, ' +\n            'already used or the domain associated with it does not match the list ' +\n            'of whitelisted domains.',\n        [\"code-expired\" /* AuthErrorCode.CODE_EXPIRED */]: 'The SMS code has expired. Please re-send the verification code to try ' +\n            'again.',\n        [\"cordova-not-ready\" /* AuthErrorCode.CORDOVA_NOT_READY */]: 'Cordova framework is not ready.',\n        [\"cors-unsupported\" /* AuthErrorCode.CORS_UNSUPPORTED */]: 'This browser is not supported.',\n        [\"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */]: 'This credential is already associated with a different user account.',\n        [\"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */]: 'The custom token corresponds to a different audience.',\n        [\"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: 'This operation is sensitive and requires recent authentication. Log in ' +\n            'again before retrying this request.',\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.',\n        [\"dynamic-link-not-activated\" /* AuthErrorCode.DYNAMIC_LINK_NOT_ACTIVATED */]: 'Please activate Dynamic Links in the Firebase Console and agree to the terms and ' +\n            'conditions.',\n        [\"email-change-needs-verification\" /* AuthErrorCode.EMAIL_CHANGE_NEEDS_VERIFICATION */]: 'Multi-factor users must always have a verified email.',\n        [\"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */]: 'The email address is already in use by another account.',\n        [\"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */]: 'Auth instance has already been used to make a network call. Auth can ' +\n            'no longer be configured to use the emulator. Try calling ' +\n            '\"connectAuthEmulator()\" sooner.',\n        [\"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */]: 'The action code has expired.',\n        [\"cancelled-popup-request\" /* AuthErrorCode.EXPIRED_POPUP_REQUEST */]: 'This operation has been cancelled due to another conflicting popup being opened.',\n        [\"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */]: 'An internal AuthError has occurred.',\n        [\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */]: 'The phone verification request contains an invalid application verifier.' +\n            ' The reCAPTCHA token response is either invalid or expired.',\n        [\"invalid-app-id\" /* AuthErrorCode.INVALID_APP_ID */]: 'The mobile app identifier is not registered for the current project.',\n        [\"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */]: \"This user's credential isn't valid for this project. This can happen \" +\n            \"if the user's token has been tampered with, or if the user isn't for \" +\n            'the project associated with this API key.',\n        [\"invalid-auth-event\" /* AuthErrorCode.INVALID_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */]: 'The SMS verification code used to create the phone auth credential is ' +\n            'invalid. Please resend the verification code sms and be sure to use the ' +\n            'verification code provided by the user.',\n        [\"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */]: 'The continue URL provided in the request is invalid.',\n        [\"invalid-cordova-configuration\" /* AuthErrorCode.INVALID_CORDOVA_CONFIGURATION */]: 'The following Cordova plugins must be installed to enable OAuth sign-in: ' +\n            'cordova-plugin-buildinfo, cordova-universal-links-plugin, ' +\n            'cordova-plugin-browsertab, cordova-plugin-inappbrowser and ' +\n            'cordova-plugin-customurlscheme.',\n        [\"invalid-custom-token\" /* AuthErrorCode.INVALID_CUSTOM_TOKEN */]: 'The custom token format is incorrect. Please check the documentation.',\n        [\"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */]: 'The provided dynamic link domain is not configured or authorized for the current project.',\n        [\"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */]: 'The email address is badly formatted.',\n        [\"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */]: 'Emulator URL must start with a valid scheme (http:// or https://).',\n        [\"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */]: 'Your API key is invalid, please check you have copied it correctly.',\n        [\"invalid-cert-hash\" /* AuthErrorCode.INVALID_CERT_HASH */]: 'The SHA-1 certificate hash provided is invalid.',\n        [\"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */]: 'The supplied auth credential is incorrect, malformed or has expired.',\n        [\"invalid-message-payload\" /* AuthErrorCode.INVALID_MESSAGE_PAYLOAD */]: 'The email template corresponding to this action contains invalid characters in its message. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */]: 'The request does not contain a valid proof of first factor successful sign-in.',\n        [\"invalid-oauth-provider\" /* AuthErrorCode.INVALID_OAUTH_PROVIDER */]: 'EmailAuthProvider is not supported for this operation. This operation ' +\n            'only supports OAuth providers.',\n        [\"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */]: 'The OAuth client ID provided is either invalid or does not match the ' +\n            'specified API key.',\n        [\"unauthorized-domain\" /* AuthErrorCode.INVALID_ORIGIN */]: 'This domain is not authorized for OAuth operations for your Firebase ' +\n            'project. Edit the list of authorized domains from the Firebase console.',\n        [\"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */]: 'The action code is invalid. This can happen if the code is malformed, ' +\n            'expired, or has already been used.',\n        [\"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */]: 'The password is invalid or the user does not have a password.',\n        [\"invalid-persistence-type\" /* AuthErrorCode.INVALID_PERSISTENCE */]: 'The specified persistence type is invalid. It can only be local, session or none.',\n        [\"invalid-phone-number\" /* AuthErrorCode.INVALID_PHONE_NUMBER */]: 'The format of the phone number provided is incorrect. Please enter the ' +\n            'phone number in a format that can be parsed into E.164 format. E.164 ' +\n            'phone numbers are written in the format [+][country code][subscriber ' +\n            'number including area code].',\n        [\"invalid-provider-id\" /* AuthErrorCode.INVALID_PROVIDER_ID */]: 'The specified provider ID is invalid.',\n        [\"invalid-recipient-email\" /* AuthErrorCode.INVALID_RECIPIENT_EMAIL */]: 'The email corresponding to this action failed to send as the provided ' +\n            'recipient email address is invalid.',\n        [\"invalid-sender\" /* AuthErrorCode.INVALID_SENDER */]: 'The email template corresponding to this action contains an invalid sender email or name. ' +\n            'Please fix by going to the Auth email templates section in the Firebase Console.',\n        [\"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */]: 'The verification ID used to create the phone auth credential is invalid.',\n        [\"invalid-tenant-id\" /* AuthErrorCode.INVALID_TENANT_ID */]: \"The Auth instance's tenant ID is invalid.\",\n        [\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */]: 'Login blocked by user-provided method: {$originalMessage}',\n        [\"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */]: 'An Android Package Name must be provided if the Android App is required to be installed.',\n        [\"auth-domain-config-required\" /* AuthErrorCode.MISSING_AUTH_DOMAIN */]: 'Be sure to include authDomain when calling firebase.initializeApp(), ' +\n            'by following the instructions in the Firebase console.',\n        [\"missing-app-credential\" /* AuthErrorCode.MISSING_APP_CREDENTIAL */]: 'The phone verification request is missing an application verifier ' +\n            'assertion. A reCAPTCHA response token needs to be provided.',\n        [\"missing-verification-code\" /* AuthErrorCode.MISSING_CODE */]: 'The phone auth credential was created with an empty SMS verification code.',\n        [\"missing-continue-uri\" /* AuthErrorCode.MISSING_CONTINUE_URI */]: 'A continue URL must be provided in the request.',\n        [\"missing-iframe-start\" /* AuthErrorCode.MISSING_IFRAME_START */]: 'An internal AuthError has occurred.',\n        [\"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */]: 'An iOS Bundle ID must be provided if an App Store ID is provided.',\n        [\"missing-or-invalid-nonce\" /* AuthErrorCode.MISSING_OR_INVALID_NONCE */]: 'The request does not contain a valid nonce. This can occur if the ' +\n            'SHA-256 hash of the provided raw nonce does not match the hashed nonce ' +\n            'in the ID token payload.',\n        [\"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */]: 'A non-empty password must be provided',\n        [\"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */]: 'No second factor identifier is provided.',\n        [\"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */]: 'The request is missing proof of first factor successful sign-in.',\n        [\"missing-phone-number\" /* AuthErrorCode.MISSING_PHONE_NUMBER */]: 'To send verification codes, provide a phone number for the recipient.',\n        [\"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */]: 'The phone auth credential was created with an empty verification ID.',\n        [\"app-deleted\" /* AuthErrorCode.MODULE_DESTROYED */]: 'This instance of FirebaseApp has been deleted.',\n        [\"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */]: 'The user does not have a second factor matching the identifier provided.',\n        [\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */]: 'Proof of ownership of a second factor is required to complete sign-in.',\n        [\"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */]: 'An account already exists with the same email address but different ' +\n            'sign-in credentials. Sign in using a provider associated with this ' +\n            'email address.',\n        [\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */]: 'A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.',\n        [\"no-auth-event\" /* AuthErrorCode.NO_AUTH_EVENT */]: 'An internal AuthError has occurred.',\n        [\"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */]: 'User was not linked to an account with the given provider.',\n        [\"null-user\" /* AuthErrorCode.NULL_USER */]: 'A null user object was provided as the argument for an operation which ' +\n            'requires a non-null user object.',\n        [\"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */]: 'The given sign-in provider is disabled for this Firebase project. ' +\n            'Enable it in the Firebase console, under the sign-in method tab of the ' +\n            'Auth section.',\n        [\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */]: 'This operation is not supported in the environment this application is ' +\n            'running on. \"location.protocol\" must be http, https or chrome-extension' +\n            ' and web storage must be enabled.',\n        [\"popup-blocked\" /* AuthErrorCode.POPUP_BLOCKED */]: 'Unable to establish a connection with the popup. It may have been blocked by the browser.',\n        [\"popup-closed-by-user\" /* AuthErrorCode.POPUP_CLOSED_BY_USER */]: 'The popup has been closed by the user before finalizing the operation.',\n        [\"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */]: 'User can only be linked to one identity for the given provider.',\n        [\"quota-exceeded\" /* AuthErrorCode.QUOTA_EXCEEDED */]: \"The project's quota for this operation has been exceeded.\",\n        [\"redirect-cancelled-by-user\" /* AuthErrorCode.REDIRECT_CANCELLED_BY_USER */]: 'The redirect operation has been cancelled by the user before finalizing.',\n        [\"redirect-operation-pending\" /* AuthErrorCode.REDIRECT_OPERATION_PENDING */]: 'A redirect sign-in operation is already pending.',\n        [\"rejected-credential\" /* AuthErrorCode.REJECTED_CREDENTIAL */]: 'The request contains malformed or mismatching credentials.',\n        [\"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */]: 'The second factor is already enrolled on this account.',\n        [\"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */]: 'The maximum allowed number of second factors on a user has been exceeded.',\n        [\"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */]: \"The provided tenant ID does not match the Auth instance's tenant ID\",\n        [\"timeout\" /* AuthErrorCode.TIMEOUT */]: 'The operation has timed out.',\n        [\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */]: \"The user's credential is no longer valid. The user must sign in again.\",\n        [\"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */]: 'We have blocked all requests from this device due to unusual activity. ' +\n            'Try again later.',\n        [\"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */]: 'The domain of the continue URL is not whitelisted.  Please whitelist ' +\n            'the domain in the Firebase console.',\n        [\"unsupported-first-factor\" /* AuthErrorCode.UNSUPPORTED_FIRST_FACTOR */]: 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',\n        [\"unsupported-persistence-type\" /* AuthErrorCode.UNSUPPORTED_PERSISTENCE */]: 'The current environment does not support the specified persistence type.',\n        [\"unsupported-tenant-operation\" /* AuthErrorCode.UNSUPPORTED_TENANT_OPERATION */]: 'This operation is not supported in a multi-tenant context.',\n        [\"unverified-email\" /* AuthErrorCode.UNVERIFIED_EMAIL */]: 'The operation requires a verified email.',\n        [\"user-cancelled\" /* AuthErrorCode.USER_CANCELLED */]: 'The user did not grant your application the permissions it requested.',\n        [\"user-not-found\" /* AuthErrorCode.USER_DELETED */]: 'There is no user record corresponding to this identifier. The user may ' +\n            'have been deleted.',\n        [\"user-disabled\" /* AuthErrorCode.USER_DISABLED */]: 'The user account has been disabled by an administrator.',\n        [\"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */]: 'The supplied credentials do not correspond to the previously signed in user.',\n        [\"user-signed-out\" /* AuthErrorCode.USER_SIGNED_OUT */]: '',\n        [\"weak-password\" /* AuthErrorCode.WEAK_PASSWORD */]: 'The password must be 6 characters long or more.',\n        [\"web-storage-unsupported\" /* AuthErrorCode.WEB_STORAGE_UNSUPPORTED */]: 'This browser is not supported or 3rd party cookies and data may be disabled.',\n        [\"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */]: 'initializeAuth() has already been called with ' +\n            'different options. To avoid this error, call initializeAuth() with the ' +\n            'same options as when it was originally called, or call getAuth() to return the' +\n            ' already initialized instance.',\n        [\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is missing when sending request to the backend.',\n        [\"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */]: 'The reCAPTCHA token is invalid when sending request to the backend.',\n        [\"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */]: 'The reCAPTCHA action is invalid when sending request to the backend.',\n        [\"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */]: 'reCAPTCHA Enterprise integration is not enabled for this project.',\n        [\"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */]: 'The reCAPTCHA client type is missing when sending request to the backend.',\n        [\"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is missing when sending request to the backend.',\n        [\"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */]: 'Invalid request parameters.',\n        [\"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */]: 'The reCAPTCHA version is invalid when sending request to the backend.',\n        [\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */]: 'The password policy received from the backend uses a schema version that is not supported by this version of the Firebase SDK.',\n        [\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: 'The password does not meet the requirements.'\n    };\n}\nfunction _prodErrorMap() {\n    // We will include this one message in the prod error map since by the very\n    // nature of this error, developers will never be able to see the message\n    // using the debugErrorMap (which is installed during auth initialization).\n    return {\n        [\"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */]: 'Another Firebase SDK was initialized and is trying to use Auth before Auth is ' +\n            'initialized. Please be sure to call `initializeAuth` or `getAuth` before ' +\n            'starting any other Firebase SDK.'\n    };\n}\n/**\n * A verbose error map with detailed descriptions for most error codes.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst debugErrorMap = _debugErrorMap;\n/**\n * A minimal error map with all verbose error messages stripped.\n *\n * See discussion at {@link AuthErrorMap}\n *\n * @public\n */\nconst prodErrorMap = _prodErrorMap;\nconst _DEFAULT_AUTH_ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', _prodErrorMap());\n/**\n * A map of potential `Auth` error codes, for easier comparison with errors\n * thrown by the SDK.\n *\n * @remarks\n * Note that you can't tree-shake individual keys\n * in the map, so by using the map you might substantially increase your\n * bundle size.\n *\n * @public\n */\nconst AUTH_ERROR_CODES_MAP_DO_NOT_USE_INTERNALLY = {\n    ADMIN_ONLY_OPERATION: 'auth/admin-restricted-operation',\n    ARGUMENT_ERROR: 'auth/argument-error',\n    APP_NOT_AUTHORIZED: 'auth/app-not-authorized',\n    APP_NOT_INSTALLED: 'auth/app-not-installed',\n    CAPTCHA_CHECK_FAILED: 'auth/captcha-check-failed',\n    CODE_EXPIRED: 'auth/code-expired',\n    CORDOVA_NOT_READY: 'auth/cordova-not-ready',\n    CORS_UNSUPPORTED: 'auth/cors-unsupported',\n    CREDENTIAL_ALREADY_IN_USE: 'auth/credential-already-in-use',\n    CREDENTIAL_MISMATCH: 'auth/custom-token-mismatch',\n    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'auth/requires-recent-login',\n    DEPENDENT_SDK_INIT_BEFORE_AUTH: 'auth/dependent-sdk-initialized-before-auth',\n    DYNAMIC_LINK_NOT_ACTIVATED: 'auth/dynamic-link-not-activated',\n    EMAIL_CHANGE_NEEDS_VERIFICATION: 'auth/email-change-needs-verification',\n    EMAIL_EXISTS: 'auth/email-already-in-use',\n    EMULATOR_CONFIG_FAILED: 'auth/emulator-config-failed',\n    EXPIRED_OOB_CODE: 'auth/expired-action-code',\n    EXPIRED_POPUP_REQUEST: 'auth/cancelled-popup-request',\n    INTERNAL_ERROR: 'auth/internal-error',\n    INVALID_API_KEY: 'auth/invalid-api-key',\n    INVALID_APP_CREDENTIAL: 'auth/invalid-app-credential',\n    INVALID_APP_ID: 'auth/invalid-app-id',\n    INVALID_AUTH: 'auth/invalid-user-token',\n    INVALID_AUTH_EVENT: 'auth/invalid-auth-event',\n    INVALID_CERT_HASH: 'auth/invalid-cert-hash',\n    INVALID_CODE: 'auth/invalid-verification-code',\n    INVALID_CONTINUE_URI: 'auth/invalid-continue-uri',\n    INVALID_CORDOVA_CONFIGURATION: 'auth/invalid-cordova-configuration',\n    INVALID_CUSTOM_TOKEN: 'auth/invalid-custom-token',\n    INVALID_DYNAMIC_LINK_DOMAIN: 'auth/invalid-dynamic-link-domain',\n    INVALID_EMAIL: 'auth/invalid-email',\n    INVALID_EMULATOR_SCHEME: 'auth/invalid-emulator-scheme',\n    INVALID_IDP_RESPONSE: 'auth/invalid-credential',\n    INVALID_LOGIN_CREDENTIALS: 'auth/invalid-credential',\n    INVALID_MESSAGE_PAYLOAD: 'auth/invalid-message-payload',\n    INVALID_MFA_SESSION: 'auth/invalid-multi-factor-session',\n    INVALID_OAUTH_CLIENT_ID: 'auth/invalid-oauth-client-id',\n    INVALID_OAUTH_PROVIDER: 'auth/invalid-oauth-provider',\n    INVALID_OOB_CODE: 'auth/invalid-action-code',\n    INVALID_ORIGIN: 'auth/unauthorized-domain',\n    INVALID_PASSWORD: 'auth/wrong-password',\n    INVALID_PERSISTENCE: 'auth/invalid-persistence-type',\n    INVALID_PHONE_NUMBER: 'auth/invalid-phone-number',\n    INVALID_PROVIDER_ID: 'auth/invalid-provider-id',\n    INVALID_RECIPIENT_EMAIL: 'auth/invalid-recipient-email',\n    INVALID_SENDER: 'auth/invalid-sender',\n    INVALID_SESSION_INFO: 'auth/invalid-verification-id',\n    INVALID_TENANT_ID: 'auth/invalid-tenant-id',\n    MFA_INFO_NOT_FOUND: 'auth/multi-factor-info-not-found',\n    MFA_REQUIRED: 'auth/multi-factor-auth-required',\n    MISSING_ANDROID_PACKAGE_NAME: 'auth/missing-android-pkg-name',\n    MISSING_APP_CREDENTIAL: 'auth/missing-app-credential',\n    MISSING_AUTH_DOMAIN: 'auth/auth-domain-config-required',\n    MISSING_CODE: 'auth/missing-verification-code',\n    MISSING_CONTINUE_URI: 'auth/missing-continue-uri',\n    MISSING_IFRAME_START: 'auth/missing-iframe-start',\n    MISSING_IOS_BUNDLE_ID: 'auth/missing-ios-bundle-id',\n    MISSING_OR_INVALID_NONCE: 'auth/missing-or-invalid-nonce',\n    MISSING_MFA_INFO: 'auth/missing-multi-factor-info',\n    MISSING_MFA_SESSION: 'auth/missing-multi-factor-session',\n    MISSING_PHONE_NUMBER: 'auth/missing-phone-number',\n    MISSING_SESSION_INFO: 'auth/missing-verification-id',\n    MODULE_DESTROYED: 'auth/app-deleted',\n    NEED_CONFIRMATION: 'auth/account-exists-with-different-credential',\n    NETWORK_REQUEST_FAILED: 'auth/network-request-failed',\n    NULL_USER: 'auth/null-user',\n    NO_AUTH_EVENT: 'auth/no-auth-event',\n    NO_SUCH_PROVIDER: 'auth/no-such-provider',\n    OPERATION_NOT_ALLOWED: 'auth/operation-not-allowed',\n    OPERATION_NOT_SUPPORTED: 'auth/operation-not-supported-in-this-environment',\n    POPUP_BLOCKED: 'auth/popup-blocked',\n    POPUP_CLOSED_BY_USER: 'auth/popup-closed-by-user',\n    PROVIDER_ALREADY_LINKED: 'auth/provider-already-linked',\n    QUOTA_EXCEEDED: 'auth/quota-exceeded',\n    REDIRECT_CANCELLED_BY_USER: 'auth/redirect-cancelled-by-user',\n    REDIRECT_OPERATION_PENDING: 'auth/redirect-operation-pending',\n    REJECTED_CREDENTIAL: 'auth/rejected-credential',\n    SECOND_FACTOR_ALREADY_ENROLLED: 'auth/second-factor-already-in-use',\n    SECOND_FACTOR_LIMIT_EXCEEDED: 'auth/maximum-second-factor-count-exceeded',\n    TENANT_ID_MISMATCH: 'auth/tenant-id-mismatch',\n    TIMEOUT: 'auth/timeout',\n    TOKEN_EXPIRED: 'auth/user-token-expired',\n    TOO_MANY_ATTEMPTS_TRY_LATER: 'auth/too-many-requests',\n    UNAUTHORIZED_DOMAIN: 'auth/unauthorized-continue-uri',\n    UNSUPPORTED_FIRST_FACTOR: 'auth/unsupported-first-factor',\n    UNSUPPORTED_PERSISTENCE: 'auth/unsupported-persistence-type',\n    UNSUPPORTED_TENANT_OPERATION: 'auth/unsupported-tenant-operation',\n    UNVERIFIED_EMAIL: 'auth/unverified-email',\n    USER_CANCELLED: 'auth/user-cancelled',\n    USER_DELETED: 'auth/user-not-found',\n    USER_DISABLED: 'auth/user-disabled',\n    USER_MISMATCH: 'auth/user-mismatch',\n    USER_SIGNED_OUT: 'auth/user-signed-out',\n    WEAK_PASSWORD: 'auth/weak-password',\n    WEB_STORAGE_UNSUPPORTED: 'auth/web-storage-unsupported',\n    ALREADY_INITIALIZED: 'auth/already-initialized',\n    RECAPTCHA_NOT_ENABLED: 'auth/recaptcha-not-enabled',\n    MISSING_RECAPTCHA_TOKEN: 'auth/missing-recaptcha-token',\n    INVALID_RECAPTCHA_TOKEN: 'auth/invalid-recaptcha-token',\n    INVALID_RECAPTCHA_ACTION: 'auth/invalid-recaptcha-action',\n    MISSING_CLIENT_TYPE: 'auth/missing-client-type',\n    MISSING_RECAPTCHA_VERSION: 'auth/missing-recaptcha-version',\n    INVALID_RECAPTCHA_VERSION: 'auth/invalid-recaptcha-version',\n    INVALID_REQ_TYPE: 'auth/invalid-req-type'\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logClient = new _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.Logger('@firebase/auth');\nfunction _logWarn(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.WARN) {\n        logClient.warn(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\nfunction _logError(msg, ...args) {\n    if (logClient.logLevel <= _firebase_logger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.ERROR) {\n        logClient.error(`Auth (${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}): ${msg}`, ...args);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _fail(authOrCode, ...rest) {\n    throw createErrorInternal(authOrCode, ...rest);\n}\nfunction _createError(authOrCode, ...rest) {\n    return createErrorInternal(authOrCode, ...rest);\n}\nfunction _errorWithCustomMessage(auth, code, message) {\n    const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });\n    const factory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap);\n    return factory.create(code, {\n        appName: auth.name\n    });\n}\nfunction _serverAppCurrentUserOperationNotSupportedError(auth) {\n    return _errorWithCustomMessage(auth, \"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */, 'Operations that alter the current user are not supported in conjunction with FirebaseServerApp');\n}\nfunction createErrorInternal(authOrCode, ...rest) {\n    if (typeof authOrCode !== 'string') {\n        const code = rest[0];\n        const fullParams = [...rest.slice(1)];\n        if (fullParams[0]) {\n            fullParams[0].appName = authOrCode.name;\n        }\n        return authOrCode._errorFactory.create(code, ...fullParams);\n    }\n    return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);\n}\nfunction _assert(assertion, authOrCode, ...rest) {\n    if (!assertion) {\n        throw createErrorInternal(authOrCode, ...rest);\n    }\n}\n/**\n * Unconditionally fails, throwing an internal error with the given message.\n *\n * @param failure type of failure encountered\n * @throws Error\n */\nfunction debugFail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    const message = `INTERNAL ASSERTION FAILED: ` + failure;\n    _logError(message);\n    // NOTE: We don't use FirebaseError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * @param assertion\n * @param message\n */\nfunction debugAssert(assertion, message) {\n    if (!assertion) {\n        debugFail(message);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _getCurrentUrl() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href)) || '';\n}\nfunction _isHttpOrHttps() {\n    return _getCurrentScheme() === 'http:' || _getCurrentScheme() === 'https:';\n}\nfunction _getCurrentScheme() {\n    var _a;\n    return (typeof self !== 'undefined' && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol)) || null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine whether the browser is working online\n */\nfunction _isOnline() {\n    if (typeof navigator !== 'undefined' &&\n        navigator &&\n        'onLine' in navigator &&\n        typeof navigator.onLine === 'boolean' &&\n        // Apply only for traditional web apps and Chrome extensions.\n        // This is especially true for Cordova apps which have unreliable\n        // navigator.onLine behavior unless cordova-plugin-network-information is\n        // installed which overwrites the native navigator.onLine value and\n        // defines navigator.connection.\n        (_isHttpOrHttps() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isBrowserExtension)() || 'connection' in navigator)) {\n        return navigator.onLine;\n    }\n    // If we can't determine the state, assume it is online.\n    return true;\n}\nfunction _getUserLanguage() {\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const navigatorLanguage = navigator;\n    return (\n    // Most reliable, but only supported in Chrome/Firefox.\n    (navigatorLanguage.languages && navigatorLanguage.languages[0]) ||\n        // Supported in most browsers, but returns the language of the browser\n        // UI, not the language set in browser settings.\n        navigatorLanguage.language ||\n        // Couldn't determine language.\n        null);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A structure to help pick between a range of long and short delay durations\n * depending on the current environment. In general, the long delay is used for\n * mobile environments whereas short delays are used for desktop environments.\n */\nclass Delay {\n    constructor(shortDelay, longDelay) {\n        this.shortDelay = shortDelay;\n        this.longDelay = longDelay;\n        // Internal error when improperly initialized.\n        debugAssert(longDelay > shortDelay, 'Short delay should be less than long delay!');\n        this.isMobile = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isMobileCordova)() || (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isReactNative)();\n    }\n    get() {\n        if (!_isOnline()) {\n            // Pick the shorter timeout.\n            return Math.min(5000 /* DelayMin.OFFLINE */, this.shortDelay);\n        }\n        // If running in a mobile environment, return the long delay, otherwise\n        // return the short delay.\n        // This could be improved in the future to dynamically change based on other\n        // variables instead of just reading the current environment.\n        return this.isMobile ? this.longDelay : this.shortDelay;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _emulatorUrl(config, path) {\n    debugAssert(config.emulator, 'Emulator should always be set here');\n    const { url } = config.emulator;\n    if (!path) {\n        return url;\n    }\n    return `${url}${path.startsWith('/') ? path.slice(1) : path}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass FetchProvider {\n    static initialize(fetchImpl, headersImpl, responseImpl) {\n        this.fetchImpl = fetchImpl;\n        if (headersImpl) {\n            this.headersImpl = headersImpl;\n        }\n        if (responseImpl) {\n            this.responseImpl = responseImpl;\n        }\n    }\n    static fetch() {\n        if (this.fetchImpl) {\n            return this.fetchImpl;\n        }\n        if (typeof self !== 'undefined' && 'fetch' in self) {\n            return self.fetch;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.fetch) {\n            return globalThis.fetch;\n        }\n        if (typeof fetch !== 'undefined') {\n            return fetch;\n        }\n        debugFail('Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static headers() {\n        if (this.headersImpl) {\n            return this.headersImpl;\n        }\n        if (typeof self !== 'undefined' && 'Headers' in self) {\n            return self.Headers;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Headers) {\n            return globalThis.Headers;\n        }\n        if (typeof Headers !== 'undefined') {\n            return Headers;\n        }\n        debugFail('Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n    static response() {\n        if (this.responseImpl) {\n            return this.responseImpl;\n        }\n        if (typeof self !== 'undefined' && 'Response' in self) {\n            return self.Response;\n        }\n        if (typeof globalThis !== 'undefined' && globalThis.Response) {\n            return globalThis.Response;\n        }\n        if (typeof Response !== 'undefined') {\n            return Response;\n        }\n        debugFail('Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Map from errors returned by the server to errors to developer visible errors\n */\nconst SERVER_ERROR_MAP = {\n    // Custom token errors.\n    [\"CREDENTIAL_MISMATCH\" /* ServerError.CREDENTIAL_MISMATCH */]: \"custom-token-mismatch\" /* AuthErrorCode.CREDENTIAL_MISMATCH */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CUSTOM_TOKEN\" /* ServerError.MISSING_CUSTOM_TOKEN */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Create Auth URI errors.\n    [\"INVALID_IDENTIFIER\" /* ServerError.INVALID_IDENTIFIER */]: \"invalid-email\" /* AuthErrorCode.INVALID_EMAIL */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_CONTINUE_URI\" /* ServerError.MISSING_CONTINUE_URI */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Sign in with email and password errors (some apply to sign up too).\n    [\"INVALID_PASSWORD\" /* ServerError.INVALID_PASSWORD */]: \"wrong-password\" /* AuthErrorCode.INVALID_PASSWORD */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_PASSWORD\" /* ServerError.MISSING_PASSWORD */]: \"missing-password\" /* AuthErrorCode.MISSING_PASSWORD */,\n    // Thrown if Email Enumeration Protection is enabled in the project and the email or password is\n    // invalid.\n    [\"INVALID_LOGIN_CREDENTIALS\" /* ServerError.INVALID_LOGIN_CREDENTIALS */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    // Sign up with email and password errors.\n    [\"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */]: \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */,\n    [\"PASSWORD_LOGIN_DISABLED\" /* ServerError.PASSWORD_LOGIN_DISABLED */]: \"operation-not-allowed\" /* AuthErrorCode.OPERATION_NOT_ALLOWED */,\n    // Verify assertion for sign in with credential errors:\n    [\"INVALID_IDP_RESPONSE\" /* ServerError.INVALID_IDP_RESPONSE */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"INVALID_PENDING_TOKEN\" /* ServerError.INVALID_PENDING_TOKEN */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */]: \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_REQ_TYPE\" /* ServerError.MISSING_REQ_TYPE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Send Password reset email errors:\n    [\"EMAIL_NOT_FOUND\" /* ServerError.EMAIL_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */,\n    [\"RESET_PASSWORD_EXCEED_LIMIT\" /* ServerError.RESET_PASSWORD_EXCEED_LIMIT */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"EXPIRED_OOB_CODE\" /* ServerError.EXPIRED_OOB_CODE */]: \"expired-action-code\" /* AuthErrorCode.EXPIRED_OOB_CODE */,\n    [\"INVALID_OOB_CODE\" /* ServerError.INVALID_OOB_CODE */]: \"invalid-action-code\" /* AuthErrorCode.INVALID_OOB_CODE */,\n    // This can only happen if the SDK sends a bad request.\n    [\"MISSING_OOB_CODE\" /* ServerError.MISSING_OOB_CODE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Operations that require ID token in request:\n    [\"CREDENTIAL_TOO_OLD_LOGIN_AGAIN\" /* ServerError.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */]: \"requires-recent-login\" /* AuthErrorCode.CREDENTIAL_TOO_OLD_LOGIN_AGAIN */,\n    [\"INVALID_ID_TOKEN\" /* ServerError.INVALID_ID_TOKEN */]: \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */,\n    [\"TOKEN_EXPIRED\" /* ServerError.TOKEN_EXPIRED */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */,\n    // Other errors.\n    [\"TOO_MANY_ATTEMPTS_TRY_LATER\" /* ServerError.TOO_MANY_ATTEMPTS_TRY_LATER */]: \"too-many-requests\" /* AuthErrorCode.TOO_MANY_ATTEMPTS_TRY_LATER */,\n    [\"PASSWORD_DOES_NOT_MEET_REQUIREMENTS\" /* ServerError.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */]: \"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */,\n    // Phone Auth related errors.\n    [\"INVALID_CODE\" /* ServerError.INVALID_CODE */]: \"invalid-verification-code\" /* AuthErrorCode.INVALID_CODE */,\n    [\"INVALID_SESSION_INFO\" /* ServerError.INVALID_SESSION_INFO */]: \"invalid-verification-id\" /* AuthErrorCode.INVALID_SESSION_INFO */,\n    [\"INVALID_TEMPORARY_PROOF\" /* ServerError.INVALID_TEMPORARY_PROOF */]: \"invalid-credential\" /* AuthErrorCode.INVALID_CREDENTIAL */,\n    [\"MISSING_SESSION_INFO\" /* ServerError.MISSING_SESSION_INFO */]: \"missing-verification-id\" /* AuthErrorCode.MISSING_SESSION_INFO */,\n    [\"SESSION_EXPIRED\" /* ServerError.SESSION_EXPIRED */]: \"code-expired\" /* AuthErrorCode.CODE_EXPIRED */,\n    // Other action code errors when additional settings passed.\n    // MISSING_CONTINUE_URI is getting mapped to INTERNAL_ERROR above.\n    // This is OK as this error will be caught by client side validation.\n    [\"MISSING_ANDROID_PACKAGE_NAME\" /* ServerError.MISSING_ANDROID_PACKAGE_NAME */]: \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */,\n    [\"UNAUTHORIZED_DOMAIN\" /* ServerError.UNAUTHORIZED_DOMAIN */]: \"unauthorized-continue-uri\" /* AuthErrorCode.UNAUTHORIZED_DOMAIN */,\n    // getProjectConfig errors when clientId is passed.\n    [\"INVALID_OAUTH_CLIENT_ID\" /* ServerError.INVALID_OAUTH_CLIENT_ID */]: \"invalid-oauth-client-id\" /* AuthErrorCode.INVALID_OAUTH_CLIENT_ID */,\n    // User actions (sign-up or deletion) disabled errors.\n    [\"ADMIN_ONLY_OPERATION\" /* ServerError.ADMIN_ONLY_OPERATION */]: \"admin-restricted-operation\" /* AuthErrorCode.ADMIN_ONLY_OPERATION */,\n    // Multi factor related errors.\n    [\"INVALID_MFA_PENDING_CREDENTIAL\" /* ServerError.INVALID_MFA_PENDING_CREDENTIAL */]: \"invalid-multi-factor-session\" /* AuthErrorCode.INVALID_MFA_SESSION */,\n    [\"MFA_ENROLLMENT_NOT_FOUND\" /* ServerError.MFA_ENROLLMENT_NOT_FOUND */]: \"multi-factor-info-not-found\" /* AuthErrorCode.MFA_INFO_NOT_FOUND */,\n    [\"MISSING_MFA_ENROLLMENT_ID\" /* ServerError.MISSING_MFA_ENROLLMENT_ID */]: \"missing-multi-factor-info\" /* AuthErrorCode.MISSING_MFA_INFO */,\n    [\"MISSING_MFA_PENDING_CREDENTIAL\" /* ServerError.MISSING_MFA_PENDING_CREDENTIAL */]: \"missing-multi-factor-session\" /* AuthErrorCode.MISSING_MFA_SESSION */,\n    [\"SECOND_FACTOR_EXISTS\" /* ServerError.SECOND_FACTOR_EXISTS */]: \"second-factor-already-in-use\" /* AuthErrorCode.SECOND_FACTOR_ALREADY_ENROLLED */,\n    [\"SECOND_FACTOR_LIMIT_EXCEEDED\" /* ServerError.SECOND_FACTOR_LIMIT_EXCEEDED */]: \"maximum-second-factor-count-exceeded\" /* AuthErrorCode.SECOND_FACTOR_LIMIT_EXCEEDED */,\n    // Blocking functions related errors.\n    [\"BLOCKING_FUNCTION_ERROR_RESPONSE\" /* ServerError.BLOCKING_FUNCTION_ERROR_RESPONSE */]: \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */,\n    // Recaptcha related errors.\n    [\"RECAPTCHA_NOT_ENABLED\" /* ServerError.RECAPTCHA_NOT_ENABLED */]: \"recaptcha-not-enabled\" /* AuthErrorCode.RECAPTCHA_NOT_ENABLED */,\n    [\"MISSING_RECAPTCHA_TOKEN\" /* ServerError.MISSING_RECAPTCHA_TOKEN */]: \"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_TOKEN\" /* ServerError.INVALID_RECAPTCHA_TOKEN */]: \"invalid-recaptcha-token\" /* AuthErrorCode.INVALID_RECAPTCHA_TOKEN */,\n    [\"INVALID_RECAPTCHA_ACTION\" /* ServerError.INVALID_RECAPTCHA_ACTION */]: \"invalid-recaptcha-action\" /* AuthErrorCode.INVALID_RECAPTCHA_ACTION */,\n    [\"MISSING_CLIENT_TYPE\" /* ServerError.MISSING_CLIENT_TYPE */]: \"missing-client-type\" /* AuthErrorCode.MISSING_CLIENT_TYPE */,\n    [\"MISSING_RECAPTCHA_VERSION\" /* ServerError.MISSING_RECAPTCHA_VERSION */]: \"missing-recaptcha-version\" /* AuthErrorCode.MISSING_RECAPTCHA_VERSION */,\n    [\"INVALID_RECAPTCHA_VERSION\" /* ServerError.INVALID_RECAPTCHA_VERSION */]: \"invalid-recaptcha-version\" /* AuthErrorCode.INVALID_RECAPTCHA_VERSION */,\n    [\"INVALID_REQ_TYPE\" /* ServerError.INVALID_REQ_TYPE */]: \"invalid-req-type\" /* AuthErrorCode.INVALID_REQ_TYPE */\n};\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_API_TIMEOUT_MS = new Delay(30000, 60000);\nfunction _addTidIfNecessary(auth, request) {\n    if (auth.tenantId && !request.tenantId) {\n        return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });\n    }\n    return request;\n}\nasync function _performApiRequest(auth, method, path, request, customErrorMap = {}) {\n    return _performFetchWithErrorHandling(auth, customErrorMap, async () => {\n        let body = {};\n        let params = {};\n        if (request) {\n            if (method === \"GET\" /* HttpMethod.GET */) {\n                params = request;\n            }\n            else {\n                body = {\n                    body: JSON.stringify(request)\n                };\n            }\n        }\n        const query = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(Object.assign({ key: auth.config.apiKey }, params)).slice(1);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/json';\n        if (auth.languageCode) {\n            headers[\"X-Firebase-Locale\" /* HttpHeader.X_FIREBASE_LOCALE */] = auth.languageCode;\n        }\n        const fetchArgs = Object.assign({ method,\n            headers }, body);\n        /* Security-conscious server-side frameworks tend to have built in mitigations for referrer\n           problems\". See the Cloudflare GitHub issue #487: Error: The 'referrerPolicy' field on\n           'RequestInitializerDict' is not implemented.\"\n           https://github.com/cloudflare/next-on-pages/issues/487 */\n        if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isCloudflareWorker)()) {\n            fetchArgs.referrerPolicy = 'no-referrer';\n        }\n        return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), fetchArgs);\n    });\n}\nasync function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {\n    auth._canInitEmulator = false;\n    const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);\n    try {\n        const networkTimeout = new NetworkTimeout(auth);\n        const response = await Promise.race([\n            fetchFn(),\n            networkTimeout.promise\n        ]);\n        // If we've reached this point, the fetch succeeded and the networkTimeout\n        // didn't throw; clear the network timeout delay so that Node won't hang\n        networkTimeout.clearNetworkTimeout();\n        const json = await response.json();\n        if ('needConfirmation' in json) {\n            throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, json);\n        }\n        if (response.ok && !('errorMessage' in json)) {\n            return json;\n        }\n        else {\n            const errorMessage = response.ok ? json.errorMessage : json.error.message;\n            const [serverErrorCode, serverErrorMessage] = errorMessage.split(' : ');\n            if (serverErrorCode === \"FEDERATED_USER_ID_ALREADY_LINKED\" /* ServerError.FEDERATED_USER_ID_ALREADY_LINKED */) {\n                throw _makeTaggedError(auth, \"credential-already-in-use\" /* AuthErrorCode.CREDENTIAL_ALREADY_IN_USE */, json);\n            }\n            else if (serverErrorCode === \"EMAIL_EXISTS\" /* ServerError.EMAIL_EXISTS */) {\n                throw _makeTaggedError(auth, \"email-already-in-use\" /* AuthErrorCode.EMAIL_EXISTS */, json);\n            }\n            else if (serverErrorCode === \"USER_DISABLED\" /* ServerError.USER_DISABLED */) {\n                throw _makeTaggedError(auth, \"user-disabled\" /* AuthErrorCode.USER_DISABLED */, json);\n            }\n            const authError = errorMap[serverErrorCode] ||\n                serverErrorCode\n                    .toLowerCase()\n                    .replace(/[_\\s]+/g, '-');\n            if (serverErrorMessage) {\n                throw _errorWithCustomMessage(auth, authError, serverErrorMessage);\n            }\n            else {\n                _fail(auth, authError);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError) {\n            throw e;\n        }\n        // Changing this to a different error code will log user out when there is a network error\n        // because we treat any error other than NETWORK_REQUEST_FAILED as token is invalid.\n        // https://github.com/firebase/firebase-js-sdk/blob/4fbc73610d70be4e0852e7de63a39cb7897e8546/packages/auth/src/core/auth/auth_impl.ts#L309-L316\n        _fail(auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */, { 'message': String(e) });\n    }\n}\nasync function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {\n    const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);\n    if ('mfaPendingCredential' in serverResponse) {\n        _fail(auth, \"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */, {\n            _serverResponse: serverResponse\n        });\n    }\n    return serverResponse;\n}\nfunction _getFinalTarget(auth, host, path, query) {\n    const base = `${host}${path}?${query}`;\n    if (!auth.config.emulator) {\n        return `${auth.config.apiScheme}://${base}`;\n    }\n    return _emulatorUrl(auth.config, base);\n}\nfunction _parseEnforcementState(enforcementStateStr) {\n    switch (enforcementStateStr) {\n        case 'ENFORCE':\n            return \"ENFORCE\" /* EnforcementState.ENFORCE */;\n        case 'AUDIT':\n            return \"AUDIT\" /* EnforcementState.AUDIT */;\n        case 'OFF':\n            return \"OFF\" /* EnforcementState.OFF */;\n        default:\n            return \"ENFORCEMENT_STATE_UNSPECIFIED\" /* EnforcementState.ENFORCEMENT_STATE_UNSPECIFIED */;\n    }\n}\nclass NetworkTimeout {\n    clearNetworkTimeout() {\n        clearTimeout(this.timer);\n    }\n    constructor(auth) {\n        this.auth = auth;\n        // Node timers and browser timers are fundamentally incompatible, but we\n        // don't care about the value here\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timer = null;\n        this.promise = new Promise((_, reject) => {\n            this.timer = setTimeout(() => {\n                return reject(_createError(this.auth, \"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */));\n            }, DEFAULT_API_TIMEOUT_MS.get());\n        });\n    }\n}\nfunction _makeTaggedError(auth, code, response) {\n    const errorParams = {\n        appName: auth.name\n    };\n    if (response.email) {\n        errorParams.email = response.email;\n    }\n    if (response.phoneNumber) {\n        errorParams.phoneNumber = response.phoneNumber;\n    }\n    const error = _createError(auth, code, errorParams);\n    // We know customData is defined on error because errorParams is defined\n    error.customData._tokenResponse = response;\n    return error;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isEnterprise(grecaptcha) {\n    return (grecaptcha !== undefined &&\n        grecaptcha.enterprise !== undefined);\n}\nclass RecaptchaConfig {\n    constructor(response) {\n        /**\n         * The reCAPTCHA site key.\n         */\n        this.siteKey = '';\n        /**\n         * The list of providers and their enablement status for reCAPTCHA Enterprise.\n         */\n        this.recaptchaEnforcementState = [];\n        if (response.recaptchaKey === undefined) {\n            throw new Error('recaptchaKey undefined');\n        }\n        // Example response.recaptchaKey: \"projects/proj123/keys/sitekey123\"\n        this.siteKey = response.recaptchaKey.split('/')[3];\n        this.recaptchaEnforcementState = response.recaptchaEnforcementState;\n    }\n    /**\n     * Returns the reCAPTCHA Enterprise enforcement state for the given provider.\n     *\n     * @param providerStr - The provider whose enforcement state is to be returned.\n     * @returns The reCAPTCHA Enterprise enforcement state for the given provider.\n     */\n    getProviderEnforcementState(providerStr) {\n        if (!this.recaptchaEnforcementState ||\n            this.recaptchaEnforcementState.length === 0) {\n            return null;\n        }\n        for (const recaptchaEnforcementState of this.recaptchaEnforcementState) {\n            if (recaptchaEnforcementState.provider &&\n                recaptchaEnforcementState.provider === providerStr) {\n                return _parseEnforcementState(recaptchaEnforcementState.enforcementState);\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the reCAPTCHA Enterprise enforcement state for the provider is set to ENFORCE or AUDIT.\n     *\n     * @param providerStr - The provider whose enablement state is to be returned.\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for the given provider.\n     */\n    isProviderEnabled(providerStr) {\n        return (this.getProviderEnforcementState(providerStr) ===\n            \"ENFORCE\" /* EnforcementState.ENFORCE */ ||\n            this.getProviderEnforcementState(providerStr) === \"AUDIT\" /* EnforcementState.AUDIT */);\n    }\n    /**\n     * Returns true if reCAPTCHA Enterprise protection is enabled in at least one provider, otherwise\n     * returns false.\n     *\n     * @returns Whether or not reCAPTCHA Enterprise protection is enabled for at least one provider.\n     */\n    isAnyProviderEnabled() {\n        return (this.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) ||\n            this.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */));\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function getRecaptchaConfig(auth, request) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/recaptchaConfig\" /* Endpoint.GET_RECAPTCHA_CONFIG */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function deleteAccount(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:delete\" /* Endpoint.DELETE_ACCOUNT */, request);\n}\nasync function deleteLinkedAccounts(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\nasync function getAccountInfo(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:lookup\" /* Endpoint.GET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction utcTimestampToDateString(utcTimestamp) {\n    if (!utcTimestamp) {\n        return undefined;\n    }\n    try {\n        // Convert to date object.\n        const date = new Date(Number(utcTimestamp));\n        // Test date is valid.\n        if (!isNaN(date.getTime())) {\n            // Convert to UTC date string.\n            return date.toUTCString();\n        }\n    }\n    catch (e) {\n        // Do nothing. undefined will be returned.\n    }\n    return undefined;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nfunction getIdToken(user, forceRefresh = false) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).getIdToken(forceRefresh);\n}\n/**\n * Returns a deserialized JSON Web Token (JWT) used to identify the user to a Firebase service.\n *\n * @remarks\n * Returns the current token if it has not expired or if it will not expire in the next five\n * minutes. Otherwise, this will refresh the token and return a new one.\n *\n * @param user - The user.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */\nasync function getIdTokenResult(user, forceRefresh = false) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const token = await userInternal.getIdToken(forceRefresh);\n    const claims = _parseToken(token);\n    _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const firebase = typeof claims.firebase === 'object' ? claims.firebase : undefined;\n    const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_provider'];\n    return {\n        claims,\n        token,\n        authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),\n        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),\n        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),\n        signInProvider: signInProvider || null,\n        signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase['sign_in_second_factor']) || null\n    };\n}\nfunction secondsStringToMilliseconds(seconds) {\n    return Number(seconds) * 1000;\n}\nfunction _parseToken(token) {\n    const [algorithm, payload, signature] = token.split('.');\n    if (algorithm === undefined ||\n        payload === undefined ||\n        signature === undefined) {\n        _logError('JWT malformed, contained fewer than 3 sections');\n        return null;\n    }\n    try {\n        const decoded = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.base64Decode)(payload);\n        if (!decoded) {\n            _logError('Failed to decode base64 JWT payload');\n            return null;\n        }\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        _logError('Caught error parsing JWT payload as JSON', e === null || e === void 0 ? void 0 : e.toString());\n        return null;\n    }\n}\n/**\n * Extract expiresIn TTL from a token by subtracting the expiration from the issuance.\n */\nfunction _tokenExpiresIn(token) {\n    const parsedToken = _parseToken(token);\n    _assert(parsedToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.exp !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    _assert(typeof parsedToken.iat !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    return Number(parsedToken.exp) - Number(parsedToken.iat);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _logoutIfInvalidated(user, promise, bypassAuthState = false) {\n    if (bypassAuthState) {\n        return promise;\n    }\n    try {\n        return await promise;\n    }\n    catch (e) {\n        if (e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError && isUserInvalidated(e)) {\n            if (user.auth.currentUser === user) {\n                await user.auth.signOut();\n            }\n        }\n        throw e;\n    }\n}\nfunction isUserInvalidated({ code }) {\n    return (code === `auth/${\"user-disabled\" /* AuthErrorCode.USER_DISABLED */}` ||\n        code === `auth/${\"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */}`);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass ProactiveRefresh {\n    constructor(user) {\n        this.user = user;\n        this.isRunning = false;\n        // Node timers and browser timers return fundamentally different types.\n        // We don't actually care what the value is but TS won't accept unknown and\n        // we can't cast properly in both environments.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.timerId = null;\n        this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n    }\n    _start() {\n        if (this.isRunning) {\n            return;\n        }\n        this.isRunning = true;\n        this.schedule();\n    }\n    _stop() {\n        if (!this.isRunning) {\n            return;\n        }\n        this.isRunning = false;\n        if (this.timerId !== null) {\n            clearTimeout(this.timerId);\n        }\n    }\n    getInterval(wasError) {\n        var _a;\n        if (wasError) {\n            const interval = this.errorBackoff;\n            this.errorBackoff = Math.min(this.errorBackoff * 2, 960000 /* Duration.RETRY_BACKOFF_MAX */);\n            return interval;\n        }\n        else {\n            // Reset the error backoff\n            this.errorBackoff = 30000 /* Duration.RETRY_BACKOFF_MIN */;\n            const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;\n            const interval = expTime - Date.now() - 300000 /* Duration.OFFSET */;\n            return Math.max(0, interval);\n        }\n    }\n    schedule(wasError = false) {\n        if (!this.isRunning) {\n            // Just in case...\n            return;\n        }\n        const interval = this.getInterval(wasError);\n        this.timerId = setTimeout(async () => {\n            await this.iteration();\n        }, interval);\n    }\n    async iteration() {\n        try {\n            await this.user.getIdToken(true);\n        }\n        catch (e) {\n            // Only retry on network errors\n            if ((e === null || e === void 0 ? void 0 : e.code) ===\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                this.schedule(/* wasError */ true);\n            }\n            return;\n        }\n        this.schedule();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserMetadata {\n    constructor(createdAt, lastLoginAt) {\n        this.createdAt = createdAt;\n        this.lastLoginAt = lastLoginAt;\n        this._initializeTime();\n    }\n    _initializeTime() {\n        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);\n        this.creationTime = utcTimestampToDateString(this.createdAt);\n    }\n    _copy(metadata) {\n        this.createdAt = metadata.createdAt;\n        this.lastLoginAt = metadata.lastLoginAt;\n        this._initializeTime();\n    }\n    toJSON() {\n        return {\n            createdAt: this.createdAt,\n            lastLoginAt: this.lastLoginAt\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reloadWithoutSaving(user) {\n    var _a;\n    const auth = user.auth;\n    const idToken = await user.getIdToken();\n    const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));\n    _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    const coreAccount = response.users[0];\n    user._notifyReloadListener(coreAccount);\n    const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length)\n        ? extractProviderData(coreAccount.providerUserInfo)\n        : [];\n    const providerData = mergeProviderData(user.providerData, newProviderData);\n    // Preserves the non-nonymous status of the stored user, even if no more\n    // credentials (federated or email/password) are linked to the user. If\n    // the user was previously anonymous, then use provider data to update.\n    // On the other hand, if it was not anonymous before, it should never be\n    // considered anonymous now.\n    const oldIsAnonymous = user.isAnonymous;\n    const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n    const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;\n    const updates = {\n        uid: coreAccount.localId,\n        displayName: coreAccount.displayName || null,\n        photoURL: coreAccount.photoUrl || null,\n        email: coreAccount.email || null,\n        emailVerified: coreAccount.emailVerified || false,\n        phoneNumber: coreAccount.phoneNumber || null,\n        tenantId: coreAccount.tenantId || null,\n        providerData,\n        metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n        isAnonymous\n    };\n    Object.assign(user, updates);\n}\n/**\n * Reloads user account data, if signed in.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function reload(user) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _reloadWithoutSaving(userInternal);\n    // Even though the current user hasn't changed, update\n    // current user will trigger a persistence update w/ the\n    // new info.\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    userInternal.auth._notifyListenersIfCurrent(userInternal);\n}\nfunction mergeProviderData(original, newData) {\n    const deduped = original.filter(o => !newData.some(n => n.providerId === o.providerId));\n    return [...deduped, ...newData];\n}\nfunction extractProviderData(providers) {\n    return providers.map((_a) => {\n        var { providerId } = _a, provider = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\"providerId\"]);\n        return {\n            providerId,\n            uid: provider.rawId || '',\n            displayName: provider.displayName || null,\n            email: provider.email || null,\n            phoneNumber: provider.phoneNumber || null,\n            photoURL: provider.photoUrl || null\n        };\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function requestStsToken(auth, refreshToken) {\n    const response = await _performFetchWithErrorHandling(auth, {}, async () => {\n        const body = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)({\n            'grant_type': 'refresh_token',\n            'refresh_token': refreshToken\n        }).slice(1);\n        const { tokenApiHost, apiKey } = auth.config;\n        const url = _getFinalTarget(auth, tokenApiHost, \"/v1/token\" /* Endpoint.TOKEN */, `key=${apiKey}`);\n        const headers = await auth._getAdditionalHeaders();\n        headers[\"Content-Type\" /* HttpHeader.CONTENT_TYPE */] = 'application/x-www-form-urlencoded';\n        return FetchProvider.fetch()(url, {\n            method: \"POST\" /* HttpMethod.POST */,\n            headers,\n            body\n        });\n    });\n    // The response comes back in snake_case. Convert to camel:\n    return {\n        accessToken: response.access_token,\n        expiresIn: response.expires_in,\n        refreshToken: response.refresh_token\n    };\n}\nasync function revokeToken(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts:revokeToken\" /* Endpoint.REVOKE_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * We need to mark this class as internal explicitly to exclude it in the public typings, because\n * it references AuthInternal which has a circular dependency with UserInternal.\n *\n * @internal\n */\nclass StsTokenManager {\n    constructor() {\n        this.refreshToken = null;\n        this.accessToken = null;\n        this.expirationTime = null;\n    }\n    get isExpired() {\n        return (!this.expirationTime ||\n            Date.now() > this.expirationTime - 30000 /* Buffer.TOKEN_REFRESH */);\n    }\n    updateFromServerResponse(response) {\n        _assert(response.idToken, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.idToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof response.refreshToken !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = 'expiresIn' in response && typeof response.expiresIn !== 'undefined'\n            ? Number(response.expiresIn)\n            : _tokenExpiresIn(response.idToken);\n        this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);\n    }\n    updateFromIdToken(idToken) {\n        _assert(idToken.length !== 0, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const expiresIn = _tokenExpiresIn(idToken);\n        this.updateTokensAndExpiration(idToken, null, expiresIn);\n    }\n    async getToken(auth, forceRefresh = false) {\n        if (!forceRefresh && this.accessToken && !this.isExpired) {\n            return this.accessToken;\n        }\n        _assert(this.refreshToken, auth, \"user-token-expired\" /* AuthErrorCode.TOKEN_EXPIRED */);\n        if (this.refreshToken) {\n            await this.refresh(auth, this.refreshToken);\n            return this.accessToken;\n        }\n        return null;\n    }\n    clearRefreshToken() {\n        this.refreshToken = null;\n    }\n    async refresh(auth, oldToken) {\n        const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);\n        this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));\n    }\n    updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {\n        this.refreshToken = refreshToken || null;\n        this.accessToken = accessToken || null;\n        this.expirationTime = Date.now() + expiresInSec * 1000;\n    }\n    static fromJSON(appName, object) {\n        const { refreshToken, accessToken, expirationTime } = object;\n        const manager = new StsTokenManager();\n        if (refreshToken) {\n            _assert(typeof refreshToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.refreshToken = refreshToken;\n        }\n        if (accessToken) {\n            _assert(typeof accessToken === 'string', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.accessToken = accessToken;\n        }\n        if (expirationTime) {\n            _assert(typeof expirationTime === 'number', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, {\n                appName\n            });\n            manager.expirationTime = expirationTime;\n        }\n        return manager;\n    }\n    toJSON() {\n        return {\n            refreshToken: this.refreshToken,\n            accessToken: this.accessToken,\n            expirationTime: this.expirationTime\n        };\n    }\n    _assign(stsTokenManager) {\n        this.accessToken = stsTokenManager.accessToken;\n        this.refreshToken = stsTokenManager.refreshToken;\n        this.expirationTime = stsTokenManager.expirationTime;\n    }\n    _clone() {\n        return Object.assign(new StsTokenManager(), this.toJSON());\n    }\n    _performRefresh() {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction assertStringOrUndefined(assertion, appName) {\n    _assert(typeof assertion === 'string' || typeof assertion === 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */, { appName });\n}\nclass UserImpl {\n    constructor(_a) {\n        var { uid, auth, stsTokenManager } = _a, opt = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(_a, [\"uid\", \"auth\", \"stsTokenManager\"]);\n        // For the user object, provider is always Firebase.\n        this.providerId = \"firebase\" /* ProviderId.FIREBASE */;\n        this.proactiveRefresh = new ProactiveRefresh(this);\n        this.reloadUserInfo = null;\n        this.reloadListener = null;\n        this.uid = uid;\n        this.auth = auth;\n        this.stsTokenManager = stsTokenManager;\n        this.accessToken = stsTokenManager.accessToken;\n        this.displayName = opt.displayName || null;\n        this.email = opt.email || null;\n        this.emailVerified = opt.emailVerified || false;\n        this.phoneNumber = opt.phoneNumber || null;\n        this.photoURL = opt.photoURL || null;\n        this.isAnonymous = opt.isAnonymous || false;\n        this.tenantId = opt.tenantId || null;\n        this.providerData = opt.providerData ? [...opt.providerData] : [];\n        this.metadata = new UserMetadata(opt.createdAt || undefined, opt.lastLoginAt || undefined);\n    }\n    async getIdToken(forceRefresh) {\n        const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));\n        _assert(accessToken, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        if (this.accessToken !== accessToken) {\n            this.accessToken = accessToken;\n            await this.auth._persistUserIfCurrent(this);\n            this.auth._notifyListenersIfCurrent(this);\n        }\n        return accessToken;\n    }\n    getIdTokenResult(forceRefresh) {\n        return getIdTokenResult(this, forceRefresh);\n    }\n    reload() {\n        return reload(this);\n    }\n    _assign(user) {\n        if (this === user) {\n            return;\n        }\n        _assert(this.uid === user.uid, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.displayName = user.displayName;\n        this.photoURL = user.photoURL;\n        this.email = user.email;\n        this.emailVerified = user.emailVerified;\n        this.phoneNumber = user.phoneNumber;\n        this.isAnonymous = user.isAnonymous;\n        this.tenantId = user.tenantId;\n        this.providerData = user.providerData.map(userInfo => (Object.assign({}, userInfo)));\n        this.metadata._copy(user.metadata);\n        this.stsTokenManager._assign(user.stsTokenManager);\n    }\n    _clone(auth) {\n        const newUser = new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));\n        newUser.metadata._copy(this.metadata);\n        return newUser;\n    }\n    _onReload(callback) {\n        // There should only ever be one listener, and that is a single instance of MultiFactorUser\n        _assert(!this.reloadListener, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        this.reloadListener = callback;\n        if (this.reloadUserInfo) {\n            this._notifyReloadListener(this.reloadUserInfo);\n            this.reloadUserInfo = null;\n        }\n    }\n    _notifyReloadListener(userInfo) {\n        if (this.reloadListener) {\n            this.reloadListener(userInfo);\n        }\n        else {\n            // If no listener is subscribed yet, save the result so it's available when they do subscribe\n            this.reloadUserInfo = userInfo;\n        }\n    }\n    _startProactiveRefresh() {\n        this.proactiveRefresh._start();\n    }\n    _stopProactiveRefresh() {\n        this.proactiveRefresh._stop();\n    }\n    async _updateTokensIfNecessary(response, reload = false) {\n        let tokensRefreshed = false;\n        if (response.idToken &&\n            response.idToken !== this.stsTokenManager.accessToken) {\n            this.stsTokenManager.updateFromServerResponse(response);\n            tokensRefreshed = true;\n        }\n        if (reload) {\n            await _reloadWithoutSaving(this);\n        }\n        await this.auth._persistUserIfCurrent(this);\n        if (tokensRefreshed) {\n            this.auth._notifyListenersIfCurrent(this);\n        }\n    }\n    async delete() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.auth.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this.auth));\n        }\n        const idToken = await this.getIdToken();\n        await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));\n        this.stsTokenManager.clearRefreshToken();\n        // TODO: Determine if cancellable-promises are necessary to use in this class so that delete()\n        //       cancels pending actions...\n        return this.auth.signOut();\n    }\n    toJSON() {\n        return Object.assign(Object.assign({ uid: this.uid, email: this.email || undefined, emailVerified: this.emailVerified, displayName: this.displayName || undefined, isAnonymous: this.isAnonymous, photoURL: this.photoURL || undefined, phoneNumber: this.phoneNumber || undefined, tenantId: this.tenantId || undefined, providerData: this.providerData.map(userInfo => (Object.assign({}, userInfo))), stsTokenManager: this.stsTokenManager.toJSON(), \n            // Redirect event ID must be maintained in case there is a pending\n            // redirect event.\n            _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { \n            // Required for compatibility with the legacy SDK (go/firebase-auth-sdk-persistence-parsing):\n            apiKey: this.auth.config.apiKey, appName: this.auth.name });\n    }\n    get refreshToken() {\n        return this.stsTokenManager.refreshToken || '';\n    }\n    static _fromJSON(auth, object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : undefined;\n        const email = (_b = object.email) !== null && _b !== void 0 ? _b : undefined;\n        const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : undefined;\n        const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : undefined;\n        const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : undefined;\n        const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : undefined;\n        const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : undefined;\n        const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : undefined;\n        const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;\n        _assert(uid && plainObjectTokenManager, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);\n        _assert(typeof uid === 'string', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(displayName, auth.name);\n        assertStringOrUndefined(email, auth.name);\n        _assert(typeof emailVerified === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        _assert(typeof isAnonymous === 'boolean', auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        assertStringOrUndefined(phoneNumber, auth.name);\n        assertStringOrUndefined(photoURL, auth.name);\n        assertStringOrUndefined(tenantId, auth.name);\n        assertStringOrUndefined(_redirectEventId, auth.name);\n        assertStringOrUndefined(createdAt, auth.name);\n        assertStringOrUndefined(lastLoginAt, auth.name);\n        const user = new UserImpl({\n            uid,\n            auth,\n            email,\n            emailVerified,\n            displayName,\n            isAnonymous,\n            photoURL,\n            phoneNumber,\n            tenantId,\n            stsTokenManager,\n            createdAt,\n            lastLoginAt\n        });\n        if (providerData && Array.isArray(providerData)) {\n            user.providerData = providerData.map(userInfo => (Object.assign({}, userInfo)));\n        }\n        if (_redirectEventId) {\n            user._redirectEventId = _redirectEventId;\n        }\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromServerResponse(idTokenResponse);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: idTokenResponse.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // Updates the user info and data and resolves with a user instance.\n        await _reloadWithoutSaving(user);\n        return user;\n    }\n    /**\n     * Initialize a User from an idToken server response\n     * @param auth\n     * @param idTokenResponse\n     */\n    static async _fromGetAccountInfoResponse(auth, response, idToken) {\n        const coreAccount = response.users[0];\n        _assert(coreAccount.localId !== undefined, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const providerData = coreAccount.providerUserInfo !== undefined\n            ? extractProviderData(coreAccount.providerUserInfo)\n            : [];\n        const isAnonymous = !(coreAccount.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);\n        const stsTokenManager = new StsTokenManager();\n        stsTokenManager.updateFromIdToken(idToken);\n        // Initialize the Firebase Auth user.\n        const user = new UserImpl({\n            uid: coreAccount.localId,\n            auth,\n            stsTokenManager,\n            isAnonymous\n        });\n        // update the user with data from the GetAccountInfo response.\n        const updates = {\n            uid: coreAccount.localId,\n            displayName: coreAccount.displayName || null,\n            photoURL: coreAccount.photoUrl || null,\n            email: coreAccount.email || null,\n            emailVerified: coreAccount.emailVerified || false,\n            phoneNumber: coreAccount.phoneNumber || null,\n            tenantId: coreAccount.tenantId || null,\n            providerData,\n            metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),\n            isAnonymous: !(coreAccount.email && coreAccount.passwordHash) &&\n                !(providerData === null || providerData === void 0 ? void 0 : providerData.length)\n        };\n        Object.assign(user, updates);\n        return user;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst instanceCache = new Map();\nfunction _getInstance(cls) {\n    debugAssert(cls instanceof Function, 'Expected a class definition');\n    let instance = instanceCache.get(cls);\n    if (instance) {\n        debugAssert(instance instanceof cls, 'Instance stored in cache mismatched with class');\n        return instance;\n    }\n    instance = new cls();\n    instanceCache.set(cls, instance);\n    return instance;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass InMemoryPersistence {\n    constructor() {\n        this.type = \"NONE\" /* PersistenceType.NONE */;\n        this.storage = {};\n    }\n    async _isAvailable() {\n        return true;\n    }\n    async _set(key, value) {\n        this.storage[key] = value;\n    }\n    async _get(key) {\n        const value = this.storage[key];\n        return value === undefined ? null : value;\n    }\n    async _remove(key) {\n        delete this.storage[key];\n    }\n    _addListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n    _removeListener(_key, _listener) {\n        // Listeners are not supported for in-memory storage since it cannot be shared across windows/workers\n        return;\n    }\n}\nInMemoryPersistence.type = 'NONE';\n/**\n * An implementation of {@link Persistence} of type 'NONE'.\n *\n * @public\n */\nconst inMemoryPersistence = InMemoryPersistence;\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _persistenceKeyName(key, apiKey, appName) {\n    return `${\"firebase\" /* Namespace.PERSISTENCE */}:${key}:${apiKey}:${appName}`;\n}\nclass PersistenceUserManager {\n    constructor(persistence, auth, userKey) {\n        this.persistence = persistence;\n        this.auth = auth;\n        this.userKey = userKey;\n        const { config, name } = this.auth;\n        this.fullUserKey = _persistenceKeyName(this.userKey, config.apiKey, name);\n        this.fullPersistenceKey = _persistenceKeyName(\"persistence\" /* KeyName.PERSISTENCE_USER */, config.apiKey, name);\n        this.boundEventHandler = auth._onStorageEvent.bind(auth);\n        this.persistence._addListener(this.fullUserKey, this.boundEventHandler);\n    }\n    setCurrentUser(user) {\n        return this.persistence._set(this.fullUserKey, user.toJSON());\n    }\n    async getCurrentUser() {\n        const blob = await this.persistence._get(this.fullUserKey);\n        return blob ? UserImpl._fromJSON(this.auth, blob) : null;\n    }\n    removeCurrentUser() {\n        return this.persistence._remove(this.fullUserKey);\n    }\n    savePersistenceForRedirect() {\n        return this.persistence._set(this.fullPersistenceKey, this.persistence.type);\n    }\n    async setPersistence(newPersistence) {\n        if (this.persistence === newPersistence) {\n            return;\n        }\n        const currentUser = await this.getCurrentUser();\n        await this.removeCurrentUser();\n        this.persistence = newPersistence;\n        if (currentUser) {\n            return this.setCurrentUser(currentUser);\n        }\n    }\n    delete() {\n        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);\n    }\n    static async create(auth, persistenceHierarchy, userKey = \"authUser\" /* KeyName.AUTH_USER */) {\n        if (!persistenceHierarchy.length) {\n            return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);\n        }\n        // Eliminate any persistences that are not available\n        const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (await persistence._isAvailable()) {\n                return persistence;\n            }\n            return undefined;\n        }))).filter(persistence => persistence);\n        // Fall back to the first persistence listed, or in memory if none available\n        let selectedPersistence = availablePersistences[0] ||\n            _getInstance(inMemoryPersistence);\n        const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);\n        // Pull out the existing user, setting the chosen persistence to that\n        // persistence if the user exists.\n        let userToMigrate = null;\n        // Note, here we check for a user in _all_ persistences, not just the\n        // ones deemed available. If we can migrate a user out of a broken\n        // persistence, we will (but only if that persistence supports migration).\n        for (const persistence of persistenceHierarchy) {\n            try {\n                const blob = await persistence._get(key);\n                if (blob) {\n                    const user = UserImpl._fromJSON(auth, blob); // throws for unparsable blob (wrong format)\n                    if (persistence !== selectedPersistence) {\n                        userToMigrate = user;\n                    }\n                    selectedPersistence = persistence;\n                    break;\n                }\n            }\n            catch (_a) { }\n        }\n        // If we find the user in a persistence that does support migration, use\n        // that migration path (of only persistences that support migration)\n        const migrationHierarchy = availablePersistences.filter(p => p._shouldAllowMigration);\n        // If the persistence does _not_ allow migration, just finish off here\n        if (!selectedPersistence._shouldAllowMigration ||\n            !migrationHierarchy.length) {\n            return new PersistenceUserManager(selectedPersistence, auth, userKey);\n        }\n        selectedPersistence = migrationHierarchy[0];\n        if (userToMigrate) {\n            // This normally shouldn't throw since chosenPersistence.isAvailable() is true, but if it does\n            // we'll just let it bubble to surface the error.\n            await selectedPersistence._set(key, userToMigrate.toJSON());\n        }\n        // Attempt to clear the key in other persistences but ignore errors. This helps prevent issues\n        // such as users getting stuck with a previous account after signing out and refreshing the tab.\n        await Promise.all(persistenceHierarchy.map(async (persistence) => {\n            if (persistence !== selectedPersistence) {\n                try {\n                    await persistence._remove(key);\n                }\n                catch (_a) { }\n            }\n        }));\n        return new PersistenceUserManager(selectedPersistence, auth, userKey);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Determine the browser for the purposes of reporting usage to the API\n */\nfunction _getBrowserName(userAgent) {\n    const ua = userAgent.toLowerCase();\n    if (ua.includes('opera/') || ua.includes('opr/') || ua.includes('opios/')) {\n        return \"Opera\" /* BrowserName.OPERA */;\n    }\n    else if (_isIEMobile(ua)) {\n        // Windows phone IEMobile browser.\n        return \"IEMobile\" /* BrowserName.IEMOBILE */;\n    }\n    else if (ua.includes('msie') || ua.includes('trident/')) {\n        return \"IE\" /* BrowserName.IE */;\n    }\n    else if (ua.includes('edge/')) {\n        return \"Edge\" /* BrowserName.EDGE */;\n    }\n    else if (_isFirefox(ua)) {\n        return \"Firefox\" /* BrowserName.FIREFOX */;\n    }\n    else if (ua.includes('silk/')) {\n        return \"Silk\" /* BrowserName.SILK */;\n    }\n    else if (_isBlackBerry(ua)) {\n        // Blackberry browser.\n        return \"Blackberry\" /* BrowserName.BLACKBERRY */;\n    }\n    else if (_isWebOS(ua)) {\n        // WebOS default browser.\n        return \"Webos\" /* BrowserName.WEBOS */;\n    }\n    else if (_isSafari(ua)) {\n        return \"Safari\" /* BrowserName.SAFARI */;\n    }\n    else if ((ua.includes('chrome/') || _isChromeIOS(ua)) &&\n        !ua.includes('edge/')) {\n        return \"Chrome\" /* BrowserName.CHROME */;\n    }\n    else if (_isAndroid(ua)) {\n        // Android stock browser.\n        return \"Android\" /* BrowserName.ANDROID */;\n    }\n    else {\n        // Most modern browsers have name/version at end of user agent string.\n        const re = /([a-zA-Z\\d\\.]+)\\/[a-zA-Z\\d\\.]*$/;\n        const matches = userAgent.match(re);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {\n            return matches[1];\n        }\n    }\n    return \"Other\" /* BrowserName.OTHER */;\n}\nfunction _isFirefox(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /firefox\\//i.test(ua);\n}\nfunction _isSafari(userAgent = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    const ua = userAgent.toLowerCase();\n    return (ua.includes('safari/') &&\n        !ua.includes('chrome/') &&\n        !ua.includes('crios/') &&\n        !ua.includes('android'));\n}\nfunction _isChromeIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /crios\\//i.test(ua);\n}\nfunction _isIEMobile(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /iemobile/i.test(ua);\n}\nfunction _isAndroid(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /android/i.test(ua);\n}\nfunction _isBlackBerry(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /blackberry/i.test(ua);\n}\nfunction _isWebOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return /webos/i.test(ua);\n}\nfunction _isIOS(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return (/iphone|ipad|ipod/i.test(ua) ||\n        (/macintosh/i.test(ua) && /mobile/i.test(ua)));\n}\nfunction _isIOS7Or8(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    return (/(iPad|iPhone|iPod).*OS 7_\\d/i.test(ua) ||\n        /(iPad|iPhone|iPod).*OS 8_\\d/i.test(ua));\n}\nfunction _isIE10() {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.isIE)() && document.documentMode === 10;\n}\nfunction _isMobileBrowser(ua = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)()) {\n    // TODO: implement getBrowserName equivalent for OS.\n    return (_isIOS(ua) ||\n        _isAndroid(ua) ||\n        _isWebOS(ua) ||\n        _isBlackBerry(ua) ||\n        /windows phone/i.test(ua) ||\n        _isIEMobile(ua));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * Determine the SDK version string\n */\nfunction _getClientVersion(clientPlatform, frameworks = []) {\n    let reportedPlatform;\n    switch (clientPlatform) {\n        case \"Browser\" /* ClientPlatform.BROWSER */:\n            // In a browser environment, report the browser name.\n            reportedPlatform = _getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)());\n            break;\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            // Technically a worker runs from a browser but we need to differentiate a\n            // worker from a browser.\n            // For example: Chrome-Worker/JsCore/4.9.1/FirebaseCore-web.\n            reportedPlatform = `${_getBrowserName((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getUA)())}-${clientPlatform}`;\n            break;\n        default:\n            reportedPlatform = clientPlatform;\n    }\n    const reportedFrameworks = frameworks.length\n        ? frameworks.join(',')\n        : 'FirebaseCore-web'; /* default value if no other framework is used */\n    return `${reportedPlatform}/${\"JsCore\" /* ClientImplementation.CORE */}/${_firebase_app__WEBPACK_IMPORTED_MODULE_0__.SDK_VERSION}/${reportedFrameworks}`;\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthMiddlewareQueue {\n    constructor(auth) {\n        this.auth = auth;\n        this.queue = [];\n    }\n    pushCallback(callback, onAbort) {\n        // The callback could be sync or async. Wrap it into a\n        // function that is always async.\n        const wrappedCallback = (user) => new Promise((resolve, reject) => {\n            try {\n                const result = callback(user);\n                // Either resolve with existing promise or wrap a non-promise\n                // return value into a promise.\n                resolve(result);\n            }\n            catch (e) {\n                // Sync callback throws.\n                reject(e);\n            }\n        });\n        // Attach the onAbort if present\n        wrappedCallback.onAbort = onAbort;\n        this.queue.push(wrappedCallback);\n        const index = this.queue.length - 1;\n        return () => {\n            // Unsubscribe. Replace with no-op. Do not remove from array, or it will disturb\n            // indexing of other elements.\n            this.queue[index] = () => Promise.resolve();\n        };\n    }\n    async runMiddleware(nextUser) {\n        if (this.auth.currentUser === nextUser) {\n            return;\n        }\n        // While running the middleware, build a temporary stack of onAbort\n        // callbacks to call if one middleware callback rejects.\n        const onAbortStack = [];\n        try {\n            for (const beforeStateCallback of this.queue) {\n                await beforeStateCallback(nextUser);\n                // Only push the onAbort if the callback succeeds\n                if (beforeStateCallback.onAbort) {\n                    onAbortStack.push(beforeStateCallback.onAbort);\n                }\n            }\n        }\n        catch (e) {\n            // Run all onAbort, with separate try/catch to ignore any errors and\n            // continue\n            onAbortStack.reverse();\n            for (const onAbort of onAbortStack) {\n                try {\n                    onAbort();\n                }\n                catch (_) {\n                    /* swallow error */\n                }\n            }\n            throw this.auth._errorFactory.create(\"login-blocked\" /* AuthErrorCode.LOGIN_BLOCKED */, {\n                originalMessage: e === null || e === void 0 ? void 0 : e.message\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Fetches the password policy for the currently set tenant or the project if no tenant is set.\n *\n * @param auth Auth object.\n * @param request Password policy request.\n * @returns Password policy response.\n */\nasync function _getPasswordPolicy(auth, request = {}) {\n    return _performApiRequest(auth, \"GET\" /* HttpMethod.GET */, \"/v2/passwordPolicy\" /* Endpoint.GET_PASSWORD_POLICY */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Minimum min password length enforced by the backend, even if no minimum length is set.\nconst MINIMUM_MIN_PASSWORD_LENGTH = 6;\n/**\n * Stores password policy requirements and provides password validation against the policy.\n *\n * @internal\n */\nclass PasswordPolicyImpl {\n    constructor(response) {\n        var _a, _b, _c, _d;\n        // Only include custom strength options defined in the response.\n        const responseOptions = response.customStrengthOptions;\n        this.customStrengthOptions = {};\n        // TODO: Remove once the backend is updated to include the minimum min password length instead of undefined when there is no minimum length set.\n        this.customStrengthOptions.minPasswordLength =\n            (_a = responseOptions.minPasswordLength) !== null && _a !== void 0 ? _a : MINIMUM_MIN_PASSWORD_LENGTH;\n        if (responseOptions.maxPasswordLength) {\n            this.customStrengthOptions.maxPasswordLength =\n                responseOptions.maxPasswordLength;\n        }\n        if (responseOptions.containsLowercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsLowercaseLetter =\n                responseOptions.containsLowercaseCharacter;\n        }\n        if (responseOptions.containsUppercaseCharacter !== undefined) {\n            this.customStrengthOptions.containsUppercaseLetter =\n                responseOptions.containsUppercaseCharacter;\n        }\n        if (responseOptions.containsNumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNumericCharacter =\n                responseOptions.containsNumericCharacter;\n        }\n        if (responseOptions.containsNonAlphanumericCharacter !== undefined) {\n            this.customStrengthOptions.containsNonAlphanumericCharacter =\n                responseOptions.containsNonAlphanumericCharacter;\n        }\n        this.enforcementState = response.enforcementState;\n        if (this.enforcementState === 'ENFORCEMENT_STATE_UNSPECIFIED') {\n            this.enforcementState = 'OFF';\n        }\n        // Use an empty string if no non-alphanumeric characters are specified in the response.\n        this.allowedNonAlphanumericCharacters =\n            (_c = (_b = response.allowedNonAlphanumericCharacters) === null || _b === void 0 ? void 0 : _b.join('')) !== null && _c !== void 0 ? _c : '';\n        this.forceUpgradeOnSignin = (_d = response.forceUpgradeOnSignin) !== null && _d !== void 0 ? _d : false;\n        this.schemaVersion = response.schemaVersion;\n    }\n    validatePassword(password) {\n        var _a, _b, _c, _d, _e, _f;\n        const status = {\n            isValid: true,\n            passwordPolicy: this\n        };\n        // Check the password length and character options.\n        this.validatePasswordLengthOptions(password, status);\n        this.validatePasswordCharacterOptions(password, status);\n        // Combine the status into single isValid property.\n        status.isValid && (status.isValid = (_a = status.meetsMinPasswordLength) !== null && _a !== void 0 ? _a : true);\n        status.isValid && (status.isValid = (_b = status.meetsMaxPasswordLength) !== null && _b !== void 0 ? _b : true);\n        status.isValid && (status.isValid = (_c = status.containsLowercaseLetter) !== null && _c !== void 0 ? _c : true);\n        status.isValid && (status.isValid = (_d = status.containsUppercaseLetter) !== null && _d !== void 0 ? _d : true);\n        status.isValid && (status.isValid = (_e = status.containsNumericCharacter) !== null && _e !== void 0 ? _e : true);\n        status.isValid && (status.isValid = (_f = status.containsNonAlphanumericCharacter) !== null && _f !== void 0 ? _f : true);\n        return status;\n    }\n    /**\n     * Validates that the password meets the length options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordLengthOptions(password, status) {\n        const minPasswordLength = this.customStrengthOptions.minPasswordLength;\n        const maxPasswordLength = this.customStrengthOptions.maxPasswordLength;\n        if (minPasswordLength) {\n            status.meetsMinPasswordLength = password.length >= minPasswordLength;\n        }\n        if (maxPasswordLength) {\n            status.meetsMaxPasswordLength = password.length <= maxPasswordLength;\n        }\n    }\n    /**\n     * Validates that the password meets the character options for the policy.\n     *\n     * @param password Password to validate.\n     * @param status Validation status.\n     */\n    validatePasswordCharacterOptions(password, status) {\n        // Assign statuses for requirements even if the password is an empty string.\n        this.updatePasswordCharacterOptionsStatuses(status, \n        /* containsLowercaseCharacter= */ false, \n        /* containsUppercaseCharacter= */ false, \n        /* containsNumericCharacter= */ false, \n        /* containsNonAlphanumericCharacter= */ false);\n        let passwordChar;\n        for (let i = 0; i < password.length; i++) {\n            passwordChar = password.charAt(i);\n            this.updatePasswordCharacterOptionsStatuses(status, \n            /* containsLowercaseCharacter= */ passwordChar >= 'a' &&\n                passwordChar <= 'z', \n            /* containsUppercaseCharacter= */ passwordChar >= 'A' &&\n                passwordChar <= 'Z', \n            /* containsNumericCharacter= */ passwordChar >= '0' &&\n                passwordChar <= '9', \n            /* containsNonAlphanumericCharacter= */ this.allowedNonAlphanumericCharacters.includes(passwordChar));\n        }\n    }\n    /**\n     * Updates the running validation status with the statuses for the character options.\n     * Expected to be called each time a character is processed to update each option status\n     * based on the current character.\n     *\n     * @param status Validation status.\n     * @param containsLowercaseCharacter Whether the character is a lowercase letter.\n     * @param containsUppercaseCharacter Whether the character is an uppercase letter.\n     * @param containsNumericCharacter Whether the character is a numeric character.\n     * @param containsNonAlphanumericCharacter Whether the character is a non-alphanumeric character.\n     */\n    updatePasswordCharacterOptionsStatuses(status, containsLowercaseCharacter, containsUppercaseCharacter, containsNumericCharacter, containsNonAlphanumericCharacter) {\n        if (this.customStrengthOptions.containsLowercaseLetter) {\n            status.containsLowercaseLetter || (status.containsLowercaseLetter = containsLowercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsUppercaseLetter) {\n            status.containsUppercaseLetter || (status.containsUppercaseLetter = containsUppercaseCharacter);\n        }\n        if (this.customStrengthOptions.containsNumericCharacter) {\n            status.containsNumericCharacter || (status.containsNumericCharacter = containsNumericCharacter);\n        }\n        if (this.customStrengthOptions.containsNonAlphanumericCharacter) {\n            status.containsNonAlphanumericCharacter || (status.containsNonAlphanumericCharacter = containsNonAlphanumericCharacter);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthImpl {\n    constructor(app, heartbeatServiceProvider, appCheckServiceProvider, config) {\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n        this.appCheckServiceProvider = appCheckServiceProvider;\n        this.config = config;\n        this.currentUser = null;\n        this.emulatorConfig = null;\n        this.operations = Promise.resolve();\n        this.authStateSubscription = new Subscription(this);\n        this.idTokenSubscription = new Subscription(this);\n        this.beforeStateQueue = new AuthMiddlewareQueue(this);\n        this.redirectUser = null;\n        this.isProactiveRefreshEnabled = false;\n        this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION = 1;\n        // Any network calls will set this to true and prevent subsequent emulator\n        // initialization\n        this._canInitEmulator = true;\n        this._isInitialized = false;\n        this._deleted = false;\n        this._initializationPromise = null;\n        this._popupRedirectResolver = null;\n        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;\n        this._agentRecaptchaConfig = null;\n        this._tenantRecaptchaConfigs = {};\n        this._projectPasswordPolicy = null;\n        this._tenantPasswordPolicies = {};\n        // Tracks the last notified UID for state change listeners to prevent\n        // repeated calls to the callbacks. Undefined means it's never been\n        // called, whereas null means it's been called with a signed out user\n        this.lastNotifiedUid = undefined;\n        this.languageCode = null;\n        this.tenantId = null;\n        this.settings = { appVerificationDisabledForTesting: false };\n        this.frameworks = [];\n        this.name = app.name;\n        this.clientVersion = config.sdkClientVersion;\n    }\n    _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {\n        if (popupRedirectResolver) {\n            this._popupRedirectResolver = _getInstance(popupRedirectResolver);\n        }\n        // Have to check for app deletion throughout initialization (after each\n        // promise resolution)\n        this._initializationPromise = this.queue(async () => {\n            var _a, _b;\n            if (this._deleted) {\n                return;\n            }\n            this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);\n            if (this._deleted) {\n                return;\n            }\n            // Initialize the resolver early if necessary (only applicable to web:\n            // this will cause the iframe to load immediately in certain cases)\n            if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {\n                // If this fails, don't halt auth loading\n                try {\n                    await this._popupRedirectResolver._initialize(this);\n                }\n                catch (e) {\n                    /* Ignore the error */\n                }\n            }\n            await this.initializeCurrentUser(popupRedirectResolver);\n            this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;\n            if (this._deleted) {\n                return;\n            }\n            this._isInitialized = true;\n        });\n        return this._initializationPromise;\n    }\n    /**\n     * If the persistence is changed in another window, the user manager will let us know\n     */\n    async _onStorageEvent() {\n        if (this._deleted) {\n            return;\n        }\n        const user = await this.assertedPersistence.getCurrentUser();\n        if (!this.currentUser && !user) {\n            // No change, do nothing (was signed out and remained signed out).\n            return;\n        }\n        // If the same user is to be synchronized.\n        if (this.currentUser && user && this.currentUser.uid === user.uid) {\n            // Data update, simply copy data changes.\n            this._currentUser._assign(user);\n            // If tokens changed from previous user tokens, this will trigger\n            // notifyAuthListeners_.\n            await this.currentUser.getIdToken();\n            return;\n        }\n        // Update current Auth state. Either a new login or logout.\n        // Skip blocking callbacks, they should not apply to a change in another tab.\n        await this._updateCurrentUser(user, /* skipBeforeStateCallbacks */ true);\n    }\n    async initializeCurrentUserFromIdToken(idToken) {\n        try {\n            const response = await getAccountInfo(this, { idToken });\n            const user = await UserImpl._fromGetAccountInfoResponse(this, response, idToken);\n            await this.directlySetCurrentUser(user);\n        }\n        catch (err) {\n            console.warn('FirebaseServerApp could not login user with provided authIdToken: ', err);\n            await this.directlySetCurrentUser(null);\n        }\n    }\n    async initializeCurrentUser(popupRedirectResolver) {\n        var _a;\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            const idToken = this.app.settings.authIdToken;\n            if (idToken) {\n                // Start the auth operation in the next tick to allow a moment for the customer's app to\n                // attach an emulator, if desired.\n                return new Promise(resolve => {\n                    setTimeout(() => this.initializeCurrentUserFromIdToken(idToken).then(resolve, resolve));\n                });\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        // First check to see if we have a pending redirect event.\n        const previouslyStoredUser = (await this.assertedPersistence.getCurrentUser());\n        let futureCurrentUser = previouslyStoredUser;\n        let needsTocheckMiddleware = false;\n        if (popupRedirectResolver && this.config.authDomain) {\n            await this.getOrInitRedirectPersistenceManager();\n            const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;\n            const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;\n            const result = await this.tryRedirectSignIn(popupRedirectResolver);\n            // If the stored user (i.e. the old \"currentUser\") has a redirectId that\n            // matches the redirect user, then we want to initially sign in with the\n            // new user object from result.\n            // TODO(samgho): More thoroughly test all of this\n            if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) &&\n                (result === null || result === void 0 ? void 0 : result.user)) {\n                futureCurrentUser = result.user;\n                needsTocheckMiddleware = true;\n            }\n        }\n        // If no user in persistence, there is no current user. Set to null.\n        if (!futureCurrentUser) {\n            return this.directlySetCurrentUser(null);\n        }\n        if (!futureCurrentUser._redirectEventId) {\n            // This isn't a redirect link operation, we can reload and bail.\n            // First though, ensure that we check the middleware is happy.\n            if (needsTocheckMiddleware) {\n                try {\n                    await this.beforeStateQueue.runMiddleware(futureCurrentUser);\n                }\n                catch (e) {\n                    futureCurrentUser = previouslyStoredUser;\n                    // We know this is available since the bit is only set when the\n                    // resolver is available\n                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e));\n                }\n            }\n            if (futureCurrentUser) {\n                return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n            }\n            else {\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        _assert(this._popupRedirectResolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        await this.getOrInitRedirectPersistenceManager();\n        // If the redirect user's event ID matches the current user's event ID,\n        // DO NOT reload the current user, otherwise they'll be cleared from storage.\n        // This is important for the reauthenticateWithRedirect() flow.\n        if (this.redirectUser &&\n            this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {\n            return this.directlySetCurrentUser(futureCurrentUser);\n        }\n        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);\n    }\n    async tryRedirectSignIn(redirectResolver) {\n        // The redirect user needs to be checked (and signed in if available)\n        // during auth initialization. All of the normal sign in and link/reauth\n        // flows call back into auth and push things onto the promise queue. We\n        // need to await the result of the redirect sign in *inside the promise\n        // queue*. This presents a problem: we run into deadlock. See:\n        //    ┌> [Initialization] ─────┐\n        //    ┌> [<other queue tasks>] │\n        //    └─ [getRedirectResult] <─┘\n        //    where [] are tasks on the queue and arrows denote awaits\n        // Initialization will never complete because it's waiting on something\n        // that's waiting for initialization to complete!\n        //\n        // Instead, this method calls getRedirectResult() (stored in\n        // _completeRedirectFn) with an optional parameter that instructs all of\n        // the underlying auth operations to skip anything that mutates auth state.\n        let result = null;\n        try {\n            // We know this._popupRedirectResolver is set since redirectResolver\n            // is passed in. The _completeRedirectFn expects the unwrapped extern.\n            result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);\n        }\n        catch (e) {\n            // Swallow any errors here; the code can retrieve them in\n            // getRedirectResult().\n            await this._setRedirectUser(null);\n        }\n        return result;\n    }\n    async reloadAndSetCurrentUserOrClear(user) {\n        try {\n            await _reloadWithoutSaving(user);\n        }\n        catch (e) {\n            if ((e === null || e === void 0 ? void 0 : e.code) !==\n                `auth/${\"network-request-failed\" /* AuthErrorCode.NETWORK_REQUEST_FAILED */}`) {\n                // Something's wrong with the user's token. Log them out and remove\n                // them from storage\n                return this.directlySetCurrentUser(null);\n            }\n        }\n        return this.directlySetCurrentUser(user);\n    }\n    useDeviceLanguage() {\n        this.languageCode = _getUserLanguage();\n    }\n    async _delete() {\n        this._deleted = true;\n    }\n    async updateCurrentUser(userExtern) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // The public updateCurrentUser method needs to make a copy of the user,\n        // and also check that the project matches\n        const user = userExtern\n            ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(userExtern)\n            : null;\n        if (user) {\n            _assert(user.auth.config.apiKey === this.config.apiKey, this, \"invalid-user-token\" /* AuthErrorCode.INVALID_AUTH */);\n        }\n        return this._updateCurrentUser(user && user._clone(this));\n    }\n    async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {\n        if (this._deleted) {\n            return;\n        }\n        if (user) {\n            _assert(this.tenantId === user.tenantId, this, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n        }\n        if (!skipBeforeStateCallbacks) {\n            await this.beforeStateQueue.runMiddleware(user);\n        }\n        return this.queue(async () => {\n            await this.directlySetCurrentUser(user);\n            this.notifyAuthListeners();\n        });\n    }\n    async signOut() {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        // Run first, to block _setRedirectUser() if any callbacks fail.\n        await this.beforeStateQueue.runMiddleware(null);\n        // Clear the redirect user when signOut is called\n        if (this.redirectPersistenceManager || this._popupRedirectResolver) {\n            await this._setRedirectUser(null);\n        }\n        // Prevent callbacks from being called again in _updateCurrentUser, as\n        // they were already called in the first line.\n        return this._updateCurrentUser(null, /* skipBeforeStateCallbacks */ true);\n    }\n    setPersistence(persistence) {\n        if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(this.app)) {\n            return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(this));\n        }\n        return this.queue(async () => {\n            await this.assertedPersistence.setPersistence(_getInstance(persistence));\n        });\n    }\n    _getRecaptchaConfig() {\n        if (this.tenantId == null) {\n            return this._agentRecaptchaConfig;\n        }\n        else {\n            return this._tenantRecaptchaConfigs[this.tenantId];\n        }\n    }\n    async validatePassword(password) {\n        if (!this._getPasswordPolicyInternal()) {\n            await this._updatePasswordPolicy();\n        }\n        // Password policy will be defined after fetching.\n        const passwordPolicy = this._getPasswordPolicyInternal();\n        // Check that the policy schema version is supported by the SDK.\n        // TODO: Update this logic to use a max supported policy schema version once we have multiple schema versions.\n        if (passwordPolicy.schemaVersion !==\n            this.EXPECTED_PASSWORD_POLICY_SCHEMA_VERSION) {\n            return Promise.reject(this._errorFactory.create(\"unsupported-password-policy-schema-version\" /* AuthErrorCode.UNSUPPORTED_PASSWORD_POLICY_SCHEMA_VERSION */, {}));\n        }\n        return passwordPolicy.validatePassword(password);\n    }\n    _getPasswordPolicyInternal() {\n        if (this.tenantId === null) {\n            return this._projectPasswordPolicy;\n        }\n        else {\n            return this._tenantPasswordPolicies[this.tenantId];\n        }\n    }\n    async _updatePasswordPolicy() {\n        const response = await _getPasswordPolicy(this);\n        const passwordPolicy = new PasswordPolicyImpl(response);\n        if (this.tenantId === null) {\n            this._projectPasswordPolicy = passwordPolicy;\n        }\n        else {\n            this._tenantPasswordPolicies[this.tenantId] = passwordPolicy;\n        }\n    }\n    _getPersistence() {\n        return this.assertedPersistence.persistence.type;\n    }\n    _updateErrorMap(errorMap) {\n        this._errorFactory = new _firebase_util__WEBPACK_IMPORTED_MODULE_1__.ErrorFactory('auth', 'Firebase', errorMap());\n    }\n    onAuthStateChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);\n    }\n    beforeAuthStateChanged(callback, onAbort) {\n        return this.beforeStateQueue.pushCallback(callback, onAbort);\n    }\n    onIdTokenChanged(nextOrObserver, error, completed) {\n        return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);\n    }\n    authStateReady() {\n        return new Promise((resolve, reject) => {\n            if (this.currentUser) {\n                resolve();\n            }\n            else {\n                const unsubscribe = this.onAuthStateChanged(() => {\n                    unsubscribe();\n                    resolve();\n                }, reject);\n            }\n        });\n    }\n    /**\n     * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n     */\n    async revokeAccessToken(token) {\n        if (this.currentUser) {\n            const idToken = await this.currentUser.getIdToken();\n            // Generalize this to accept other providers once supported.\n            const request = {\n                providerId: 'apple.com',\n                tokenType: \"ACCESS_TOKEN\" /* TokenType.ACCESS_TOKEN */,\n                token,\n                idToken\n            };\n            if (this.tenantId != null) {\n                request.tenantId = this.tenantId;\n            }\n            await revokeToken(this, request);\n        }\n    }\n    toJSON() {\n        var _a;\n        return {\n            apiKey: this.config.apiKey,\n            authDomain: this.config.authDomain,\n            appName: this.name,\n            currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()\n        };\n    }\n    async _setRedirectUser(user, popupRedirectResolver) {\n        const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);\n        return user === null\n            ? redirectManager.removeCurrentUser()\n            : redirectManager.setCurrentUser(user);\n    }\n    async getOrInitRedirectPersistenceManager(popupRedirectResolver) {\n        if (!this.redirectPersistenceManager) {\n            const resolver = (popupRedirectResolver && _getInstance(popupRedirectResolver)) ||\n                this._popupRedirectResolver;\n            _assert(resolver, this, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], \"redirectUser\" /* KeyName.REDIRECT_USER */);\n            this.redirectUser =\n                await this.redirectPersistenceManager.getCurrentUser();\n        }\n        return this.redirectPersistenceManager;\n    }\n    async _redirectUserForId(id) {\n        var _a, _b;\n        // Make sure we've cleared any pending persistence actions if we're not in\n        // the initializer\n        if (this._isInitialized) {\n            await this.queue(async () => { });\n        }\n        if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {\n            return this._currentUser;\n        }\n        if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {\n            return this.redirectUser;\n        }\n        return null;\n    }\n    async _persistUserIfCurrent(user) {\n        if (user === this.currentUser) {\n            return this.queue(async () => this.directlySetCurrentUser(user));\n        }\n    }\n    /** Notifies listeners only if the user is current */\n    _notifyListenersIfCurrent(user) {\n        if (user === this.currentUser) {\n            this.notifyAuthListeners();\n        }\n    }\n    _key() {\n        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;\n    }\n    _startProactiveRefresh() {\n        this.isProactiveRefreshEnabled = true;\n        if (this.currentUser) {\n            this._currentUser._startProactiveRefresh();\n        }\n    }\n    _stopProactiveRefresh() {\n        this.isProactiveRefreshEnabled = false;\n        if (this.currentUser) {\n            this._currentUser._stopProactiveRefresh();\n        }\n    }\n    /** Returns the current user cast as the internal type */\n    get _currentUser() {\n        return this.currentUser;\n    }\n    notifyAuthListeners() {\n        var _a, _b;\n        if (!this._isInitialized) {\n            return;\n        }\n        this.idTokenSubscription.next(this.currentUser);\n        const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;\n        if (this.lastNotifiedUid !== currentUid) {\n            this.lastNotifiedUid = currentUid;\n            this.authStateSubscription.next(this.currentUser);\n        }\n    }\n    registerStateListener(subscription, nextOrObserver, error, completed) {\n        if (this._deleted) {\n            return () => { };\n        }\n        const cb = typeof nextOrObserver === 'function'\n            ? nextOrObserver\n            : nextOrObserver.next.bind(nextOrObserver);\n        let isUnsubscribed = false;\n        const promise = this._isInitialized\n            ? Promise.resolve()\n            : this._initializationPromise;\n        _assert(promise, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // The callback needs to be called asynchronously per the spec.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promise.then(() => {\n            if (isUnsubscribed) {\n                return;\n            }\n            cb(this.currentUser);\n        });\n        if (typeof nextOrObserver === 'function') {\n            const unsubscribe = subscription.addObserver(nextOrObserver, error, completed);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n        else {\n            const unsubscribe = subscription.addObserver(nextOrObserver);\n            return () => {\n                isUnsubscribed = true;\n                unsubscribe();\n            };\n        }\n    }\n    /**\n     * Unprotected (from race conditions) method to set the current user. This\n     * should only be called from within a queued callback. This is necessary\n     * because the queue shouldn't rely on another queued callback.\n     */\n    async directlySetCurrentUser(user) {\n        if (this.currentUser && this.currentUser !== user) {\n            this._currentUser._stopProactiveRefresh();\n        }\n        if (user && this.isProactiveRefreshEnabled) {\n            user._startProactiveRefresh();\n        }\n        this.currentUser = user;\n        if (user) {\n            await this.assertedPersistence.setCurrentUser(user);\n        }\n        else {\n            await this.assertedPersistence.removeCurrentUser();\n        }\n    }\n    queue(action) {\n        // In case something errors, the callback still should be called in order\n        // to keep the promise chain alive\n        this.operations = this.operations.then(action, action);\n        return this.operations;\n    }\n    get assertedPersistence() {\n        _assert(this.persistenceManager, this, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.persistenceManager;\n    }\n    _logFramework(framework) {\n        if (!framework || this.frameworks.includes(framework)) {\n            return;\n        }\n        this.frameworks.push(framework);\n        // Sort alphabetically so that \"FirebaseCore-web,FirebaseUI-web\" and\n        // \"FirebaseUI-web,FirebaseCore-web\" aren't viewed as different.\n        this.frameworks.sort();\n        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());\n    }\n    _getFrameworks() {\n        return this.frameworks;\n    }\n    async _getAdditionalHeaders() {\n        var _a;\n        // Additional headers on every request\n        const headers = {\n            [\"X-Client-Version\" /* HttpHeader.X_CLIENT_VERSION */]: this.clientVersion\n        };\n        if (this.app.options.appId) {\n            headers[\"X-Firebase-gmpid\" /* HttpHeader.X_FIREBASE_GMPID */] = this.app.options.appId;\n        }\n        // If the heartbeat service exists, add the heartbeat string\n        const heartbeatsHeader = await ((_a = this.heartbeatServiceProvider\n            .getImmediate({\n            optional: true\n        })) === null || _a === void 0 ? void 0 : _a.getHeartbeatsHeader());\n        if (heartbeatsHeader) {\n            headers[\"X-Firebase-Client\" /* HttpHeader.X_FIREBASE_CLIENT */] = heartbeatsHeader;\n        }\n        // If the App Check service exists, add the App Check token in the headers\n        const appCheckToken = await this._getAppCheckToken();\n        if (appCheckToken) {\n            headers[\"X-Firebase-AppCheck\" /* HttpHeader.X_FIREBASE_APP_CHECK */] = appCheckToken;\n        }\n        return headers;\n    }\n    async _getAppCheckToken() {\n        var _a;\n        const appCheckTokenResult = await ((_a = this.appCheckServiceProvider\n            .getImmediate({ optional: true })) === null || _a === void 0 ? void 0 : _a.getToken());\n        if (appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.error) {\n            // Context: appCheck.getToken() will never throw even if an error happened.\n            // In the error case, a dummy token will be returned along with an error field describing\n            // the error. In general, we shouldn't care about the error condition and just use\n            // the token (actual or dummy) to send requests.\n            _logWarn(`Error while retrieving App Check token: ${appCheckTokenResult.error}`);\n        }\n        return appCheckTokenResult === null || appCheckTokenResult === void 0 ? void 0 : appCheckTokenResult.token;\n    }\n}\n/**\n * Method to be used to cast down to our private implementation of Auth.\n * It will also handle unwrapping from the compat type if necessary\n *\n * @param auth Auth object passed in from developer\n */\nfunction _castAuth(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n}\n/** Helper class to wrap subscriber logic */\nclass Subscription {\n    constructor(auth) {\n        this.auth = auth;\n        this.observer = null;\n        this.addObserver = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.createSubscribe)(observer => (this.observer = observer));\n    }\n    get next() {\n        _assert(this.observer, this.auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        return this.observer.next.bind(this.observer);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nlet externalJSProvider = {\n    async loadJS() {\n        throw new Error('Unable to load external scripts');\n    },\n    recaptchaV2Script: '',\n    recaptchaEnterpriseScript: '',\n    gapiScript: ''\n};\nfunction _loadJS(url) {\n    return externalJSProvider.loadJS(url);\n}\nfunction _recaptchaEnterpriseScriptUrl() {\n    return externalJSProvider.recaptchaEnterpriseScript;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MockGreCAPTCHATopLevel {\n    constructor() {\n        this.enterprise = new MockGreCAPTCHA();\n    }\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\nclass MockGreCAPTCHA {\n    ready(callback) {\n        callback();\n    }\n    execute(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _siteKey, _options) {\n        return Promise.resolve('token');\n    }\n    render(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _container, _parameters) {\n        return '';\n    }\n}\n\n/* eslint-disable @typescript-eslint/no-require-imports */\nconst RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = 'recaptcha-enterprise';\nconst FAKE_TOKEN = 'NO_RECAPTCHA';\nclass RecaptchaEnterpriseVerifier {\n    /**\n     *\n     * @param authExtern - The corresponding Firebase {@link Auth} instance.\n     *\n     */\n    constructor(authExtern) {\n        /**\n         * Identifies the type of application verifier (e.g. \"recaptcha-enterprise\").\n         */\n        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE;\n        this.auth = _castAuth(authExtern);\n    }\n    /**\n     * Executes the verification process.\n     *\n     * @returns A Promise for a token that can be used to assert the validity of a request.\n     */\n    async verify(action = 'verify', forceRefresh = false) {\n        async function retrieveSiteKey(auth) {\n            if (!forceRefresh) {\n                if (auth.tenantId == null && auth._agentRecaptchaConfig != null) {\n                    return auth._agentRecaptchaConfig.siteKey;\n                }\n                if (auth.tenantId != null &&\n                    auth._tenantRecaptchaConfigs[auth.tenantId] !== undefined) {\n                    return auth._tenantRecaptchaConfigs[auth.tenantId].siteKey;\n                }\n            }\n            return new Promise(async (resolve, reject) => {\n                getRecaptchaConfig(auth, {\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                })\n                    .then(response => {\n                    if (response.recaptchaKey === undefined) {\n                        reject(new Error('recaptcha Enterprise site key undefined'));\n                    }\n                    else {\n                        const config = new RecaptchaConfig(response);\n                        if (auth.tenantId == null) {\n                            auth._agentRecaptchaConfig = config;\n                        }\n                        else {\n                            auth._tenantRecaptchaConfigs[auth.tenantId] = config;\n                        }\n                        return resolve(config.siteKey);\n                    }\n                })\n                    .catch(error => {\n                    reject(error);\n                });\n            });\n        }\n        function retrieveRecaptchaToken(siteKey, resolve, reject) {\n            const grecaptcha = window.grecaptcha;\n            if (isEnterprise(grecaptcha)) {\n                grecaptcha.enterprise.ready(() => {\n                    grecaptcha.enterprise\n                        .execute(siteKey, { action })\n                        .then(token => {\n                        resolve(token);\n                    })\n                        .catch(() => {\n                        resolve(FAKE_TOKEN);\n                    });\n                });\n            }\n            else {\n                reject(Error('No reCAPTCHA enterprise script loaded.'));\n            }\n        }\n        // Returns Promise for a mock token when appVerificationDisabledForTesting is true.\n        if (this.auth.settings.appVerificationDisabledForTesting) {\n            const mockRecaptcha = new MockGreCAPTCHATopLevel();\n            return mockRecaptcha.execute('siteKey', { action: 'verify' });\n        }\n        return new Promise((resolve, reject) => {\n            retrieveSiteKey(this.auth)\n                .then(siteKey => {\n                if (!forceRefresh && isEnterprise(window.grecaptcha)) {\n                    retrieveRecaptchaToken(siteKey, resolve, reject);\n                }\n                else {\n                    if (typeof window === 'undefined') {\n                        reject(new Error('RecaptchaVerifier is only supported in browser'));\n                        return;\n                    }\n                    let url = _recaptchaEnterpriseScriptUrl();\n                    if (url.length !== 0) {\n                        url += siteKey;\n                    }\n                    _loadJS(url)\n                        .then(() => {\n                        retrieveRecaptchaToken(siteKey, resolve, reject);\n                    })\n                        .catch(error => {\n                        reject(error);\n                    });\n                }\n            })\n                .catch(error => {\n                reject(error);\n            });\n        });\n    }\n}\nasync function injectRecaptchaFields(auth, request, action, isCaptchaResp = false, isFakeToken = false) {\n    const verifier = new RecaptchaEnterpriseVerifier(auth);\n    let captchaResponse;\n    if (isFakeToken) {\n        captchaResponse = FAKE_TOKEN;\n    }\n    else {\n        try {\n            captchaResponse = await verifier.verify(action);\n        }\n        catch (error) {\n            captchaResponse = await verifier.verify(action, true);\n        }\n    }\n    const newRequest = Object.assign({}, request);\n    if (action === \"mfaSmsEnrollment\" /* RecaptchaActionName.MFA_SMS_ENROLLMENT */ ||\n        action === \"mfaSmsSignIn\" /* RecaptchaActionName.MFA_SMS_SIGNIN */) {\n        if ('phoneEnrollmentInfo' in newRequest) {\n            const phoneNumber = newRequest.phoneEnrollmentInfo.phoneNumber;\n            const recaptchaToken = newRequest.phoneEnrollmentInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneEnrollmentInfo': {\n                    phoneNumber,\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        else if ('phoneSignInInfo' in newRequest) {\n            const recaptchaToken = newRequest.phoneSignInInfo.recaptchaToken;\n            Object.assign(newRequest, {\n                'phoneSignInInfo': {\n                    recaptchaToken,\n                    captchaResponse,\n                    'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n                    'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n                }\n            });\n        }\n        return newRequest;\n    }\n    if (!isCaptchaResp) {\n        Object.assign(newRequest, { captchaResponse });\n    }\n    else {\n        Object.assign(newRequest, { 'captchaResp': captchaResponse });\n    }\n    Object.assign(newRequest, { 'clientType': \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */ });\n    Object.assign(newRequest, {\n        'recaptchaVersion': \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    return newRequest;\n}\nasync function handleRecaptchaFlow(authInstance, request, actionName, actionMethod, recaptchaAuthProvider) {\n    var _a, _b;\n    if (recaptchaAuthProvider === \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */) {\n        if ((_a = authInstance\n            ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.isProviderEnabled(\"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n            return actionMethod(authInstance, requestWithRecaptcha);\n        }\n        else {\n            return actionMethod(authInstance, request).catch(async (error) => {\n                if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}`) {\n                    console.log(`${actionName} is protected by reCAPTCHA Enterprise for this project. Automatically triggering the reCAPTCHA flow and restarting the flow.`);\n                    const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName, actionName === \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */);\n                    return actionMethod(authInstance, requestWithRecaptcha);\n                }\n                else {\n                    return Promise.reject(error);\n                }\n            });\n        }\n    }\n    else if (recaptchaAuthProvider === \"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */) {\n        if ((_b = authInstance\n            ._getRecaptchaConfig()) === null || _b === void 0 ? void 0 : _b.isProviderEnabled(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) {\n            const requestWithRecaptcha = await injectRecaptchaFields(authInstance, request, actionName);\n            return actionMethod(authInstance, requestWithRecaptcha).catch(async (error) => {\n                var _a;\n                if (((_a = authInstance\n                    ._getRecaptchaConfig()) === null || _a === void 0 ? void 0 : _a.getProviderEnforcementState(\"PHONE_PROVIDER\" /* RecaptchaAuthProvider.PHONE_PROVIDER */)) === \"AUDIT\" /* EnforcementState.AUDIT */) {\n                    // AUDIT mode\n                    if (error.code === `auth/${\"missing-recaptcha-token\" /* AuthErrorCode.MISSING_RECAPTCHA_TOKEN */}` ||\n                        error.code === `auth/${\"invalid-app-credential\" /* AuthErrorCode.INVALID_APP_CREDENTIAL */}`) {\n                        console.log(`Failed to verify with reCAPTCHA Enterprise. Automatically triggering the reCAPTCHA v2 flow to complete the ${actionName} flow.`);\n                        // reCAPTCHA Enterprise token is missing or reCAPTCHA Enterprise token\n                        // check fails.\n                        // Fallback to reCAPTCHA v2 flow.\n                        const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n                        true // isFakeToken\n                        );\n                        // This will call the PhoneApiCaller to fetch and inject reCAPTCHA v2 token.\n                        return actionMethod(authInstance, requestWithRecaptchaFields);\n                    }\n                }\n                // ENFORCE mode or AUDIT mode with any other error.\n                return Promise.reject(error);\n            });\n        }\n        else {\n            // Do reCAPTCHA v2 flow.\n            const requestWithRecaptchaFields = await injectRecaptchaFields(authInstance, request, actionName, false, // isCaptchaResp\n            true // isFakeToken\n            );\n            // This will call the PhoneApiCaller to fetch and inject v2 token.\n            return actionMethod(authInstance, requestWithRecaptchaFields);\n        }\n    }\n    else {\n        return Promise.reject(recaptchaAuthProvider + ' provider is not supported.');\n    }\n}\nasync function _initializeRecaptchaConfig(auth) {\n    const authInternal = _castAuth(auth);\n    const response = await getRecaptchaConfig(authInternal, {\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */,\n        version: \"RECAPTCHA_ENTERPRISE\" /* RecaptchaVersion.ENTERPRISE */\n    });\n    const config = new RecaptchaConfig(response);\n    if (authInternal.tenantId == null) {\n        authInternal._agentRecaptchaConfig = config;\n    }\n    else {\n        authInternal._tenantRecaptchaConfigs[authInternal.tenantId] = config;\n    }\n    if (config.isAnyProviderEnabled()) {\n        const verifier = new RecaptchaEnterpriseVerifier(authInternal);\n        void verifier.verify();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Initializes an {@link Auth} instance with fine-grained control over\n * {@link Dependencies}.\n *\n * @remarks\n *\n * This function allows more control over the {@link Auth} instance than\n * {@link getAuth}. `getAuth` uses platform-specific defaults to supply\n * the {@link Dependencies}. In general, `getAuth` is the easiest way to\n * initialize Auth and works for most use cases. Use `initializeAuth` if you\n * need control over which persistence layer is used, or to minimize bundle\n * size if you're not using either `signInWithPopup` or `signInWithRedirect`.\n *\n * For example, if your app only uses anonymous accounts and you only want\n * accounts saved for the current session, initialize `Auth` with:\n *\n * ```js\n * const auth = initializeAuth(app, {\n *   persistence: browserSessionPersistence,\n *   popupRedirectResolver: undefined,\n * });\n * ```\n *\n * @public\n */\nfunction initializeAuth(app, deps) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\n    if (provider.isInitialized()) {\n        const auth = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {\n            return auth;\n        }\n        else {\n            _fail(auth, \"already-initialized\" /* AuthErrorCode.ALREADY_INITIALIZED */);\n        }\n    }\n    const auth = provider.initialize({ options: deps });\n    return auth;\n}\nfunction _initializeAuthInstance(auth, deps) {\n    const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];\n    const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);\n    if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {\n        auth._updateErrorMap(deps.errorMap);\n    }\n    // This promise is intended to float; auth initialization happens in the\n    // background, meanwhile the auth object may be used by the app.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);\n}\n\n/**\n * Changes the {@link Auth} instance to communicate with the Firebase Auth Emulator, instead of production\n * Firebase Auth services.\n *\n * @remarks\n * This must be called synchronously immediately following the first call to\n * {@link initializeAuth}.  Do not use with production credentials as emulator\n * traffic is not encrypted.\n *\n *\n * @example\n * ```javascript\n * connectAuthEmulator(auth, 'http://127.0.0.1:9099', { disableWarnings: true });\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param url - The URL at which the emulator is running (eg, 'http://localhost:9099').\n * @param options - Optional. `options.disableWarnings` defaults to `false`. Set it to\n * `true` to disable the warning banner attached to the DOM.\n *\n * @public\n */\nfunction connectAuthEmulator(auth, url, options) {\n    const authInternal = _castAuth(auth);\n    _assert(authInternal._canInitEmulator, authInternal, \"emulator-config-failed\" /* AuthErrorCode.EMULATOR_CONFIG_FAILED */);\n    _assert(/^https?:\\/\\//.test(url), authInternal, \"invalid-emulator-scheme\" /* AuthErrorCode.INVALID_EMULATOR_SCHEME */);\n    const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);\n    const protocol = extractProtocol(url);\n    const { host, port } = extractHostAndPort(url);\n    const portStr = port === null ? '' : `:${port}`;\n    // Always replace path with \"/\" (even if input url had no path at all, or had a different one).\n    authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };\n    authInternal.settings.appVerificationDisabledForTesting = true;\n    authInternal.emulatorConfig = Object.freeze({\n        host,\n        port,\n        protocol: protocol.replace(':', ''),\n        options: Object.freeze({ disableWarnings })\n    });\n    if (!disableWarnings) {\n        emitEmulatorWarning();\n    }\n}\nfunction extractProtocol(url) {\n    const protocolEnd = url.indexOf(':');\n    return protocolEnd < 0 ? '' : url.substr(0, protocolEnd + 1);\n}\nfunction extractHostAndPort(url) {\n    const protocol = extractProtocol(url);\n    const authority = /(\\/\\/)?([^?#/]+)/.exec(url.substr(protocol.length)); // Between // and /, ? or #.\n    if (!authority) {\n        return { host: '', port: null };\n    }\n    const hostAndPort = authority[2].split('@').pop() || ''; // Strip out \"username:password@\".\n    const bracketedIPv6 = /^(\\[[^\\]]+\\])(:|$)/.exec(hostAndPort);\n    if (bracketedIPv6) {\n        const host = bracketedIPv6[1];\n        return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };\n    }\n    else {\n        const [host, port] = hostAndPort.split(':');\n        return { host, port: parsePort(port) };\n    }\n}\nfunction parsePort(portStr) {\n    if (!portStr) {\n        return null;\n    }\n    const port = Number(portStr);\n    if (isNaN(port)) {\n        return null;\n    }\n    return port;\n}\nfunction emitEmulatorWarning() {\n    function attachBanner() {\n        const el = document.createElement('p');\n        const sty = el.style;\n        el.innerText =\n            'Running in emulator mode. Do not use with production credentials.';\n        sty.position = 'fixed';\n        sty.width = '100%';\n        sty.backgroundColor = '#ffffff';\n        sty.border = '.1em solid #000000';\n        sty.color = '#b50000';\n        sty.bottom = '0px';\n        sty.left = '0px';\n        sty.margin = '0px';\n        sty.zIndex = '10000';\n        sty.textAlign = 'center';\n        el.classList.add('firebase-emulator-warning');\n        document.body.appendChild(el);\n    }\n    if (typeof console !== 'undefined' && typeof console.info === 'function') {\n        console.info('WARNING: You are using the Auth Emulator,' +\n            ' which is intended for local testing only.  Do not use with' +\n            ' production credentials.');\n    }\n    if (typeof window !== 'undefined' && typeof document !== 'undefined') {\n        if (document.readyState === 'loading') {\n            window.addEventListener('DOMContentLoaded', attachBanner);\n        }\n        else {\n            attachBanner();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by an {@link AuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass AuthCredential {\n    /** @internal */\n    constructor(\n    /**\n     * The authentication provider ID for the credential.\n     *\n     * @remarks\n     * For example, 'facebook.com', or 'google.com'.\n     */\n    providerId, \n    /**\n     * The authentication sign in method for the credential.\n     *\n     * @remarks\n     * For example, {@link SignInMethod}.EMAIL_PASSWORD, or\n     * {@link SignInMethod}.EMAIL_LINK. This corresponds to the sign-in method\n     * identifier as returned in {@link fetchSignInMethodsForEmail}.\n     */\n    signInMethod) {\n        this.providerId = providerId;\n        this.signInMethod = signInMethod;\n    }\n    /**\n     * Returns a JSON-serializable representation of this object.\n     *\n     * @returns a JSON-serializable representation of this object.\n     */\n    toJSON() {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getIdTokenResponse(_auth) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _linkToIdToken(_auth, _idToken) {\n        return debugFail('not implemented');\n    }\n    /** @internal */\n    _getReauthenticationResolver(_auth) {\n        return debugFail('not implemented');\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function resetPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:resetPassword\" /* Endpoint.RESET_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function updateEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n// Used for linking an email/password account to an existing idToken. Uses the same request/response\n// format as updateEmailPassword.\nasync function linkEmailPassword(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, request);\n}\nasync function applyActionCode$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPassword(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPassword\" /* Endpoint.SIGN_IN_WITH_PASSWORD */, _addTidIfNecessary(auth, request));\n}\nasync function sendOobCode(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:sendOobCode\" /* Endpoint.SEND_OOB_CODE */, _addTidIfNecessary(auth, request));\n}\nasync function sendEmailVerification$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendPasswordResetEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function sendSignInLinkToEmail$1(auth, request) {\n    return sendOobCode(auth, request);\n}\nasync function verifyAndChangeEmail(auth, request) {\n    return sendOobCode(auth, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithEmailLink$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\nasync function signInWithEmailLinkForLinking(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithEmailLink\" /* Endpoint.SIGN_IN_WITH_EMAIL_LINK */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Interface that represents the credentials returned by {@link EmailAuthProvider} for\n * {@link ProviderId}.PASSWORD\n *\n * @remarks\n * Covers both {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @public\n */\nclass EmailAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(\n    /** @internal */\n    _email, \n    /** @internal */\n    _password, signInMethod, \n    /** @internal */\n    _tenantId = null) {\n        super(\"password\" /* ProviderId.PASSWORD */, signInMethod);\n        this._email = _email;\n        this._password = _password;\n        this._tenantId = _tenantId;\n    }\n    /** @internal */\n    static _fromEmailAndPassword(email, password) {\n        return new EmailAuthCredential(email, password, \"password\" /* SignInMethod.EMAIL_PASSWORD */);\n    }\n    /** @internal */\n    static _fromEmailAndCode(email, oobCode, tenantId = null) {\n        return new EmailAuthCredential(email, oobCode, \"emailLink\" /* SignInMethod.EMAIL_LINK */, tenantId);\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        return {\n            email: this._email,\n            password: this._password,\n            signInMethod: this.signInMethod,\n            tenantId: this._tenantId\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an {@link  AuthCredential}.\n     *\n     * @param json - Either `object` or the stringified representation of the object. When string is\n     * provided, `JSON.parse` would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {\n            if (obj.signInMethod === \"password\" /* SignInMethod.EMAIL_PASSWORD */) {\n                return this._fromEmailAndPassword(obj.email, obj.password);\n            }\n            else if (obj.signInMethod === \"emailLink\" /* SignInMethod.EMAIL_LINK */) {\n                return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);\n            }\n        }\n        return null;\n    }\n    /** @internal */\n    async _getIdTokenResponse(auth) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signInWithPassword\" /* RecaptchaActionName.SIGN_IN_WITH_PASSWORD */, signInWithPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLink$1(auth, {\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    async _linkToIdToken(auth, idToken) {\n        switch (this.signInMethod) {\n            case \"password\" /* SignInMethod.EMAIL_PASSWORD */:\n                const request = {\n                    idToken,\n                    returnSecureToken: true,\n                    email: this._email,\n                    password: this._password,\n                    clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n                };\n                return handleRecaptchaFlow(auth, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, linkEmailPassword, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n            case \"emailLink\" /* SignInMethod.EMAIL_LINK */:\n                return signInWithEmailLinkForLinking(auth, {\n                    idToken,\n                    email: this._email,\n                    oobCode: this._password\n                });\n            default:\n                _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        }\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return this._getIdTokenResponse(auth);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithIdp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithIdp\" /* Endpoint.SIGN_IN_WITH_IDP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI$1 = 'http://localhost';\n/**\n * Represents the OAuth credentials returned by an {@link OAuthProvider}.\n *\n * @remarks\n * Implementations specify the details about each auth provider's credential requirements.\n *\n * @public\n */\nclass OAuthCredential extends AuthCredential {\n    constructor() {\n        super(...arguments);\n        this.pendingToken = null;\n    }\n    /** @internal */\n    static _fromParams(params) {\n        const cred = new OAuthCredential(params.providerId, params.signInMethod);\n        if (params.idToken || params.accessToken) {\n            // OAuth 2 and either ID token or access token.\n            if (params.idToken) {\n                cred.idToken = params.idToken;\n            }\n            if (params.accessToken) {\n                cred.accessToken = params.accessToken;\n            }\n            // Add nonce if available and no pendingToken is present.\n            if (params.nonce && !params.pendingToken) {\n                cred.nonce = params.nonce;\n            }\n            if (params.pendingToken) {\n                cred.pendingToken = params.pendingToken;\n            }\n        }\n        else if (params.oauthToken && params.oauthTokenSecret) {\n            // OAuth 1 and OAuth token with token secret\n            cred.accessToken = params.oauthToken;\n            cred.secret = params.oauthTokenSecret;\n        }\n        else {\n            _fail(\"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        }\n        return cred;\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            idToken: this.idToken,\n            accessToken: this.accessToken,\n            secret: this.secret,\n            nonce: this.nonce,\n            pendingToken: this.pendingToken,\n            providerId: this.providerId,\n            signInMethod: this.signInMethod\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod } = obj, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(obj, [\"providerId\", \"signInMethod\"]);\n        if (!providerId || !signInMethod) {\n            return null;\n        }\n        const cred = new OAuthCredential(providerId, signInMethod);\n        cred.idToken = rest.idToken || undefined;\n        cred.accessToken = rest.accessToken || undefined;\n        cred.secret = rest.secret;\n        cred.nonce = rest.nonce;\n        cred.pendingToken = rest.pendingToken || null;\n        return cred;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    buildRequest() {\n        const request = {\n            requestUri: IDP_REQUEST_URI$1,\n            returnSecureToken: true\n        };\n        if (this.pendingToken) {\n            request.pendingToken = this.pendingToken;\n        }\n        else {\n            const postBody = {};\n            if (this.idToken) {\n                postBody['id_token'] = this.idToken;\n            }\n            if (this.accessToken) {\n                postBody['access_token'] = this.accessToken;\n            }\n            if (this.secret) {\n                postBody['oauth_token_secret'] = this.secret;\n            }\n            postBody['providerId'] = this.providerId;\n            if (this.nonce && !this.pendingToken) {\n                postBody['nonce'] = this.nonce;\n            }\n            request.postBody = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystring)(postBody);\n        }\n        return request;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithPhoneNumber$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n}\nasync function linkWithPhoneNumber$1(auth, request) {\n    const response = await _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, request));\n    if (response.temporaryProof) {\n        throw _makeTaggedError(auth, \"account-exists-with-different-credential\" /* AuthErrorCode.NEED_CONFIRMATION */, response);\n    }\n    return response;\n}\nconst VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_ = {\n    [\"USER_NOT_FOUND\" /* ServerError.USER_NOT_FOUND */]: \"user-not-found\" /* AuthErrorCode.USER_DELETED */\n};\nasync function verifyPhoneNumberForExisting(auth, request) {\n    const apiRequest = Object.assign(Object.assign({}, request), { operation: 'REAUTH' });\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithPhoneNumber\" /* Endpoint.SIGN_IN_WITH_PHONE_NUMBER */, _addTidIfNecessary(auth, apiRequest), VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Represents the credentials returned by {@link PhoneAuthProvider}.\n *\n * @public\n */\nclass PhoneAuthCredential extends AuthCredential {\n    constructor(params) {\n        super(\"phone\" /* ProviderId.PHONE */, \"phone\" /* SignInMethod.PHONE */);\n        this.params = params;\n    }\n    /** @internal */\n    static _fromVerification(verificationId, verificationCode) {\n        return new PhoneAuthCredential({ verificationId, verificationCode });\n    }\n    /** @internal */\n    static _fromTokenResponse(phoneNumber, temporaryProof) {\n        return new PhoneAuthCredential({ phoneNumber, temporaryProof });\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        return signInWithPhoneNumber$1(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        return linkWithPhoneNumber$1(auth, Object.assign({ idToken }, this._makeVerificationRequest()));\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        return verifyPhoneNumberForExisting(auth, this._makeVerificationRequest());\n    }\n    /** @internal */\n    _makeVerificationRequest() {\n        const { temporaryProof, phoneNumber, verificationId, verificationCode } = this.params;\n        if (temporaryProof && phoneNumber) {\n            return { temporaryProof, phoneNumber };\n        }\n        return {\n            sessionInfo: verificationId,\n            code: verificationCode\n        };\n    }\n    /** {@inheritdoc AuthCredential.toJSON} */\n    toJSON() {\n        const obj = {\n            providerId: this.providerId\n        };\n        if (this.params.phoneNumber) {\n            obj.phoneNumber = this.params.phoneNumber;\n        }\n        if (this.params.temporaryProof) {\n            obj.temporaryProof = this.params.temporaryProof;\n        }\n        if (this.params.verificationCode) {\n            obj.verificationCode = this.params.verificationCode;\n        }\n        if (this.params.verificationId) {\n            obj.verificationId = this.params.verificationId;\n        }\n        return obj;\n    }\n    /** Generates a phone credential based on a plain object or a JSON string. */\n    static fromJSON(json) {\n        if (typeof json === 'string') {\n            json = JSON.parse(json);\n        }\n        const { verificationId, verificationCode, phoneNumber, temporaryProof } = json;\n        if (!verificationCode &&\n            !verificationId &&\n            !phoneNumber &&\n            !temporaryProof) {\n            return null;\n        }\n        return new PhoneAuthCredential({\n            verificationId,\n            verificationCode,\n            phoneNumber,\n            temporaryProof\n        });\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Maps the mode string in action code URL to Action Code Info operation.\n *\n * @param mode\n */\nfunction parseMode(mode) {\n    switch (mode) {\n        case 'recoverEmail':\n            return \"RECOVER_EMAIL\" /* ActionCodeOperation.RECOVER_EMAIL */;\n        case 'resetPassword':\n            return \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */;\n        case 'signIn':\n            return \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n        case 'verifyEmail':\n            return \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */;\n        case 'verifyAndChangeEmail':\n            return \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */;\n        case 'revertSecondFactorAddition':\n            return \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */;\n        default:\n            return null;\n    }\n}\n/**\n * Helper to parse FDL links\n *\n * @param url\n */\nfunction parseDeepLink(url) {\n    const link = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['link'];\n    // Double link case (automatic redirect).\n    const doubleDeepLink = link\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(link))['deep_link_id']\n        : null;\n    // iOS custom scheme links.\n    const iOSDeepLink = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(url))['deep_link_id'];\n    const iOSDoubleDeepLink = iOSDeepLink\n        ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(iOSDeepLink))['link']\n        : null;\n    return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;\n}\n/**\n * A utility class to parse email action URLs such as password reset, email verification,\n * email link sign in, etc.\n *\n * @public\n */\nclass ActionCodeURL {\n    /**\n     * @param actionLink - The link from which to extract the URL.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @internal\n     */\n    constructor(actionLink) {\n        var _a, _b, _c, _d, _e, _f;\n        const searchParams = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.querystringDecode)((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.extractQuerystring)(actionLink));\n        const apiKey = (_a = searchParams[\"apiKey\" /* QueryField.API_KEY */]) !== null && _a !== void 0 ? _a : null;\n        const code = (_b = searchParams[\"oobCode\" /* QueryField.CODE */]) !== null && _b !== void 0 ? _b : null;\n        const operation = parseMode((_c = searchParams[\"mode\" /* QueryField.MODE */]) !== null && _c !== void 0 ? _c : null);\n        // Validate API key, code and mode.\n        _assert(apiKey && code && operation, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        this.apiKey = apiKey;\n        this.operation = operation;\n        this.code = code;\n        this.continueUrl = (_d = searchParams[\"continueUrl\" /* QueryField.CONTINUE_URL */]) !== null && _d !== void 0 ? _d : null;\n        this.languageCode = (_e = searchParams[\"languageCode\" /* QueryField.LANGUAGE_CODE */]) !== null && _e !== void 0 ? _e : null;\n        this.tenantId = (_f = searchParams[\"tenantId\" /* QueryField.TENANT_ID */]) !== null && _f !== void 0 ? _f : null;\n    }\n    /**\n     * Parses the email action link string and returns an {@link ActionCodeURL} if the link is valid,\n     * otherwise returns null.\n     *\n     * @param link  - The email action link string.\n     * @returns The {@link ActionCodeURL} object, or null if the link is invalid.\n     *\n     * @public\n     */\n    static parseLink(link) {\n        const actionLink = parseDeepLink(link);\n        try {\n            return new ActionCodeURL(actionLink);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/**\n * Parses the email action link string and returns an {@link ActionCodeURL} if\n * the link is valid, otherwise returns null.\n *\n * @public\n */\nfunction parseActionCodeURL(link) {\n    return ActionCodeURL.parseLink(link);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating {@link EmailAuthCredential}.\n *\n * @public\n */\nclass EmailAuthProvider {\n    constructor() {\n        /**\n         * Always set to {@link ProviderId}.PASSWORD, even for email link.\n         */\n        this.providerId = EmailAuthProvider.PROVIDER_ID;\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and password.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credential(email, password);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * const userCredential = await signInWithEmailAndPassword(auth, email, password);\n     * ```\n     *\n     * @param email - Email address.\n     * @param password - User account password.\n     * @returns The auth provider credential.\n     */\n    static credential(email, password) {\n        return EmailAuthCredential._fromEmailAndPassword(email, password);\n    }\n    /**\n     * Initialize an {@link AuthCredential} using an email and an email link after a sign in with\n     * email link operation.\n     *\n     * @example\n     * ```javascript\n     * const authCredential = EmailAuthProvider.credentialWithLink(auth, email, emailLink);\n     * const userCredential = await signInWithCredential(auth, authCredential);\n     * ```\n     *\n     * @example\n     * ```javascript\n     * await sendSignInLinkToEmail(auth, email);\n     * // Obtain emailLink from user.\n     * const userCredential = await signInWithEmailLink(auth, email, emailLink);\n     * ```\n     *\n     * @param auth - The {@link Auth} instance used to verify the link.\n     * @param email - Email address.\n     * @param emailLink - Sign-in email link.\n     * @returns - The auth provider credential.\n     */\n    static credentialWithLink(email, emailLink) {\n        const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n        _assert(actionCodeUrl, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);\n    }\n}\n/**\n * Always set to {@link ProviderId}.PASSWORD, even for email link.\n */\nEmailAuthProvider.PROVIDER_ID = \"password\" /* ProviderId.PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_PASSWORD.\n */\nEmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = \"password\" /* SignInMethod.EMAIL_PASSWORD */;\n/**\n * Always set to {@link SignInMethod}.EMAIL_LINK.\n */\nEmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = \"emailLink\" /* SignInMethod.EMAIL_LINK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The base class for all Federated providers (OAuth (including OIDC), SAML).\n *\n * This class is not meant to be instantiated directly.\n *\n * @public\n */\nclass FederatedAuthProvider {\n    /**\n     * Constructor for generic OAuth providers.\n     *\n     * @param providerId - Provider for which credentials should be generated.\n     */\n    constructor(providerId) {\n        this.providerId = providerId;\n        /** @internal */\n        this.defaultLanguageCode = null;\n        /** @internal */\n        this.customParameters = {};\n    }\n    /**\n     * Set the language gode.\n     *\n     * @param languageCode - language code\n     */\n    setDefaultLanguage(languageCode) {\n        this.defaultLanguageCode = languageCode;\n    }\n    /**\n     * Sets the OAuth custom parameters to pass in an OAuth request for popup and redirect sign-in\n     * operations.\n     *\n     * @remarks\n     * For a detailed list, check the reserved required OAuth 2.0 parameters such as `client_id`,\n     * `redirect_uri`, `scope`, `response_type`, and `state` are not allowed and will be ignored.\n     *\n     * @param customOAuthParameters - The custom OAuth parameters to pass in the OAuth request.\n     */\n    setCustomParameters(customOAuthParameters) {\n        this.customParameters = customOAuthParameters;\n        return this;\n    }\n    /**\n     * Retrieve the current list of {@link CustomParameters}.\n     */\n    getCustomParameters() {\n        return this.customParameters;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Common code to all OAuth providers. This is separate from the\n * {@link OAuthProvider} so that child providers (like\n * {@link GoogleAuthProvider}) don't inherit the `credential` instance method.\n * Instead, they rely on a static `credential` method.\n */\nclass BaseOAuthProvider extends FederatedAuthProvider {\n    constructor() {\n        super(...arguments);\n        /** @internal */\n        this.scopes = [];\n    }\n    /**\n     * Add an OAuth scope to the credential.\n     *\n     * @param scope - Provider OAuth scope to add.\n     */\n    addScope(scope) {\n        // If not already added, add scope to list.\n        if (!this.scopes.includes(scope)) {\n            this.scopes.push(scope);\n        }\n        return this;\n    }\n    /**\n     * Retrieve the current list of OAuth scopes.\n     */\n    getScopes() {\n        return [...this.scopes];\n    }\n}\n/**\n * Provider for generating generic {@link OAuthCredential}.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new OAuthProvider('google.com');\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a OAuth Access Token for the provider.\n *   const credential = provider.credentialFromResult(auth, result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new OAuthProvider('google.com');\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a OAuth Access Token for the provider.\n * const credential = provider.credentialFromResult(auth, result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass OAuthProvider extends BaseOAuthProvider {\n    /**\n     * Creates an {@link OAuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        _assert('providerId' in obj && 'signInMethod' in obj, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return OAuthCredential._fromParams(obj);\n    }\n    /**\n     * Creates a {@link OAuthCredential} from a generic OAuth provider's access token or ID token.\n     *\n     * @remarks\n     * The raw nonce is required when an ID token with a nonce field is provided. The SHA-256 hash of\n     * the raw nonce must match the nonce field in the ID token.\n     *\n     * @example\n     * ```javascript\n     * // `googleUser` from the onsuccess Google Sign In callback.\n     * // Initialize a generate OAuth provider with a `google.com` providerId.\n     * const provider = new OAuthProvider('google.com');\n     * const credential = provider.credential({\n     *   idToken: googleUser.getAuthResponse().id_token,\n     * });\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param params - Either the options object containing the ID token, access token and raw nonce\n     * or the ID token string.\n     */\n    credential(params) {\n        return this._credential(Object.assign(Object.assign({}, params), { nonce: params.rawNonce }));\n    }\n    /** An internal credential method that accepts more permissive options */\n    _credential(params) {\n        _assert(params.idToken || params.accessToken, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        // For OAuthCredential, sign in method is same as providerId.\n        return OAuthCredential._fromParams(Object.assign(Object.assign({}, params), { providerId: this.providerId, signInMethod: this.providerId }));\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return OAuthProvider.oauthCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return OAuthProvider.oauthCredentialFromTaggedObject((error.customData || {}));\n    }\n    static oauthCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken, oauthTokenSecret, pendingToken, nonce, providerId } = tokenResponse;\n        if (!oauthAccessToken &&\n            !oauthTokenSecret &&\n            !oauthIdToken &&\n            !pendingToken) {\n            return null;\n        }\n        if (!providerId) {\n            return null;\n        }\n        try {\n            return new OAuthProvider(providerId)._credential({\n                idToken: oauthIdToken,\n                accessToken: oauthAccessToken,\n                nonce,\n                pendingToken\n            });\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.FACEBOOK.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new FacebookAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('user_birthday');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Facebook Access Token.\n *   const credential = FacebookAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new FacebookAuthProvider();\n * provider.addScope('user_birthday');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Facebook Access Token.\n * const credential = FacebookAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass FacebookAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"facebook.com\" /* ProviderId.FACEBOOK */);\n    }\n    /**\n     * Creates a credential for Facebook.\n     *\n     * @example\n     * ```javascript\n     * // `event` from the Facebook auth.authResponseChange callback.\n     * const credential = FacebookAuthProvider.credential(event.authResponse.accessToken);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param accessToken - Facebook access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: FacebookAuthProvider.PROVIDER_ID,\n            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return FacebookAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return FacebookAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.FACEBOOK. */\nFacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = \"facebook.com\" /* SignInMethod.FACEBOOK */;\n/** Always set to {@link ProviderId}.FACEBOOK. */\nFacebookAuthProvider.PROVIDER_ID = \"facebook.com\" /* ProviderId.FACEBOOK */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GOOGLE.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GoogleAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('profile');\n * provider.addScope('email');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Google Access Token.\n *   const credential = GoogleAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GoogleAuthProvider();\n * provider.addScope('profile');\n * provider.addScope('email');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Google Access Token.\n * const credential = GoogleAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n *\n * @public\n */\nclass GoogleAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"google.com\" /* ProviderId.GOOGLE */);\n        this.addScope('profile');\n    }\n    /**\n     * Creates a credential for Google. At least one of ID token and access token is required.\n     *\n     * @example\n     * ```javascript\n     * // \\`googleUser\\` from the onsuccess Google Sign In callback.\n     * const credential = GoogleAuthProvider.credential(googleUser.getAuthResponse().id_token);\n     * const result = await signInWithCredential(credential);\n     * ```\n     *\n     * @param idToken - Google ID token.\n     * @param accessToken - Google access token.\n     */\n    static credential(idToken, accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GoogleAuthProvider.PROVIDER_ID,\n            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,\n            idToken,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GoogleAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GoogleAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthIdToken, oauthAccessToken } = tokenResponse;\n        if (!oauthIdToken && !oauthAccessToken) {\n            // This could be an oauth 1 credential or a phone credential\n            return null;\n        }\n        try {\n            return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GOOGLE. */\nGoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = \"google.com\" /* SignInMethod.GOOGLE */;\n/** Always set to {@link ProviderId}.GOOGLE. */\nGoogleAuthProvider.PROVIDER_ID = \"google.com\" /* ProviderId.GOOGLE */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.GITHUB.\n *\n * @remarks\n * GitHub requires an OAuth 2.0 redirect, so you can either handle the redirect directly, or use\n * the {@link signInWithPopup} handler:\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new GithubAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * provider.addScope('repo');\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a GitHub Access Token.\n *   const credential = GithubAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new GithubAuthProvider();\n * provider.addScope('repo');\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a GitHub Access Token.\n * const credential = GithubAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * ```\n * @public\n */\nclass GithubAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"github.com\" /* ProviderId.GITHUB */);\n    }\n    /**\n     * Creates a credential for GitHub.\n     *\n     * @param accessToken - GitHub access token.\n     */\n    static credential(accessToken) {\n        return OAuthCredential._fromParams({\n            providerId: GithubAuthProvider.PROVIDER_ID,\n            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,\n            accessToken\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return GithubAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return GithubAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse || !('oauthAccessToken' in tokenResponse)) {\n            return null;\n        }\n        if (!tokenResponse.oauthAccessToken) {\n            return null;\n        }\n        try {\n            return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.GITHUB. */\nGithubAuthProvider.GITHUB_SIGN_IN_METHOD = \"github.com\" /* SignInMethod.GITHUB */;\n/** Always set to {@link ProviderId}.GITHUB. */\nGithubAuthProvider.PROVIDER_ID = \"github.com\" /* ProviderId.GITHUB */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst IDP_REQUEST_URI = 'http://localhost';\n/**\n * @public\n */\nclass SAMLAuthCredential extends AuthCredential {\n    /** @internal */\n    constructor(providerId, pendingToken) {\n        super(providerId, providerId);\n        this.pendingToken = pendingToken;\n    }\n    /** @internal */\n    _getIdTokenResponse(auth) {\n        const request = this.buildRequest();\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _linkToIdToken(auth, idToken) {\n        const request = this.buildRequest();\n        request.idToken = idToken;\n        return signInWithIdp(auth, request);\n    }\n    /** @internal */\n    _getReauthenticationResolver(auth) {\n        const request = this.buildRequest();\n        request.autoCreate = false;\n        return signInWithIdp(auth, request);\n    }\n    /** {@inheritdoc AuthCredential.toJSON}  */\n    toJSON() {\n        return {\n            signInMethod: this.signInMethod,\n            providerId: this.providerId,\n            pendingToken: this.pendingToken\n        };\n    }\n    /**\n     * Static method to deserialize a JSON representation of an object into an\n     * {@link  AuthCredential}.\n     *\n     * @param json - Input can be either Object or the stringified representation of the object.\n     * When string is provided, JSON.parse would be called first.\n     *\n     * @returns If the JSON input does not represent an {@link  AuthCredential}, null is returned.\n     */\n    static fromJSON(json) {\n        const obj = typeof json === 'string' ? JSON.parse(json) : json;\n        const { providerId, signInMethod, pendingToken } = obj;\n        if (!providerId ||\n            !signInMethod ||\n            !pendingToken ||\n            providerId !== signInMethod) {\n            return null;\n        }\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    /**\n     * Helper static method to avoid exposing the constructor to end users.\n     *\n     * @internal\n     */\n    static _create(providerId, pendingToken) {\n        return new SAMLAuthCredential(providerId, pendingToken);\n    }\n    buildRequest() {\n        return {\n            requestUri: IDP_REQUEST_URI,\n            returnSecureToken: true,\n            pendingToken: this.pendingToken\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst SAML_PROVIDER_PREFIX = 'saml.';\n/**\n * An {@link AuthProvider} for SAML.\n *\n * @public\n */\nclass SAMLAuthProvider extends FederatedAuthProvider {\n    /**\n     * Constructor. The providerId must start with \"saml.\"\n     * @param providerId - SAML provider ID.\n     */\n    constructor(providerId) {\n        _assert(providerId.startsWith(SAML_PROVIDER_PREFIX), \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        super(providerId);\n    }\n    /**\n     * Generates an {@link AuthCredential} from a {@link UserCredential} after a\n     * successful SAML flow completes.\n     *\n     * @remarks\n     *\n     * For example, to get an {@link AuthCredential}, you could write the\n     * following code:\n     *\n     * ```js\n     * const userCredential = await signInWithPopup(auth, samlProvider);\n     * const credential = SAMLAuthProvider.credentialFromResult(userCredential);\n     * ```\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return SAMLAuthProvider.samlCredentialFromTaggedObject((error.customData || {}));\n    }\n    /**\n     * Creates an {@link AuthCredential} from a JSON string or a plain object.\n     * @param json - A plain object or a JSON string\n     */\n    static credentialFromJSON(json) {\n        const credential = SAMLAuthCredential.fromJSON(json);\n        _assert(credential, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return credential;\n    }\n    static samlCredentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { pendingToken, providerId } = tokenResponse;\n        if (!pendingToken || !providerId) {\n            return null;\n        }\n        try {\n            return SAMLAuthCredential._create(providerId, pendingToken);\n        }\n        catch (e) {\n            return null;\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for generating an {@link OAuthCredential} for {@link ProviderId}.TWITTER.\n *\n * @example\n * ```javascript\n * // Sign in using a redirect.\n * const provider = new TwitterAuthProvider();\n * // Start a sign in process for an unauthenticated user.\n * await signInWithRedirect(auth, provider);\n * // This will trigger a full page redirect away from your app\n *\n * // After returning from the redirect when your app initializes you can obtain the result\n * const result = await getRedirectResult(auth);\n * if (result) {\n *   // This is the signed-in user\n *   const user = result.user;\n *   // This gives you a Twitter Access Token and Secret.\n *   const credential = TwitterAuthProvider.credentialFromResult(result);\n *   const token = credential.accessToken;\n *   const secret = credential.secret;\n * }\n * ```\n *\n * @example\n * ```javascript\n * // Sign in using a popup.\n * const provider = new TwitterAuthProvider();\n * const result = await signInWithPopup(auth, provider);\n *\n * // The signed-in user info.\n * const user = result.user;\n * // This gives you a Twitter Access Token and Secret.\n * const credential = TwitterAuthProvider.credentialFromResult(result);\n * const token = credential.accessToken;\n * const secret = credential.secret;\n * ```\n *\n * @public\n */\nclass TwitterAuthProvider extends BaseOAuthProvider {\n    constructor() {\n        super(\"twitter.com\" /* ProviderId.TWITTER */);\n    }\n    /**\n     * Creates a credential for Twitter.\n     *\n     * @param token - Twitter access token.\n     * @param secret - Twitter secret.\n     */\n    static credential(token, secret) {\n        return OAuthCredential._fromParams({\n            providerId: TwitterAuthProvider.PROVIDER_ID,\n            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,\n            oauthToken: token,\n            oauthTokenSecret: secret\n        });\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link UserCredential}.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromResult(userCredential) {\n        return TwitterAuthProvider.credentialFromTaggedObject(userCredential);\n    }\n    /**\n     * Used to extract the underlying {@link OAuthCredential} from a {@link AuthError} which was\n     * thrown during a sign-in, link, or reauthenticate operation.\n     *\n     * @param userCredential - The user credential.\n     */\n    static credentialFromError(error) {\n        return TwitterAuthProvider.credentialFromTaggedObject((error.customData || {}));\n    }\n    static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {\n        if (!tokenResponse) {\n            return null;\n        }\n        const { oauthAccessToken, oauthTokenSecret } = tokenResponse;\n        if (!oauthAccessToken || !oauthTokenSecret) {\n            return null;\n        }\n        try {\n            return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n}\n/** Always set to {@link SignInMethod}.TWITTER. */\nTwitterAuthProvider.TWITTER_SIGN_IN_METHOD = \"twitter.com\" /* SignInMethod.TWITTER */;\n/** Always set to {@link ProviderId}.TWITTER. */\nTwitterAuthProvider.PROVIDER_ID = \"twitter.com\" /* ProviderId.TWITTER */;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signUp(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signUp\" /* Endpoint.SIGN_UP */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass UserCredentialImpl {\n    constructor(params) {\n        this.user = params.user;\n        this.providerId = params.providerId;\n        this._tokenResponse = params._tokenResponse;\n        this.operationType = params.operationType;\n    }\n    static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {\n        const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);\n        const providerId = providerIdForResponse(idTokenResponse);\n        const userCred = new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: idTokenResponse,\n            operationType\n        });\n        return userCred;\n    }\n    static async _forOperation(user, operationType, response) {\n        await user._updateTokensIfNecessary(response, /* reload */ true);\n        const providerId = providerIdForResponse(response);\n        return new UserCredentialImpl({\n            user,\n            providerId,\n            _tokenResponse: response,\n            operationType\n        });\n    }\n}\nfunction providerIdForResponse(response) {\n    if (response.providerId) {\n        return response.providerId;\n    }\n    if ('phoneNumber' in response) {\n        return \"phone\" /* ProviderId.PHONE */;\n    }\n    return null;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in as an anonymous user.\n *\n * @remarks\n * If there is already an anonymous user signed in, that user will be returned; otherwise, a\n * new anonymous user identity will be created and returned.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nasync function signInAnonymously(auth) {\n    var _a;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    await authInternal._initializationPromise;\n    if ((_a = authInternal.currentUser) === null || _a === void 0 ? void 0 : _a.isAnonymous) {\n        // If an anonymous user is already signed in, no need to sign them in again.\n        return new UserCredentialImpl({\n            user: authInternal.currentUser,\n            providerId: null,\n            operationType: \"signIn\" /* OperationType.SIGN_IN */\n        });\n    }\n    const response = await signUp(authInternal, {\n        returnSecureToken: true\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response, true);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorError extends _firebase_util__WEBPACK_IMPORTED_MODULE_1__.FirebaseError {\n    constructor(auth, error, operationType, user) {\n        var _a;\n        super(error.code, error.message);\n        this.operationType = operationType;\n        this.user = user;\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, MultiFactorError.prototype);\n        this.customData = {\n            appName: auth.name,\n            tenantId: (_a = auth.tenantId) !== null && _a !== void 0 ? _a : undefined,\n            _serverResponse: error.customData._serverResponse,\n            operationType\n        };\n    }\n    static _fromErrorAndOperation(auth, error, operationType, user) {\n        return new MultiFactorError(auth, error, operationType, user);\n    }\n}\nfunction _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {\n    const idTokenProvider = operationType === \"reauthenticate\" /* OperationType.REAUTHENTICATE */\n        ? credential._getReauthenticationResolver(auth)\n        : credential._getIdTokenResponse(auth);\n    return idTokenProvider.catch(error => {\n        if (error.code === `auth/${\"multi-factor-auth-required\" /* AuthErrorCode.MFA_REQUIRED */}`) {\n            throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Takes a set of UserInfo provider data and converts it to a set of names\n */\nfunction providerDataAsNames(providerData) {\n    return new Set(providerData\n        .map(({ providerId }) => providerId)\n        .filter(pid => !!pid));\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Unlinks a provider from a user account.\n *\n * @param user - The user.\n * @param providerId - The provider to unlink.\n *\n * @public\n */\nasync function unlink(user, providerId) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(true, userInternal, providerId);\n    const { providerUserInfo } = await deleteLinkedAccounts(userInternal.auth, {\n        idToken: await userInternal.getIdToken(),\n        deleteProvider: [providerId]\n    });\n    const providersLeft = providerDataAsNames(providerUserInfo || []);\n    userInternal.providerData = userInternal.providerData.filter(pd => providersLeft.has(pd.providerId));\n    if (!providersLeft.has(\"phone\" /* ProviderId.PHONE */)) {\n        userInternal.phoneNumber = null;\n    }\n    await userInternal.auth._persistUserIfCurrent(userInternal);\n    return userInternal;\n}\nasync function _link(user, credential, bypassAuthState = false) {\n    const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);\n    return UserCredentialImpl._forOperation(user, \"link\" /* OperationType.LINK */, response);\n}\nasync function _assertLinkedStatus(expected, user, provider) {\n    await _reloadWithoutSaving(user);\n    const providerIds = providerDataAsNames(user.providerData);\n    const code = expected === false\n        ? \"provider-already-linked\" /* AuthErrorCode.PROVIDER_ALREADY_LINKED */\n        : \"no-such-provider\" /* AuthErrorCode.NO_SUCH_PROVIDER */;\n    _assert(providerIds.has(provider) === expected, user.auth, code);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _reauthenticate(user, credential, bypassAuthState = false) {\n    const { auth } = user;\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"reauthenticate\" /* OperationType.REAUTHENTICATE */;\n    try {\n        const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);\n        _assert(response.idToken, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const parsed = _parseToken(response.idToken);\n        _assert(parsed, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const { sub: localId } = parsed;\n        _assert(user.uid === localId, auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        return UserCredentialImpl._forOperation(user, operationType, response);\n    }\n    catch (e) {\n        // Convert user deleted error into user mismatch\n        if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${\"user-not-found\" /* AuthErrorCode.USER_DELETED */}`) {\n            _fail(auth, \"user-mismatch\" /* AuthErrorCode.USER_MISMATCH */);\n        }\n        throw e;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function _signInWithCredential(auth, credential, bypassAuthState = false) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const operationType = \"signIn\" /* OperationType.SIGN_IN */;\n    const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);\n    if (!bypassAuthState) {\n        await auth._updateCurrentUser(userCredential.user);\n    }\n    return userCredential;\n}\n/**\n * Asynchronously signs in with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function signInWithCredential(auth, credential) {\n    return _signInWithCredential(_castAuth(auth), credential);\n}\n/**\n * Links the user account with the given credentials.\n *\n * @remarks\n * An {@link AuthProvider} can be used to generate the credential.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function linkWithCredential(user, credential) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    await _assertLinkedStatus(false, userInternal, credential.providerId);\n    return _link(userInternal, credential);\n}\n/**\n * Re-authenticates a user using a fresh credential.\n *\n * @remarks\n * Use before operations such as {@link updatePassword} that require tokens from recent sign-in\n * attempts. This method can be used to recover from a `CREDENTIAL_TOO_OLD_LOGIN_AGAIN` error\n * or a `TOKEN_EXPIRED` error.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * @param user - The user.\n * @param credential - The auth credential.\n *\n * @public\n */\nasync function reauthenticateWithCredential(user, credential) {\n    return _reauthenticate((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function signInWithCustomToken$1(auth, request) {\n    return _performSignInRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:signInWithCustomToken\" /* Endpoint.SIGN_IN_WITH_CUSTOM_TOKEN */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Asynchronously signs in using a custom token.\n *\n * @remarks\n * Custom tokens are used to integrate Firebase Auth with existing auth systems, and must\n * be generated by an auth backend using the\n * {@link https://firebase.google.com/docs/reference/admin/node/admin.auth.Auth#createcustomtoken | createCustomToken}\n * method in the {@link https://firebase.google.com/docs/auth/admin | Admin SDK} .\n *\n * Fails with an error if the token is invalid, expired, or not accepted by the Firebase Auth service.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param customToken - The custom token to sign in with.\n *\n * @public\n */\nasync function signInWithCustomToken(auth, customToken) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const response = await signInWithCustomToken$1(authInternal, {\n        token: customToken,\n        returnSecureToken: true\n    });\n    const cred = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(cred.user);\n    return cred;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorInfoImpl {\n    constructor(factorId, response) {\n        this.factorId = factorId;\n        this.uid = response.mfaEnrollmentId;\n        this.enrollmentTime = new Date(response.enrolledAt).toUTCString();\n        this.displayName = response.displayName;\n    }\n    static _fromServerResponse(auth, enrollment) {\n        if ('phoneInfo' in enrollment) {\n            return PhoneMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        else if ('totpInfo' in enrollment) {\n            return TotpMultiFactorInfoImpl._fromServerResponse(auth, enrollment);\n        }\n        return _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n}\nclass PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"phone\" /* FactorId.PHONE */, response);\n        this.phoneNumber = response.phoneInfo;\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new PhoneMultiFactorInfoImpl(enrollment);\n    }\n}\nclass TotpMultiFactorInfoImpl extends MultiFactorInfoImpl {\n    constructor(response) {\n        super(\"totp\" /* FactorId.TOTP */, response);\n    }\n    static _fromServerResponse(_auth, enrollment) {\n        return new TotpMultiFactorInfoImpl(enrollment);\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {\n    var _a;\n    _assert(((_a = actionCodeSettings.url) === null || _a === void 0 ? void 0 : _a.length) > 0, auth, \"invalid-continue-uri\" /* AuthErrorCode.INVALID_CONTINUE_URI */);\n    _assert(typeof actionCodeSettings.dynamicLinkDomain === 'undefined' ||\n        actionCodeSettings.dynamicLinkDomain.length > 0, auth, \"invalid-dynamic-link-domain\" /* AuthErrorCode.INVALID_DYNAMIC_LINK_DOMAIN */);\n    request.continueUrl = actionCodeSettings.url;\n    request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;\n    request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;\n    if (actionCodeSettings.iOS) {\n        _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, \"missing-ios-bundle-id\" /* AuthErrorCode.MISSING_IOS_BUNDLE_ID */);\n        request.iOSBundleId = actionCodeSettings.iOS.bundleId;\n    }\n    if (actionCodeSettings.android) {\n        _assert(actionCodeSettings.android.packageName.length > 0, auth, \"missing-android-pkg-name\" /* AuthErrorCode.MISSING_ANDROID_PACKAGE_NAME */);\n        request.androidInstallApp = actionCodeSettings.android.installApp;\n        request.androidMinimumVersionCode =\n            actionCodeSettings.android.minimumVersion;\n        request.androidPackageName = actionCodeSettings.android.packageName;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates the password policy cached in the {@link Auth} instance if a policy is already\n * cached for the project or tenant.\n *\n * @remarks\n * We only fetch the password policy if the password did not meet policy requirements and\n * there is an existing policy cached. A developer must call validatePassword at least\n * once for the cache to be automatically updated.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @private\n */\nasync function recachePasswordPolicy(auth) {\n    const authInternal = _castAuth(auth);\n    if (authInternal._getPasswordPolicyInternal()) {\n        await authInternal._updatePasswordPolicy();\n    }\n}\n/**\n * Sends a password reset email to the given email address. This method does not throw an error when\n * there's no user account with the given email address and\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n *\n * @remarks\n * To complete the password reset, call {@link confirmPasswordReset} with the code supplied in\n * the email sent to the user, along with the new password specified by the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendPasswordResetEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain code from user.\n * await confirmPasswordReset('user@example.com', code);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendPasswordResetEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"PASSWORD_RESET\" /* ActionCodeOperation.PASSWORD_RESET */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n    }\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendPasswordResetEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Completes the password reset process, given a confirmation code and new password.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A confirmation code sent to the user.\n * @param newPassword - The new password.\n *\n * @public\n */\nasync function confirmPasswordReset(auth, oobCode, newPassword) {\n    await resetPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), {\n        oobCode,\n        newPassword\n    })\n        .catch(async (error) => {\n        if (error.code ===\n            `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    // Do not return the email.\n}\n/**\n * Applies a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function applyActionCode(auth, oobCode) {\n    await applyActionCode$1((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), { oobCode });\n}\n/**\n * Checks a verification code sent to the user by email or other out-of-band mechanism.\n *\n * @returns metadata about the code.\n *\n * @param auth - The {@link Auth} instance.\n * @param oobCode - A verification code sent to the user.\n *\n * @public\n */\nasync function checkActionCode(auth, oobCode) {\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const response = await resetPassword(authModular, { oobCode });\n    // Email could be empty only if the request type is EMAIL_SIGNIN or\n    // VERIFY_AND_CHANGE_EMAIL.\n    // New email should not be empty if the request type is\n    // VERIFY_AND_CHANGE_EMAIL.\n    // Multi-factor info could not be empty if the request type is\n    // REVERT_SECOND_FACTOR_ADDITION.\n    const operation = response.requestType;\n    _assert(operation, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    switch (operation) {\n        case \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */:\n            break;\n        case \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */:\n            _assert(response.newEmail, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            break;\n        case \"REVERT_SECOND_FACTOR_ADDITION\" /* ActionCodeOperation.REVERT_SECOND_FACTOR_ADDITION */:\n            _assert(response.mfaInfo, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        // fall through\n        default:\n            _assert(response.email, authModular, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n    }\n    // The multi-factor info for revert second factor addition\n    let multiFactorInfo = null;\n    if (response.mfaInfo) {\n        multiFactorInfo = MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular), response.mfaInfo);\n    }\n    return {\n        data: {\n            email: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.newEmail\n                : response.email) || null,\n            previousEmail: (response.requestType === \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */\n                ? response.email\n                : response.newEmail) || null,\n            multiFactorInfo\n        },\n        operation\n    };\n}\n/**\n * Checks a password reset code sent to the user by email or other out-of-band mechanism.\n *\n * @returns the user's email address if valid.\n *\n * @param auth - The {@link Auth} instance.\n * @param code - A verification code sent to the user.\n *\n * @public\n */\nasync function verifyPasswordResetCode(auth, code) {\n    const { data } = await checkActionCode((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), code);\n    // Email should always be present since a code was sent to it\n    return data.email;\n}\n/**\n * Creates a new user account associated with the specified email address and password.\n *\n * @remarks\n * On successful creation of the user account, this user will also be signed in to your application.\n *\n * User account creation can fail if the account already exists or the password is invalid.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The email address acts as a unique identifier for the user and enables an email-based\n * password reset. This function will create a new user account and set the initial user password.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param password - The user's chosen password.\n *\n * @public\n */\nasync function createUserWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authInternal = _castAuth(auth);\n    const request = {\n        returnSecureToken: true,\n        email,\n        password,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    const signUpResponse = handleRecaptchaFlow(authInternal, request, \"signUpPassword\" /* RecaptchaActionName.SIGN_UP_PASSWORD */, signUp, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n    const response = await signUpResponse.catch(error => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n    const userCredential = await UserCredentialImpl._fromIdTokenResponse(authInternal, \"signIn\" /* OperationType.SIGN_IN */, response);\n    await authInternal._updateCurrentUser(userCredential.user);\n    return userCredential;\n}\n/**\n * Asynchronously signs in using an email and password.\n *\n * @remarks\n * Fails with an error if the email address and password do not match. When\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, this method fails with \"auth/invalid-credential\" in case of an invalid\n * email/password.\n *\n * This method is not supported on {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: The user's password is NOT the password used to access the user's email account. The\n * email address serves as a unique identifier for the user, and the password is used to access\n * the user's account in your Firebase project. See also: {@link createUserWithEmailAndPassword}.\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The users email address.\n * @param password - The users password.\n *\n * @public\n */\nfunction signInWithEmailAndPassword(auth, email, password) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    return signInWithCredential((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), EmailAuthProvider.credential(email, password)).catch(async (error) => {\n        if (error.code === `auth/${\"password-does-not-meet-requirements\" /* AuthErrorCode.PASSWORD_DOES_NOT_MEET_REQUIREMENTS */}`) {\n            void recachePasswordPolicy(auth);\n        }\n        throw error;\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Sends a sign-in email link to the user with the specified email.\n *\n * @remarks\n * The sign-in operation has to always be completed in the app unlike other out of band email\n * actions (password reset and email verifications). This is because, at the end of the flow,\n * the user is expected to be signed in and their Auth state persisted within the app.\n *\n * To complete sign in with the email link, call {@link signInWithEmailLink} with the email\n * address and the email link supplied in the email sent to the user.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n * @param authInternal - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendSignInLinkToEmail(auth, email, actionCodeSettings) {\n    const authInternal = _castAuth(auth);\n    const request = {\n        requestType: \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */,\n        email,\n        clientType: \"CLIENT_TYPE_WEB\" /* RecaptchaClientType.WEB */\n    };\n    function setActionCodeSettings(request, actionCodeSettings) {\n        _assert(actionCodeSettings.handleCodeInApp, authInternal, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        if (actionCodeSettings) {\n            _setActionCodeSettingsOnRequest(authInternal, request, actionCodeSettings);\n        }\n    }\n    setActionCodeSettings(request, actionCodeSettings);\n    await handleRecaptchaFlow(authInternal, request, \"getOobCode\" /* RecaptchaActionName.GET_OOB_CODE */, sendSignInLinkToEmail$1, \"EMAIL_PASSWORD_PROVIDER\" /* RecaptchaAuthProvider.EMAIL_PASSWORD_PROVIDER */);\n}\n/**\n * Checks if an incoming link is a sign-in with email link suitable for {@link signInWithEmailLink}.\n *\n * @param auth - The {@link Auth} instance.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nfunction isSignInWithEmailLink(auth, emailLink) {\n    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);\n    return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === \"EMAIL_SIGNIN\" /* ActionCodeOperation.EMAIL_SIGNIN */;\n}\n/**\n * Asynchronously signs in using an email and sign-in email link.\n *\n * @remarks\n * If no link is passed, the link is inferred from the current URL.\n *\n * Fails with an error if the email address is invalid or OTP in email link expires.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * Note: Confirm the link is a sign-in email link before calling this method firebase.auth.Auth.isSignInWithEmailLink.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendSignInLinkToEmail(auth, 'user@example.com', actionCodeSettings);\n * // Obtain emailLink from the user.\n * if(isSignInWithEmailLink(auth, emailLink)) {\n *   await signInWithEmailLink(auth, 'user@example.com', emailLink);\n * }\n * ```\n *\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n * @param emailLink - The link sent to the user's email address.\n *\n * @public\n */\nasync function signInWithEmailLink(auth, email, emailLink) {\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(auth));\n    }\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());\n    // Check if the tenant ID in the email link matches the tenant ID on Auth\n    // instance.\n    _assert(credential._tenantId === (authModular.tenantId || null), authModular, \"tenant-id-mismatch\" /* AuthErrorCode.TENANT_ID_MISMATCH */);\n    return signInWithCredential(authModular, credential);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function createAuthUri(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:createAuthUri\" /* Endpoint.CREATE_AUTH_URI */, _addTidIfNecessary(auth, request));\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Gets the list of possible sign in methods for the given email address. This method returns an\n * empty list when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled, irrespective of the number of authentication methods available for the given email.\n *\n * @remarks\n * This is useful to differentiate methods of sign-in for the same provider, eg.\n * {@link EmailAuthProvider} which has 2 methods of sign-in,\n * {@link SignInMethod}.EMAIL_PASSWORD and\n * {@link SignInMethod}.EMAIL_LINK.\n *\n * @param auth - The {@link Auth} instance.\n * @param email - The user's email address.\n *\n * Deprecated. Migrating off of this method is recommended as a security best-practice.\n * Learn more in the Identity Platform documentation for\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}.\n * @public\n */\nasync function fetchSignInMethodsForEmail(auth, email) {\n    // createAuthUri returns an error if continue URI is not http or https.\n    // For environments like Cordova, Chrome extensions, native frameworks, file\n    // systems, etc, use http://localhost as continue URL.\n    const continueUri = _isHttpOrHttps() ? _getCurrentUrl() : 'http://localhost';\n    const request = {\n        identifier: email,\n        continueUri\n    };\n    const { signinMethods } = await createAuthUri((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth), request);\n    return signinMethods || [];\n}\n/**\n * Sends a verification email to a user.\n *\n * @remarks\n * The verification process is completed by calling {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await sendEmailVerification(user, actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function sendEmailVerification(user, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_EMAIL\" /* ActionCodeOperation.VERIFY_EMAIL */,\n        idToken\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await sendEmailVerification$1(userInternal.auth, request);\n    if (email !== user.email) {\n        await user.reload();\n    }\n}\n/**\n * Sends a verification email to a new email address.\n *\n * @remarks\n * The user's email will be updated to the new one after being verified.\n *\n * If you have a custom email action handler, you can complete the verification process by calling\n * {@link applyActionCode}.\n *\n * @example\n * ```javascript\n * const actionCodeSettings = {\n *   url: 'https://www.example.com/?email=user@example.com',\n *   iOS: {\n *      bundleId: 'com.example.ios'\n *   },\n *   android: {\n *     packageName: 'com.example.android',\n *     installApp: true,\n *     minimumVersion: '12'\n *   },\n *   handleCodeInApp: true\n * };\n * await verifyBeforeUpdateEmail(user, 'newemail@example.com', actionCodeSettings);\n * // Obtain code from the user.\n * await applyActionCode(auth, code);\n * ```\n *\n * @param user - The user.\n * @param newEmail - The new email address to be verified before update.\n * @param actionCodeSettings - The {@link ActionCodeSettings}.\n *\n * @public\n */\nasync function verifyBeforeUpdateEmail(user, newEmail, actionCodeSettings) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await user.getIdToken();\n    const request = {\n        requestType: \"VERIFY_AND_CHANGE_EMAIL\" /* ActionCodeOperation.VERIFY_AND_CHANGE_EMAIL */,\n        idToken,\n        newEmail\n    };\n    if (actionCodeSettings) {\n        _setActionCodeSettingsOnRequest(userInternal.auth, request, actionCodeSettings);\n    }\n    const { email } = await verifyAndChangeEmail(userInternal.auth, request);\n    if (email !== user.email) {\n        // If the local copy of the email on user is outdated, reload the\n        // user.\n        await user.reload();\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function updateProfile$1(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v1/accounts:update\" /* Endpoint.SET_ACCOUNT_INFO */, request);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Updates a user's profile data.\n *\n * @param user - The user.\n * @param profile - The profile's `displayName` and `photoURL` to update.\n *\n * @public\n */\nasync function updateProfile(user, { displayName, photoURL: photoUrl }) {\n    if (displayName === undefined && photoUrl === undefined) {\n        return;\n    }\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    const idToken = await userInternal.getIdToken();\n    const profileRequest = {\n        idToken,\n        displayName,\n        photoUrl,\n        returnSecureToken: true\n    };\n    const response = await _logoutIfInvalidated(userInternal, updateProfile$1(userInternal.auth, profileRequest));\n    userInternal.displayName = response.displayName || null;\n    userInternal.photoURL = response.photoUrl || null;\n    // Update the password provider as well\n    const passwordProvider = userInternal.providerData.find(({ providerId }) => providerId === \"password\" /* ProviderId.PASSWORD */);\n    if (passwordProvider) {\n        passwordProvider.displayName = userInternal.displayName;\n        passwordProvider.photoURL = userInternal.photoURL;\n    }\n    await userInternal._updateTokensIfNecessary(response);\n}\n/**\n * Updates the user's email address.\n *\n * @remarks\n * An email will be sent to the original email address (if it was set) that allows to revoke the\n * email address change, in order to protect them from account hijacking.\n *\n * This method is not supported on any {@link User} signed in by {@link Auth} instances\n * created with a {@link @firebase/app#FirebaseServerApp}.\n *\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newEmail - The new email address.\n *\n * Throws \"auth/operation-not-allowed\" error when\n * {@link https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection | Email Enumeration Protection}\n * is enabled.\n * Deprecated - Use {@link verifyBeforeUpdateEmail} instead.\n *\n * @public\n */\nfunction updateEmail(user, newEmail) {\n    const userInternal = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if ((0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._isFirebaseServerApp)(userInternal.auth.app)) {\n        return Promise.reject(_serverAppCurrentUserOperationNotSupportedError(userInternal.auth));\n    }\n    return updateEmailOrPassword(userInternal, newEmail, null);\n}\n/**\n * Updates the user's password.\n *\n * @remarks\n * Important: this is a security sensitive operation that requires the user to have recently signed\n * in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n * @param newPassword - The new password.\n *\n * @public\n */\nfunction updatePassword(user, newPassword) {\n    return updateEmailOrPassword((0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user), null, newPassword);\n}\nasync function updateEmailOrPassword(user, email, password) {\n    const { auth } = user;\n    const idToken = await user.getIdToken();\n    const request = {\n        idToken,\n        returnSecureToken: true\n    };\n    if (email) {\n        request.email = email;\n    }\n    if (password) {\n        request.password = password;\n    }\n    const response = await _logoutIfInvalidated(user, updateEmailPassword(auth, request));\n    await user._updateTokensIfNecessary(response, /* reload */ true);\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parse the `AdditionalUserInfo` from the ID token response.\n *\n */\nfunction _fromIdTokenResponse(idTokenResponse) {\n    var _a, _b;\n    if (!idTokenResponse) {\n        return null;\n    }\n    const { providerId } = idTokenResponse;\n    const profile = idTokenResponse.rawUserInfo\n        ? JSON.parse(idTokenResponse.rawUserInfo)\n        : {};\n    const isNewUser = idTokenResponse.isNewUser ||\n        idTokenResponse.kind === \"identitytoolkit#SignupNewUserResponse\" /* IdTokenResponseKind.SignupNewUser */;\n    if (!providerId && (idTokenResponse === null || idTokenResponse === void 0 ? void 0 : idTokenResponse.idToken)) {\n        const signInProvider = (_b = (_a = _parseToken(idTokenResponse.idToken)) === null || _a === void 0 ? void 0 : _a.firebase) === null || _b === void 0 ? void 0 : _b['sign_in_provider'];\n        if (signInProvider) {\n            const filteredProviderId = signInProvider !== \"anonymous\" /* ProviderId.ANONYMOUS */ &&\n                signInProvider !== \"custom\" /* ProviderId.CUSTOM */\n                ? signInProvider\n                : null;\n            // Uses generic class in accordance with the legacy SDK.\n            return new GenericAdditionalUserInfo(isNewUser, filteredProviderId);\n        }\n    }\n    if (!providerId) {\n        return null;\n    }\n    switch (providerId) {\n        case \"facebook.com\" /* ProviderId.FACEBOOK */:\n            return new FacebookAdditionalUserInfo(isNewUser, profile);\n        case \"github.com\" /* ProviderId.GITHUB */:\n            return new GithubAdditionalUserInfo(isNewUser, profile);\n        case \"google.com\" /* ProviderId.GOOGLE */:\n            return new GoogleAdditionalUserInfo(isNewUser, profile);\n        case \"twitter.com\" /* ProviderId.TWITTER */:\n            return new TwitterAdditionalUserInfo(isNewUser, profile, idTokenResponse.screenName || null);\n        case \"custom\" /* ProviderId.CUSTOM */:\n        case \"anonymous\" /* ProviderId.ANONYMOUS */:\n            return new GenericAdditionalUserInfo(isNewUser, null);\n        default:\n            return new GenericAdditionalUserInfo(isNewUser, providerId, profile);\n    }\n}\nclass GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile = {}) {\n        this.isNewUser = isNewUser;\n        this.providerId = providerId;\n        this.profile = profile;\n    }\n}\nclass FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo {\n    constructor(isNewUser, providerId, profile, username) {\n        super(isNewUser, providerId, profile);\n        this.username = username;\n    }\n}\nclass FacebookAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"facebook.com\" /* ProviderId.FACEBOOK */, profile);\n    }\n}\nclass GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"github.com\" /* ProviderId.GITHUB */, profile, typeof (profile === null || profile === void 0 ? void 0 : profile.login) === 'string' ? profile === null || profile === void 0 ? void 0 : profile.login : null);\n    }\n}\nclass GoogleAdditionalUserInfo extends GenericAdditionalUserInfo {\n    constructor(isNewUser, profile) {\n        super(isNewUser, \"google.com\" /* ProviderId.GOOGLE */, profile);\n    }\n}\nclass TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername {\n    constructor(isNewUser, profile, screenName) {\n        super(isNewUser, \"twitter.com\" /* ProviderId.TWITTER */, profile, screenName);\n    }\n}\n/**\n * Extracts provider specific {@link AdditionalUserInfo} for the given credential.\n *\n * @param userCredential - The user credential.\n *\n * @public\n */\nfunction getAdditionalUserInfo(userCredential) {\n    const { user, _tokenResponse } = userCredential;\n    if (user.isAnonymous && !_tokenResponse) {\n        // Handle the special case where signInAnonymously() gets called twice.\n        // No network call is made so there's nothing to actually fill this in\n        return {\n            providerId: null,\n            isNewUser: false,\n            profile: null\n        };\n    }\n    return _fromIdTokenResponse(_tokenResponse);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Non-optional auth methods.\n/**\n * Changes the type of persistence on the {@link Auth} instance for the currently saved\n * `Auth` session and applies this type of persistence for future sign-in requests, including\n * sign-in with redirect requests.\n *\n * @remarks\n * This makes it easy for a user signing in to specify whether their session should be\n * remembered or not. It also makes it easier to never persist the `Auth` state for applications\n * that are shared by other users or have sensitive data.\n *\n * This method does not work in a Node.js environment or with {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @example\n * ```javascript\n * setPersistence(auth, browserSessionPersistence);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n * @param persistence - The {@link Persistence} to use.\n * @returns A `Promise` that resolves once the persistence change has completed\n *\n * @public\n */\nfunction setPersistence(auth, persistence) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).setPersistence(persistence);\n}\n/**\n * Loads the reCAPTCHA configuration into the `Auth` instance.\n *\n * @remarks\n * This will load the reCAPTCHA config, which indicates whether the reCAPTCHA\n * verification flow should be triggered for each auth provider, into the\n * current Auth session.\n *\n * If initializeRecaptchaConfig() is not invoked, the auth flow will always start\n * without reCAPTCHA verification. If the provider is configured to require reCAPTCHA\n * verification, the SDK will transparently load the reCAPTCHA config and restart the\n * auth flows.\n *\n * Thus, by calling this optional method, you will reduce the latency of future auth flows.\n * Loading the reCAPTCHA config early will also enhance the signal collected by reCAPTCHA.\n *\n * This method does not work in a Node.js environment.\n *\n * @example\n * ```javascript\n * initializeRecaptchaConfig(auth);\n * ```\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction initializeRecaptchaConfig(auth) {\n    return _initializeRecaptchaConfig(auth);\n}\n/**\n * Validates the password against the password policy configured for the project or tenant.\n *\n * @remarks\n * If no tenant ID is set on the `Auth` instance, then this method will use the password\n * policy configured for the project. Otherwise, this method will use the policy configured\n * for the tenant. If a password policy has not been configured, then the default policy\n * configured for all projects will be used.\n *\n * If an auth flow fails because a submitted password does not meet the password policy\n * requirements and this method has previously been called, then this method will use the\n * most recent policy available when called again.\n *\n * @example\n * ```javascript\n * validatePassword(auth, 'some-password');\n * ```\n *\n * @param auth The {@link Auth} instance.\n * @param password The password to validate.\n *\n * @public\n */\nasync function validatePassword(auth, password) {\n    const authInternal = _castAuth(auth);\n    return authInternal.validatePassword(password);\n}\n/**\n * Adds an observer for changes to the signed-in user's ID token.\n *\n * @remarks\n * This includes sign-in, sign-out, and token refresh events.\n * This will not be triggered automatically upon ID token expiration. Use {@link User.getIdToken} to refresh the ID token.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onIdTokenChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onIdTokenChanged(nextOrObserver, error, completed);\n}\n/**\n * Adds a blocking callback that runs before an auth state change\n * sets a new user.\n *\n * @param auth - The {@link Auth} instance.\n * @param callback - callback triggered before new user value is set.\n *   If this throws, it blocks the user from being set.\n * @param onAbort - callback triggered if a later `beforeAuthStateChanged()`\n *   callback throws, allowing you to undo any side effects.\n */\nfunction beforeAuthStateChanged(auth, callback, onAbort) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).beforeAuthStateChanged(callback, onAbort);\n}\n/**\n * Adds an observer for changes to the user's sign-in state.\n *\n * @remarks\n * To keep the old behavior, see {@link onIdTokenChanged}.\n *\n * @param auth - The {@link Auth} instance.\n * @param nextOrObserver - callback triggered on change.\n * @param error - Deprecated. This callback is never triggered. Errors\n * on signing in/out can be caught in promises returned from\n * sign-in/sign-out functions.\n * @param completed - Deprecated. This callback is never triggered.\n *\n * @public\n */\nfunction onAuthStateChanged(auth, nextOrObserver, error, completed) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).onAuthStateChanged(nextOrObserver, error, completed);\n}\n/**\n * Sets the current language to the default device/browser preference.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction useDeviceLanguage(auth) {\n    (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).useDeviceLanguage();\n}\n/**\n * Asynchronously sets the provided user as {@link Auth.currentUser} on the\n * {@link Auth} instance.\n *\n * @remarks\n * A new instance copy of the user provided will be made and set as currentUser.\n *\n * This will trigger {@link onAuthStateChanged} and {@link onIdTokenChanged} listeners\n * like other sign in methods.\n *\n * The operation fails with an error if the user to be updated belongs to a different Firebase\n * project.\n *\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n * @param user - The new {@link User}.\n *\n * @public\n */\nfunction updateCurrentUser(auth, user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).updateCurrentUser(user);\n}\n/**\n * Signs out the current user.\n *\n * @remarks\n * This method is not supported by {@link Auth} instances created with a\n * {@link @firebase/app#FirebaseServerApp}.\n *\n * @param auth - The {@link Auth} instance.\n *\n * @public\n */\nfunction signOut(auth) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth).signOut();\n}\n/**\n * Revokes the given access token. Currently only supports Apple OAuth access tokens.\n *\n * @param auth - The {@link Auth} instance.\n * @param token - The Apple OAuth access token.\n *\n * @public\n */\nfunction revokeAccessToken(auth, token) {\n    const authInternal = _castAuth(auth);\n    return authInternal.revokeAccessToken(token);\n}\n/**\n * Deletes and signs out the user.\n *\n * @remarks\n * Important: this is a security-sensitive operation that requires the user to have recently\n * signed in. If this requirement isn't met, ask the user to authenticate again and then call\n * {@link reauthenticateWithCredential}.\n *\n * @param user - The user.\n *\n * @public\n */\nasync function deleteUser(user) {\n    return (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user).delete();\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorSessionImpl {\n    constructor(type, credential, user) {\n        this.type = type;\n        this.credential = credential;\n        this.user = user;\n    }\n    static _fromIdtoken(idToken, user) {\n        return new MultiFactorSessionImpl(\"enroll\" /* MultiFactorSessionType.ENROLL */, idToken, user);\n    }\n    static _fromMfaPendingCredential(mfaPendingCredential) {\n        return new MultiFactorSessionImpl(\"signin\" /* MultiFactorSessionType.SIGN_IN */, mfaPendingCredential);\n    }\n    toJSON() {\n        const key = this.type === \"enroll\" /* MultiFactorSessionType.ENROLL */\n            ? 'idToken'\n            : 'pendingCredential';\n        return {\n            multiFactorSession: {\n                [key]: this.credential\n            }\n        };\n    }\n    static fromJSON(obj) {\n        var _a, _b;\n        if (obj === null || obj === void 0 ? void 0 : obj.multiFactorSession) {\n            if ((_a = obj.multiFactorSession) === null || _a === void 0 ? void 0 : _a.pendingCredential) {\n                return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);\n            }\n            else if ((_b = obj.multiFactorSession) === null || _b === void 0 ? void 0 : _b.idToken) {\n                return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken);\n            }\n        }\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass MultiFactorResolverImpl {\n    constructor(session, hints, signInResolver) {\n        this.session = session;\n        this.hints = hints;\n        this.signInResolver = signInResolver;\n    }\n    /** @internal */\n    static _fromError(authExtern, error) {\n        const auth = _castAuth(authExtern);\n        const serverResponse = error.customData._serverResponse;\n        const hints = (serverResponse.mfaInfo || []).map(enrollment => MultiFactorInfoImpl._fromServerResponse(auth, enrollment));\n        _assert(serverResponse.mfaPendingCredential, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const session = MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);\n        return new MultiFactorResolverImpl(session, hints, async (assertion) => {\n            const mfaResponse = await assertion._process(auth, session);\n            // Clear out the unneeded fields from the old login response\n            delete serverResponse.mfaInfo;\n            delete serverResponse.mfaPendingCredential;\n            // Use in the new token & refresh token in the old response\n            const idTokenResponse = Object.assign(Object.assign({}, serverResponse), { idToken: mfaResponse.idToken, refreshToken: mfaResponse.refreshToken });\n            // TODO: we should collapse this switch statement into UserCredentialImpl._forOperation and have it support the SIGN_IN case\n            switch (error.operationType) {\n                case \"signIn\" /* OperationType.SIGN_IN */:\n                    const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, error.operationType, idTokenResponse);\n                    await auth._updateCurrentUser(userCredential.user);\n                    return userCredential;\n                case \"reauthenticate\" /* OperationType.REAUTHENTICATE */:\n                    _assert(error.user, auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n                    return UserCredentialImpl._forOperation(error.user, error.operationType, idTokenResponse);\n                default:\n                    _fail(auth, \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n            }\n        });\n    }\n    async resolveSignIn(assertionExtern) {\n        const assertion = assertionExtern;\n        return this.signInResolver(assertion);\n    }\n}\n/**\n * Provides a {@link MultiFactorResolver} suitable for completion of a\n * multi-factor flow.\n *\n * @param auth - The {@link Auth} instance.\n * @param error - The {@link MultiFactorError} raised during a sign-in, or\n * reauthentication operation.\n *\n * @public\n */\nfunction getMultiFactorResolver(auth, error) {\n    var _a;\n    const authModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(auth);\n    const errorInternal = error;\n    _assert(error.customData.operationType, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    _assert((_a = errorInternal.customData._serverResponse) === null || _a === void 0 ? void 0 : _a.mfaPendingCredential, authModular, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n    return MultiFactorResolverImpl._fromError(authModular, errorInternal);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction startEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:start\" /* Endpoint.START_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction finalizeEnrollTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:finalize\" /* Endpoint.FINALIZE_MFA_ENROLLMENT */, _addTidIfNecessary(auth, request));\n}\nfunction withdrawMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaEnrollment:withdraw\" /* Endpoint.WITHDRAW_MFA */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorUserImpl {\n    constructor(user) {\n        this.user = user;\n        this.enrolledFactors = [];\n        user._onReload(userInfo => {\n            if (userInfo.mfaInfo) {\n                this.enrolledFactors = userInfo.mfaInfo.map(enrollment => MultiFactorInfoImpl._fromServerResponse(user.auth, enrollment));\n            }\n        });\n    }\n    static _fromUser(user) {\n        return new MultiFactorUserImpl(user);\n    }\n    async getSession() {\n        return MultiFactorSessionImpl._fromIdtoken(await this.user.getIdToken(), this.user);\n    }\n    async enroll(assertionExtern, displayName) {\n        const assertion = assertionExtern;\n        const session = (await this.getSession());\n        const finalizeMfaResponse = await _logoutIfInvalidated(this.user, assertion._process(this.user.auth, session, displayName));\n        // New tokens will be issued after enrollment of the new second factors.\n        // They need to be updated on the user.\n        await this.user._updateTokensIfNecessary(finalizeMfaResponse);\n        // The user needs to be reloaded to get the new multi-factor information\n        // from server. USER_RELOADED event will be triggered and `enrolledFactors`\n        // will be updated.\n        return this.user.reload();\n    }\n    async unenroll(infoOrUid) {\n        const mfaEnrollmentId = typeof infoOrUid === 'string' ? infoOrUid : infoOrUid.uid;\n        const idToken = await this.user.getIdToken();\n        try {\n            const idTokenResponse = await _logoutIfInvalidated(this.user, withdrawMfa(this.user.auth, {\n                idToken,\n                mfaEnrollmentId\n            }));\n            // Remove the second factor from the user's list.\n            this.enrolledFactors = this.enrolledFactors.filter(({ uid }) => uid !== mfaEnrollmentId);\n            // Depending on whether the backend decided to revoke the user's session,\n            // the tokenResponse may be empty. If the tokens were not updated (and they\n            // are now invalid), reloading the user will discover this and invalidate\n            // the user's state accordingly.\n            await this.user._updateTokensIfNecessary(idTokenResponse);\n            await this.user.reload();\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n}\nconst multiFactorUserCache = new WeakMap();\n/**\n * The {@link MultiFactorUser} corresponding to the user.\n *\n * @remarks\n * This is used to access all multi-factor properties and operations related to the user.\n *\n * @param user - The user.\n *\n * @public\n */\nfunction multiFactor(user) {\n    const userModular = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getModularInstance)(user);\n    if (!multiFactorUserCache.has(userModular)) {\n        multiFactorUserCache.set(userModular, MultiFactorUserImpl._fromUser(userModular));\n    }\n    return multiFactorUserCache.get(userModular);\n}\n\nvar name = \"@firebase/auth\";\nvar version = \"1.8.1\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass AuthInterop {\n    constructor(auth) {\n        this.auth = auth;\n        this.internalListeners = new Map();\n    }\n    getUid() {\n        var _a;\n        this.assertAuthConfigured();\n        return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;\n    }\n    async getToken(forceRefresh) {\n        this.assertAuthConfigured();\n        await this.auth._initializationPromise;\n        if (!this.auth.currentUser) {\n            return null;\n        }\n        const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);\n        return { accessToken };\n    }\n    addAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        if (this.internalListeners.has(listener)) {\n            return;\n        }\n        const unsubscribe = this.auth.onIdTokenChanged(user => {\n            listener((user === null || user === void 0 ? void 0 : user.stsTokenManager.accessToken) || null);\n        });\n        this.internalListeners.set(listener, unsubscribe);\n        this.updateProactiveRefresh();\n    }\n    removeAuthTokenListener(listener) {\n        this.assertAuthConfigured();\n        const unsubscribe = this.internalListeners.get(listener);\n        if (!unsubscribe) {\n            return;\n        }\n        this.internalListeners.delete(listener);\n        unsubscribe();\n        this.updateProactiveRefresh();\n    }\n    assertAuthConfigured() {\n        _assert(this.auth._initializationPromise, \"dependent-sdk-initialized-before-auth\" /* AuthErrorCode.DEPENDENT_SDK_INIT_BEFORE_AUTH */);\n    }\n    updateProactiveRefresh() {\n        if (this.internalListeners.size > 0) {\n            this.auth._startProactiveRefresh();\n        }\n        else {\n            this.auth._stopProactiveRefresh();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getVersionForPlatform(clientPlatform) {\n    switch (clientPlatform) {\n        case \"Node\" /* ClientPlatform.NODE */:\n            return 'node';\n        case \"ReactNative\" /* ClientPlatform.REACT_NATIVE */:\n            return 'rn';\n        case \"Worker\" /* ClientPlatform.WORKER */:\n            return 'webworker';\n        case \"Cordova\" /* ClientPlatform.CORDOVA */:\n            return 'cordova';\n        case \"WebExtension\" /* ClientPlatform.WEB_EXTENSION */:\n            return 'web-extension';\n        default:\n            return undefined;\n    }\n}\n/** @internal */\nfunction registerAuth(clientPlatform) {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth\" /* _ComponentName.AUTH */, (container, { options: deps }) => {\n        const app = container.getProvider('app').getImmediate();\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\n        const appCheckServiceProvider = container.getProvider('app-check-internal');\n        const { apiKey, authDomain } = app.options;\n        _assert(apiKey && !apiKey.includes(':'), \"invalid-api-key\" /* AuthErrorCode.INVALID_API_KEY */, { appName: app.name });\n        const config = {\n            apiKey,\n            authDomain,\n            clientPlatform,\n            apiHost: \"identitytoolkit.googleapis.com\" /* DefaultConfig.API_HOST */,\n            tokenApiHost: \"securetoken.googleapis.com\" /* DefaultConfig.TOKEN_API_HOST */,\n            apiScheme: \"https\" /* DefaultConfig.API_SCHEME */,\n            sdkClientVersion: _getClientVersion(clientPlatform)\n        };\n        const authInstance = new AuthImpl(app, heartbeatServiceProvider, appCheckServiceProvider, config);\n        _initializeAuthInstance(authInstance, deps);\n        return authInstance;\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\n        /**\n         * Auth can only be initialized by explicitly calling getAuth() or initializeAuth()\n         * For why we do this, See go/firebase-next-auth-init\n         */\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n        /**\n         * Because all firebase products that depend on auth depend on auth-internal directly,\n         * we need to initialize auth-internal after auth is initialized to make it available to other firebase products.\n         */\n        .setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {\n        const authInternalProvider = container.getProvider(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */);\n        authInternalProvider.initialize();\n    }));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_2__.Component(\"auth-internal\" /* _ComponentName.AUTH_INTERNAL */, container => {\n        const auth = _castAuth(container.getProvider(\"auth\" /* _ComponentName.AUTH */).getImmediate());\n        return (auth => new AuthInterop(auth))(auth);\n    }, \"PRIVATE\" /* ComponentType.PRIVATE */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, getVersionForPlatform(clientPlatform));\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, 'esm2017');\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initialize the fetch polyfill, the types are slightly off so just cast and hope for the best\nFetchProvider.initialize(fetch, Headers, Response);\n// First, we set up the various platform-specific features for Node (register\n// the version and declare the Node getAuth function)\nfunction getAuth(app = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)()) {\n    const provider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, 'auth');\n    if (provider.isInitialized()) {\n        return provider.getImmediate();\n    }\n    const auth = initializeAuth(app);\n    const authEmulatorHost = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_1__.getDefaultEmulatorHost)('auth');\n    if (authEmulatorHost) {\n        connectAuthEmulator(auth, `http://${authEmulatorHost}`);\n    }\n    return auth;\n}\nregisterAuth(\"Node\" /* ClientPlatform.NODE */);\n// The rest of this file contains no-ops and errors for browser-specific\n// methods. We keep the browser and Node entry points the same, but features\n// that only work in browsers are set to either do nothing (setPersistence) or\n// to reject with an auth/operation-not-supported-in-this-environment error.\n// The below exports are pulled into the main entry point by a rollup alias\n// plugin (overwriting the default browser imports).\n/** auth/operation-not-supported-in-this-environment */\nconst NOT_AVAILABLE_ERROR = _createError(\"operation-not-supported-in-this-environment\" /* AuthErrorCode.OPERATION_NOT_SUPPORTED */);\n/** Reject with auth/operation-not-supported-in-this-environment */\nasync function fail() {\n    throw NOT_AVAILABLE_ERROR;\n}\n/**\n * A class which will throw with\n * auth/operation-not-supported-in-this-environment if instantiated\n */\nclass FailClass {\n    constructor() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\nconst browserLocalPersistence = inMemoryPersistence;\nconst browserSessionPersistence = inMemoryPersistence;\nconst indexedDBLocalPersistence = inMemoryPersistence;\nconst browserPopupRedirectResolver = NOT_AVAILABLE_ERROR;\nconst PhoneAuthProvider = FailClass;\nconst signInWithPhoneNumber = fail;\nconst linkWithPhoneNumber = fail;\nconst reauthenticateWithPhoneNumber = fail;\nconst updatePhoneNumber = fail;\nconst signInWithPopup = fail;\nconst linkWithPopup = fail;\nconst reauthenticateWithPopup = fail;\nconst signInWithRedirect = fail;\nconst linkWithRedirect = fail;\nconst reauthenticateWithRedirect = fail;\nconst getRedirectResult = fail;\nconst RecaptchaVerifier = FailClass;\nclass PhoneMultiFactorGenerator {\n    static assertion() {\n        throw NOT_AVAILABLE_ERROR;\n    }\n}\n// Set persistence should no-op instead of fail. Changing the prototype will\n// make sure both setPersistence(auth, persistence) and\n// auth.setPersistence(persistence) are covered.\nAuthImpl.prototype.setPersistence = async () => { };\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction finalizeSignInTotpMfa(auth, request) {\n    return _performApiRequest(auth, \"POST\" /* HttpMethod.POST */, \"/v2/accounts/mfaSignIn:finalize\" /* Endpoint.FINALIZE_MFA_SIGN_IN */, _addTidIfNecessary(auth, request));\n}\n\nclass MultiFactorAssertionImpl {\n    constructor(factorId) {\n        this.factorId = factorId;\n    }\n    _process(auth, session, displayName) {\n        switch (session.type) {\n            case \"enroll\" /* MultiFactorSessionType.ENROLL */:\n                return this._finalizeEnroll(auth, session.credential, displayName);\n            case \"signin\" /* MultiFactorSessionType.SIGN_IN */:\n                return this._finalizeSignIn(auth, session.credential);\n            default:\n                return debugFail('unexpected MultiFactorSessionType');\n        }\n    }\n}\n\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * @public\n */\nclass TotpMultiFactorGenerator {\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of\n     * the TOTP (time-based one-time password) second factor.\n     * This assertion is used to complete enrollment in TOTP second factor.\n     *\n     * @param secret A {@link TotpSecret} containing the shared secret key and other TOTP parameters.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorUser.enroll}.\n     */\n    static assertionForEnrollment(secret, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromSecret(secret, oneTimePassword);\n    }\n    /**\n     * Provides a {@link TotpMultiFactorAssertion} to confirm ownership of the TOTP second factor.\n     * This assertion is used to complete signIn with TOTP as the second factor.\n     *\n     * @param enrollmentId identifies the enrolled TOTP second factor.\n     * @param oneTimePassword One-time password from TOTP App.\n     * @returns A {@link TotpMultiFactorAssertion} which can be used with\n     * {@link MultiFactorResolver.resolveSignIn}.\n     */\n    static assertionForSignIn(enrollmentId, oneTimePassword) {\n        return TotpMultiFactorAssertionImpl._fromEnrollmentId(enrollmentId, oneTimePassword);\n    }\n    /**\n     * Returns a promise to {@link TotpSecret} which contains the TOTP shared secret key and other parameters.\n     * Creates a TOTP secret as part of enrolling a TOTP second factor.\n     * Used for generating a QR code URL or inputting into a TOTP app.\n     * This method uses the auth instance corresponding to the user in the multiFactorSession.\n     *\n     * @param session The {@link MultiFactorSession} that the user is part of.\n     * @returns A promise to {@link TotpSecret}.\n     */\n    static async generateSecret(session) {\n        var _a;\n        const mfaSession = session;\n        _assert(typeof ((_a = mfaSession.user) === null || _a === void 0 ? void 0 : _a.auth) !== 'undefined', \"internal-error\" /* AuthErrorCode.INTERNAL_ERROR */);\n        const response = await startEnrollTotpMfa(mfaSession.user.auth, {\n            idToken: mfaSession.credential,\n            totpEnrollmentInfo: {}\n        });\n        return TotpSecret._fromStartTotpMfaEnrollmentResponse(response, mfaSession.user.auth);\n    }\n}\n/**\n * The identifier of the TOTP second factor: `totp`.\n */\nTotpMultiFactorGenerator.FACTOR_ID = \"totp\" /* FactorId.TOTP */;\nclass TotpMultiFactorAssertionImpl extends MultiFactorAssertionImpl {\n    constructor(otp, enrollmentId, secret) {\n        super(\"totp\" /* FactorId.TOTP */);\n        this.otp = otp;\n        this.enrollmentId = enrollmentId;\n        this.secret = secret;\n    }\n    /** @internal */\n    static _fromSecret(secret, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, undefined, secret);\n    }\n    /** @internal */\n    static _fromEnrollmentId(enrollmentId, otp) {\n        return new TotpMultiFactorAssertionImpl(otp, enrollmentId);\n    }\n    /** @internal */\n    async _finalizeEnroll(auth, idToken, displayName) {\n        _assert(typeof this.secret !== 'undefined', auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        return finalizeEnrollTotpMfa(auth, {\n            idToken,\n            displayName,\n            totpVerificationInfo: this.secret._makeTotpVerificationInfo(this.otp)\n        });\n    }\n    /** @internal */\n    async _finalizeSignIn(auth, mfaPendingCredential) {\n        _assert(this.enrollmentId !== undefined && this.otp !== undefined, auth, \"argument-error\" /* AuthErrorCode.ARGUMENT_ERROR */);\n        const totpVerificationInfo = { verificationCode: this.otp };\n        return finalizeSignInTotpMfa(auth, {\n            mfaPendingCredential,\n            mfaEnrollmentId: this.enrollmentId,\n            totpVerificationInfo\n        });\n    }\n}\n/**\n * Provider for generating a {@link TotpMultiFactorAssertion}.\n *\n * Stores the shared secret key and other parameters to generate time-based OTPs.\n * Implements methods to retrieve the shared secret key and generate a QR code URL.\n * @public\n */\nclass TotpSecret {\n    // The public members are declared outside the constructor so the docs can be generated.\n    constructor(secretKey, hashingAlgorithm, codeLength, codeIntervalSeconds, enrollmentCompletionDeadline, sessionInfo, auth) {\n        this.sessionInfo = sessionInfo;\n        this.auth = auth;\n        this.secretKey = secretKey;\n        this.hashingAlgorithm = hashingAlgorithm;\n        this.codeLength = codeLength;\n        this.codeIntervalSeconds = codeIntervalSeconds;\n        this.enrollmentCompletionDeadline = enrollmentCompletionDeadline;\n    }\n    /** @internal */\n    static _fromStartTotpMfaEnrollmentResponse(response, auth) {\n        return new TotpSecret(response.totpSessionInfo.sharedSecretKey, response.totpSessionInfo.hashingAlgorithm, response.totpSessionInfo.verificationCodeLength, response.totpSessionInfo.periodSec, new Date(response.totpSessionInfo.finalizeEnrollmentTime).toUTCString(), response.totpSessionInfo.sessionInfo, auth);\n    }\n    /** @internal */\n    _makeTotpVerificationInfo(otp) {\n        return { sessionInfo: this.sessionInfo, verificationCode: otp };\n    }\n    /**\n     * Returns a QR code URL as described in\n     * https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n     * This can be displayed to the user as a QR code to be scanned into a TOTP app like Google Authenticator.\n     * If the optional parameters are unspecified, an accountName of <userEmail> and issuer of <firebaseAppName> are used.\n     *\n     * @param accountName the name of the account/app along with a user identifier.\n     * @param issuer issuer of the TOTP (likely the app name).\n     * @returns A QR code URL string.\n     */\n    generateQrCodeUrl(accountName, issuer) {\n        var _a;\n        let useDefaults = false;\n        if (_isEmptyString(accountName) || _isEmptyString(issuer)) {\n            useDefaults = true;\n        }\n        if (useDefaults) {\n            if (_isEmptyString(accountName)) {\n                accountName = ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.email) || 'unknownuser';\n            }\n            if (_isEmptyString(issuer)) {\n                issuer = this.auth.name;\n            }\n        }\n        return `otpauth://totp/${issuer}:${accountName}?secret=${this.secretKey}&issuer=${issuer}&algorithm=${this.hashingAlgorithm}&digits=${this.codeLength}`;\n    }\n}\n/** @internal */\nfunction _isEmptyString(input) {\n    return typeof input === 'undefined' || (input === null || input === void 0 ? void 0 : input.length) === 0;\n}\n\n\n//# sourceMappingURL=totp-3df2f5f9.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2F1dGgvZGlzdC9ub2RlLWVzbS90b3RwLTNkZjJmNWY5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDK0o7QUFDN1A7QUFDaUI7QUFDSTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csaUJBQWlCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBLDhCQUE4QixzREFBUTtBQUN0QyxnQ0FBZ0Msc0RBQVcsQ0FBQyxLQUFLLElBQUk7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFRO0FBQ3RDLGlDQUFpQyxzREFBVyxDQUFDLEtBQUssSUFBSTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQscUJBQXFCLGlCQUFpQjtBQUN6Rix3QkFBd0Isd0RBQVk7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBZSxNQUFNLDZEQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSw0Q0FBNEM7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLHlCQUF5QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQVcsaUJBQWlCLHlCQUF5QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsc0JBQXNCO0FBQ2pIO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxFQUFFLEtBQUssR0FBRyxNQUFNO0FBQ3pDO0FBQ0Esa0JBQWtCLHNCQUFzQixLQUFLLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix5REFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DLDZCQUE2QixrREFBa0Q7QUFDL0UseUJBQXlCLHVEQUF1RDtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvRUFBb0U7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFNBQVM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhLGlCQUFpQiw2Q0FBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUscUJBQXFCLDJEQUFXO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLHVCQUF1QjtBQUN2QyxpR0FBaUcsT0FBTztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUE0QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJLFNBQVM7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsWUFBWSw2Q0FBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVcsc0RBQXNEO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNWQUFzVjtBQUNuWTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEZBQTBGO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUNBQXVDLEdBQUcsSUFBSSxHQUFHLE9BQU8sR0FBRyxRQUFRO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBSztBQUM5QjtBQUNBO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxREFBSztBQUNoQztBQUNBO0FBQ0EsMEJBQTBCLHFEQUFLO0FBQy9CO0FBQ0E7QUFDQSx5QkFBeUIscURBQUs7QUFDOUI7QUFDQTtBQUNBLDRCQUE0QixxREFBSztBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLHFEQUFLO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIscURBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBSTtBQUNmO0FBQ0EsK0JBQStCLHFEQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFEQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCLHFEQUFLLElBQUksR0FBRyxlQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixjQUFjLGlCQUFpQixHQUFHLHlDQUF5QyxHQUFHLHNEQUFXLENBQUMsR0FBRyxtQkFBbUI7QUFDaEg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9FQUFvRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtRUFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0VBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZLG1FQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUVBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMktBQTJLO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwwQkFBMEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwrREFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQyxnQ0FBZ0M7QUFDcEU7QUFDQSxnQ0FBZ0MsK0RBQStEO0FBQy9GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNFQUFzRTtBQUNqSCxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzRUFBc0U7QUFDckgsK0NBQStDLG9FQUFvRTtBQUNuSCxrSkFBa0osWUFBWTtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixJQUFJLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRCxJQUFJLGNBQWM7QUFDbEIsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQVMsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQSxxQ0FBcUMsUUFBUSxTQUFTLElBQUksS0FBSyxFQUFFLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLFFBQVEsbUJBQW1CO0FBQzNCLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkYsSUFBSSxpQkFBaUI7QUFDckI7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkMsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysc0JBQXNCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHFCQUFxQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9DQUFvQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCLGNBQWMsNkNBQU07QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjLHFCQUFxQjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtDQUFrQztBQUMzRTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNkJBQTZCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWdFO0FBQ2hGO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUNBQW1DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQWdFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUVBQWlCLENBQUMsa0VBQWtCO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVLGlFQUFpQixDQUFDLGtFQUFrQjtBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLGlFQUFpQixDQUFDLGtFQUFrQjtBQUM1RDtBQUNBLFVBQVUsaUVBQWlCLENBQUMsa0VBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpRUFBaUIsQ0FBQyxrRUFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQkFBcUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFCQUFxQjtBQUN6QixJQUFJLHlCQUF5QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLHdCQUF3QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWEsNERBQTREO0FBQ2xKO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0ZBQW9GO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsS0FBSyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixLQUFLLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxxQkFBcUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUIsS0FBSyxpQkFBaUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLHFCQUFxQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUIsUUFBUSxpQkFBaUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxvQ0FBb0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5Q0FBeUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQixRQUFRLHNCQUFzQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHVCQUF1QixLQUFLLGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCLFFBQVEscUJBQXFCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixRQUFRLGlCQUFpQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUNBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5REFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhEQUE4RDtBQUNqRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0M7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxrREFBa0Q7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvQkFBb0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0VBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxjQUFjLFlBQVk7QUFDOUUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrRUFBa0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLCtEQUErRDtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0QkFBNEI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0Esb0NBQW9DLHlCQUF5QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQiw4RkFBOEY7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtFQUFrQixVQUFVLFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUMsd0RBQXdELFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8sd0JBQXdCLGtFQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1FQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhGQUE4RjtBQUNqSTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxxQ0FBcUM7QUFDaEc7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0VBQWtCO0FBQ2xELG1DQUFtQyw4RkFBOEY7QUFDakk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyQkFBMkI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwwQkFBMEI7QUFDbkc7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUVBQW9CO0FBQzVCO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseUJBQXlCO0FBQzdCLElBQUksbUJBQW1CO0FBQ3ZCLElBQUksbUJBQW1CO0FBQ3ZCO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdIQUF3SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0Isc0JBQXNCLGtFQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQ0FBaUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWSxjQUFjLFlBQVk7QUFDOUUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0I7QUFDM0MsUUFBUSxtRUFBb0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1DQUFtQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrRUFBa0I7QUFDbkQ7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsWUFBWTtBQUMzRSxJQUFJLHNDQUFzQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSx1QkFBdUI7QUFDbEc7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxrRUFBa0I7QUFDdEI7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0I7QUFDckUsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQixLQUFLLHdCQUF3QjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsSUFBSSxzQ0FBc0M7QUFDMUM7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQywwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCxJQUFJLHNDQUFzQztBQUMxQztBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrRUFBa0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCLHNFQUFzRTtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0VBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrRUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRUFBa0IsS0FBSywwREFBUyxpREFBaUQsZUFBZTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDLDBHQUEwRyxtQkFBbUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGlFQUFrQixLQUFLLDBEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw4REFBZTtBQUNuQjtBQUNBLElBQUksOERBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBTTtBQUM3QixxQkFBcUIsMkRBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNCO0FBQ25EO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRCxRQUFRLDZCQUE2QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBZ0M7QUFDbkQsUUFBUSx3Q0FBd0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JELDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxHQUFHLFlBQVksVUFBVSxlQUFlLFVBQVUsT0FBTyxhQUFhLHNCQUFzQixVQUFVLGdCQUFnQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStvRjtBQUMvb0YiLCJzb3VyY2VzIjpbIi9ob21lL3JndGVjaDAwOC9hY2FkZW1pYy1jb25uZWN0LXByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3Qvbm9kZS1lc20vdG90cC0zZGYyZjVmOS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTREtfVkVSU0lPTiwgX2lzRmlyZWJhc2VTZXJ2ZXJBcHAsIF9nZXRQcm92aWRlciwgX3JlZ2lzdGVyQ29tcG9uZW50LCByZWdpc3RlclZlcnNpb24sIGdldEFwcCB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5LCBpc0Jyb3dzZXJFeHRlbnNpb24sIGlzTW9iaWxlQ29yZG92YSwgaXNSZWFjdE5hdGl2ZSwgRmlyZWJhc2VFcnJvciwgcXVlcnlzdHJpbmcsIGlzQ2xvdWRmbGFyZVdvcmtlciwgZ2V0TW9kdWxhckluc3RhbmNlLCBiYXNlNjREZWNvZGUsIGdldFVBLCBpc0lFLCBjcmVhdGVTdWJzY3JpYmUsIGRlZXBFcXVhbCwgcXVlcnlzdHJpbmdEZWNvZGUsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0BmaXJlYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IHsgTG9nZ2VyLCBMb2dMZXZlbCB9IGZyb20gJ0BmaXJlYmFzZS9sb2dnZXInO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBbiBlbnVtIG9mIGZhY3RvcnMgdGhhdCBtYXkgYmUgdXNlZCBmb3IgbXVsdGlmYWN0b3IgYXV0aGVudGljYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBGYWN0b3JJZCA9IHtcbiAgICAvKiogUGhvbmUgYXMgc2Vjb25kIGZhY3RvciAqL1xuICAgIFBIT05FOiAncGhvbmUnLFxuICAgIFRPVFA6ICd0b3RwJ1xufTtcbi8qKlxuICogRW51bWVyYXRpb24gb2Ygc3VwcG9ydGVkIHByb3ZpZGVycy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IFByb3ZpZGVySWQgPSB7XG4gICAgLyoqIEZhY2Vib29rIHByb3ZpZGVyIElEICovXG4gICAgRkFDRUJPT0s6ICdmYWNlYm9vay5jb20nLFxuICAgIC8qKiBHaXRIdWIgcHJvdmlkZXIgSUQgKi9cbiAgICBHSVRIVUI6ICdnaXRodWIuY29tJyxcbiAgICAvKiogR29vZ2xlIHByb3ZpZGVyIElEICovXG4gICAgR09PR0xFOiAnZ29vZ2xlLmNvbScsXG4gICAgLyoqIFBhc3N3b3JkIHByb3ZpZGVyICovXG4gICAgUEFTU1dPUkQ6ICdwYXNzd29yZCcsXG4gICAgLyoqIFBob25lIHByb3ZpZGVyICovXG4gICAgUEhPTkU6ICdwaG9uZScsXG4gICAgLyoqIFR3aXR0ZXIgcHJvdmlkZXIgSUQgKi9cbiAgICBUV0lUVEVSOiAndHdpdHRlci5jb20nXG59O1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgc2lnbi1pbiBtZXRob2RzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgU2lnbkluTWV0aG9kID0ge1xuICAgIC8qKiBFbWFpbCBsaW5rIHNpZ24gaW4gbWV0aG9kICovXG4gICAgRU1BSUxfTElOSzogJ2VtYWlsTGluaycsXG4gICAgLyoqIEVtYWlsL3Bhc3N3b3JkIHNpZ24gaW4gbWV0aG9kICovXG4gICAgRU1BSUxfUEFTU1dPUkQ6ICdwYXNzd29yZCcsXG4gICAgLyoqIEZhY2Vib29rIHNpZ24gaW4gbWV0aG9kICovXG4gICAgRkFDRUJPT0s6ICdmYWNlYm9vay5jb20nLFxuICAgIC8qKiBHaXRIdWIgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBHSVRIVUI6ICdnaXRodWIuY29tJyxcbiAgICAvKiogR29vZ2xlIHNpZ24gaW4gbWV0aG9kICovXG4gICAgR09PR0xFOiAnZ29vZ2xlLmNvbScsXG4gICAgLyoqIFBob25lIHNpZ24gaW4gbWV0aG9kICovXG4gICAgUEhPTkU6ICdwaG9uZScsXG4gICAgLyoqIFR3aXR0ZXIgc2lnbiBpbiBtZXRob2QgKi9cbiAgICBUV0lUVEVSOiAndHdpdHRlci5jb20nXG59O1xuLyoqXG4gKiBFbnVtZXJhdGlvbiBvZiBzdXBwb3J0ZWQgb3BlcmF0aW9uIHR5cGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgT3BlcmF0aW9uVHlwZSA9IHtcbiAgICAvKiogT3BlcmF0aW9uIGludm9sdmluZyBsaW5raW5nIGFuIGFkZGl0aW9uYWwgcHJvdmlkZXIgdG8gYW4gYWxyZWFkeSBzaWduZWQtaW4gdXNlci4gKi9cbiAgICBMSU5LOiAnbGluaycsXG4gICAgLyoqIE9wZXJhdGlvbiBpbnZvbHZpbmcgdXNpbmcgYSBwcm92aWRlciB0byByZWF1dGhlbnRpY2F0ZSBhbiBhbHJlYWR5IHNpZ25lZC1pbiB1c2VyLiAqL1xuICAgIFJFQVVUSEVOVElDQVRFOiAncmVhdXRoZW50aWNhdGUnLFxuICAgIC8qKiBPcGVyYXRpb24gaW52b2x2aW5nIHNpZ25pbmcgaW4gYSB1c2VyLiAqL1xuICAgIFNJR05fSU46ICdzaWduSW4nXG59O1xuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB0aGUgcG9zc2libGUgZW1haWwgYWN0aW9uIHR5cGVzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgQWN0aW9uQ29kZU9wZXJhdGlvbiA9IHtcbiAgICAvKiogVGhlIGVtYWlsIGxpbmsgc2lnbi1pbiBhY3Rpb24uICovXG4gICAgRU1BSUxfU0lHTklOOiAnRU1BSUxfU0lHTklOJyxcbiAgICAvKiogVGhlIHBhc3N3b3JkIHJlc2V0IGFjdGlvbi4gKi9cbiAgICBQQVNTV09SRF9SRVNFVDogJ1BBU1NXT1JEX1JFU0VUJyxcbiAgICAvKiogVGhlIGVtYWlsIHJldm9jYXRpb24gYWN0aW9uLiAqL1xuICAgIFJFQ09WRVJfRU1BSUw6ICdSRUNPVkVSX0VNQUlMJyxcbiAgICAvKiogVGhlIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uIGVtYWlsIGFjdGlvbi4gKi9cbiAgICBSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTjogJ1JFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OJyxcbiAgICAvKiogVGhlIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uIGVtYWlsIGFjdGlvbi4gKi9cbiAgICBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTDogJ1ZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMJyxcbiAgICAvKiogVGhlIGVtYWlsIHZlcmlmaWNhdGlvbiBhY3Rpb24uICovXG4gICAgVkVSSUZZX0VNQUlMOiAnVkVSSUZZX0VNQUlMJ1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9kZWJ1Z0Vycm9yTWFwKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtcImFkbWluLXJlc3RyaWN0ZWQtb3BlcmF0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5BRE1JTl9PTkxZX09QRVJBVElPTiAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyByZXN0cmljdGVkIHRvIGFkbWluaXN0cmF0b3JzIG9ubHkuJyxcbiAgICAgICAgW1wiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovXTogJycsXG4gICAgICAgIFtcImFwcC1ub3QtYXV0aG9yaXplZFwiIC8qIEF1dGhFcnJvckNvZGUuQVBQX05PVF9BVVRIT1JJWkVEICovXTogXCJUaGlzIGFwcCwgaWRlbnRpZmllZCBieSB0aGUgZG9tYWluIHdoZXJlIGl0J3MgaG9zdGVkLCBpcyBub3QgXCIgK1xuICAgICAgICAgICAgJ2F1dGhvcml6ZWQgdG8gdXNlIEZpcmViYXNlIEF1dGhlbnRpY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIEFQSSBrZXkuICcgK1xuICAgICAgICAgICAgJ1JldmlldyB5b3VyIGtleSBjb25maWd1cmF0aW9uIGluIHRoZSBHb29nbGUgQVBJIGNvbnNvbGUuJyxcbiAgICAgICAgW1wiYXBwLW5vdC1pbnN0YWxsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkFQUF9OT1RfSU5TVEFMTEVEICovXTogJ1RoZSByZXF1ZXN0ZWQgbW9iaWxlIGFwcGxpY2F0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlkZW50aWZpZXIgKCcgK1xuICAgICAgICAgICAgJ0FuZHJvaWQgcGFja2FnZSBuYW1lIG9yIGlPUyBidW5kbGUgSUQpIHByb3ZpZGVkIGlzIG5vdCBpbnN0YWxsZWQgb24gJyArXG4gICAgICAgICAgICAndGhpcyBkZXZpY2UuJyxcbiAgICAgICAgW1wiY2FwdGNoYS1jaGVjay1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNBUFRDSEFfQ0hFQ0tfRkFJTEVEICovXTogJ1RoZSByZUNBUFRDSEEgcmVzcG9uc2UgdG9rZW4gcHJvdmlkZWQgaXMgZWl0aGVyIGludmFsaWQsIGV4cGlyZWQsICcgK1xuICAgICAgICAgICAgJ2FscmVhZHkgdXNlZCBvciB0aGUgZG9tYWluIGFzc29jaWF0ZWQgd2l0aCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgbGlzdCAnICtcbiAgICAgICAgICAgICdvZiB3aGl0ZWxpc3RlZCBkb21haW5zLicsXG4gICAgICAgIFtcImNvZGUtZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuQ09ERV9FWFBJUkVEICovXTogJ1RoZSBTTVMgY29kZSBoYXMgZXhwaXJlZC4gUGxlYXNlIHJlLXNlbmQgdGhlIHZlcmlmaWNhdGlvbiBjb2RlIHRvIHRyeSAnICtcbiAgICAgICAgICAgICdhZ2Fpbi4nLFxuICAgICAgICBbXCJjb3Jkb3ZhLW5vdC1yZWFkeVwiIC8qIEF1dGhFcnJvckNvZGUuQ09SRE9WQV9OT1RfUkVBRFkgKi9dOiAnQ29yZG92YSBmcmFtZXdvcmsgaXMgbm90IHJlYWR5LicsXG4gICAgICAgIFtcImNvcnMtdW5zdXBwb3J0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPUlNfVU5TVVBQT1JURUQgKi9dOiAnVGhpcyBicm93c2VyIGlzIG5vdCBzdXBwb3J0ZWQuJyxcbiAgICAgICAgW1wiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9BTFJFQURZX0lOX1VTRSAqL106ICdUaGlzIGNyZWRlbnRpYWwgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHdpdGggYSBkaWZmZXJlbnQgdXNlciBhY2NvdW50LicsXG4gICAgICAgIFtcImN1c3RvbS10b2tlbi1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9NSVNNQVRDSCAqL106ICdUaGUgY3VzdG9tIHRva2VuIGNvcnJlc3BvbmRzIHRvIGEgZGlmZmVyZW50IGF1ZGllbmNlLicsXG4gICAgICAgIFtcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovXTogJ1RoaXMgb3BlcmF0aW9uIGlzIHNlbnNpdGl2ZSBhbmQgcmVxdWlyZXMgcmVjZW50IGF1dGhlbnRpY2F0aW9uLiBMb2cgaW4gJyArXG4gICAgICAgICAgICAnYWdhaW4gYmVmb3JlIHJldHJ5aW5nIHRoaXMgcmVxdWVzdC4nLFxuICAgICAgICBbXCJkZXBlbmRlbnQtc2RrLWluaXRpYWxpemVkLWJlZm9yZS1hdXRoXCIgLyogQXV0aEVycm9yQ29kZS5ERVBFTkRFTlRfU0RLX0lOSVRfQkVGT1JFX0FVVEggKi9dOiAnQW5vdGhlciBGaXJlYmFzZSBTREsgd2FzIGluaXRpYWxpemVkIGFuZCBpcyB0cnlpbmcgdG8gdXNlIEF1dGggYmVmb3JlIEF1dGggaXMgJyArXG4gICAgICAgICAgICAnaW5pdGlhbGl6ZWQuIFBsZWFzZSBiZSBzdXJlIHRvIGNhbGwgYGluaXRpYWxpemVBdXRoYCBvciBgZ2V0QXV0aGAgYmVmb3JlICcgK1xuICAgICAgICAgICAgJ3N0YXJ0aW5nIGFueSBvdGhlciBGaXJlYmFzZSBTREsuJyxcbiAgICAgICAgW1wiZHluYW1pYy1saW5rLW5vdC1hY3RpdmF0ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkRZTkFNSUNfTElOS19OT1RfQUNUSVZBVEVEICovXTogJ1BsZWFzZSBhY3RpdmF0ZSBEeW5hbWljIExpbmtzIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlIGFuZCBhZ3JlZSB0byB0aGUgdGVybXMgYW5kICcgK1xuICAgICAgICAgICAgJ2NvbmRpdGlvbnMuJyxcbiAgICAgICAgW1wiZW1haWwtY2hhbmdlLW5lZWRzLXZlcmlmaWNhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuRU1BSUxfQ0hBTkdFX05FRURTX1ZFUklGSUNBVElPTiAqL106ICdNdWx0aS1mYWN0b3IgdXNlcnMgbXVzdCBhbHdheXMgaGF2ZSBhIHZlcmlmaWVkIGVtYWlsLicsXG4gICAgICAgIFtcImVtYWlsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5FTUFJTF9FWElTVFMgKi9dOiAnVGhlIGVtYWlsIGFkZHJlc3MgaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciBhY2NvdW50LicsXG4gICAgICAgIFtcImVtdWxhdG9yLWNvbmZpZy1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkVNVUxBVE9SX0NPTkZJR19GQUlMRUQgKi9dOiAnQXV0aCBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgdG8gbWFrZSBhIG5ldHdvcmsgY2FsbC4gQXV0aCBjYW4gJyArXG4gICAgICAgICAgICAnbm8gbG9uZ2VyIGJlIGNvbmZpZ3VyZWQgdG8gdXNlIHRoZSBlbXVsYXRvci4gVHJ5IGNhbGxpbmcgJyArXG4gICAgICAgICAgICAnXCJjb25uZWN0QXV0aEVtdWxhdG9yKClcIiBzb29uZXIuJyxcbiAgICAgICAgW1wiZXhwaXJlZC1hY3Rpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuRVhQSVJFRF9PT0JfQ09ERSAqL106ICdUaGUgYWN0aW9uIGNvZGUgaGFzIGV4cGlyZWQuJyxcbiAgICAgICAgW1wiY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3RcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfUE9QVVBfUkVRVUVTVCAqL106ICdUaGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgZHVlIHRvIGFub3RoZXIgY29uZmxpY3RpbmcgcG9wdXAgYmVpbmcgb3BlbmVkLicsXG4gICAgICAgIFtcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgICAgIFtcImludmFsaWQtYXBwLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVBQX0NSRURFTlRJQUwgKi9dOiAnVGhlIHBob25lIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGNvbnRhaW5zIGFuIGludmFsaWQgYXBwbGljYXRpb24gdmVyaWZpZXIuJyArXG4gICAgICAgICAgICAnIFRoZSByZUNBUFRDSEEgdG9rZW4gcmVzcG9uc2UgaXMgZWl0aGVyIGludmFsaWQgb3IgZXhwaXJlZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLWFwcC1pZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUFBfSUQgKi9dOiAnVGhlIG1vYmlsZSBhcHAgaWRlbnRpZmllciBpcyBub3QgcmVnaXN0ZXJlZCBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqL106IFwiVGhpcyB1c2VyJ3MgY3JlZGVudGlhbCBpc24ndCB2YWxpZCBmb3IgdGhpcyBwcm9qZWN0LiBUaGlzIGNhbiBoYXBwZW4gXCIgK1xuICAgICAgICAgICAgXCJpZiB0aGUgdXNlcidzIHRva2VuIGhhcyBiZWVuIHRhbXBlcmVkIHdpdGgsIG9yIGlmIHRoZSB1c2VyIGlzbid0IGZvciBcIiArXG4gICAgICAgICAgICAndGhlIHByb2plY3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVBJIGtleS4nLFxuICAgICAgICBbXCJpbnZhbGlkLWF1dGgtZXZlbnRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSF9FVkVOVCAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgICAgIFtcImludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09ERSAqL106ICdUaGUgU01TIHZlcmlmaWNhdGlvbiBjb2RlIHVzZWQgdG8gY3JlYXRlIHRoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgaXMgJyArXG4gICAgICAgICAgICAnaW52YWxpZC4gUGxlYXNlIHJlc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgc21zIGFuZCBiZSBzdXJlIHRvIHVzZSB0aGUgJyArXG4gICAgICAgICAgICAndmVyaWZpY2F0aW9uIGNvZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIuJyxcbiAgICAgICAgW1wiaW52YWxpZC1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ09OVElOVUVfVVJJICovXTogJ1RoZSBjb250aW51ZSBVUkwgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QgaXMgaW52YWxpZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT04gKi9dOiAnVGhlIGZvbGxvd2luZyBDb3Jkb3ZhIHBsdWdpbnMgbXVzdCBiZSBpbnN0YWxsZWQgdG8gZW5hYmxlIE9BdXRoIHNpZ24taW46ICcgK1xuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWJ1aWxkaW5mbywgY29yZG92YS11bml2ZXJzYWwtbGlua3MtcGx1Z2luLCAnICtcbiAgICAgICAgICAgICdjb3Jkb3ZhLXBsdWdpbi1icm93c2VydGFiLCBjb3Jkb3ZhLXBsdWdpbi1pbmFwcGJyb3dzZXIgYW5kICcgK1xuICAgICAgICAgICAgJ2NvcmRvdmEtcGx1Z2luLWN1c3RvbXVybHNjaGVtZS4nLFxuICAgICAgICBbXCJpbnZhbGlkLWN1c3RvbS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DVVNUT01fVE9LRU4gKi9dOiAnVGhlIGN1c3RvbSB0b2tlbiBmb3JtYXQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgY2hlY2sgdGhlIGRvY3VtZW50YXRpb24uJyxcbiAgICAgICAgW1wiaW52YWxpZC1keW5hbWljLWxpbmstZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0RZTkFNSUNfTElOS19ET01BSU4gKi9dOiAnVGhlIHByb3ZpZGVkIGR5bmFtaWMgbGluayBkb21haW4gaXMgbm90IGNvbmZpZ3VyZWQgb3IgYXV0aG9yaXplZCBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdC4nLFxuICAgICAgICBbXCJpbnZhbGlkLWVtYWlsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNQUlMICovXTogJ1RoZSBlbWFpbCBhZGRyZXNzIGlzIGJhZGx5IGZvcm1hdHRlZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLWVtdWxhdG9yLXNjaGVtZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTVVMQVRPUl9TQ0hFTUUgKi9dOiAnRW11bGF0b3IgVVJMIG11c3Qgc3RhcnQgd2l0aCBhIHZhbGlkIHNjaGVtZSAoaHR0cDovLyBvciBodHRwczovLykuJyxcbiAgICAgICAgW1wiaW52YWxpZC1hcGkta2V5XCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQSV9LRVkgKi9dOiAnWW91ciBBUEkga2V5IGlzIGludmFsaWQsIHBsZWFzZSBjaGVjayB5b3UgaGF2ZSBjb3BpZWQgaXQgY29ycmVjdGx5LicsXG4gICAgICAgIFtcImludmFsaWQtY2VydC1oYXNoXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NFUlRfSEFTSCAqL106ICdUaGUgU0hBLTEgY2VydGlmaWNhdGUgaGFzaCBwcm92aWRlZCBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovXTogJ1RoZSBzdXBwbGllZCBhdXRoIGNyZWRlbnRpYWwgaXMgaW5jb3JyZWN0LCBtYWxmb3JtZWQgb3IgaGFzIGV4cGlyZWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1tZXNzYWdlLXBheWxvYWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRV9QQVlMT0FEICovXTogJ1RoZSBlbWFpbCB0ZW1wbGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyBpbiBpdHMgbWVzc2FnZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIGZpeCBieSBnb2luZyB0byB0aGUgQXV0aCBlbWFpbCB0ZW1wbGF0ZXMgc2VjdGlvbiBpbiB0aGUgRmlyZWJhc2UgQ29uc29sZS4nLFxuICAgICAgICBbXCJpbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX01GQV9TRVNTSU9OICovXTogJ1RoZSByZXF1ZXN0IGRvZXMgbm90IGNvbnRhaW4gYSB2YWxpZCBwcm9vZiBvZiBmaXJzdCBmYWN0b3Igc3VjY2Vzc2Z1bCBzaWduLWluLicsXG4gICAgICAgIFtcImludmFsaWQtb2F1dGgtcHJvdmlkZXJcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT0FVVEhfUFJPVklERVIgKi9dOiAnRW1haWxBdXRoUHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uICcgK1xuICAgICAgICAgICAgJ29ubHkgc3VwcG9ydHMgT0F1dGggcHJvdmlkZXJzLicsXG4gICAgICAgIFtcImludmFsaWQtb2F1dGgtY2xpZW50LWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqL106ICdUaGUgT0F1dGggY2xpZW50IElEIHByb3ZpZGVkIGlzIGVpdGhlciBpbnZhbGlkIG9yIGRvZXMgbm90IG1hdGNoIHRoZSAnICtcbiAgICAgICAgICAgICdzcGVjaWZpZWQgQVBJIGtleS4nLFxuICAgICAgICBbXCJ1bmF1dGhvcml6ZWQtZG9tYWluXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09SSUdJTiAqL106ICdUaGlzIGRvbWFpbiBpcyBub3QgYXV0aG9yaXplZCBmb3IgT0F1dGggb3BlcmF0aW9ucyBmb3IgeW91ciBGaXJlYmFzZSAnICtcbiAgICAgICAgICAgICdwcm9qZWN0LiBFZGl0IHRoZSBsaXN0IG9mIGF1dGhvcml6ZWQgZG9tYWlucyBmcm9tIHRoZSBGaXJlYmFzZSBjb25zb2xlLicsXG4gICAgICAgIFtcImludmFsaWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT09CX0NPREUgKi9dOiAnVGhlIGFjdGlvbiBjb2RlIGlzIGludmFsaWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgY29kZSBpcyBtYWxmb3JtZWQsICcgK1xuICAgICAgICAgICAgJ2V4cGlyZWQsIG9yIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nLFxuICAgICAgICBbXCJ3cm9uZy1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9QQVNTV09SRCAqL106ICdUaGUgcGFzc3dvcmQgaXMgaW52YWxpZCBvciB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgcGFzc3dvcmQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1wZXJzaXN0ZW5jZS10eXBlXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BFUlNJU1RFTkNFICovXTogJ1RoZSBzcGVjaWZpZWQgcGVyc2lzdGVuY2UgdHlwZSBpcyBpbnZhbGlkLiBJdCBjYW4gb25seSBiZSBsb2NhbCwgc2Vzc2lvbiBvciBub25lLicsXG4gICAgICAgIFtcImludmFsaWQtcGhvbmUtbnVtYmVyXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BIT05FX05VTUJFUiAqL106ICdUaGUgZm9ybWF0IG9mIHRoZSBwaG9uZSBudW1iZXIgcHJvdmlkZWQgaXMgaW5jb3JyZWN0LiBQbGVhc2UgZW50ZXIgdGhlICcgK1xuICAgICAgICAgICAgJ3Bob25lIG51bWJlciBpbiBhIGZvcm1hdCB0aGF0IGNhbiBiZSBwYXJzZWQgaW50byBFLjE2NCBmb3JtYXQuIEUuMTY0ICcgK1xuICAgICAgICAgICAgJ3Bob25lIG51bWJlcnMgYXJlIHdyaXR0ZW4gaW4gdGhlIGZvcm1hdCBbK11bY291bnRyeSBjb2RlXVtzdWJzY3JpYmVyICcgK1xuICAgICAgICAgICAgJ251bWJlciBpbmNsdWRpbmcgYXJlYSBjb2RlXS4nLFxuICAgICAgICBbXCJpbnZhbGlkLXByb3ZpZGVyLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1BST1ZJREVSX0lEICovXTogJ1RoZSBzcGVjaWZpZWQgcHJvdmlkZXIgSUQgaXMgaW52YWxpZC4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlY2lwaWVudC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNJUElFTlRfRU1BSUwgKi9dOiAnVGhlIGVtYWlsIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gZmFpbGVkIHRvIHNlbmQgYXMgdGhlIHByb3ZpZGVkICcgK1xuICAgICAgICAgICAgJ3JlY2lwaWVudCBlbWFpbCBhZGRyZXNzIGlzIGludmFsaWQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1zZW5kZXJcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VOREVSICovXTogJ1RoZSBlbWFpbCB0ZW1wbGF0ZSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYWN0aW9uIGNvbnRhaW5zIGFuIGludmFsaWQgc2VuZGVyIGVtYWlsIG9yIG5hbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBmaXggYnkgZ29pbmcgdG8gdGhlIEF1dGggZW1haWwgdGVtcGxhdGVzIHNlY3Rpb24gaW4gdGhlIEZpcmViYXNlIENvbnNvbGUuJyxcbiAgICAgICAgW1wiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfU0VTU0lPTl9JTkZPICovXTogJ1RoZSB2ZXJpZmljYXRpb24gSUQgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLicsXG4gICAgICAgIFtcImludmFsaWQtdGVuYW50LWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1RFTkFOVF9JRCAqL106IFwiVGhlIEF1dGggaW5zdGFuY2UncyB0ZW5hbnQgSUQgaXMgaW52YWxpZC5cIixcbiAgICAgICAgW1wibG9naW4tYmxvY2tlZFwiIC8qIEF1dGhFcnJvckNvZGUuTE9HSU5fQkxPQ0tFRCAqL106ICdMb2dpbiBibG9ja2VkIGJ5IHVzZXItcHJvdmlkZWQgbWV0aG9kOiB7JG9yaWdpbmFsTWVzc2FnZX0nLFxuICAgICAgICBbXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi9dOiAnQW4gQW5kcm9pZCBQYWNrYWdlIE5hbWUgbXVzdCBiZSBwcm92aWRlZCBpZiB0aGUgQW5kcm9pZCBBcHAgaXMgcmVxdWlyZWQgdG8gYmUgaW5zdGFsbGVkLicsXG4gICAgICAgIFtcImF1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19BVVRIX0RPTUFJTiAqL106ICdCZSBzdXJlIHRvIGluY2x1ZGUgYXV0aERvbWFpbiB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLCAnICtcbiAgICAgICAgICAgICdieSBmb2xsb3dpbmcgdGhlIGluc3RydWN0aW9ucyBpbiB0aGUgRmlyZWJhc2UgY29uc29sZS4nLFxuICAgICAgICBbXCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DUkVERU5USUFMICovXTogJ1RoZSBwaG9uZSB2ZXJpZmljYXRpb24gcmVxdWVzdCBpcyBtaXNzaW5nIGFuIGFwcGxpY2F0aW9uIHZlcmlmaWVyICcgK1xuICAgICAgICAgICAgJ2Fzc2VydGlvbi4gQSByZUNBUFRDSEEgcmVzcG9uc2UgdG9rZW4gbmVlZHMgdG8gYmUgcHJvdmlkZWQuJyxcbiAgICAgICAgW1wibWlzc2luZy12ZXJpZmljYXRpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DT0RFICovXTogJ1RoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgd2FzIGNyZWF0ZWQgd2l0aCBhbiBlbXB0eSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUuJyxcbiAgICAgICAgW1wibWlzc2luZy1jb250aW51ZS11cmlcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ09OVElOVUVfVVJJICovXTogJ0EgY29udGludWUgVVJMIG11c3QgYmUgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QuJyxcbiAgICAgICAgW1wibWlzc2luZy1pZnJhbWUtc3RhcnRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfSUZSQU1FX1NUQVJUICovXTogJ0FuIGludGVybmFsIEF1dGhFcnJvciBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wibWlzc2luZy1pb3MtYnVuZGxlLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lPU19CVU5ETEVfSUQgKi9dOiAnQW4gaU9TIEJ1bmRsZSBJRCBtdXN0IGJlIHByb3ZpZGVkIGlmIGFuIEFwcCBTdG9yZSBJRCBpcyBwcm92aWRlZC4nLFxuICAgICAgICBbXCJtaXNzaW5nLW9yLWludmFsaWQtbm9uY2VcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfT1JfSU5WQUxJRF9OT05DRSAqL106ICdUaGUgcmVxdWVzdCBkb2VzIG5vdCBjb250YWluIGEgdmFsaWQgbm9uY2UuIFRoaXMgY2FuIG9jY3VyIGlmIHRoZSAnICtcbiAgICAgICAgICAgICdTSEEtMjU2IGhhc2ggb2YgdGhlIHByb3ZpZGVkIHJhdyBub25jZSBkb2VzIG5vdCBtYXRjaCB0aGUgaGFzaGVkIG5vbmNlICcgK1xuICAgICAgICAgICAgJ2luIHRoZSBJRCB0b2tlbiBwYXlsb2FkLicsXG4gICAgICAgIFtcIm1pc3NpbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUEFTU1dPUkQgKi9dOiAnQSBub24tZW1wdHkgcGFzc3dvcmQgbXVzdCBiZSBwcm92aWRlZCcsXG4gICAgICAgIFtcIm1pc3NpbmctbXVsdGktZmFjdG9yLWluZm9cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX0lORk8gKi9dOiAnTm8gc2Vjb25kIGZhY3RvciBpZGVudGlmaWVyIGlzIHByb3ZpZGVkLicsXG4gICAgICAgIFtcIm1pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfTUZBX1NFU1NJT04gKi9dOiAnVGhlIHJlcXVlc3QgaXMgbWlzc2luZyBwcm9vZiBvZiBmaXJzdCBmYWN0b3Igc3VjY2Vzc2Z1bCBzaWduLWluLicsXG4gICAgICAgIFtcIm1pc3NpbmctcGhvbmUtbnVtYmVyXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BIT05FX05VTUJFUiAqL106ICdUbyBzZW5kIHZlcmlmaWNhdGlvbiBjb2RlcywgcHJvdmlkZSBhIHBob25lIG51bWJlciBmb3IgdGhlIHJlY2lwaWVudC4nLFxuICAgICAgICBbXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19TRVNTSU9OX0lORk8gKi9dOiAnVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IHZlcmlmaWNhdGlvbiBJRC4nLFxuICAgICAgICBbXCJhcHAtZGVsZXRlZFwiIC8qIEF1dGhFcnJvckNvZGUuTU9EVUxFX0RFU1RST1lFRCAqL106ICdUaGlzIGluc3RhbmNlIG9mIEZpcmViYXNlQXBwIGhhcyBiZWVuIGRlbGV0ZWQuJyxcbiAgICAgICAgW1wibXVsdGktZmFjdG9yLWluZm8tbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5NRkFfSU5GT19OT1RfRk9VTkQgKi9dOiAnVGhlIHVzZXIgZG9lcyBub3QgaGF2ZSBhIHNlY29uZCBmYWN0b3IgbWF0Y2hpbmcgdGhlIGlkZW50aWZpZXIgcHJvdmlkZWQuJyxcbiAgICAgICAgW1wibXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCAqL106ICdQcm9vZiBvZiBvd25lcnNoaXAgb2YgYSBzZWNvbmQgZmFjdG9yIGlzIHJlcXVpcmVkIHRvIGNvbXBsZXRlIHNpZ24taW4uJyxcbiAgICAgICAgW1wiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuTkVFRF9DT05GSVJNQVRJT04gKi9dOiAnQW4gYWNjb3VudCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGVtYWlsIGFkZHJlc3MgYnV0IGRpZmZlcmVudCAnICtcbiAgICAgICAgICAgICdzaWduLWluIGNyZWRlbnRpYWxzLiBTaWduIGluIHVzaW5nIGEgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgJyArXG4gICAgICAgICAgICAnZW1haWwgYWRkcmVzcy4nLFxuICAgICAgICBbXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovXTogJ0EgbmV0d29yayBBdXRoRXJyb3IgKHN1Y2ggYXMgdGltZW91dCwgaW50ZXJydXB0ZWQgY29ubmVjdGlvbiBvciB1bnJlYWNoYWJsZSBob3N0KSBoYXMgb2NjdXJyZWQuJyxcbiAgICAgICAgW1wibm8tYXV0aC1ldmVudFwiIC8qIEF1dGhFcnJvckNvZGUuTk9fQVVUSF9FVkVOVCAqL106ICdBbiBpbnRlcm5hbCBBdXRoRXJyb3IgaGFzIG9jY3VycmVkLicsXG4gICAgICAgIFtcIm5vLXN1Y2gtcHJvdmlkZXJcIiAvKiBBdXRoRXJyb3JDb2RlLk5PX1NVQ0hfUFJPVklERVIgKi9dOiAnVXNlciB3YXMgbm90IGxpbmtlZCB0byBhbiBhY2NvdW50IHdpdGggdGhlIGdpdmVuIHByb3ZpZGVyLicsXG4gICAgICAgIFtcIm51bGwtdXNlclwiIC8qIEF1dGhFcnJvckNvZGUuTlVMTF9VU0VSICovXTogJ0EgbnVsbCB1c2VyIG9iamVjdCB3YXMgcHJvdmlkZWQgYXMgdGhlIGFyZ3VtZW50IGZvciBhbiBvcGVyYXRpb24gd2hpY2ggJyArXG4gICAgICAgICAgICAncmVxdWlyZXMgYSBub24tbnVsbCB1c2VyIG9iamVjdC4nLFxuICAgICAgICBbXCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfQUxMT1dFRCAqL106ICdUaGUgZ2l2ZW4gc2lnbi1pbiBwcm92aWRlciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBGaXJlYmFzZSBwcm9qZWN0LiAnICtcbiAgICAgICAgICAgICdFbmFibGUgaXQgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUsIHVuZGVyIHRoZSBzaWduLWluIG1ldGhvZCB0YWIgb2YgdGhlICcgK1xuICAgICAgICAgICAgJ0F1dGggc2VjdGlvbi4nLFxuICAgICAgICBbXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIgLyogQXV0aEVycm9yQ29kZS5PUEVSQVRJT05fTk9UX1NVUFBPUlRFRCAqL106ICdUaGlzIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBlbnZpcm9ubWVudCB0aGlzIGFwcGxpY2F0aW9uIGlzICcgK1xuICAgICAgICAgICAgJ3J1bm5pbmcgb24uIFwibG9jYXRpb24ucHJvdG9jb2xcIiBtdXN0IGJlIGh0dHAsIGh0dHBzIG9yIGNocm9tZS1leHRlbnNpb24nICtcbiAgICAgICAgICAgICcgYW5kIHdlYiBzdG9yYWdlIG11c3QgYmUgZW5hYmxlZC4nLFxuICAgICAgICBbXCJwb3B1cC1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5QT1BVUF9CTE9DS0VEICovXTogJ1VuYWJsZSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHBvcHVwLiBJdCBtYXkgaGF2ZSBiZWVuIGJsb2NrZWQgYnkgdGhlIGJyb3dzZXIuJyxcbiAgICAgICAgW1wicG9wdXAtY2xvc2VkLWJ5LXVzZXJcIiAvKiBBdXRoRXJyb3JDb2RlLlBPUFVQX0NMT1NFRF9CWV9VU0VSICovXTogJ1RoZSBwb3B1cCBoYXMgYmVlbiBjbG9zZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcgdGhlIG9wZXJhdGlvbi4nLFxuICAgICAgICBbXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiIC8qIEF1dGhFcnJvckNvZGUuUFJPVklERVJfQUxSRUFEWV9MSU5LRUQgKi9dOiAnVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuJyxcbiAgICAgICAgW1wicXVvdGEtZXhjZWVkZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlFVT1RBX0VYQ0VFREVEICovXTogXCJUaGUgcHJvamVjdCdzIHF1b3RhIGZvciB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBleGNlZWRlZC5cIixcbiAgICAgICAgW1wicmVkaXJlY3QtY2FuY2VsbGVkLWJ5LXVzZXJcIiAvKiBBdXRoRXJyb3JDb2RlLlJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSICovXTogJ1RoZSByZWRpcmVjdCBvcGVyYXRpb24gaGFzIGJlZW4gY2FuY2VsbGVkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nLicsXG4gICAgICAgIFtcInJlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nXCIgLyogQXV0aEVycm9yQ29kZS5SRURJUkVDVF9PUEVSQVRJT05fUEVORElORyAqL106ICdBIHJlZGlyZWN0IHNpZ24taW4gb3BlcmF0aW9uIGlzIGFscmVhZHkgcGVuZGluZy4nLFxuICAgICAgICBbXCJyZWplY3RlZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5SRUpFQ1RFRF9DUkVERU5USUFMICovXTogJ1RoZSByZXF1ZXN0IGNvbnRhaW5zIG1hbGZvcm1lZCBvciBtaXNtYXRjaGluZyBjcmVkZW50aWFscy4nLFxuICAgICAgICBbXCJzZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQgKi9dOiAnVGhlIHNlY29uZCBmYWN0b3IgaXMgYWxyZWFkeSBlbnJvbGxlZCBvbiB0aGlzIGFjY291bnQuJyxcbiAgICAgICAgW1wibWF4aW11bS1zZWNvbmQtZmFjdG9yLWNvdW50LWV4Y2VlZGVkXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0xJTUlUX0VYQ0VFREVEICovXTogJ1RoZSBtYXhpbXVtIGFsbG93ZWQgbnVtYmVyIG9mIHNlY29uZCBmYWN0b3JzIG9uIGEgdXNlciBoYXMgYmVlbiBleGNlZWRlZC4nLFxuICAgICAgICBbXCJ0ZW5hbnQtaWQtbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlRFTkFOVF9JRF9NSVNNQVRDSCAqL106IFwiVGhlIHByb3ZpZGVkIHRlbmFudCBJRCBkb2VzIG5vdCBtYXRjaCB0aGUgQXV0aCBpbnN0YW5jZSdzIHRlbmFudCBJRFwiLFxuICAgICAgICBbXCJ0aW1lb3V0XCIgLyogQXV0aEVycm9yQ29kZS5USU1FT1VUICovXTogJ1RoZSBvcGVyYXRpb24gaGFzIHRpbWVkIG91dC4nLFxuICAgICAgICBbXCJ1c2VyLXRva2VuLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlRPS0VOX0VYUElSRUQgKi9dOiBcIlRoZSB1c2VyJ3MgY3JlZGVudGlhbCBpcyBubyBsb25nZXIgdmFsaWQuIFRoZSB1c2VyIG11c3Qgc2lnbiBpbiBhZ2Fpbi5cIixcbiAgICAgICAgW1widG9vLW1hbnktcmVxdWVzdHNcIiAvKiBBdXRoRXJyb3JDb2RlLlRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUiAqL106ICdXZSBoYXZlIGJsb2NrZWQgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBkZXZpY2UgZHVlIHRvIHVudXN1YWwgYWN0aXZpdHkuICcgK1xuICAgICAgICAgICAgJ1RyeSBhZ2FpbiBsYXRlci4nLFxuICAgICAgICBbXCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5VTkFVVEhPUklaRURfRE9NQUlOICovXTogJ1RoZSBkb21haW4gb2YgdGhlIGNvbnRpbnVlIFVSTCBpcyBub3Qgd2hpdGVsaXN0ZWQuICBQbGVhc2Ugd2hpdGVsaXN0ICcgK1xuICAgICAgICAgICAgJ3RoZSBkb21haW4gaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuJyxcbiAgICAgICAgW1widW5zdXBwb3J0ZWQtZmlyc3QtZmFjdG9yXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9GSVJTVF9GQUNUT1IgKi9dOiAnRW5yb2xsaW5nIGEgc2Vjb25kIGZhY3RvciBvciBzaWduaW5nIGluIHdpdGggYSBtdWx0aS1mYWN0b3IgYWNjb3VudCByZXF1aXJlcyBzaWduLWluIHdpdGggYSBzdXBwb3J0ZWQgZmlyc3QgZmFjdG9yLicsXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLXBlcnNpc3RlbmNlLXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFICovXTogJ1RoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgdGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlLicsXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLXRlbmFudC1vcGVyYXRpb25cIiAvKiBBdXRoRXJyb3JDb2RlLlVOU1VQUE9SVEVEX1RFTkFOVF9PUEVSQVRJT04gKi9dOiAnVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiBhIG11bHRpLXRlbmFudCBjb250ZXh0LicsXG4gICAgICAgIFtcInVudmVyaWZpZWQtZW1haWxcIiAvKiBBdXRoRXJyb3JDb2RlLlVOVkVSSUZJRURfRU1BSUwgKi9dOiAnVGhlIG9wZXJhdGlvbiByZXF1aXJlcyBhIHZlcmlmaWVkIGVtYWlsLicsXG4gICAgICAgIFtcInVzZXItY2FuY2VsbGVkXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0NBTkNFTExFRCAqL106ICdUaGUgdXNlciBkaWQgbm90IGdyYW50IHlvdXIgYXBwbGljYXRpb24gdGhlIHBlcm1pc3Npb25zIGl0IHJlcXVlc3RlZC4nLFxuICAgICAgICBbXCJ1c2VyLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ERUxFVEVEICovXTogJ1RoZXJlIGlzIG5vIHVzZXIgcmVjb3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpZGVudGlmaWVyLiBUaGUgdXNlciBtYXkgJyArXG4gICAgICAgICAgICAnaGF2ZSBiZWVuIGRlbGV0ZWQuJyxcbiAgICAgICAgW1widXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqL106ICdUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuJyxcbiAgICAgICAgW1widXNlci1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9NSVNNQVRDSCAqL106ICdUaGUgc3VwcGxpZWQgY3JlZGVudGlhbHMgZG8gbm90IGNvcnJlc3BvbmQgdG8gdGhlIHByZXZpb3VzbHkgc2lnbmVkIGluIHVzZXIuJyxcbiAgICAgICAgW1widXNlci1zaWduZWQtb3V0XCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX1NJR05FRF9PVVQgKi9dOiAnJyxcbiAgICAgICAgW1wid2Vhay1wYXNzd29yZFwiIC8qIEF1dGhFcnJvckNvZGUuV0VBS19QQVNTV09SRCAqL106ICdUaGUgcGFzc3dvcmQgbXVzdCBiZSA2IGNoYXJhY3RlcnMgbG9uZyBvciBtb3JlLicsXG4gICAgICAgIFtcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIgLyogQXV0aEVycm9yQ29kZS5XRUJfU1RPUkFHRV9VTlNVUFBPUlRFRCAqL106ICdUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBvciAzcmQgcGFydHkgY29va2llcyBhbmQgZGF0YSBtYXkgYmUgZGlzYWJsZWQuJyxcbiAgICAgICAgW1wiYWxyZWFkeS1pbml0aWFsaXplZFwiIC8qIEF1dGhFcnJvckNvZGUuQUxSRUFEWV9JTklUSUFMSVpFRCAqL106ICdpbml0aWFsaXplQXV0aCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkIHdpdGggJyArXG4gICAgICAgICAgICAnZGlmZmVyZW50IG9wdGlvbnMuIFRvIGF2b2lkIHRoaXMgZXJyb3IsIGNhbGwgaW5pdGlhbGl6ZUF1dGgoKSB3aXRoIHRoZSAnICtcbiAgICAgICAgICAgICdzYW1lIG9wdGlvbnMgYXMgd2hlbiBpdCB3YXMgb3JpZ2luYWxseSBjYWxsZWQsIG9yIGNhbGwgZ2V0QXV0aCgpIHRvIHJldHVybiB0aGUnICtcbiAgICAgICAgICAgICcgYWxyZWFkeSBpbml0aWFsaXplZCBpbnN0YW5jZS4nLFxuICAgICAgICBbXCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi9dOiAnVGhlIHJlQ0FQVENIQSB0b2tlbiBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcImludmFsaWQtcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9UT0tFTiAqL106ICdUaGUgcmVDQVBUQ0hBIHRva2VuIGlzIGludmFsaWQgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1yZWNhcHRjaGEtYWN0aW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9BQ1RJT04gKi9dOiAnVGhlIHJlQ0FQVENIQSBhY3Rpb24gaXMgaW52YWxpZCB3aGVuIHNlbmRpbmcgcmVxdWVzdCB0byB0aGUgYmFja2VuZC4nLFxuICAgICAgICBbXCJyZWNhcHRjaGEtbm90LWVuYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlJFQ0FQVENIQV9OT1RfRU5BQkxFRCAqL106ICdyZUNBUFRDSEEgRW50ZXJwcmlzZSBpbnRlZ3JhdGlvbiBpcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBwcm9qZWN0LicsXG4gICAgICAgIFtcIm1pc3NpbmctY2xpZW50LXR5cGVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQ0xJRU5UX1RZUEUgKi9dOiAnVGhlIHJlQ0FQVENIQSBjbGllbnQgdHlwZSBpcyBtaXNzaW5nIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcIm1pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb25cIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT04gKi9dOiAnVGhlIHJlQ0FQVENIQSB2ZXJzaW9uIGlzIG1pc3Npbmcgd2hlbiBzZW5kaW5nIHJlcXVlc3QgdG8gdGhlIGJhY2tlbmQuJyxcbiAgICAgICAgW1wiaW52YWxpZC1yZXEtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRVFfVFlQRSAqL106ICdJbnZhbGlkIHJlcXVlc3QgcGFyYW1ldGVycy4nLFxuICAgICAgICBbXCJpbnZhbGlkLXJlY2FwdGNoYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OICovXTogJ1RoZSByZUNBUFRDSEEgdmVyc2lvbiBpcyBpbnZhbGlkIHdoZW4gc2VuZGluZyByZXF1ZXN0IHRvIHRoZSBiYWNrZW5kLicsXG4gICAgICAgIFtcInVuc3VwcG9ydGVkLXBhc3N3b3JkLXBvbGljeS1zY2hlbWEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuVU5TVVBQT1JURURfUEFTU1dPUkRfUE9MSUNZX1NDSEVNQV9WRVJTSU9OICovXTogJ1RoZSBwYXNzd29yZCBwb2xpY3kgcmVjZWl2ZWQgZnJvbSB0aGUgYmFja2VuZCB1c2VzIGEgc2NoZW1hIHZlcnNpb24gdGhhdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgRmlyZWJhc2UgU0RLLicsXG4gICAgICAgIFtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL106ICdUaGUgcGFzc3dvcmQgZG9lcyBub3QgbWVldCB0aGUgcmVxdWlyZW1lbnRzLidcbiAgICB9O1xufVxuZnVuY3Rpb24gX3Byb2RFcnJvck1hcCgpIHtcbiAgICAvLyBXZSB3aWxsIGluY2x1ZGUgdGhpcyBvbmUgbWVzc2FnZSBpbiB0aGUgcHJvZCBlcnJvciBtYXAgc2luY2UgYnkgdGhlIHZlcnlcbiAgICAvLyBuYXR1cmUgb2YgdGhpcyBlcnJvciwgZGV2ZWxvcGVycyB3aWxsIG5ldmVyIGJlIGFibGUgdG8gc2VlIHRoZSBtZXNzYWdlXG4gICAgLy8gdXNpbmcgdGhlIGRlYnVnRXJyb3JNYXAgKHdoaWNoIGlzIGluc3RhbGxlZCBkdXJpbmcgYXV0aCBpbml0aWFsaXphdGlvbikuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1wiZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aFwiIC8qIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIICovXTogJ0Fub3RoZXIgRmlyZWJhc2UgU0RLIHdhcyBpbml0aWFsaXplZCBhbmQgaXMgdHJ5aW5nIHRvIHVzZSBBdXRoIGJlZm9yZSBBdXRoIGlzICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemVkLiBQbGVhc2UgYmUgc3VyZSB0byBjYWxsIGBpbml0aWFsaXplQXV0aGAgb3IgYGdldEF1dGhgIGJlZm9yZSAnICtcbiAgICAgICAgICAgICdzdGFydGluZyBhbnkgb3RoZXIgRmlyZWJhc2UgU0RLLidcbiAgICB9O1xufVxuLyoqXG4gKiBBIHZlcmJvc2UgZXJyb3IgbWFwIHdpdGggZGV0YWlsZWQgZGVzY3JpcHRpb25zIGZvciBtb3N0IGVycm9yIGNvZGVzLlxuICpcbiAqIFNlZSBkaXNjdXNzaW9uIGF0IHtAbGluayBBdXRoRXJyb3JNYXB9XG4gKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBkZWJ1Z0Vycm9yTWFwID0gX2RlYnVnRXJyb3JNYXA7XG4vKipcbiAqIEEgbWluaW1hbCBlcnJvciBtYXAgd2l0aCBhbGwgdmVyYm9zZSBlcnJvciBtZXNzYWdlcyBzdHJpcHBlZC5cbiAqXG4gKiBTZWUgZGlzY3Vzc2lvbiBhdCB7QGxpbmsgQXV0aEVycm9yTWFwfVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcHJvZEVycm9yTWFwID0gX3Byb2RFcnJvck1hcDtcbmNvbnN0IF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWSA9IG5ldyBFcnJvckZhY3RvcnkoJ2F1dGgnLCAnRmlyZWJhc2UnLCBfcHJvZEVycm9yTWFwKCkpO1xuLyoqXG4gKiBBIG1hcCBvZiBwb3RlbnRpYWwgYEF1dGhgIGVycm9yIGNvZGVzLCBmb3IgZWFzaWVyIGNvbXBhcmlzb24gd2l0aCBlcnJvcnNcbiAqIHRocm93biBieSB0aGUgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBOb3RlIHRoYXQgeW91IGNhbid0IHRyZWUtc2hha2UgaW5kaXZpZHVhbCBrZXlzXG4gKiBpbiB0aGUgbWFwLCBzbyBieSB1c2luZyB0aGUgbWFwIHlvdSBtaWdodCBzdWJzdGFudGlhbGx5IGluY3JlYXNlIHlvdXJcbiAqIGJ1bmRsZSBzaXplLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgQVVUSF9FUlJPUl9DT0RFU19NQVBfRE9fTk9UX1VTRV9JTlRFUk5BTExZID0ge1xuICAgIEFETUlOX09OTFlfT1BFUkFUSU9OOiAnYXV0aC9hZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvbicsXG4gICAgQVJHVU1FTlRfRVJST1I6ICdhdXRoL2FyZ3VtZW50LWVycm9yJyxcbiAgICBBUFBfTk9UX0FVVEhPUklaRUQ6ICdhdXRoL2FwcC1ub3QtYXV0aG9yaXplZCcsXG4gICAgQVBQX05PVF9JTlNUQUxMRUQ6ICdhdXRoL2FwcC1ub3QtaW5zdGFsbGVkJyxcbiAgICBDQVBUQ0hBX0NIRUNLX0ZBSUxFRDogJ2F1dGgvY2FwdGNoYS1jaGVjay1mYWlsZWQnLFxuICAgIENPREVfRVhQSVJFRDogJ2F1dGgvY29kZS1leHBpcmVkJyxcbiAgICBDT1JET1ZBX05PVF9SRUFEWTogJ2F1dGgvY29yZG92YS1ub3QtcmVhZHknLFxuICAgIENPUlNfVU5TVVBQT1JURUQ6ICdhdXRoL2NvcnMtdW5zdXBwb3J0ZWQnLFxuICAgIENSRURFTlRJQUxfQUxSRUFEWV9JTl9VU0U6ICdhdXRoL2NyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2UnLFxuICAgIENSRURFTlRJQUxfTUlTTUFUQ0g6ICdhdXRoL2N1c3RvbS10b2tlbi1taXNtYXRjaCcsXG4gICAgQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOiAnYXV0aC9yZXF1aXJlcy1yZWNlbnQtbG9naW4nLFxuICAgIERFUEVOREVOVF9TREtfSU5JVF9CRUZPUkVfQVVUSDogJ2F1dGgvZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aCcsXG4gICAgRFlOQU1JQ19MSU5LX05PVF9BQ1RJVkFURUQ6ICdhdXRoL2R5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkJyxcbiAgICBFTUFJTF9DSEFOR0VfTkVFRFNfVkVSSUZJQ0FUSU9OOiAnYXV0aC9lbWFpbC1jaGFuZ2UtbmVlZHMtdmVyaWZpY2F0aW9uJyxcbiAgICBFTUFJTF9FWElTVFM6ICdhdXRoL2VtYWlsLWFscmVhZHktaW4tdXNlJyxcbiAgICBFTVVMQVRPUl9DT05GSUdfRkFJTEVEOiAnYXV0aC9lbXVsYXRvci1jb25maWctZmFpbGVkJyxcbiAgICBFWFBJUkVEX09PQl9DT0RFOiAnYXV0aC9leHBpcmVkLWFjdGlvbi1jb2RlJyxcbiAgICBFWFBJUkVEX1BPUFVQX1JFUVVFU1Q6ICdhdXRoL2NhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0JyxcbiAgICBJTlRFUk5BTF9FUlJPUjogJ2F1dGgvaW50ZXJuYWwtZXJyb3InLFxuICAgIElOVkFMSURfQVBJX0tFWTogJ2F1dGgvaW52YWxpZC1hcGkta2V5JyxcbiAgICBJTlZBTElEX0FQUF9DUkVERU5USUFMOiAnYXV0aC9pbnZhbGlkLWFwcC1jcmVkZW50aWFsJyxcbiAgICBJTlZBTElEX0FQUF9JRDogJ2F1dGgvaW52YWxpZC1hcHAtaWQnLFxuICAgIElOVkFMSURfQVVUSDogJ2F1dGgvaW52YWxpZC11c2VyLXRva2VuJyxcbiAgICBJTlZBTElEX0FVVEhfRVZFTlQ6ICdhdXRoL2ludmFsaWQtYXV0aC1ldmVudCcsXG4gICAgSU5WQUxJRF9DRVJUX0hBU0g6ICdhdXRoL2ludmFsaWQtY2VydC1oYXNoJyxcbiAgICBJTlZBTElEX0NPREU6ICdhdXRoL2ludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGUnLFxuICAgIElOVkFMSURfQ09OVElOVUVfVVJJOiAnYXV0aC9pbnZhbGlkLWNvbnRpbnVlLXVyaScsXG4gICAgSU5WQUxJRF9DT1JET1ZBX0NPTkZJR1VSQVRJT046ICdhdXRoL2ludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uJyxcbiAgICBJTlZBTElEX0NVU1RPTV9UT0tFTjogJ2F1dGgvaW52YWxpZC1jdXN0b20tdG9rZW4nLFxuICAgIElOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTjogJ2F1dGgvaW52YWxpZC1keW5hbWljLWxpbmstZG9tYWluJyxcbiAgICBJTlZBTElEX0VNQUlMOiAnYXV0aC9pbnZhbGlkLWVtYWlsJyxcbiAgICBJTlZBTElEX0VNVUxBVE9SX1NDSEVNRTogJ2F1dGgvaW52YWxpZC1lbXVsYXRvci1zY2hlbWUnLFxuICAgIElOVkFMSURfSURQX1JFU1BPTlNFOiAnYXV0aC9pbnZhbGlkLWNyZWRlbnRpYWwnLFxuICAgIElOVkFMSURfTE9HSU5fQ1JFREVOVElBTFM6ICdhdXRoL2ludmFsaWQtY3JlZGVudGlhbCcsXG4gICAgSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6ICdhdXRoL2ludmFsaWQtbWVzc2FnZS1wYXlsb2FkJyxcbiAgICBJTlZBTElEX01GQV9TRVNTSU9OOiAnYXV0aC9pbnZhbGlkLW11bHRpLWZhY3Rvci1zZXNzaW9uJyxcbiAgICBJTlZBTElEX09BVVRIX0NMSUVOVF9JRDogJ2F1dGgvaW52YWxpZC1vYXV0aC1jbGllbnQtaWQnLFxuICAgIElOVkFMSURfT0FVVEhfUFJPVklERVI6ICdhdXRoL2ludmFsaWQtb2F1dGgtcHJvdmlkZXInLFxuICAgIElOVkFMSURfT09CX0NPREU6ICdhdXRoL2ludmFsaWQtYWN0aW9uLWNvZGUnLFxuICAgIElOVkFMSURfT1JJR0lOOiAnYXV0aC91bmF1dGhvcml6ZWQtZG9tYWluJyxcbiAgICBJTlZBTElEX1BBU1NXT1JEOiAnYXV0aC93cm9uZy1wYXNzd29yZCcsXG4gICAgSU5WQUxJRF9QRVJTSVNURU5DRTogJ2F1dGgvaW52YWxpZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgICBJTlZBTElEX1BIT05FX05VTUJFUjogJ2F1dGgvaW52YWxpZC1waG9uZS1udW1iZXInLFxuICAgIElOVkFMSURfUFJPVklERVJfSUQ6ICdhdXRoL2ludmFsaWQtcHJvdmlkZXItaWQnLFxuICAgIElOVkFMSURfUkVDSVBJRU5UX0VNQUlMOiAnYXV0aC9pbnZhbGlkLXJlY2lwaWVudC1lbWFpbCcsXG4gICAgSU5WQUxJRF9TRU5ERVI6ICdhdXRoL2ludmFsaWQtc2VuZGVyJyxcbiAgICBJTlZBTElEX1NFU1NJT05fSU5GTzogJ2F1dGgvaW52YWxpZC12ZXJpZmljYXRpb24taWQnLFxuICAgIElOVkFMSURfVEVOQU5UX0lEOiAnYXV0aC9pbnZhbGlkLXRlbmFudC1pZCcsXG4gICAgTUZBX0lORk9fTk9UX0ZPVU5EOiAnYXV0aC9tdWx0aS1mYWN0b3ItaW5mby1ub3QtZm91bmQnLFxuICAgIE1GQV9SRVFVSVJFRDogJ2F1dGgvbXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWQnLFxuICAgIE1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUU6ICdhdXRoL21pc3NpbmctYW5kcm9pZC1wa2ctbmFtZScsXG4gICAgTUlTU0lOR19BUFBfQ1JFREVOVElBTDogJ2F1dGgvbWlzc2luZy1hcHAtY3JlZGVudGlhbCcsXG4gICAgTUlTU0lOR19BVVRIX0RPTUFJTjogJ2F1dGgvYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkJyxcbiAgICBNSVNTSU5HX0NPREU6ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGUnLFxuICAgIE1JU1NJTkdfQ09OVElOVUVfVVJJOiAnYXV0aC9taXNzaW5nLWNvbnRpbnVlLXVyaScsXG4gICAgTUlTU0lOR19JRlJBTUVfU1RBUlQ6ICdhdXRoL21pc3NpbmctaWZyYW1lLXN0YXJ0JyxcbiAgICBNSVNTSU5HX0lPU19CVU5ETEVfSUQ6ICdhdXRoL21pc3NpbmctaW9zLWJ1bmRsZS1pZCcsXG4gICAgTUlTU0lOR19PUl9JTlZBTElEX05PTkNFOiAnYXV0aC9taXNzaW5nLW9yLWludmFsaWQtbm9uY2UnLFxuICAgIE1JU1NJTkdfTUZBX0lORk86ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLWluZm8nLFxuICAgIE1JU1NJTkdfTUZBX1NFU1NJT046ICdhdXRoL21pc3NpbmctbXVsdGktZmFjdG9yLXNlc3Npb24nLFxuICAgIE1JU1NJTkdfUEhPTkVfTlVNQkVSOiAnYXV0aC9taXNzaW5nLXBob25lLW51bWJlcicsXG4gICAgTUlTU0lOR19TRVNTSU9OX0lORk86ICdhdXRoL21pc3NpbmctdmVyaWZpY2F0aW9uLWlkJyxcbiAgICBNT0RVTEVfREVTVFJPWUVEOiAnYXV0aC9hcHAtZGVsZXRlZCcsXG4gICAgTkVFRF9DT05GSVJNQVRJT046ICdhdXRoL2FjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWwnLFxuICAgIE5FVFdPUktfUkVRVUVTVF9GQUlMRUQ6ICdhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWQnLFxuICAgIE5VTExfVVNFUjogJ2F1dGgvbnVsbC11c2VyJyxcbiAgICBOT19BVVRIX0VWRU5UOiAnYXV0aC9uby1hdXRoLWV2ZW50JyxcbiAgICBOT19TVUNIX1BST1ZJREVSOiAnYXV0aC9uby1zdWNoLXByb3ZpZGVyJyxcbiAgICBPUEVSQVRJT05fTk9UX0FMTE9XRUQ6ICdhdXRoL29wZXJhdGlvbi1ub3QtYWxsb3dlZCcsXG4gICAgT1BFUkFUSU9OX05PVF9TVVBQT1JURUQ6ICdhdXRoL29wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnQnLFxuICAgIFBPUFVQX0JMT0NLRUQ6ICdhdXRoL3BvcHVwLWJsb2NrZWQnLFxuICAgIFBPUFVQX0NMT1NFRF9CWV9VU0VSOiAnYXV0aC9wb3B1cC1jbG9zZWQtYnktdXNlcicsXG4gICAgUFJPVklERVJfQUxSRUFEWV9MSU5LRUQ6ICdhdXRoL3Byb3ZpZGVyLWFscmVhZHktbGlua2VkJyxcbiAgICBRVU9UQV9FWENFRURFRDogJ2F1dGgvcXVvdGEtZXhjZWVkZWQnLFxuICAgIFJFRElSRUNUX0NBTkNFTExFRF9CWV9VU0VSOiAnYXV0aC9yZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlcicsXG4gICAgUkVESVJFQ1RfT1BFUkFUSU9OX1BFTkRJTkc6ICdhdXRoL3JlZGlyZWN0LW9wZXJhdGlvbi1wZW5kaW5nJyxcbiAgICBSRUpFQ1RFRF9DUkVERU5USUFMOiAnYXV0aC9yZWplY3RlZC1jcmVkZW50aWFsJyxcbiAgICBTRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQ6ICdhdXRoL3NlY29uZC1mYWN0b3ItYWxyZWFkeS1pbi11c2UnLFxuICAgIFNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQ6ICdhdXRoL21heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZCcsXG4gICAgVEVOQU5UX0lEX01JU01BVENIOiAnYXV0aC90ZW5hbnQtaWQtbWlzbWF0Y2gnLFxuICAgIFRJTUVPVVQ6ICdhdXRoL3RpbWVvdXQnLFxuICAgIFRPS0VOX0VYUElSRUQ6ICdhdXRoL3VzZXItdG9rZW4tZXhwaXJlZCcsXG4gICAgVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSOiAnYXV0aC90b28tbWFueS1yZXF1ZXN0cycsXG4gICAgVU5BVVRIT1JJWkVEX0RPTUFJTjogJ2F1dGgvdW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaScsXG4gICAgVU5TVVBQT1JURURfRklSU1RfRkFDVE9SOiAnYXV0aC91bnN1cHBvcnRlZC1maXJzdC1mYWN0b3InLFxuICAgIFVOU1VQUE9SVEVEX1BFUlNJU1RFTkNFOiAnYXV0aC91bnN1cHBvcnRlZC1wZXJzaXN0ZW5jZS10eXBlJyxcbiAgICBVTlNVUFBPUlRFRF9URU5BTlRfT1BFUkFUSU9OOiAnYXV0aC91bnN1cHBvcnRlZC10ZW5hbnQtb3BlcmF0aW9uJyxcbiAgICBVTlZFUklGSUVEX0VNQUlMOiAnYXV0aC91bnZlcmlmaWVkLWVtYWlsJyxcbiAgICBVU0VSX0NBTkNFTExFRDogJ2F1dGgvdXNlci1jYW5jZWxsZWQnLFxuICAgIFVTRVJfREVMRVRFRDogJ2F1dGgvdXNlci1ub3QtZm91bmQnLFxuICAgIFVTRVJfRElTQUJMRUQ6ICdhdXRoL3VzZXItZGlzYWJsZWQnLFxuICAgIFVTRVJfTUlTTUFUQ0g6ICdhdXRoL3VzZXItbWlzbWF0Y2gnLFxuICAgIFVTRVJfU0lHTkVEX09VVDogJ2F1dGgvdXNlci1zaWduZWQtb3V0JyxcbiAgICBXRUFLX1BBU1NXT1JEOiAnYXV0aC93ZWFrLXBhc3N3b3JkJyxcbiAgICBXRUJfU1RPUkFHRV9VTlNVUFBPUlRFRDogJ2F1dGgvd2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWQnLFxuICAgIEFMUkVBRFlfSU5JVElBTElaRUQ6ICdhdXRoL2FscmVhZHktaW5pdGlhbGl6ZWQnLFxuICAgIFJFQ0FQVENIQV9OT1RfRU5BQkxFRDogJ2F1dGgvcmVjYXB0Y2hhLW5vdC1lbmFibGVkJyxcbiAgICBNSVNTSU5HX1JFQ0FQVENIQV9UT0tFTjogJ2F1dGgvbWlzc2luZy1yZWNhcHRjaGEtdG9rZW4nLFxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1RPS0VOOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS10b2tlbicsXG4gICAgSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OOiAnYXV0aC9pbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb24nLFxuICAgIE1JU1NJTkdfQ0xJRU5UX1RZUEU6ICdhdXRoL21pc3NpbmctY2xpZW50LXR5cGUnLFxuICAgIE1JU1NJTkdfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL21pc3NpbmctcmVjYXB0Y2hhLXZlcnNpb24nLFxuICAgIElOVkFMSURfUkVDQVBUQ0hBX1ZFUlNJT046ICdhdXRoL2ludmFsaWQtcmVjYXB0Y2hhLXZlcnNpb24nLFxuICAgIElOVkFMSURfUkVRX1RZUEU6ICdhdXRoL2ludmFsaWQtcmVxLXR5cGUnXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbG9nQ2xpZW50ID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2F1dGgnKTtcbmZ1bmN0aW9uIF9sb2dXYXJuKG1zZywgLi4uYXJncykge1xuICAgIGlmIChsb2dDbGllbnQubG9nTGV2ZWwgPD0gTG9nTGV2ZWwuV0FSTikge1xuICAgICAgICBsb2dDbGllbnQud2FybihgQXV0aCAoJHtTREtfVkVSU0lPTn0pOiAke21zZ31gLCAuLi5hcmdzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfbG9nRXJyb3IobXNnLCAuLi5hcmdzKSB7XG4gICAgaWYgKGxvZ0NsaWVudC5sb2dMZXZlbCA8PSBMb2dMZXZlbC5FUlJPUikge1xuICAgICAgICBsb2dDbGllbnQuZXJyb3IoYEF1dGggKCR7U0RLX1ZFUlNJT059KTogJHttc2d9YCwgLi4uYXJncyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX2ZhaWwoYXV0aE9yQ29kZSwgLi4ucmVzdCkge1xuICAgIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBfY3JlYXRlRXJyb3IoYXV0aE9yQ29kZSwgLi4ucmVzdCkge1xuICAgIHJldHVybiBjcmVhdGVFcnJvckludGVybmFsKGF1dGhPckNvZGUsIC4uLnJlc3QpO1xufVxuZnVuY3Rpb24gX2Vycm9yV2l0aEN1c3RvbU1lc3NhZ2UoYXV0aCwgY29kZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yTWFwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9kRXJyb3JNYXAoKSksIHsgW2NvZGVdOiBtZXNzYWdlIH0pO1xuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXApO1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZShjb2RlLCB7XG4gICAgICAgIGFwcE5hbWU6IGF1dGgubmFtZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkge1xuICAgIHJldHVybiBfZXJyb3JXaXRoQ3VzdG9tTWVzc2FnZShhdXRoLCBcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfU1VQUE9SVEVEICovLCAnT3BlcmF0aW9ucyB0aGF0IGFsdGVyIHRoZSBjdXJyZW50IHVzZXIgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gY29uanVuY3Rpb24gd2l0aCBGaXJlYmFzZVNlcnZlckFwcCcpO1xufVxuZnVuY3Rpb24gY3JlYXRlRXJyb3JJbnRlcm5hbChhdXRoT3JDb2RlLCAuLi5yZXN0KSB7XG4gICAgaWYgKHR5cGVvZiBhdXRoT3JDb2RlICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjb2RlID0gcmVzdFswXTtcbiAgICAgICAgY29uc3QgZnVsbFBhcmFtcyA9IFsuLi5yZXN0LnNsaWNlKDEpXTtcbiAgICAgICAgaWYgKGZ1bGxQYXJhbXNbMF0pIHtcbiAgICAgICAgICAgIGZ1bGxQYXJhbXNbMF0uYXBwTmFtZSA9IGF1dGhPckNvZGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aE9yQ29kZS5fZXJyb3JGYWN0b3J5LmNyZWF0ZShjb2RlLCAuLi5mdWxsUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIF9ERUZBVUxUX0FVVEhfRVJST1JfRkFDVE9SWS5jcmVhdGUoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG59XG5mdW5jdGlvbiBfYXNzZXJ0KGFzc2VydGlvbiwgYXV0aE9yQ29kZSwgLi4ucmVzdCkge1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9ySW50ZXJuYWwoYXV0aE9yQ29kZSwgLi4ucmVzdCk7XG4gICAgfVxufVxuLyoqXG4gKiBVbmNvbmRpdGlvbmFsbHkgZmFpbHMsIHRocm93aW5nIGFuIGludGVybmFsIGVycm9yIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGZhaWx1cmUgdHlwZSBvZiBmYWlsdXJlIGVuY291bnRlcmVkXG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cbmZ1bmN0aW9uIGRlYnVnRmFpbChmYWlsdXJlKSB7XG4gICAgLy8gTG9nIHRoZSBmYWlsdXJlIGluIGFkZGl0aW9uIHRvIHRocm93IGFuIGV4Y2VwdGlvbiwganVzdCBpbiBjYXNlIHRoZVxuICAgIC8vIGV4Y2VwdGlvbiBpcyBzd2FsbG93ZWQuXG4gICAgY29uc3QgbWVzc2FnZSA9IGBJTlRFUk5BTCBBU1NFUlRJT04gRkFJTEVEOiBgICsgZmFpbHVyZTtcbiAgICBfbG9nRXJyb3IobWVzc2FnZSk7XG4gICAgLy8gTk9URTogV2UgZG9uJ3QgdXNlIEZpcmViYXNlRXJyb3IgaGVyZSBiZWNhdXNlIHRoZXNlIGFyZSBpbnRlcm5hbCBmYWlsdXJlc1xuICAgIC8vIHRoYXQgY2Fubm90IGJlIGhhbmRsZWQgYnkgdGhlIHVzZXIuIChBbHNvIGl0IHdvdWxkIGNyZWF0ZSBhIGNpcmN1bGFyXG4gICAgLy8gZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSBlcnJvciBhbmQgYXNzZXJ0IG1vZHVsZXMgd2hpY2ggZG9lc24ndCB3b3JrLilcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4vKipcbiAqIEZhaWxzIGlmIHRoZSBnaXZlbiBhc3NlcnRpb24gY29uZGl0aW9uIGlzIGZhbHNlLCB0aHJvd2luZyBhbiBFcnJvciB3aXRoIHRoZVxuICogZ2l2ZW4gbWVzc2FnZSBpZiBpdCBkaWQuXG4gKlxuICogQHBhcmFtIGFzc2VydGlvblxuICogQHBhcmFtIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZGVidWdBc3NlcnQoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgZGVidWdGYWlsKG1lc3NhZ2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIF9nZXRDdXJyZW50VXJsKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gc2VsZi5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSB8fCAnJztcbn1cbmZ1bmN0aW9uIF9pc0h0dHBPckh0dHBzKCkge1xuICAgIHJldHVybiBfZ2V0Q3VycmVudFNjaGVtZSgpID09PSAnaHR0cDonIHx8IF9nZXRDdXJyZW50U2NoZW1lKCkgPT09ICdodHRwczonO1xufVxuZnVuY3Rpb24gX2dldEN1cnJlbnRTY2hlbWUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBzZWxmLmxvY2F0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvdG9jb2wpKSB8fCBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgYnJvd3NlciBpcyB3b3JraW5nIG9ubGluZVxuICovXG5mdW5jdGlvbiBfaXNPbmxpbmUoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvciAmJlxuICAgICAgICAnb25MaW5lJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvci5vbkxpbmUgPT09ICdib29sZWFuJyAmJlxuICAgICAgICAvLyBBcHBseSBvbmx5IGZvciB0cmFkaXRpb25hbCB3ZWIgYXBwcyBhbmQgQ2hyb21lIGV4dGVuc2lvbnMuXG4gICAgICAgIC8vIFRoaXMgaXMgZXNwZWNpYWxseSB0cnVlIGZvciBDb3Jkb3ZhIGFwcHMgd2hpY2ggaGF2ZSB1bnJlbGlhYmxlXG4gICAgICAgIC8vIG5hdmlnYXRvci5vbkxpbmUgYmVoYXZpb3IgdW5sZXNzIGNvcmRvdmEtcGx1Z2luLW5ldHdvcmstaW5mb3JtYXRpb24gaXNcbiAgICAgICAgLy8gaW5zdGFsbGVkIHdoaWNoIG92ZXJ3cml0ZXMgdGhlIG5hdGl2ZSBuYXZpZ2F0b3Iub25MaW5lIHZhbHVlIGFuZFxuICAgICAgICAvLyBkZWZpbmVzIG5hdmlnYXRvci5jb25uZWN0aW9uLlxuICAgICAgICAoX2lzSHR0cE9ySHR0cHMoKSB8fCBpc0Jyb3dzZXJFeHRlbnNpb24oKSB8fCAnY29ubmVjdGlvbicgaW4gbmF2aWdhdG9yKSkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcbiAgICB9XG4gICAgLy8gSWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBzdGF0ZSwgYXNzdW1lIGl0IGlzIG9ubGluZS5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9nZXRVc2VyTGFuZ3VhZ2UoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBuYXZpZ2F0b3JMYW5ndWFnZSA9IG5hdmlnYXRvcjtcbiAgICByZXR1cm4gKFxuICAgIC8vIE1vc3QgcmVsaWFibGUsIGJ1dCBvbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWUvRmlyZWZveC5cbiAgICAobmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2VzICYmIG5hdmlnYXRvckxhbmd1YWdlLmxhbmd1YWdlc1swXSkgfHxcbiAgICAgICAgLy8gU3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZXR1cm5zIHRoZSBsYW5ndWFnZSBvZiB0aGUgYnJvd3NlclxuICAgICAgICAvLyBVSSwgbm90IHRoZSBsYW5ndWFnZSBzZXQgaW4gYnJvd3NlciBzZXR0aW5ncy5cbiAgICAgICAgbmF2aWdhdG9yTGFuZ3VhZ2UubGFuZ3VhZ2UgfHxcbiAgICAgICAgLy8gQ291bGRuJ3QgZGV0ZXJtaW5lIGxhbmd1YWdlLlxuICAgICAgICBudWxsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSBzdHJ1Y3R1cmUgdG8gaGVscCBwaWNrIGJldHdlZW4gYSByYW5nZSBvZiBsb25nIGFuZCBzaG9ydCBkZWxheSBkdXJhdGlvbnNcbiAqIGRlcGVuZGluZyBvbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gSW4gZ2VuZXJhbCwgdGhlIGxvbmcgZGVsYXkgaXMgdXNlZCBmb3JcbiAqIG1vYmlsZSBlbnZpcm9ubWVudHMgd2hlcmVhcyBzaG9ydCBkZWxheXMgYXJlIHVzZWQgZm9yIGRlc2t0b3AgZW52aXJvbm1lbnRzLlxuICovXG5jbGFzcyBEZWxheSB7XG4gICAgY29uc3RydWN0b3Ioc2hvcnREZWxheSwgbG9uZ0RlbGF5KSB7XG4gICAgICAgIHRoaXMuc2hvcnREZWxheSA9IHNob3J0RGVsYXk7XG4gICAgICAgIHRoaXMubG9uZ0RlbGF5ID0gbG9uZ0RlbGF5O1xuICAgICAgICAvLyBJbnRlcm5hbCBlcnJvciB3aGVuIGltcHJvcGVybHkgaW5pdGlhbGl6ZWQuXG4gICAgICAgIGRlYnVnQXNzZXJ0KGxvbmdEZWxheSA+IHNob3J0RGVsYXksICdTaG9ydCBkZWxheSBzaG91bGQgYmUgbGVzcyB0aGFuIGxvbmcgZGVsYXkhJyk7XG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSBpc01vYmlsZUNvcmRvdmEoKSB8fCBpc1JlYWN0TmF0aXZlKCk7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgaWYgKCFfaXNPbmxpbmUoKSkge1xuICAgICAgICAgICAgLy8gUGljayB0aGUgc2hvcnRlciB0aW1lb3V0LlxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKDUwMDAgLyogRGVsYXlNaW4uT0ZGTElORSAqLywgdGhpcy5zaG9ydERlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBydW5uaW5nIGluIGEgbW9iaWxlIGVudmlyb25tZW50LCByZXR1cm4gdGhlIGxvbmcgZGVsYXksIG90aGVyd2lzZVxuICAgICAgICAvLyByZXR1cm4gdGhlIHNob3J0IGRlbGF5LlxuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGltcHJvdmVkIGluIHRoZSBmdXR1cmUgdG8gZHluYW1pY2FsbHkgY2hhbmdlIGJhc2VkIG9uIG90aGVyXG4gICAgICAgIC8vIHZhcmlhYmxlcyBpbnN0ZWFkIG9mIGp1c3QgcmVhZGluZyB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNNb2JpbGUgPyB0aGlzLmxvbmdEZWxheSA6IHRoaXMuc2hvcnREZWxheTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfZW11bGF0b3JVcmwoY29uZmlnLCBwYXRoKSB7XG4gICAgZGVidWdBc3NlcnQoY29uZmlnLmVtdWxhdG9yLCAnRW11bGF0b3Igc2hvdWxkIGFsd2F5cyBiZSBzZXQgaGVyZScpO1xuICAgIGNvbnN0IHsgdXJsIH0gPSBjb25maWcuZW11bGF0b3I7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHJldHVybiBgJHt1cmx9JHtwYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdGguc2xpY2UoMSkgOiBwYXRofWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBGZXRjaFByb3ZpZGVyIHtcbiAgICBzdGF0aWMgaW5pdGlhbGl6ZShmZXRjaEltcGwsIGhlYWRlcnNJbXBsLCByZXNwb25zZUltcGwpIHtcbiAgICAgICAgdGhpcy5mZXRjaEltcGwgPSBmZXRjaEltcGw7XG4gICAgICAgIGlmIChoZWFkZXJzSW1wbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzSW1wbCA9IGhlYWRlcnNJbXBsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZUltcGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VJbXBsID0gcmVzcG9uc2VJbXBsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmZXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAnZmV0Y2gnIGluIHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmZldGNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5mZXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaDtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Z0ZhaWwoJ0NvdWxkIG5vdCBmaW5kIGZldGNoIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xuICAgIH1cbiAgICBzdGF0aWMgaGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlcnNJbXBsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ0hlYWRlcnMnIGluIHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLkhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLkhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzLkhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBIZWFkZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIEhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBIZWFkZXJzIGltcGxlbWVudGF0aW9uLCBtYWtlIHN1cmUgeW91IGNhbGwgRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKCkgd2l0aCBhbiBhcHByb3ByaWF0ZSBwb2x5ZmlsbCcpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzcG9uc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbXBsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1Jlc3BvbnNlJyBpbiBzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5SZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzLlJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWdGYWlsKCdDb3VsZCBub3QgZmluZCBSZXNwb25zZSBpbXBsZW1lbnRhdGlvbiwgbWFrZSBzdXJlIHlvdSBjYWxsIEZldGNoUHJvdmlkZXIuaW5pdGlhbGl6ZSgpIHdpdGggYW4gYXBwcm9wcmlhdGUgcG9seWZpbGwnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE1hcCBmcm9tIGVycm9ycyByZXR1cm5lZCBieSB0aGUgc2VydmVyIHRvIGVycm9ycyB0byBkZXZlbG9wZXIgdmlzaWJsZSBlcnJvcnNcbiAqL1xuY29uc3QgU0VSVkVSX0VSUk9SX01BUCA9IHtcbiAgICAvLyBDdXN0b20gdG9rZW4gZXJyb3JzLlxuICAgIFtcIkNSRURFTlRJQUxfTUlTTUFUQ0hcIiAvKiBTZXJ2ZXJFcnJvci5DUkVERU5USUFMX01JU01BVENIICovXTogXCJjdXN0b20tdG9rZW4tbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLkNSRURFTlRJQUxfTUlTTUFUQ0ggKi8sXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICAgIFtcIk1JU1NJTkdfQ1VTVE9NX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DVVNUT01fVE9LRU4gKi9dOiBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyxcbiAgICAvLyBDcmVhdGUgQXV0aCBVUkkgZXJyb3JzLlxuICAgIFtcIklOVkFMSURfSURFTlRJRklFUlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfSURFTlRJRklFUiAqL106IFwiaW52YWxpZC1lbWFpbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9FTUFJTCAqLyxcbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgU0RLIHNlbmRzIGEgYmFkIHJlcXVlc3QuXG4gICAgW1wiTUlTU0lOR19DT05USU5VRV9VUklcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX0NPTlRJTlVFX1VSSSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxuICAgIC8vIFNpZ24gaW4gd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgZXJyb3JzIChzb21lIGFwcGx5IHRvIHNpZ24gdXAgdG9vKS5cbiAgICBbXCJJTlZBTElEX1BBU1NXT1JEXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9QQVNTV09SRCAqL106IFwid3JvbmctcGFzc3dvcmRcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUEFTU1dPUkQgKi8sXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICAgIFtcIk1JU1NJTkdfUEFTU1dPUkRcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX1BBU1NXT1JEICovXTogXCJtaXNzaW5nLXBhc3N3b3JkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1BBU1NXT1JEICovLFxuICAgIC8vIFRocm93biBpZiBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9uIGlzIGVuYWJsZWQgaW4gdGhlIHByb2plY3QgYW5kIHRoZSBlbWFpbCBvciBwYXNzd29yZCBpc1xuICAgIC8vIGludmFsaWQuXG4gICAgW1wiSU5WQUxJRF9MT0dJTl9DUkVERU5USUFMU1wiIC8qIFNlcnZlckVycm9yLklOVkFMSURfTE9HSU5fQ1JFREVOVElBTFMgKi9dOiBcImludmFsaWQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DUkVERU5USUFMICovLFxuICAgIC8vIFNpZ24gdXAgd2l0aCBlbWFpbCBhbmQgcGFzc3dvcmQgZXJyb3JzLlxuICAgIFtcIkVNQUlMX0VYSVNUU1wiIC8qIFNlcnZlckVycm9yLkVNQUlMX0VYSVNUUyAqL106IFwiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqLyxcbiAgICBbXCJQQVNTV09SRF9MT0dJTl9ESVNBQkxFRFwiIC8qIFNlcnZlckVycm9yLlBBU1NXT1JEX0xPR0lOX0RJU0FCTEVEICovXTogXCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk9QRVJBVElPTl9OT1RfQUxMT1dFRCAqLyxcbiAgICAvLyBWZXJpZnkgYXNzZXJ0aW9uIGZvciBzaWduIGluIHdpdGggY3JlZGVudGlhbCBlcnJvcnM6XG4gICAgW1wiSU5WQUxJRF9JRFBfUkVTUE9OU0VcIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0lEUF9SRVNQT05TRSAqL106IFwiaW52YWxpZC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NSRURFTlRJQUwgKi8sXG4gICAgW1wiSU5WQUxJRF9QRU5ESU5HX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9QRU5ESU5HX1RPS0VOICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcbiAgICBbXCJGRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRFwiIC8qIFNlcnZlckVycm9yLkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEICovXTogXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovLFxuICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBTREsgc2VuZHMgYSBiYWQgcmVxdWVzdC5cbiAgICBbXCJNSVNTSU5HX1JFUV9UWVBFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRVFfVFlQRSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxuICAgIC8vIFNlbmQgUGFzc3dvcmQgcmVzZXQgZW1haWwgZXJyb3JzOlxuICAgIFtcIkVNQUlMX05PVF9GT1VORFwiIC8qIFNlcnZlckVycm9yLkVNQUlMX05PVF9GT1VORCAqL106IFwidXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqLyxcbiAgICBbXCJSRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVRcIiAvKiBTZXJ2ZXJFcnJvci5SRVNFVF9QQVNTV09SRF9FWENFRURfTElNSVQgKi9dOiBcInRvby1tYW55LXJlcXVlc3RzXCIgLyogQXV0aEVycm9yQ29kZS5UT09fTUFOWV9BVFRFTVBUU19UUllfTEFURVIgKi8sXG4gICAgW1wiRVhQSVJFRF9PT0JfQ09ERVwiIC8qIFNlcnZlckVycm9yLkVYUElSRURfT09CX0NPREUgKi9dOiBcImV4cGlyZWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLkVYUElSRURfT09CX0NPREUgKi8sXG4gICAgW1wiSU5WQUxJRF9PT0JfQ09ERVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfT09CX0NPREUgKi9dOiBcImludmFsaWQtYWN0aW9uLWNvZGVcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfT09CX0NPREUgKi8sXG4gICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIFNESyBzZW5kcyBhIGJhZCByZXF1ZXN0LlxuICAgIFtcIk1JU1NJTkdfT09CX0NPREVcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX09PQl9DT0RFICovXTogXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8sXG4gICAgLy8gT3BlcmF0aW9ucyB0aGF0IHJlcXVpcmUgSUQgdG9rZW4gaW4gcmVxdWVzdDpcbiAgICBbXCJDUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU5cIiAvKiBTZXJ2ZXJFcnJvci5DUkVERU5USUFMX1RPT19PTERfTE9HSU5fQUdBSU4gKi9dOiBcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiIC8qIEF1dGhFcnJvckNvZGUuQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOICovLFxuICAgIFtcIklOVkFMSURfSURfVE9LRU5cIiAvKiBTZXJ2ZXJFcnJvci5JTlZBTElEX0lEX1RPS0VOICovXTogXCJpbnZhbGlkLXVzZXItdG9rZW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQVVUSCAqLyxcbiAgICBbXCJUT0tFTl9FWFBJUkVEXCIgLyogU2VydmVyRXJyb3IuVE9LRU5fRVhQSVJFRCAqL106IFwidXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovLFxuICAgIFtcIlVTRVJfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkQgKi9dOiBcInVzZXItdG9rZW4tZXhwaXJlZFwiIC8qIEF1dGhFcnJvckNvZGUuVE9LRU5fRVhQSVJFRCAqLyxcbiAgICAvLyBPdGhlciBlcnJvcnMuXG4gICAgW1wiVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSXCIgLyogU2VydmVyRXJyb3IuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovXTogXCJ0b28tbWFueS1yZXF1ZXN0c1wiIC8qIEF1dGhFcnJvckNvZGUuVE9PX01BTllfQVRURU1QVFNfVFJZX0xBVEVSICovLFxuICAgIFtcIlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTXCIgLyogU2VydmVyRXJyb3IuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi9dOiBcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqLyxcbiAgICAvLyBQaG9uZSBBdXRoIHJlbGF0ZWQgZXJyb3JzLlxuICAgIFtcIklOVkFMSURfQ09ERVwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfQ09ERSAqL106IFwiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9DT0RFICovLFxuICAgIFtcIklOVkFMSURfU0VTU0lPTl9JTkZPXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9TRVNTSU9OX0lORk8gKi9dOiBcImludmFsaWQtdmVyaWZpY2F0aW9uLWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX1NFU1NJT05fSU5GTyAqLyxcbiAgICBbXCJJTlZBTElEX1RFTVBPUkFSWV9QUk9PRlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfVEVNUE9SQVJZX1BST09GICovXTogXCJpbnZhbGlkLWNyZWRlbnRpYWxcIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfQ1JFREVOVElBTCAqLyxcbiAgICBbXCJNSVNTSU5HX1NFU1NJT05fSU5GT1wiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfU0VTU0lPTl9JTkZPICovXTogXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19TRVNTSU9OX0lORk8gKi8sXG4gICAgW1wiU0VTU0lPTl9FWFBJUkVEXCIgLyogU2VydmVyRXJyb3IuU0VTU0lPTl9FWFBJUkVEICovXTogXCJjb2RlLWV4cGlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLkNPREVfRVhQSVJFRCAqLyxcbiAgICAvLyBPdGhlciBhY3Rpb24gY29kZSBlcnJvcnMgd2hlbiBhZGRpdGlvbmFsIHNldHRpbmdzIHBhc3NlZC5cbiAgICAvLyBNSVNTSU5HX0NPTlRJTlVFX1VSSSBpcyBnZXR0aW5nIG1hcHBlZCB0byBJTlRFUk5BTF9FUlJPUiBhYm92ZS5cbiAgICAvLyBUaGlzIGlzIE9LIGFzIHRoaXMgZXJyb3Igd2lsbCBiZSBjYXVnaHQgYnkgY2xpZW50IHNpZGUgdmFsaWRhdGlvbi5cbiAgICBbXCJNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19BTkRST0lEX1BBQ0tBR0VfTkFNRSAqL106IFwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FICovLFxuICAgIFtcIlVOQVVUSE9SSVpFRF9ET01BSU5cIiAvKiBTZXJ2ZXJFcnJvci5VTkFVVEhPUklaRURfRE9NQUlOICovXTogXCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5VTkFVVEhPUklaRURfRE9NQUlOICovLFxuICAgIC8vIGdldFByb2plY3RDb25maWcgZXJyb3JzIHdoZW4gY2xpZW50SWQgaXMgcGFzc2VkLlxuICAgIFtcIklOVkFMSURfT0FVVEhfQ0xJRU5UX0lEXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9PQVVUSF9DTElFTlRfSUQgKi9dOiBcImludmFsaWQtb2F1dGgtY2xpZW50LWlkXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX09BVVRIX0NMSUVOVF9JRCAqLyxcbiAgICAvLyBVc2VyIGFjdGlvbnMgKHNpZ24tdXAgb3IgZGVsZXRpb24pIGRpc2FibGVkIGVycm9ycy5cbiAgICBbXCJBRE1JTl9PTkxZX09QRVJBVElPTlwiIC8qIFNlcnZlckVycm9yLkFETUlOX09OTFlfT1BFUkFUSU9OICovXTogXCJhZG1pbi1yZXN0cmljdGVkLW9wZXJhdGlvblwiIC8qIEF1dGhFcnJvckNvZGUuQURNSU5fT05MWV9PUEVSQVRJT04gKi8sXG4gICAgLy8gTXVsdGkgZmFjdG9yIHJlbGF0ZWQgZXJyb3JzLlxuICAgIFtcIklOVkFMSURfTUZBX1BFTkRJTkdfQ1JFREVOVElBTFwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfTUZBX1BFTkRJTkdfQ1JFREVOVElBTCAqL106IFwiaW52YWxpZC1tdWx0aS1mYWN0b3Itc2Vzc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9NRkFfU0VTU0lPTiAqLyxcbiAgICBbXCJNRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkRcIiAvKiBTZXJ2ZXJFcnJvci5NRkFfRU5ST0xMTUVOVF9OT1RfRk9VTkQgKi9dOiBcIm11bHRpLWZhY3Rvci1pbmZvLW5vdC1mb3VuZFwiIC8qIEF1dGhFcnJvckNvZGUuTUZBX0lORk9fTk9UX0ZPVU5EICovLFxuICAgIFtcIk1JU1NJTkdfTUZBX0VOUk9MTE1FTlRfSURcIiAvKiBTZXJ2ZXJFcnJvci5NSVNTSU5HX01GQV9FTlJPTExNRU5UX0lEICovXTogXCJtaXNzaW5nLW11bHRpLWZhY3Rvci1pbmZvXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX01GQV9JTkZPICovLFxuICAgIFtcIk1JU1NJTkdfTUZBX1BFTkRJTkdfQ1JFREVOVElBTFwiIC8qIFNlcnZlckVycm9yLk1JU1NJTkdfTUZBX1BFTkRJTkdfQ1JFREVOVElBTCAqL106IFwibWlzc2luZy1tdWx0aS1mYWN0b3Itc2Vzc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19NRkFfU0VTU0lPTiAqLyxcbiAgICBbXCJTRUNPTkRfRkFDVE9SX0VYSVNUU1wiIC8qIFNlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfRVhJU1RTICovXTogXCJzZWNvbmQtZmFjdG9yLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5TRUNPTkRfRkFDVE9SX0FMUkVBRFlfRU5ST0xMRUQgKi8sXG4gICAgW1wiU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRFwiIC8qIFNlcnZlckVycm9yLlNFQ09ORF9GQUNUT1JfTElNSVRfRVhDRUVERUQgKi9dOiBcIm1heGltdW0tc2Vjb25kLWZhY3Rvci1jb3VudC1leGNlZWRlZFwiIC8qIEF1dGhFcnJvckNvZGUuU0VDT05EX0ZBQ1RPUl9MSU1JVF9FWENFRURFRCAqLyxcbiAgICAvLyBCbG9ja2luZyBmdW5jdGlvbnMgcmVsYXRlZCBlcnJvcnMuXG4gICAgW1wiQkxPQ0tJTkdfRlVOQ1RJT05fRVJST1JfUkVTUE9OU0VcIiAvKiBTZXJ2ZXJFcnJvci5CTE9DS0lOR19GVU5DVElPTl9FUlJPUl9SRVNQT05TRSAqL106IFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLFxuICAgIC8vIFJlY2FwdGNoYSByZWxhdGVkIGVycm9ycy5cbiAgICBbXCJSRUNBUFRDSEFfTk9UX0VOQUJMRURcIiAvKiBTZXJ2ZXJFcnJvci5SRUNBUFRDSEFfTk9UX0VOQUJMRUQgKi9dOiBcInJlY2FwdGNoYS1ub3QtZW5hYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuUkVDQVBUQ0hBX05PVF9FTkFCTEVEICovLFxuICAgIFtcIk1JU1NJTkdfUkVDQVBUQ0hBX1RPS0VOXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi9dOiBcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqLyxcbiAgICBbXCJJTlZBTElEX1JFQ0FQVENIQV9UT0tFTlwiIC8qIFNlcnZlckVycm9yLklOVkFMSURfUkVDQVBUQ0hBX1RPS0VOICovXTogXCJpbnZhbGlkLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVE9LRU4gKi8sXG4gICAgW1wiSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfQUNUSU9OICovXTogXCJpbnZhbGlkLXJlY2FwdGNoYS1hY3Rpb25cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfUkVDQVBUQ0hBX0FDVElPTiAqLyxcbiAgICBbXCJNSVNTSU5HX0NMSUVOVF9UWVBFXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19DTElFTlRfVFlQRSAqL106IFwibWlzc2luZy1jbGllbnQtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19DTElFTlRfVFlQRSAqLyxcbiAgICBbXCJNSVNTSU5HX1JFQ0FQVENIQV9WRVJTSU9OXCIgLyogU2VydmVyRXJyb3IuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqL106IFwibWlzc2luZy1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVkVSU0lPTiAqLyxcbiAgICBbXCJJTlZBTElEX1JFQ0FQVENIQV9WRVJTSU9OXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTiAqL106IFwiaW52YWxpZC1yZWNhcHRjaGEtdmVyc2lvblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRUNBUFRDSEFfVkVSU0lPTiAqLyxcbiAgICBbXCJJTlZBTElEX1JFUV9UWVBFXCIgLyogU2VydmVyRXJyb3IuSU5WQUxJRF9SRVFfVFlQRSAqL106IFwiaW52YWxpZC1yZXEtdHlwZVwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9SRVFfVFlQRSAqL1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfQVBJX1RJTUVPVVRfTVMgPSBuZXcgRGVsYXkoMzAwMDAsIDYwMDAwKTtcbmZ1bmN0aW9uIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSB7XG4gICAgaWYgKGF1dGgudGVuYW50SWQgJiYgIXJlcXVlc3QudGVuYW50SWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgdGVuYW50SWQ6IGF1dGgudGVuYW50SWQgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0O1xufVxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXAgPSB7fSkge1xuICAgIHJldHVybiBfcGVyZm9ybUZldGNoV2l0aEVycm9ySGFuZGxpbmcoYXV0aCwgY3VzdG9tRXJyb3JNYXAsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGV0IGJvZHkgPSB7fTtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJHRVRcIiAvKiBIdHRwTWV0aG9kLkdFVCAqLykge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHJlcXVlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2R5ID0ge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnkgPSBxdWVyeXN0cmluZyhPYmplY3QuYXNzaWduKHsga2V5OiBhdXRoLmNvbmZpZy5hcGlLZXkgfSwgcGFyYW1zKSkuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBhdXRoLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCIgLyogSHR0cEhlYWRlci5DT05URU5UX1RZUEUgKi9dID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICBpZiAoYXV0aC5sYW5ndWFnZUNvZGUpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUxvY2FsZVwiIC8qIEh0dHBIZWFkZXIuWF9GSVJFQkFTRV9MT0NBTEUgKi9dID0gYXV0aC5sYW5ndWFnZUNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmV0Y2hBcmdzID0gT2JqZWN0LmFzc2lnbih7IG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMgfSwgYm9keSk7XG4gICAgICAgIC8qIFNlY3VyaXR5LWNvbnNjaW91cyBzZXJ2ZXItc2lkZSBmcmFtZXdvcmtzIHRlbmQgdG8gaGF2ZSBidWlsdCBpbiBtaXRpZ2F0aW9ucyBmb3IgcmVmZXJyZXJcbiAgICAgICAgICAgcHJvYmxlbXNcIi4gU2VlIHRoZSBDbG91ZGZsYXJlIEdpdEh1YiBpc3N1ZSAjNDg3OiBFcnJvcjogVGhlICdyZWZlcnJlclBvbGljeScgZmllbGQgb25cbiAgICAgICAgICAgJ1JlcXVlc3RJbml0aWFsaXplckRpY3QnIGlzIG5vdCBpbXBsZW1lbnRlZC5cIlxuICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS9uZXh0LW9uLXBhZ2VzL2lzc3Vlcy80ODcgKi9cbiAgICAgICAgaWYgKCFpc0Nsb3VkZmxhcmVXb3JrZXIoKSkge1xuICAgICAgICAgICAgZmV0Y2hBcmdzLnJlZmVycmVyUG9saWN5ID0gJ25vLXJlZmVycmVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRmV0Y2hQcm92aWRlci5mZXRjaCgpKF9nZXRGaW5hbFRhcmdldChhdXRoLCBhdXRoLmNvbmZpZy5hcGlIb3N0LCBwYXRoLCBxdWVyeSksIGZldGNoQXJncyk7XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBfcGVyZm9ybUZldGNoV2l0aEVycm9ySGFuZGxpbmcoYXV0aCwgY3VzdG9tRXJyb3JNYXAsIGZldGNoRm4pIHtcbiAgICBhdXRoLl9jYW5Jbml0RW11bGF0b3IgPSBmYWxzZTtcbiAgICBjb25zdCBlcnJvck1hcCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgU0VSVkVSX0VSUk9SX01BUCksIGN1c3RvbUVycm9yTWFwKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXR3b3JrVGltZW91dCA9IG5ldyBOZXR3b3JrVGltZW91dChhdXRoKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgZmV0Y2hGbigpLFxuICAgICAgICAgICAgbmV0d29ya1RpbWVvdXQucHJvbWlzZVxuICAgICAgICBdKTtcbiAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGlzIHBvaW50LCB0aGUgZmV0Y2ggc3VjY2VlZGVkIGFuZCB0aGUgbmV0d29ya1RpbWVvdXRcbiAgICAgICAgLy8gZGlkbid0IHRocm93OyBjbGVhciB0aGUgbmV0d29yayB0aW1lb3V0IGRlbGF5IHNvIHRoYXQgTm9kZSB3b24ndCBoYW5nXG4gICAgICAgIG5ldHdvcmtUaW1lb3V0LmNsZWFyTmV0d29ya1RpbWVvdXQoKTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKCduZWVkQ29uZmlybWF0aW9uJyBpbiBqc29uKSB7XG4gICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuTkVFRF9DT05GSVJNQVRJT04gKi8sIGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAhKCdlcnJvck1lc3NhZ2UnIGluIGpzb24pKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLm9rID8ganNvbi5lcnJvck1lc3NhZ2UgOiBqc29uLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICBjb25zdCBbc2VydmVyRXJyb3JDb2RlLCBzZXJ2ZXJFcnJvck1lc3NhZ2VdID0gZXJyb3JNZXNzYWdlLnNwbGl0KCcgOiAnKTtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRURcIiAvKiBTZXJ2ZXJFcnJvci5GRURFUkFURURfVVNFUl9JRF9BTFJFQURZX0xJTktFRCAqLykge1xuICAgICAgICAgICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIgLyogQXV0aEVycm9yQ29kZS5DUkVERU5USUFMX0FMUkVBRFlfSU5fVVNFICovLCBqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlcnZlckVycm9yQ29kZSA9PT0gXCJFTUFJTF9FWElTVFNcIiAvKiBTZXJ2ZXJFcnJvci5FTUFJTF9FWElTVFMgKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwiZW1haWwtYWxyZWFkeS1pbi11c2VcIiAvKiBBdXRoRXJyb3JDb2RlLkVNQUlMX0VYSVNUUyAqLywganNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJFcnJvckNvZGUgPT09IFwiVVNFUl9ESVNBQkxFRFwiIC8qIFNlcnZlckVycm9yLlVTRVJfRElTQUJMRUQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfbWFrZVRhZ2dlZEVycm9yKGF1dGgsIFwidXNlci1kaXNhYmxlZFwiIC8qIEF1dGhFcnJvckNvZGUuVVNFUl9ESVNBQkxFRCAqLywganNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRoRXJyb3IgPSBlcnJvck1hcFtzZXJ2ZXJFcnJvckNvZGVdIHx8XG4gICAgICAgICAgICAgICAgc2VydmVyRXJyb3JDb2RlXG4gICAgICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bX1xcc10rL2csICctJyk7XG4gICAgICAgICAgICBpZiAoc2VydmVyRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2Vycm9yV2l0aEN1c3RvbU1lc3NhZ2UoYXV0aCwgYXV0aEVycm9yLCBzZXJ2ZXJFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2ZhaWwoYXV0aCwgYXV0aEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hhbmdpbmcgdGhpcyB0byBhIGRpZmZlcmVudCBlcnJvciBjb2RlIHdpbGwgbG9nIHVzZXIgb3V0IHdoZW4gdGhlcmUgaXMgYSBuZXR3b3JrIGVycm9yXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgdHJlYXQgYW55IGVycm9yIG90aGVyIHRoYW4gTkVUV09SS19SRVFVRVNUX0ZBSUxFRCBhcyB0b2tlbiBpcyBpbnZhbGlkLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2Jsb2IvNGZiYzczNjEwZDcwYmU0ZTA4NTJlN2RlNjNhMzljYjc4OTdlODU0Ni9wYWNrYWdlcy9hdXRoL3NyYy9jb3JlL2F1dGgvYXV0aF9pbXBsLnRzI0wzMDktTDMxNlxuICAgICAgICBfZmFpbChhdXRoLCBcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi8sIHsgJ21lc3NhZ2UnOiBTdHJpbmcoZSkgfSk7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXAgPSB7fSkge1xuICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gYXdhaXQgX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIG1ldGhvZCwgcGF0aCwgcmVxdWVzdCwgY3VzdG9tRXJyb3JNYXApO1xuICAgIGlmICgnbWZhUGVuZGluZ0NyZWRlbnRpYWwnIGluIHNlcnZlclJlc3BvbnNlKSB7XG4gICAgICAgIF9mYWlsKGF1dGgsIFwibXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCAqLywge1xuICAgICAgICAgICAgX3NlcnZlclJlc3BvbnNlOiBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcnZlclJlc3BvbnNlO1xufVxuZnVuY3Rpb24gX2dldEZpbmFsVGFyZ2V0KGF1dGgsIGhvc3QsIHBhdGgsIHF1ZXJ5KSB7XG4gICAgY29uc3QgYmFzZSA9IGAke2hvc3R9JHtwYXRofT8ke3F1ZXJ5fWA7XG4gICAgaWYgKCFhdXRoLmNvbmZpZy5lbXVsYXRvcikge1xuICAgICAgICByZXR1cm4gYCR7YXV0aC5jb25maWcuYXBpU2NoZW1lfTovLyR7YmFzZX1gO1xuICAgIH1cbiAgICByZXR1cm4gX2VtdWxhdG9yVXJsKGF1dGguY29uZmlnLCBiYXNlKTtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVuZm9yY2VtZW50U3RhdGUoZW5mb3JjZW1lbnRTdGF0ZVN0cikge1xuICAgIHN3aXRjaCAoZW5mb3JjZW1lbnRTdGF0ZVN0cikge1xuICAgICAgICBjYXNlICdFTkZPUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBcIkVORk9SQ0VcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0UgKi87XG4gICAgICAgIGNhc2UgJ0FVRElUJzpcbiAgICAgICAgICAgIHJldHVybiBcIkFVRElUXCIgLyogRW5mb3JjZW1lbnRTdGF0ZS5BVURJVCAqLztcbiAgICAgICAgY2FzZSAnT0ZGJzpcbiAgICAgICAgICAgIHJldHVybiBcIk9GRlwiIC8qIEVuZm9yY2VtZW50U3RhdGUuT0ZGICovO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiRU5GT1JDRU1FTlRfU1RBVEVfVU5TUEVDSUZJRURcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0VNRU5UX1NUQVRFX1VOU1BFQ0lGSUVEICovO1xuICAgIH1cbn1cbmNsYXNzIE5ldHdvcmtUaW1lb3V0IHtcbiAgICBjbGVhck5ldHdvcmtUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgLy8gTm9kZSB0aW1lcnMgYW5kIGJyb3dzZXIgdGltZXJzIGFyZSBmdW5kYW1lbnRhbGx5IGluY29tcGF0aWJsZSwgYnV0IHdlXG4gICAgICAgIC8vIGRvbid0IGNhcmUgYWJvdXQgdGhlIHZhbHVlIGhlcmVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KF9jcmVhdGVFcnJvcih0aGlzLmF1dGgsIFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuTkVUV09SS19SRVFVRVNUX0ZBSUxFRCAqLykpO1xuICAgICAgICAgICAgfSwgREVGQVVMVF9BUElfVElNRU9VVF9NUy5nZXQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgY29kZSwgcmVzcG9uc2UpIHtcbiAgICBjb25zdCBlcnJvclBhcmFtcyA9IHtcbiAgICAgICAgYXBwTmFtZTogYXV0aC5uYW1lXG4gICAgfTtcbiAgICBpZiAocmVzcG9uc2UuZW1haWwpIHtcbiAgICAgICAgZXJyb3JQYXJhbXMuZW1haWwgPSByZXNwb25zZS5lbWFpbDtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnBob25lTnVtYmVyKSB7XG4gICAgICAgIGVycm9yUGFyYW1zLnBob25lTnVtYmVyID0gcmVzcG9uc2UucGhvbmVOdW1iZXI7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yID0gX2NyZWF0ZUVycm9yKGF1dGgsIGNvZGUsIGVycm9yUGFyYW1zKTtcbiAgICAvLyBXZSBrbm93IGN1c3RvbURhdGEgaXMgZGVmaW5lZCBvbiBlcnJvciBiZWNhdXNlIGVycm9yUGFyYW1zIGlzIGRlZmluZWRcbiAgICBlcnJvci5jdXN0b21EYXRhLl90b2tlblJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gaXNFbnRlcnByaXNlKGdyZWNhcHRjaGEpIHtcbiAgICByZXR1cm4gKGdyZWNhcHRjaGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBncmVjYXB0Y2hhLmVudGVycHJpc2UgIT09IHVuZGVmaW5lZCk7XG59XG5jbGFzcyBSZWNhcHRjaGFDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKHJlc3BvbnNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVDQVBUQ0hBIHNpdGUga2V5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXRlS2V5ID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBwcm92aWRlcnMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdHVzIGZvciByZUNBUFRDSEEgRW50ZXJwcmlzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSA9IFtdO1xuICAgICAgICBpZiAocmVzcG9uc2UucmVjYXB0Y2hhS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjYXB0Y2hhS2V5IHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4YW1wbGUgcmVzcG9uc2UucmVjYXB0Y2hhS2V5OiBcInByb2plY3RzL3Byb2oxMjMva2V5cy9zaXRla2V5MTIzXCJcbiAgICAgICAgdGhpcy5zaXRlS2V5ID0gcmVzcG9uc2UucmVjYXB0Y2hhS2V5LnNwbGl0KCcvJylbM107XG4gICAgICAgIHRoaXMucmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZSA9IHJlc3BvbnNlLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJTdHIgLSBUaGUgcHJvdmlkZXIgd2hvc2UgZW5mb3JjZW1lbnQgc3RhdGUgaXMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJlQ0FQVENIQSBFbnRlcnByaXNlIGVuZm9yY2VtZW50IHN0YXRlIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXG4gICAgICovXG4gICAgZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlIHx8XG4gICAgICAgICAgICB0aGlzLnJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUgb2YgdGhpcy5yZWNhcHRjaGFFbmZvcmNlbWVudFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAocmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5wcm92aWRlciAmJlxuICAgICAgICAgICAgICAgIHJlY2FwdGNoYUVuZm9yY2VtZW50U3RhdGUucHJvdmlkZXIgPT09IHByb3ZpZGVyU3RyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVuZm9yY2VtZW50U3RhdGUocmVjYXB0Y2hhRW5mb3JjZW1lbnRTdGF0ZS5lbmZvcmNlbWVudFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByZUNBUFRDSEEgRW50ZXJwcmlzZSBlbmZvcmNlbWVudCBzdGF0ZSBmb3IgdGhlIHByb3ZpZGVyIGlzIHNldCB0byBFTkZPUkNFIG9yIEFVRElULlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyU3RyIC0gVGhlIHByb3ZpZGVyIHdob3NlIGVuYWJsZW1lbnQgc3RhdGUgaXMgdG8gYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybnMgV2hldGhlciBvciBub3QgcmVDQVBUQ0hBIEVudGVycHJpc2UgcHJvdGVjdGlvbiBpcyBlbmFibGVkIGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXG4gICAgICovXG4gICAgaXNQcm92aWRlckVuYWJsZWQocHJvdmlkZXJTdHIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFByb3ZpZGVyRW5mb3JjZW1lbnRTdGF0ZShwcm92aWRlclN0cikgPT09XG4gICAgICAgICAgICBcIkVORk9SQ0VcIiAvKiBFbmZvcmNlbWVudFN0YXRlLkVORk9SQ0UgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKHByb3ZpZGVyU3RyKSA9PT0gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgcmVDQVBUQ0hBIEVudGVycHJpc2UgcHJvdGVjdGlvbiBpcyBlbmFibGVkIGluIGF0IGxlYXN0IG9uZSBwcm92aWRlciwgb3RoZXJ3aXNlXG4gICAgICogcmV0dXJucyBmYWxzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHJlQ0FQVENIQSBFbnRlcnByaXNlIHByb3RlY3Rpb24gaXMgZW5hYmxlZCBmb3IgYXQgbGVhc3Qgb25lIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIGlzQW55UHJvdmlkZXJFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNQcm92aWRlckVuYWJsZWQoXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLykgfHxcbiAgICAgICAgICAgIHRoaXMuaXNQcm92aWRlckVuYWJsZWQoXCJQSE9ORV9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5QSE9ORV9QUk9WSURFUiAqLykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIkdFVFwiIC8qIEh0dHBNZXRob2QuR0VUICovLCBcIi92Mi9yZWNhcHRjaGFDb25maWdcIiAvKiBFbmRwb2ludC5HRVRfUkVDQVBUQ0hBX0NPTkZJRyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFjY291bnQoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpkZWxldGVcIiAvKiBFbmRwb2ludC5ERUxFVEVfQUNDT1VOVCAqLywgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWxldGVMaW5rZWRBY2NvdW50cyhhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QWNjb3VudEluZm8oYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpsb29rdXBcIiAvKiBFbmRwb2ludC5HRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHV0Y1RpbWVzdGFtcFRvRGF0ZVN0cmluZyh1dGNUaW1lc3RhbXApIHtcbiAgICBpZiAoIXV0Y1RpbWVzdGFtcCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBDb252ZXJ0IHRvIGRhdGUgb2JqZWN0LlxuICAgICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHV0Y1RpbWVzdGFtcCkpO1xuICAgICAgICAvLyBUZXN0IGRhdGUgaXMgdmFsaWQuXG4gICAgICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIFVUQyBkYXRlIHN0cmluZy5cbiAgICAgICAgICAgIHJldHVybiBkYXRlLnRvVVRDU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZy4gdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBKU09OIFdlYiBUb2tlbiAoSldUKSB1c2VkIHRvIGlkZW50aWZ5IHRoZSB1c2VyIHRvIGEgRmlyZWJhc2Ugc2VydmljZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogUmV0dXJucyB0aGUgY3VycmVudCB0b2tlbiBpZiBpdCBoYXMgbm90IGV4cGlyZWQgb3IgaWYgaXQgd2lsbCBub3QgZXhwaXJlIGluIHRoZSBuZXh0IGZpdmVcbiAqIG1pbnV0ZXMuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHJlZnJlc2ggdGhlIHRva2VuIGFuZCByZXR1cm4gYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRJZFRva2VuKHVzZXIsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBkZXNlcmlhbGl6ZWQgSlNPTiBXZWIgVG9rZW4gKEpXVCkgdXNlZCB0byBpZGVudGlmeSB0aGUgdXNlciB0byBhIEZpcmViYXNlIHNlcnZpY2UuXG4gKlxuICogQHJlbWFya3NcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdG9rZW4gaWYgaXQgaGFzIG5vdCBleHBpcmVkIG9yIGlmIGl0IHdpbGwgbm90IGV4cGlyZSBpbiB0aGUgbmV4dCBmaXZlXG4gKiBtaW51dGVzLiBPdGhlcndpc2UsIHRoaXMgd2lsbCByZWZyZXNoIHRoZSB0b2tlbiBhbmQgcmV0dXJuIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGZvcmNlUmVmcmVzaCAtIEZvcmNlIHJlZnJlc2ggcmVnYXJkbGVzcyBvZiB0b2tlbiBleHBpcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SWRUb2tlblJlc3VsdCh1c2VyLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKGZvcmNlUmVmcmVzaCk7XG4gICAgY29uc3QgY2xhaW1zID0gX3BhcnNlVG9rZW4odG9rZW4pO1xuICAgIF9hc3NlcnQoY2xhaW1zICYmIGNsYWltcy5leHAgJiYgY2xhaW1zLmF1dGhfdGltZSAmJiBjbGFpbXMuaWF0LCB1c2VySW50ZXJuYWwuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIGNvbnN0IGZpcmViYXNlID0gdHlwZW9mIGNsYWltcy5maXJlYmFzZSA9PT0gJ29iamVjdCcgPyBjbGFpbXMuZmlyZWJhc2UgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2lnbkluUHJvdmlkZXIgPSBmaXJlYmFzZSA9PT0gbnVsbCB8fCBmaXJlYmFzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyZWJhc2VbJ3NpZ25faW5fcHJvdmlkZXInXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFpbXMsXG4gICAgICAgIHRva2VuLFxuICAgICAgICBhdXRoVGltZTogdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhjbGFpbXMuYXV0aF90aW1lKSksXG4gICAgICAgIGlzc3VlZEF0VGltZTogdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHNlY29uZHNTdHJpbmdUb01pbGxpc2Vjb25kcyhjbGFpbXMuaWF0KSksXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcoc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKGNsYWltcy5leHApKSxcbiAgICAgICAgc2lnbkluUHJvdmlkZXI6IHNpZ25JblByb3ZpZGVyIHx8IG51bGwsXG4gICAgICAgIHNpZ25JblNlY29uZEZhY3RvcjogKGZpcmViYXNlID09PSBudWxsIHx8IGZpcmViYXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJlYmFzZVsnc2lnbl9pbl9zZWNvbmRfZmFjdG9yJ10pIHx8IG51bGxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2Vjb25kc1N0cmluZ1RvTWlsbGlzZWNvbmRzKHNlY29uZHMpIHtcbiAgICByZXR1cm4gTnVtYmVyKHNlY29uZHMpICogMTAwMDtcbn1cbmZ1bmN0aW9uIF9wYXJzZVRva2VuKHRva2VuKSB7XG4gICAgY29uc3QgW2FsZ29yaXRobSwgcGF5bG9hZCwgc2lnbmF0dXJlXSA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgaWYgKGFsZ29yaXRobSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIHBheWxvYWQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBzaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfbG9nRXJyb3IoJ0pXVCBtYWxmb3JtZWQsIGNvbnRhaW5lZCBmZXdlciB0aGFuIDMgc2VjdGlvbnMnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBiYXNlNjREZWNvZGUocGF5bG9hZCk7XG4gICAgICAgIGlmICghZGVjb2RlZCkge1xuICAgICAgICAgICAgX2xvZ0Vycm9yKCdGYWlsZWQgdG8gZGVjb2RlIGJhc2U2NCBKV1QgcGF5bG9hZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlZCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIF9sb2dFcnJvcignQ2F1Z2h0IGVycm9yIHBhcnNpbmcgSldUIHBheWxvYWQgYXMgSlNPTicsIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBFeHRyYWN0IGV4cGlyZXNJbiBUVEwgZnJvbSBhIHRva2VuIGJ5IHN1YnRyYWN0aW5nIHRoZSBleHBpcmF0aW9uIGZyb20gdGhlIGlzc3VhbmNlLlxuICovXG5mdW5jdGlvbiBfdG9rZW5FeHBpcmVzSW4odG9rZW4pIHtcbiAgICBjb25zdCBwYXJzZWRUb2tlbiA9IF9wYXJzZVRva2VuKHRva2VuKTtcbiAgICBfYXNzZXJ0KHBhcnNlZFRva2VuLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgX2Fzc2VydCh0eXBlb2YgcGFyc2VkVG9rZW4uZXhwICE9PSAndW5kZWZpbmVkJywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIF9hc3NlcnQodHlwZW9mIHBhcnNlZFRva2VuLmlhdCAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICByZXR1cm4gTnVtYmVyKHBhcnNlZFRva2VuLmV4cCkgLSBOdW1iZXIocGFyc2VkVG9rZW4uaWF0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIHByb21pc2UsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKGJ5cGFzc0F1dGhTdGF0ZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvciAmJiBpc1VzZXJJbnZhbGlkYXRlZChlKSkge1xuICAgICAgICAgICAgaWYgKHVzZXIuYXV0aC5jdXJyZW50VXNlciA9PT0gdXNlcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVzZXIuYXV0aC5zaWduT3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1VzZXJJbnZhbGlkYXRlZCh7IGNvZGUgfSkge1xuICAgIHJldHVybiAoY29kZSA9PT0gYGF1dGgvJHtcInVzZXItZGlzYWJsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfRElTQUJMRUQgKi99YCB8fFxuICAgICAgICBjb2RlID09PSBgYXV0aC8ke1widXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovfWApO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgUHJvYWN0aXZlUmVmcmVzaCB7XG4gICAgY29uc3RydWN0b3IodXNlcikge1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAvLyBOb2RlIHRpbWVycyBhbmQgYnJvd3NlciB0aW1lcnMgcmV0dXJuIGZ1bmRhbWVudGFsbHkgZGlmZmVyZW50IHR5cGVzLlxuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBjYXJlIHdoYXQgdGhlIHZhbHVlIGlzIGJ1dCBUUyB3b24ndCBhY2NlcHQgdW5rbm93biBhbmRcbiAgICAgICAgLy8gd2UgY2FuJ3QgY2FzdCBwcm9wZXJseSBpbiBib3RoIGVudmlyb25tZW50cy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgdGhpcy50aW1lcklkID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvckJhY2tvZmYgPSAzMDAwMCAvKiBEdXJhdGlvbi5SRVRSWV9CQUNLT0ZGX01JTiAqLztcbiAgICB9XG4gICAgX3N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgX3N0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy50aW1lcklkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbnRlcnZhbCh3YXNFcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh3YXNFcnJvcikge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSB0aGlzLmVycm9yQmFja29mZjtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gTWF0aC5taW4odGhpcy5lcnJvckJhY2tvZmYgKiAyLCA5NjAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NQVggKi8pO1xuICAgICAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVycm9yIGJhY2tvZmZcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCYWNrb2ZmID0gMzAwMDAgLyogRHVyYXRpb24uUkVUUllfQkFDS09GRl9NSU4gKi87XG4gICAgICAgICAgICBjb25zdCBleHBUaW1lID0gKF9hID0gdGhpcy51c2VyLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gZXhwVGltZSAtIERhdGUubm93KCkgLSAzMDAwMDAgLyogRHVyYXRpb24uT0ZGU0VUICovO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIGludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2hlZHVsZSh3YXNFcnJvciA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgICAgICAgIC8vIEp1c3QgaW4gY2FzZS4uLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5nZXRJbnRlcnZhbCh3YXNFcnJvcik7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pdGVyYXRpb24oKTtcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBhc3luYyBpdGVyYXRpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVzZXIuZ2V0SWRUb2tlbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gT25seSByZXRyeSBvbiBuZXR3b3JrIGVycm9yc1xuICAgICAgICAgICAgaWYgKChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuY29kZSkgPT09XG4gICAgICAgICAgICAgICAgYGF1dGgvJHtcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk5FVFdPUktfUkVRVUVTVF9GQUlMRUQgKi99YCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoLyogd2FzRXJyb3IgKi8gdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIFVzZXJNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3IoY3JlYXRlZEF0LCBsYXN0TG9naW5BdCkge1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IGNyZWF0ZWRBdDtcbiAgICAgICAgdGhpcy5sYXN0TG9naW5BdCA9IGxhc3RMb2dpbkF0O1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplVGltZSgpO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZVRpbWUoKSB7XG4gICAgICAgIHRoaXMubGFzdFNpZ25JblRpbWUgPSB1dGNUaW1lc3RhbXBUb0RhdGVTdHJpbmcodGhpcy5sYXN0TG9naW5BdCk7XG4gICAgICAgIHRoaXMuY3JlYXRpb25UaW1lID0gdXRjVGltZXN0YW1wVG9EYXRlU3RyaW5nKHRoaXMuY3JlYXRlZEF0KTtcbiAgICB9XG4gICAgX2NvcHkobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVkQXQgPSBtZXRhZGF0YS5jcmVhdGVkQXQ7XG4gICAgICAgIHRoaXMubGFzdExvZ2luQXQgPSBtZXRhZGF0YS5sYXN0TG9naW5BdDtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVRpbWUoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlZEF0OiB0aGlzLmNyZWF0ZWRBdCxcbiAgICAgICAgICAgIGxhc3RMb2dpbkF0OiB0aGlzLmxhc3RMb2dpbkF0XG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdXRoID0gdXNlci5hdXRoO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXIsIGdldEFjY291bnRJbmZvKGF1dGgsIHsgaWRUb2tlbiB9KSk7XG4gICAgX2Fzc2VydChyZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UudXNlcnMubGVuZ3RoLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgY29uc3QgY29yZUFjY291bnQgPSByZXNwb25zZS51c2Vyc1swXTtcbiAgICB1c2VyLl9ub3RpZnlSZWxvYWRMaXN0ZW5lcihjb3JlQWNjb3VudCk7XG4gICAgY29uc3QgbmV3UHJvdmlkZXJEYXRhID0gKChfYSA9IGNvcmVBY2NvdW50LnByb3ZpZGVyVXNlckluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpXG4gICAgICAgID8gZXh0cmFjdFByb3ZpZGVyRGF0YShjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvKVxuICAgICAgICA6IFtdO1xuICAgIGNvbnN0IHByb3ZpZGVyRGF0YSA9IG1lcmdlUHJvdmlkZXJEYXRhKHVzZXIucHJvdmlkZXJEYXRhLCBuZXdQcm92aWRlckRhdGEpO1xuICAgIC8vIFByZXNlcnZlcyB0aGUgbm9uLW5vbnltb3VzIHN0YXR1cyBvZiB0aGUgc3RvcmVkIHVzZXIsIGV2ZW4gaWYgbm8gbW9yZVxuICAgIC8vIGNyZWRlbnRpYWxzIChmZWRlcmF0ZWQgb3IgZW1haWwvcGFzc3dvcmQpIGFyZSBsaW5rZWQgdG8gdGhlIHVzZXIuIElmXG4gICAgLy8gdGhlIHVzZXIgd2FzIHByZXZpb3VzbHkgYW5vbnltb3VzLCB0aGVuIHVzZSBwcm92aWRlciBkYXRhIHRvIHVwZGF0ZS5cbiAgICAvLyBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgaXQgd2FzIG5vdCBhbm9ueW1vdXMgYmVmb3JlLCBpdCBzaG91bGQgbmV2ZXIgYmVcbiAgICAvLyBjb25zaWRlcmVkIGFub255bW91cyBub3cuXG4gICAgY29uc3Qgb2xkSXNBbm9ueW1vdXMgPSB1c2VyLmlzQW5vbnltb3VzO1xuICAgIGNvbnN0IG5ld0lzQW5vbnltb3VzID0gISh1c2VyLmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiYgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBpc0Fub255bW91cyA9ICFvbGRJc0Fub255bW91cyA/IGZhbHNlIDogbmV3SXNBbm9ueW1vdXM7XG4gICAgY29uc3QgdXBkYXRlcyA9IHtcbiAgICAgICAgdWlkOiBjb3JlQWNjb3VudC5sb2NhbElkLFxuICAgICAgICBkaXNwbGF5TmFtZTogY29yZUFjY291bnQuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgcGhvdG9VUkw6IGNvcmVBY2NvdW50LnBob3RvVXJsIHx8IG51bGwsXG4gICAgICAgIGVtYWlsOiBjb3JlQWNjb3VudC5lbWFpbCB8fCBudWxsLFxuICAgICAgICBlbWFpbFZlcmlmaWVkOiBjb3JlQWNjb3VudC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlLFxuICAgICAgICBwaG9uZU51bWJlcjogY29yZUFjY291bnQucGhvbmVOdW1iZXIgfHwgbnVsbCxcbiAgICAgICAgdGVuYW50SWQ6IGNvcmVBY2NvdW50LnRlbmFudElkIHx8IG51bGwsXG4gICAgICAgIHByb3ZpZGVyRGF0YSxcbiAgICAgICAgbWV0YWRhdGE6IG5ldyBVc2VyTWV0YWRhdGEoY29yZUFjY291bnQuY3JlYXRlZEF0LCBjb3JlQWNjb3VudC5sYXN0TG9naW5BdCksXG4gICAgICAgIGlzQW5vbnltb3VzXG4gICAgfTtcbiAgICBPYmplY3QuYXNzaWduKHVzZXIsIHVwZGF0ZXMpO1xufVxuLyoqXG4gKiBSZWxvYWRzIHVzZXIgYWNjb3VudCBkYXRhLCBpZiBzaWduZWQgaW4uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbG9hZCh1c2VyKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXJJbnRlcm5hbCk7XG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlIGN1cnJlbnQgdXNlciBoYXNuJ3QgY2hhbmdlZCwgdXBkYXRlXG4gICAgLy8gY3VycmVudCB1c2VyIHdpbGwgdHJpZ2dlciBhIHBlcnNpc3RlbmNlIHVwZGF0ZSB3LyB0aGVcbiAgICAvLyBuZXcgaW5mby5cbiAgICBhd2FpdCB1c2VySW50ZXJuYWwuYXV0aC5fcGVyc2lzdFVzZXJJZkN1cnJlbnQodXNlckludGVybmFsKTtcbiAgICB1c2VySW50ZXJuYWwuYXV0aC5fbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXJJbnRlcm5hbCk7XG59XG5mdW5jdGlvbiBtZXJnZVByb3ZpZGVyRGF0YShvcmlnaW5hbCwgbmV3RGF0YSkge1xuICAgIGNvbnN0IGRlZHVwZWQgPSBvcmlnaW5hbC5maWx0ZXIobyA9PiAhbmV3RGF0YS5zb21lKG4gPT4gbi5wcm92aWRlcklkID09PSBvLnByb3ZpZGVySWQpKTtcbiAgICByZXR1cm4gWy4uLmRlZHVwZWQsIC4uLm5ld0RhdGFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdFByb3ZpZGVyRGF0YShwcm92aWRlcnMpIHtcbiAgICByZXR1cm4gcHJvdmlkZXJzLm1hcCgoX2EpID0+IHtcbiAgICAgICAgdmFyIHsgcHJvdmlkZXJJZCB9ID0gX2EsIHByb3ZpZGVyID0gX19yZXN0KF9hLCBbXCJwcm92aWRlcklkXCJdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQsXG4gICAgICAgICAgICB1aWQ6IHByb3ZpZGVyLnJhd0lkIHx8ICcnLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IHByb3ZpZGVyLmRpc3BsYXlOYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBlbWFpbDogcHJvdmlkZXIuZW1haWwgfHwgbnVsbCxcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiBwcm92aWRlci5waG9uZU51bWJlciB8fCBudWxsLFxuICAgICAgICAgICAgcGhvdG9VUkw6IHByb3ZpZGVyLnBob3RvVXJsIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RTdHNUb2tlbihhdXRoLCByZWZyZXNoVG9rZW4pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtRmV0Y2hXaXRoRXJyb3JIYW5kbGluZyhhdXRoLCB7fSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gcXVlcnlzdHJpbmcoe1xuICAgICAgICAgICAgJ2dyYW50X3R5cGUnOiAncmVmcmVzaF90b2tlbicsXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbic6IHJlZnJlc2hUb2tlblxuICAgICAgICB9KS5zbGljZSgxKTtcbiAgICAgICAgY29uc3QgeyB0b2tlbkFwaUhvc3QsIGFwaUtleSB9ID0gYXV0aC5jb25maWc7XG4gICAgICAgIGNvbnN0IHVybCA9IF9nZXRGaW5hbFRhcmdldChhdXRoLCB0b2tlbkFwaUhvc3QsIFwiL3YxL3Rva2VuXCIgLyogRW5kcG9pbnQuVE9LRU4gKi8sIGBrZXk9JHthcGlLZXl9YCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBhdXRoLl9nZXRBZGRpdGlvbmFsSGVhZGVycygpO1xuICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCIgLyogSHR0cEhlYWRlci5DT05URU5UX1RZUEUgKi9dID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgIHJldHVybiBGZXRjaFByb3ZpZGVyLmZldGNoKCkodXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFRoZSByZXNwb25zZSBjb21lcyBiYWNrIGluIHNuYWtlX2Nhc2UuIENvbnZlcnQgdG8gY2FtZWw6XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWNjZXNzVG9rZW46IHJlc3BvbnNlLmFjY2Vzc190b2tlbixcbiAgICAgICAgZXhwaXJlc0luOiByZXNwb25zZS5leHBpcmVzX2luLFxuICAgICAgICByZWZyZXNoVG9rZW46IHJlc3BvbnNlLnJlZnJlc2hfdG9rZW5cbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcmV2b2tlVG9rZW4oYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92Mi9hY2NvdW50czpyZXZva2VUb2tlblwiIC8qIEVuZHBvaW50LlJFVk9LRV9UT0tFTiAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogV2UgbmVlZCB0byBtYXJrIHRoaXMgY2xhc3MgYXMgaW50ZXJuYWwgZXhwbGljaXRseSB0byBleGNsdWRlIGl0IGluIHRoZSBwdWJsaWMgdHlwaW5ncywgYmVjYXVzZVxuICogaXQgcmVmZXJlbmNlcyBBdXRoSW50ZXJuYWwgd2hpY2ggaGFzIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIFVzZXJJbnRlcm5hbC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgU3RzVG9rZW5NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IG51bGw7XG4gICAgfVxuICAgIGdldCBpc0V4cGlyZWQoKSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMuZXhwaXJhdGlvblRpbWUgfHxcbiAgICAgICAgICAgIERhdGUubm93KCkgPiB0aGlzLmV4cGlyYXRpb25UaW1lIC0gMzAwMDAgLyogQnVmZmVyLlRPS0VOX1JFRlJFU0ggKi8pO1xuICAgIH1cbiAgICB1cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgX2Fzc2VydChyZXNwb25zZS5pZFRva2VuLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIHJlc3BvbnNlLmlkVG9rZW4gIT09ICd1bmRlZmluZWQnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIHJlc3BvbnNlLnJlZnJlc2hUb2tlbiAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgZXhwaXJlc0luID0gJ2V4cGlyZXNJbicgaW4gcmVzcG9uc2UgJiYgdHlwZW9mIHJlc3BvbnNlLmV4cGlyZXNJbiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gTnVtYmVyKHJlc3BvbnNlLmV4cGlyZXNJbilcbiAgICAgICAgICAgIDogX3Rva2VuRXhwaXJlc0luKHJlc3BvbnNlLmlkVG9rZW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24ocmVzcG9uc2UuaWRUb2tlbiwgcmVzcG9uc2UucmVmcmVzaFRva2VuLCBleHBpcmVzSW4pO1xuICAgIH1cbiAgICB1cGRhdGVGcm9tSWRUb2tlbihpZFRva2VuKSB7XG4gICAgICAgIF9hc3NlcnQoaWRUb2tlbi5sZW5ndGggIT09IDAsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgZXhwaXJlc0luID0gX3Rva2VuRXhwaXJlc0luKGlkVG9rZW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oaWRUb2tlbiwgbnVsbCwgZXhwaXJlc0luKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9rZW4oYXV0aCwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgdGhpcy5hY2Nlc3NUb2tlbiAmJiAhdGhpcy5pc0V4cGlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIF9hc3NlcnQodGhpcy5yZWZyZXNoVG9rZW4sIGF1dGgsIFwidXNlci10b2tlbi1leHBpcmVkXCIgLyogQXV0aEVycm9yQ29kZS5UT0tFTl9FWFBJUkVEICovKTtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlZnJlc2goYXV0aCwgdGhpcy5yZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNjZXNzVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNsZWFyUmVmcmVzaFRva2VuKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IG51bGw7XG4gICAgfVxuICAgIGFzeW5jIHJlZnJlc2goYXV0aCwgb2xkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgeyBhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBleHBpcmVzSW4gfSA9IGF3YWl0IHJlcXVlc3RTdHNUb2tlbihhdXRoLCBvbGRUb2tlbik7XG4gICAgICAgIHRoaXMudXBkYXRlVG9rZW5zQW5kRXhwaXJhdGlvbihhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBOdW1iZXIoZXhwaXJlc0luKSk7XG4gICAgfVxuICAgIHVwZGF0ZVRva2Vuc0FuZEV4cGlyYXRpb24oYWNjZXNzVG9rZW4sIHJlZnJlc2hUb2tlbiwgZXhwaXJlc0luU2VjKSB7XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gcmVmcmVzaFRva2VuIHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbiB8fCBudWxsO1xuICAgICAgICB0aGlzLmV4cGlyYXRpb25UaW1lID0gRGF0ZS5ub3coKSArIGV4cGlyZXNJblNlYyAqIDEwMDA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihhcHBOYW1lLCBvYmplY3QpIHtcbiAgICAgICAgY29uc3QgeyByZWZyZXNoVG9rZW4sIGFjY2Vzc1Rva2VuLCBleHBpcmF0aW9uVGltZSB9ID0gb2JqZWN0O1xuICAgICAgICBjb25zdCBtYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xuICAgICAgICBpZiAocmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHR5cGVvZiByZWZyZXNoVG9rZW4gPT09ICdzdHJpbmcnLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLywge1xuICAgICAgICAgICAgICAgIGFwcE5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFuYWdlci5yZWZyZXNoVG9rZW4gPSByZWZyZXNoVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHR5cGVvZiBhY2Nlc3NUb2tlbiA9PT0gJ3N0cmluZycsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYW5hZ2VyLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHR5cGVvZiBleHBpcmF0aW9uVGltZSA9PT0gJ251bWJlcicsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7XG4gICAgICAgICAgICAgICAgYXBwTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtYW5hZ2VyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZnJlc2hUb2tlbjogdGhpcy5yZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICBhY2Nlc3NUb2tlbjogdGhpcy5hY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiB0aGlzLmV4cGlyYXRpb25UaW1lXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hc3NpZ24oc3RzVG9rZW5NYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW47XG4gICAgICAgIHRoaXMucmVmcmVzaFRva2VuID0gc3RzVG9rZW5NYW5hZ2VyLnJlZnJlc2hUb2tlbjtcbiAgICAgICAgdGhpcy5leHBpcmF0aW9uVGltZSA9IHN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZTtcbiAgICB9XG4gICAgX2Nsb25lKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgU3RzVG9rZW5NYW5hZ2VyKCksIHRoaXMudG9KU09OKCkpO1xuICAgIH1cbiAgICBfcGVyZm9ybVJlZnJlc2goKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGFzc2VydGlvbiwgYXBwTmFtZSkge1xuICAgIF9hc3NlcnQodHlwZW9mIGFzc2VydGlvbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGFzc2VydGlvbiA9PT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovLCB7IGFwcE5hbWUgfSk7XG59XG5jbGFzcyBVc2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IoX2EpIHtcbiAgICAgICAgdmFyIHsgdWlkLCBhdXRoLCBzdHNUb2tlbk1hbmFnZXIgfSA9IF9hLCBvcHQgPSBfX3Jlc3QoX2EsIFtcInVpZFwiLCBcImF1dGhcIiwgXCJzdHNUb2tlbk1hbmFnZXJcIl0pO1xuICAgICAgICAvLyBGb3IgdGhlIHVzZXIgb2JqZWN0LCBwcm92aWRlciBpcyBhbHdheXMgRmlyZWJhc2UuXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IFwiZmlyZWJhc2VcIiAvKiBQcm92aWRlcklkLkZJUkVCQVNFICovO1xuICAgICAgICB0aGlzLnByb2FjdGl2ZVJlZnJlc2ggPSBuZXcgUHJvYWN0aXZlUmVmcmVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWxvYWRVc2VySW5mbyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnVpZCA9IHVpZDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy5zdHNUb2tlbk1hbmFnZXIgPSBzdHNUb2tlbk1hbmFnZXI7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW47XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSBvcHQuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5lbWFpbCA9IG9wdC5lbWFpbCB8fCBudWxsO1xuICAgICAgICB0aGlzLmVtYWlsVmVyaWZpZWQgPSBvcHQuZW1haWxWZXJpZmllZCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IG9wdC5waG9uZU51bWJlciB8fCBudWxsO1xuICAgICAgICB0aGlzLnBob3RvVVJMID0gb3B0LnBob3RvVVJMIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSBvcHQuaXNBbm9ueW1vdXMgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMudGVuYW50SWQgPSBvcHQudGVuYW50SWQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5wcm92aWRlckRhdGEgPSBvcHQucHJvdmlkZXJEYXRhID8gWy4uLm9wdC5wcm92aWRlckRhdGFdIDogW107XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgVXNlck1ldGFkYXRhKG9wdC5jcmVhdGVkQXQgfHwgdW5kZWZpbmVkLCBvcHQubGFzdExvZ2luQXQgfHwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SWRUb2tlbihmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh0aGlzLCB0aGlzLnN0c1Rva2VuTWFuYWdlci5nZXRUb2tlbih0aGlzLmF1dGgsIGZvcmNlUmVmcmVzaCkpO1xuICAgICAgICBfYXNzZXJ0KGFjY2Vzc1Rva2VuLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4gIT09IGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gYWNjZXNzVG9rZW47XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5hdXRoLl9ub3RpZnlMaXN0ZW5lcnNJZkN1cnJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICBnZXRJZFRva2VuUmVzdWx0KGZvcmNlUmVmcmVzaCkge1xuICAgICAgICByZXR1cm4gZ2V0SWRUb2tlblJlc3VsdCh0aGlzLCBmb3JjZVJlZnJlc2gpO1xuICAgIH1cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHJldHVybiByZWxvYWQodGhpcyk7XG4gICAgfVxuICAgIF9hc3NpZ24odXNlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9hc3NlcnQodGhpcy51aWQgPT09IHVzZXIudWlkLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5TmFtZSA9IHVzZXIuZGlzcGxheU5hbWU7XG4gICAgICAgIHRoaXMucGhvdG9VUkwgPSB1c2VyLnBob3RvVVJMO1xuICAgICAgICB0aGlzLmVtYWlsID0gdXNlci5lbWFpbDtcbiAgICAgICAgdGhpcy5lbWFpbFZlcmlmaWVkID0gdXNlci5lbWFpbFZlcmlmaWVkO1xuICAgICAgICB0aGlzLnBob25lTnVtYmVyID0gdXNlci5waG9uZU51bWJlcjtcbiAgICAgICAgdGhpcy5pc0Fub255bW91cyA9IHVzZXIuaXNBbm9ueW1vdXM7XG4gICAgICAgIHRoaXMudGVuYW50SWQgPSB1c2VyLnRlbmFudElkO1xuICAgICAgICB0aGlzLnByb3ZpZGVyRGF0YSA9IHVzZXIucHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoT2JqZWN0LmFzc2lnbih7fSwgdXNlckluZm8pKSk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuX2NvcHkodXNlci5tZXRhZGF0YSk7XG4gICAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLl9hc3NpZ24odXNlci5zdHNUb2tlbk1hbmFnZXIpO1xuICAgIH1cbiAgICBfY2xvbmUoYXV0aCkge1xuICAgICAgICBjb25zdCBuZXdVc2VyID0gbmV3IFVzZXJJbXBsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcyksIHsgYXV0aCwgc3RzVG9rZW5NYW5hZ2VyOiB0aGlzLnN0c1Rva2VuTWFuYWdlci5fY2xvbmUoKSB9KSk7XG4gICAgICAgIG5ld1VzZXIubWV0YWRhdGEuX2NvcHkodGhpcy5tZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiBuZXdVc2VyO1xuICAgIH1cbiAgICBfb25SZWxvYWQoY2FsbGJhY2spIHtcbiAgICAgICAgLy8gVGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBvbmUgbGlzdGVuZXIsIGFuZCB0aGF0IGlzIGEgc2luZ2xlIGluc3RhbmNlIG9mIE11bHRpRmFjdG9yVXNlclxuICAgICAgICBfYXNzZXJ0KCF0aGlzLnJlbG9hZExpc3RlbmVyLCB0aGlzLmF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgdGhpcy5yZWxvYWRMaXN0ZW5lciA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodGhpcy5yZWxvYWRVc2VySW5mbykge1xuICAgICAgICAgICAgdGhpcy5fbm90aWZ5UmVsb2FkTGlzdGVuZXIodGhpcy5yZWxvYWRVc2VySW5mbyk7XG4gICAgICAgICAgICB0aGlzLnJlbG9hZFVzZXJJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbm90aWZ5UmVsb2FkTGlzdGVuZXIodXNlckluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMucmVsb2FkTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVsb2FkTGlzdGVuZXIodXNlckluZm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbGlzdGVuZXIgaXMgc3Vic2NyaWJlZCB5ZXQsIHNhdmUgdGhlIHJlc3VsdCBzbyBpdCdzIGF2YWlsYWJsZSB3aGVuIHRoZXkgZG8gc3Vic2NyaWJlXG4gICAgICAgICAgICB0aGlzLnJlbG9hZFVzZXJJbmZvID0gdXNlckluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5wcm9hY3RpdmVSZWZyZXNoLl9zdGFydCgpO1xuICAgIH1cbiAgICBfc3RvcFByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMucHJvYWN0aXZlUmVmcmVzaC5fc3RvcCgpO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIHJlbG9hZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB0b2tlbnNSZWZyZXNoZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmlkVG9rZW4gJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLmlkVG9rZW4gIT09IHRoaXMuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnN0c1Rva2VuTWFuYWdlci51cGRhdGVGcm9tU2VydmVyUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgdG9rZW5zUmVmcmVzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsb2FkKSB7XG4gICAgICAgICAgICBhd2FpdCBfcmVsb2FkV2l0aG91dFNhdmluZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmF1dGguX3BlcnNpc3RVc2VySWZDdXJyZW50KHRoaXMpO1xuICAgICAgICBpZiAodG9rZW5zUmVmcmVzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGguX25vdGlmeUxpc3RlbmVyc0lmQ3VycmVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBkZWxldGUoKSB7XG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmF1dGguYXBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMuYXV0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB0aGlzLmdldElkVG9rZW4oKTtcbiAgICAgICAgYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodGhpcywgZGVsZXRlQWNjb3VudCh0aGlzLmF1dGgsIHsgaWRUb2tlbiB9KSk7XG4gICAgICAgIHRoaXMuc3RzVG9rZW5NYW5hZ2VyLmNsZWFyUmVmcmVzaFRva2VuKCk7XG4gICAgICAgIC8vIFRPRE86IERldGVybWluZSBpZiBjYW5jZWxsYWJsZS1wcm9taXNlcyBhcmUgbmVjZXNzYXJ5IHRvIHVzZSBpbiB0aGlzIGNsYXNzIHNvIHRoYXQgZGVsZXRlKClcbiAgICAgICAgLy8gICAgICAgY2FuY2VscyBwZW5kaW5nIGFjdGlvbnMuLi5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aC5zaWduT3V0KCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHVpZDogdGhpcy51aWQsIGVtYWlsOiB0aGlzLmVtYWlsIHx8IHVuZGVmaW5lZCwgZW1haWxWZXJpZmllZDogdGhpcy5lbWFpbFZlcmlmaWVkLCBkaXNwbGF5TmFtZTogdGhpcy5kaXNwbGF5TmFtZSB8fCB1bmRlZmluZWQsIGlzQW5vbnltb3VzOiB0aGlzLmlzQW5vbnltb3VzLCBwaG90b1VSTDogdGhpcy5waG90b1VSTCB8fCB1bmRlZmluZWQsIHBob25lTnVtYmVyOiB0aGlzLnBob25lTnVtYmVyIHx8IHVuZGVmaW5lZCwgdGVuYW50SWQ6IHRoaXMudGVuYW50SWQgfHwgdW5kZWZpbmVkLCBwcm92aWRlckRhdGE6IHRoaXMucHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoT2JqZWN0LmFzc2lnbih7fSwgdXNlckluZm8pKSksIHN0c1Rva2VuTWFuYWdlcjogdGhpcy5zdHNUb2tlbk1hbmFnZXIudG9KU09OKCksIFxuICAgICAgICAgICAgLy8gUmVkaXJlY3QgZXZlbnQgSUQgbXVzdCBiZSBtYWludGFpbmVkIGluIGNhc2UgdGhlcmUgaXMgYSBwZW5kaW5nXG4gICAgICAgICAgICAvLyByZWRpcmVjdCBldmVudC5cbiAgICAgICAgICAgIF9yZWRpcmVjdEV2ZW50SWQ6IHRoaXMuX3JlZGlyZWN0RXZlbnRJZCB9LCB0aGlzLm1ldGFkYXRhLnRvSlNPTigpKSwgeyBcbiAgICAgICAgICAgIC8vIFJlcXVpcmVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGxlZ2FjeSBTREsgKGdvL2ZpcmViYXNlLWF1dGgtc2RrLXBlcnNpc3RlbmNlLXBhcnNpbmcpOlxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmF1dGguY29uZmlnLmFwaUtleSwgYXBwTmFtZTogdGhpcy5hdXRoLm5hbWUgfSk7XG4gICAgfVxuICAgIGdldCByZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0c1Rva2VuTWFuYWdlci5yZWZyZXNoVG9rZW4gfHwgJyc7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbUpTT04oYXV0aCwgb2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gKF9hID0gb2JqZWN0LmRpc3BsYXlOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gKF9iID0gb2JqZWN0LmVtYWlsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBob25lTnVtYmVyID0gKF9jID0gb2JqZWN0LnBob25lTnVtYmVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBob3RvVVJMID0gKF9kID0gb2JqZWN0LnBob3RvVVJMKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHRlbmFudElkID0gKF9lID0gb2JqZWN0LnRlbmFudElkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IF9yZWRpcmVjdEV2ZW50SWQgPSAoX2YgPSBvYmplY3QuX3JlZGlyZWN0RXZlbnRJZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSAoX2cgPSBvYmplY3QuY3JlYXRlZEF0KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGxhc3RMb2dpbkF0ID0gKF9oID0gb2JqZWN0Lmxhc3RMb2dpbkF0KSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgdWlkLCBlbWFpbFZlcmlmaWVkLCBpc0Fub255bW91cywgcHJvdmlkZXJEYXRhLCBzdHNUb2tlbk1hbmFnZXI6IHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyIH0gPSBvYmplY3Q7XG4gICAgICAgIF9hc3NlcnQodWlkICYmIHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IFN0c1Rva2VuTWFuYWdlci5mcm9tSlNPTih0aGlzLm5hbWUsIHBsYWluT2JqZWN0VG9rZW5NYW5hZ2VyKTtcbiAgICAgICAgX2Fzc2VydCh0eXBlb2YgdWlkID09PSAnc3RyaW5nJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChkaXNwbGF5TmFtZSwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQoZW1haWwsIGF1dGgubmFtZSk7XG4gICAgICAgIF9hc3NlcnQodHlwZW9mIGVtYWlsVmVyaWZpZWQgPT09ICdib29sZWFuJywgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiBpc0Fub255bW91cyA9PT0gJ2Jvb2xlYW4nLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKHBob25lTnVtYmVyLCBhdXRoLm5hbWUpO1xuICAgICAgICBhc3NlcnRTdHJpbmdPclVuZGVmaW5lZChwaG90b1VSTCwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQodGVuYW50SWQsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKF9yZWRpcmVjdEV2ZW50SWQsIGF1dGgubmFtZSk7XG4gICAgICAgIGFzc2VydFN0cmluZ09yVW5kZWZpbmVkKGNyZWF0ZWRBdCwgYXV0aC5uYW1lKTtcbiAgICAgICAgYXNzZXJ0U3RyaW5nT3JVbmRlZmluZWQobGFzdExvZ2luQXQsIGF1dGgubmFtZSk7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgZW1haWxWZXJpZmllZCxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgaXNBbm9ueW1vdXMsXG4gICAgICAgICAgICBwaG90b1VSTCxcbiAgICAgICAgICAgIHBob25lTnVtYmVyLFxuICAgICAgICAgICAgdGVuYW50SWQsXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXG4gICAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgICAgICBsYXN0TG9naW5BdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3ZpZGVyRGF0YSAmJiBBcnJheS5pc0FycmF5KHByb3ZpZGVyRGF0YSkpIHtcbiAgICAgICAgICAgIHVzZXIucHJvdmlkZXJEYXRhID0gcHJvdmlkZXJEYXRhLm1hcCh1c2VySW5mbyA9PiAoT2JqZWN0LmFzc2lnbih7fSwgdXNlckluZm8pKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgICAgICAgIHVzZXIuX3JlZGlyZWN0RXZlbnRJZCA9IF9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSBVc2VyIGZyb20gYW4gaWRUb2tlbiBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gYXV0aFxuICAgICAqIEBwYXJhbSBpZFRva2VuUmVzcG9uc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHN0c1Rva2VuTWFuYWdlciA9IG5ldyBTdHNUb2tlbk1hbmFnZXIoKTtcbiAgICAgICAgc3RzVG9rZW5NYW5hZ2VyLnVwZGF0ZUZyb21TZXJ2ZXJSZXNwb25zZShpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBGaXJlYmFzZSBBdXRoIHVzZXIuXG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlckltcGwoe1xuICAgICAgICAgICAgdWlkOiBpZFRva2VuUmVzcG9uc2UubG9jYWxJZCxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICBzdHNUb2tlbk1hbmFnZXIsXG4gICAgICAgICAgICBpc0Fub255bW91c1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlcyB0aGUgdXNlciBpbmZvIGFuZCBkYXRhIGFuZCByZXNvbHZlcyB3aXRoIGEgdXNlciBpbnN0YW5jZS5cbiAgICAgICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XG4gICAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGEgVXNlciBmcm9tIGFuIGlkVG9rZW4gc2VydmVyIHJlc3BvbnNlXG4gICAgICogQHBhcmFtIGF1dGhcbiAgICAgKiBAcGFyYW0gaWRUb2tlblJlc3BvbnNlXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIF9mcm9tR2V0QWNjb3VudEluZm9SZXNwb25zZShhdXRoLCByZXNwb25zZSwgaWRUb2tlbikge1xuICAgICAgICBjb25zdCBjb3JlQWNjb3VudCA9IHJlc3BvbnNlLnVzZXJzWzBdO1xuICAgICAgICBfYXNzZXJ0KGNvcmVBY2NvdW50LmxvY2FsSWQgIT09IHVuZGVmaW5lZCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBwcm92aWRlckRhdGEgPSBjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZXh0cmFjdFByb3ZpZGVyRGF0YShjb3JlQWNjb3VudC5wcm92aWRlclVzZXJJbmZvKVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgaXNBbm9ueW1vdXMgPSAhKGNvcmVBY2NvdW50LmVtYWlsICYmIGNvcmVBY2NvdW50LnBhc3N3b3JkSGFzaCkgJiYgIShwcm92aWRlckRhdGEgPT09IG51bGwgfHwgcHJvdmlkZXJEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm92aWRlckRhdGEubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc3RzVG9rZW5NYW5hZ2VyID0gbmV3IFN0c1Rva2VuTWFuYWdlcigpO1xuICAgICAgICBzdHNUb2tlbk1hbmFnZXIudXBkYXRlRnJvbUlkVG9rZW4oaWRUb2tlbik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIEZpcmViYXNlIEF1dGggdXNlci5cbiAgICAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VySW1wbCh7XG4gICAgICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXG4gICAgICAgICAgICBhdXRoLFxuICAgICAgICAgICAgc3RzVG9rZW5NYW5hZ2VyLFxuICAgICAgICAgICAgaXNBbm9ueW1vdXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdXNlciB3aXRoIGRhdGEgZnJvbSB0aGUgR2V0QWNjb3VudEluZm8gcmVzcG9uc2UuXG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB7XG4gICAgICAgICAgICB1aWQ6IGNvcmVBY2NvdW50LmxvY2FsSWQsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogY29yZUFjY291bnQuZGlzcGxheU5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgIHBob3RvVVJMOiBjb3JlQWNjb3VudC5waG90b1VybCB8fCBudWxsLFxuICAgICAgICAgICAgZW1haWw6IGNvcmVBY2NvdW50LmVtYWlsIHx8IG51bGwsXG4gICAgICAgICAgICBlbWFpbFZlcmlmaWVkOiBjb3JlQWNjb3VudC5lbWFpbFZlcmlmaWVkIHx8IGZhbHNlLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXI6IGNvcmVBY2NvdW50LnBob25lTnVtYmVyIHx8IG51bGwsXG4gICAgICAgICAgICB0ZW5hbnRJZDogY29yZUFjY291bnQudGVuYW50SWQgfHwgbnVsbCxcbiAgICAgICAgICAgIHByb3ZpZGVyRGF0YSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgVXNlck1ldGFkYXRhKGNvcmVBY2NvdW50LmNyZWF0ZWRBdCwgY29yZUFjY291bnQubGFzdExvZ2luQXQpLFxuICAgICAgICAgICAgaXNBbm9ueW1vdXM6ICEoY29yZUFjY291bnQuZW1haWwgJiYgY29yZUFjY291bnQucGFzc3dvcmRIYXNoKSAmJlxuICAgICAgICAgICAgICAgICEocHJvdmlkZXJEYXRhID09PSBudWxsIHx8IHByb3ZpZGVyRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdmlkZXJEYXRhLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih1c2VyLCB1cGRhdGVzKTtcbiAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgaW5zdGFuY2VDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIF9nZXRJbnN0YW5jZShjbHMpIHtcbiAgICBkZWJ1Z0Fzc2VydChjbHMgaW5zdGFuY2VvZiBGdW5jdGlvbiwgJ0V4cGVjdGVkIGEgY2xhc3MgZGVmaW5pdGlvbicpO1xuICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlQ2FjaGUuZ2V0KGNscyk7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGRlYnVnQXNzZXJ0KGluc3RhbmNlIGluc3RhbmNlb2YgY2xzLCAnSW5zdGFuY2Ugc3RvcmVkIGluIGNhY2hlIG1pc21hdGNoZWQgd2l0aCBjbGFzcycpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGluc3RhbmNlID0gbmV3IGNscygpO1xuICAgIGluc3RhbmNlQ2FjaGUuc2V0KGNscywgaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEluTWVtb3J5UGVyc2lzdGVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnR5cGUgPSBcIk5PTkVcIiAvKiBQZXJzaXN0ZW5jZVR5cGUuTk9ORSAqLztcbiAgICAgICAgdGhpcy5zdG9yYWdlID0ge307XG4gICAgfVxuICAgIGFzeW5jIF9pc0F2YWlsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFzeW5jIF9zZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2Vba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuc3RvcmFnZVtrZXldO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgX3JlbW92ZShrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RvcmFnZVtrZXldO1xuICAgIH1cbiAgICBfYWRkTGlzdGVuZXIoX2tleSwgX2xpc3RlbmVyKSB7XG4gICAgICAgIC8vIExpc3RlbmVycyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgaW4tbWVtb3J5IHN0b3JhZ2Ugc2luY2UgaXQgY2Fubm90IGJlIHNoYXJlZCBhY3Jvc3Mgd2luZG93cy93b3JrZXJzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3JlbW92ZUxpc3RlbmVyKF9rZXksIF9saXN0ZW5lcikge1xuICAgICAgICAvLyBMaXN0ZW5lcnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGluLW1lbW9yeSBzdG9yYWdlIHNpbmNlIGl0IGNhbm5vdCBiZSBzaGFyZWQgYWNyb3NzIHdpbmRvd3Mvd29ya2Vyc1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuSW5NZW1vcnlQZXJzaXN0ZW5jZS50eXBlID0gJ05PTkUnO1xuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgUGVyc2lzdGVuY2V9IG9mIHR5cGUgJ05PTkUnLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgaW5NZW1vcnlQZXJzaXN0ZW5jZSA9IEluTWVtb3J5UGVyc2lzdGVuY2U7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBfcGVyc2lzdGVuY2VLZXlOYW1lKGtleSwgYXBpS2V5LCBhcHBOYW1lKSB7XG4gICAgcmV0dXJuIGAke1wiZmlyZWJhc2VcIiAvKiBOYW1lc3BhY2UuUEVSU0lTVEVOQ0UgKi99OiR7a2V5fToke2FwaUtleX06JHthcHBOYW1lfWA7XG59XG5jbGFzcyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihwZXJzaXN0ZW5jZSwgYXV0aCwgdXNlcktleSkge1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gcGVyc2lzdGVuY2U7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMudXNlcktleSA9IHVzZXJLZXk7XG4gICAgICAgIGNvbnN0IHsgY29uZmlnLCBuYW1lIH0gPSB0aGlzLmF1dGg7XG4gICAgICAgIHRoaXMuZnVsbFVzZXJLZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHRoaXMudXNlcktleSwgY29uZmlnLmFwaUtleSwgbmFtZSk7XG4gICAgICAgIHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5ID0gX3BlcnNpc3RlbmNlS2V5TmFtZShcInBlcnNpc3RlbmNlXCIgLyogS2V5TmFtZS5QRVJTSVNURU5DRV9VU0VSICovLCBjb25maWcuYXBpS2V5LCBuYW1lKTtcbiAgICAgICAgdGhpcy5ib3VuZEV2ZW50SGFuZGxlciA9IGF1dGguX29uU3RvcmFnZUV2ZW50LmJpbmQoYXV0aCk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UuX2FkZExpc3RlbmVyKHRoaXMuZnVsbFVzZXJLZXksIHRoaXMuYm91bmRFdmVudEhhbmRsZXIpO1xuICAgIH1cbiAgICBzZXRDdXJyZW50VXNlcih1c2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9zZXQodGhpcy5mdWxsVXNlcktleSwgdXNlci50b0pTT04oKSk7XG4gICAgfVxuICAgIGFzeW5jIGdldEN1cnJlbnRVc2VyKCkge1xuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdGhpcy5wZXJzaXN0ZW5jZS5fZ2V0KHRoaXMuZnVsbFVzZXJLZXkpO1xuICAgICAgICByZXR1cm4gYmxvYiA/IFVzZXJJbXBsLl9mcm9tSlNPTih0aGlzLmF1dGgsIGJsb2IpIDogbnVsbDtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFVzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlLl9yZW1vdmUodGhpcy5mdWxsVXNlcktleSk7XG4gICAgfVxuICAgIHNhdmVQZXJzaXN0ZW5jZUZvclJlZGlyZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW5jZS5fc2V0KHRoaXMuZnVsbFBlcnNpc3RlbmNlS2V5LCB0aGlzLnBlcnNpc3RlbmNlLnR5cGUpO1xuICAgIH1cbiAgICBhc3luYyBzZXRQZXJzaXN0ZW5jZShuZXdQZXJzaXN0ZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW5jZSA9PT0gbmV3UGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VXNlciA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW1vdmVDdXJyZW50VXNlcigpO1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlID0gbmV3UGVyc2lzdGVuY2U7XG4gICAgICAgIGlmIChjdXJyZW50VXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q3VycmVudFVzZXIoY3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5fcmVtb3ZlTGlzdGVuZXIodGhpcy5mdWxsVXNlcktleSwgdGhpcy5ib3VuZEV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoYXV0aCwgcGVyc2lzdGVuY2VIaWVyYXJjaHksIHVzZXJLZXkgPSBcImF1dGhVc2VyXCIgLyogS2V5TmFtZS5BVVRIX1VTRVIgKi8pIHtcbiAgICAgICAgaWYgKCFwZXJzaXN0ZW5jZUhpZXJhcmNoeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc2lzdGVuY2VVc2VyTWFuYWdlcihfZ2V0SW5zdGFuY2UoaW5NZW1vcnlQZXJzaXN0ZW5jZSksIGF1dGgsIHVzZXJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsaW1pbmF0ZSBhbnkgcGVyc2lzdGVuY2VzIHRoYXQgYXJlIG5vdCBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUGVyc2lzdGVuY2VzID0gKGF3YWl0IFByb21pc2UuYWxsKHBlcnNpc3RlbmNlSGllcmFyY2h5Lm1hcChhc3luYyAocGVyc2lzdGVuY2UpID0+IHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwZXJzaXN0ZW5jZS5faXNBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZXJzaXN0ZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0pKSkuZmlsdGVyKHBlcnNpc3RlbmNlID0+IHBlcnNpc3RlbmNlKTtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBmaXJzdCBwZXJzaXN0ZW5jZSBsaXN0ZWQsIG9yIGluIG1lbW9yeSBpZiBub25lIGF2YWlsYWJsZVxuICAgICAgICBsZXQgc2VsZWN0ZWRQZXJzaXN0ZW5jZSA9IGF2YWlsYWJsZVBlcnNpc3RlbmNlc1swXSB8fFxuICAgICAgICAgICAgX2dldEluc3RhbmNlKGluTWVtb3J5UGVyc2lzdGVuY2UpO1xuICAgICAgICBjb25zdCBrZXkgPSBfcGVyc2lzdGVuY2VLZXlOYW1lKHVzZXJLZXksIGF1dGguY29uZmlnLmFwaUtleSwgYXV0aC5uYW1lKTtcbiAgICAgICAgLy8gUHVsbCBvdXQgdGhlIGV4aXN0aW5nIHVzZXIsIHNldHRpbmcgdGhlIGNob3NlbiBwZXJzaXN0ZW5jZSB0byB0aGF0XG4gICAgICAgIC8vIHBlcnNpc3RlbmNlIGlmIHRoZSB1c2VyIGV4aXN0cy5cbiAgICAgICAgbGV0IHVzZXJUb01pZ3JhdGUgPSBudWxsO1xuICAgICAgICAvLyBOb3RlLCBoZXJlIHdlIGNoZWNrIGZvciBhIHVzZXIgaW4gX2FsbF8gcGVyc2lzdGVuY2VzLCBub3QganVzdCB0aGVcbiAgICAgICAgLy8gb25lcyBkZWVtZWQgYXZhaWxhYmxlLiBJZiB3ZSBjYW4gbWlncmF0ZSBhIHVzZXIgb3V0IG9mIGEgYnJva2VuXG4gICAgICAgIC8vIHBlcnNpc3RlbmNlLCB3ZSB3aWxsIChidXQgb25seSBpZiB0aGF0IHBlcnNpc3RlbmNlIHN1cHBvcnRzIG1pZ3JhdGlvbikuXG4gICAgICAgIGZvciAoY29uc3QgcGVyc2lzdGVuY2Ugb2YgcGVyc2lzdGVuY2VIaWVyYXJjaHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHBlcnNpc3RlbmNlLl9nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyID0gVXNlckltcGwuX2Zyb21KU09OKGF1dGgsIGJsb2IpOyAvLyB0aHJvd3MgZm9yIHVucGFyc2FibGUgYmxvYiAod3JvbmcgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJUb01pZ3JhdGUgPSB1c2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBmaW5kIHRoZSB1c2VyIGluIGEgcGVyc2lzdGVuY2UgdGhhdCBkb2VzIHN1cHBvcnQgbWlncmF0aW9uLCB1c2VcbiAgICAgICAgLy8gdGhhdCBtaWdyYXRpb24gcGF0aCAob2Ygb25seSBwZXJzaXN0ZW5jZXMgdGhhdCBzdXBwb3J0IG1pZ3JhdGlvbilcbiAgICAgICAgY29uc3QgbWlncmF0aW9uSGllcmFyY2h5ID0gYXZhaWxhYmxlUGVyc2lzdGVuY2VzLmZpbHRlcihwID0+IHAuX3Nob3VsZEFsbG93TWlncmF0aW9uKTtcbiAgICAgICAgLy8gSWYgdGhlIHBlcnNpc3RlbmNlIGRvZXMgX25vdF8gYWxsb3cgbWlncmF0aW9uLCBqdXN0IGZpbmlzaCBvZmYgaGVyZVxuICAgICAgICBpZiAoIXNlbGVjdGVkUGVyc2lzdGVuY2UuX3Nob3VsZEFsbG93TWlncmF0aW9uIHx8XG4gICAgICAgICAgICAhbWlncmF0aW9uSGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKHNlbGVjdGVkUGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGVkUGVyc2lzdGVuY2UgPSBtaWdyYXRpb25IaWVyYXJjaHlbMF07XG4gICAgICAgIGlmICh1c2VyVG9NaWdyYXRlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG5vcm1hbGx5IHNob3VsZG4ndCB0aHJvdyBzaW5jZSBjaG9zZW5QZXJzaXN0ZW5jZS5pc0F2YWlsYWJsZSgpIGlzIHRydWUsIGJ1dCBpZiBpdCBkb2VzXG4gICAgICAgICAgICAvLyB3ZSdsbCBqdXN0IGxldCBpdCBidWJibGUgdG8gc3VyZmFjZSB0aGUgZXJyb3IuXG4gICAgICAgICAgICBhd2FpdCBzZWxlY3RlZFBlcnNpc3RlbmNlLl9zZXQoa2V5LCB1c2VyVG9NaWdyYXRlLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRlbXB0IHRvIGNsZWFyIHRoZSBrZXkgaW4gb3RoZXIgcGVyc2lzdGVuY2VzIGJ1dCBpZ25vcmUgZXJyb3JzLiBUaGlzIGhlbHBzIHByZXZlbnQgaXNzdWVzXG4gICAgICAgIC8vIHN1Y2ggYXMgdXNlcnMgZ2V0dGluZyBzdHVjayB3aXRoIGEgcHJldmlvdXMgYWNjb3VudCBhZnRlciBzaWduaW5nIG91dCBhbmQgcmVmcmVzaGluZyB0aGUgdGFiLlxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwZXJzaXN0ZW5jZUhpZXJhcmNoeS5tYXAoYXN5bmMgKHBlcnNpc3RlbmNlKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyc2lzdGVuY2UgIT09IHNlbGVjdGVkUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBwZXJzaXN0ZW5jZS5fcmVtb3ZlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyKHNlbGVjdGVkUGVyc2lzdGVuY2UsIGF1dGgsIHVzZXJLZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBicm93c2VyIGZvciB0aGUgcHVycG9zZXMgb2YgcmVwb3J0aW5nIHVzYWdlIHRvIHRoZSBBUElcbiAqL1xuZnVuY3Rpb24gX2dldEJyb3dzZXJOYW1lKHVzZXJBZ2VudCkge1xuICAgIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHVhLmluY2x1ZGVzKCdvcGVyYS8nKSB8fCB1YS5pbmNsdWRlcygnb3ByLycpIHx8IHVhLmluY2x1ZGVzKCdvcGlvcy8nKSkge1xuICAgICAgICByZXR1cm4gXCJPcGVyYVwiIC8qIEJyb3dzZXJOYW1lLk9QRVJBICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNJRU1vYmlsZSh1YSkpIHtcbiAgICAgICAgLy8gV2luZG93cyBwaG9uZSBJRU1vYmlsZSBicm93c2VyLlxuICAgICAgICByZXR1cm4gXCJJRU1vYmlsZVwiIC8qIEJyb3dzZXJOYW1lLklFTU9CSUxFICovO1xuICAgIH1cbiAgICBlbHNlIGlmICh1YS5pbmNsdWRlcygnbXNpZScpIHx8IHVhLmluY2x1ZGVzKCd0cmlkZW50LycpKSB7XG4gICAgICAgIHJldHVybiBcIklFXCIgLyogQnJvd3Nlck5hbWUuSUUgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKHVhLmluY2x1ZGVzKCdlZGdlLycpKSB7XG4gICAgICAgIHJldHVybiBcIkVkZ2VcIiAvKiBCcm93c2VyTmFtZS5FREdFICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNGaXJlZm94KHVhKSkge1xuICAgICAgICByZXR1cm4gXCJGaXJlZm94XCIgLyogQnJvd3Nlck5hbWUuRklSRUZPWCAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAodWEuaW5jbHVkZXMoJ3NpbGsvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiU2lsa1wiIC8qIEJyb3dzZXJOYW1lLlNJTEsgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc0JsYWNrQmVycnkodWEpKSB7XG4gICAgICAgIC8vIEJsYWNrYmVycnkgYnJvd3Nlci5cbiAgICAgICAgcmV0dXJuIFwiQmxhY2tiZXJyeVwiIC8qIEJyb3dzZXJOYW1lLkJMQUNLQkVSUlkgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc1dlYk9TKHVhKSkge1xuICAgICAgICAvLyBXZWJPUyBkZWZhdWx0IGJyb3dzZXIuXG4gICAgICAgIHJldHVybiBcIldlYm9zXCIgLyogQnJvd3Nlck5hbWUuV0VCT1MgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKF9pc1NhZmFyaSh1YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiU2FmYXJpXCIgLyogQnJvd3Nlck5hbWUuU0FGQVJJICovO1xuICAgIH1cbiAgICBlbHNlIGlmICgodWEuaW5jbHVkZXMoJ2Nocm9tZS8nKSB8fCBfaXNDaHJvbWVJT1ModWEpKSAmJlxuICAgICAgICAhdWEuaW5jbHVkZXMoJ2VkZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIFwiQ2hyb21lXCIgLyogQnJvd3Nlck5hbWUuQ0hST01FICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChfaXNBbmRyb2lkKHVhKSkge1xuICAgICAgICAvLyBBbmRyb2lkIHN0b2NrIGJyb3dzZXIuXG4gICAgICAgIHJldHVybiBcIkFuZHJvaWRcIiAvKiBCcm93c2VyTmFtZS5BTkRST0lEICovO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTW9zdCBtb2Rlcm4gYnJvd3NlcnMgaGF2ZSBuYW1lL3ZlcnNpb24gYXQgZW5kIG9mIHVzZXIgYWdlbnQgc3RyaW5nLlxuICAgICAgICBjb25zdCByZSA9IC8oW2EtekEtWlxcZFxcLl0rKVxcL1thLXpBLVpcXGRcXC5dKiQvO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gdXNlckFnZW50Lm1hdGNoKHJlKTtcbiAgICAgICAgaWYgKChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXMubGVuZ3RoKSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiT3RoZXJcIiAvKiBCcm93c2VyTmFtZS5PVEhFUiAqLztcbn1cbmZ1bmN0aW9uIF9pc0ZpcmVmb3godWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9maXJlZm94XFwvL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNTYWZhcmkodXNlckFnZW50ID0gZ2V0VUEoKSkge1xuICAgIGNvbnN0IHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuICh1YS5pbmNsdWRlcygnc2FmYXJpLycpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnY2hyb21lLycpICYmXG4gICAgICAgICF1YS5pbmNsdWRlcygnY3Jpb3MvJykgJiZcbiAgICAgICAgIXVhLmluY2x1ZGVzKCdhbmRyb2lkJykpO1xufVxuZnVuY3Rpb24gX2lzQ2hyb21lSU9TKHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAvY3Jpb3NcXC8vaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc0lFTW9iaWxlKHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAvaWVtb2JpbGUvaS50ZXN0KHVhKTtcbn1cbmZ1bmN0aW9uIF9pc0FuZHJvaWQodWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC9hbmRyb2lkL2kudGVzdCh1YSk7XG59XG5mdW5jdGlvbiBfaXNCbGFja0JlcnJ5KHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAvYmxhY2tiZXJyeS9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzV2ViT1ModWEgPSBnZXRVQSgpKSB7XG4gICAgcmV0dXJuIC93ZWJvcy9pLnRlc3QodWEpO1xufVxuZnVuY3Rpb24gX2lzSU9TKHVhID0gZ2V0VUEoKSkge1xuICAgIHJldHVybiAoL2lwaG9uZXxpcGFkfGlwb2QvaS50ZXN0KHVhKSB8fFxuICAgICAgICAoL21hY2ludG9zaC9pLnRlc3QodWEpICYmIC9tb2JpbGUvaS50ZXN0KHVhKSkpO1xufVxuZnVuY3Rpb24gX2lzSU9TN09yOCh1YSA9IGdldFVBKCkpIHtcbiAgICByZXR1cm4gKC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kudGVzdCh1YSkgfHxcbiAgICAgICAgLyhpUGFkfGlQaG9uZXxpUG9kKS4qT1MgOF9cXGQvaS50ZXN0KHVhKSk7XG59XG5mdW5jdGlvbiBfaXNJRTEwKCkge1xuICAgIHJldHVybiBpc0lFKCkgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID09PSAxMDtcbn1cbmZ1bmN0aW9uIF9pc01vYmlsZUJyb3dzZXIodWEgPSBnZXRVQSgpKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGdldEJyb3dzZXJOYW1lIGVxdWl2YWxlbnQgZm9yIE9TLlxuICAgIHJldHVybiAoX2lzSU9TKHVhKSB8fFxuICAgICAgICBfaXNBbmRyb2lkKHVhKSB8fFxuICAgICAgICBfaXNXZWJPUyh1YSkgfHxcbiAgICAgICAgX2lzQmxhY2tCZXJyeSh1YSkgfHxcbiAgICAgICAgL3dpbmRvd3MgcGhvbmUvaS50ZXN0KHVhKSB8fFxuICAgICAgICBfaXNJRU1vYmlsZSh1YSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLypcbiAqIERldGVybWluZSB0aGUgU0RLIHZlcnNpb24gc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIF9nZXRDbGllbnRWZXJzaW9uKGNsaWVudFBsYXRmb3JtLCBmcmFtZXdvcmtzID0gW10pIHtcbiAgICBsZXQgcmVwb3J0ZWRQbGF0Zm9ybTtcbiAgICBzd2l0Y2ggKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgICAgIGNhc2UgXCJCcm93c2VyXCIgLyogQ2xpZW50UGxhdGZvcm0uQlJPV1NFUiAqLzpcbiAgICAgICAgICAgIC8vIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCwgcmVwb3J0IHRoZSBicm93c2VyIG5hbWUuXG4gICAgICAgICAgICByZXBvcnRlZFBsYXRmb3JtID0gX2dldEJyb3dzZXJOYW1lKGdldFVBKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJXb3JrZXJcIiAvKiBDbGllbnRQbGF0Zm9ybS5XT1JLRVIgKi86XG4gICAgICAgICAgICAvLyBUZWNobmljYWxseSBhIHdvcmtlciBydW5zIGZyb20gYSBicm93c2VyIGJ1dCB3ZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYVxuICAgICAgICAgICAgLy8gd29ya2VyIGZyb20gYSBicm93c2VyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IENocm9tZS1Xb3JrZXIvSnNDb3JlLzQuOS4xL0ZpcmViYXNlQ29yZS13ZWIuXG4gICAgICAgICAgICByZXBvcnRlZFBsYXRmb3JtID0gYCR7X2dldEJyb3dzZXJOYW1lKGdldFVBKCkpfS0ke2NsaWVudFBsYXRmb3JtfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlcG9ydGVkUGxhdGZvcm0gPSBjbGllbnRQbGF0Zm9ybTtcbiAgICB9XG4gICAgY29uc3QgcmVwb3J0ZWRGcmFtZXdvcmtzID0gZnJhbWV3b3Jrcy5sZW5ndGhcbiAgICAgICAgPyBmcmFtZXdvcmtzLmpvaW4oJywnKVxuICAgICAgICA6ICdGaXJlYmFzZUNvcmUtd2ViJzsgLyogZGVmYXVsdCB2YWx1ZSBpZiBubyBvdGhlciBmcmFtZXdvcmsgaXMgdXNlZCAqL1xuICAgIHJldHVybiBgJHtyZXBvcnRlZFBsYXRmb3JtfS8ke1wiSnNDb3JlXCIgLyogQ2xpZW50SW1wbGVtZW50YXRpb24uQ09SRSAqL30vJHtTREtfVkVSU0lPTn0vJHtyZXBvcnRlZEZyYW1ld29ya3N9YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEF1dGhNaWRkbGV3YXJlUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKGF1dGgpIHtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBwdXNoQ2FsbGJhY2soY2FsbGJhY2ssIG9uQWJvcnQpIHtcbiAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGNvdWxkIGJlIHN5bmMgb3IgYXN5bmMuIFdyYXAgaXQgaW50byBhXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgaXMgYWx3YXlzIGFzeW5jLlxuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAodXNlcikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFjayh1c2VyKTtcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgcmVzb2x2ZSB3aXRoIGV4aXN0aW5nIHByb21pc2Ugb3Igd3JhcCBhIG5vbi1wcm9taXNlXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGludG8gYSBwcm9taXNlLlxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gU3luYyBjYWxsYmFjayB0aHJvd3MuXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQXR0YWNoIHRoZSBvbkFib3J0IGlmIHByZXNlbnRcbiAgICAgICAgd3JhcHBlZENhbGxiYWNrLm9uQWJvcnQgPSBvbkFib3J0O1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2god3JhcHBlZENhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBVbnN1YnNjcmliZS4gUmVwbGFjZSB3aXRoIG5vLW9wLiBEbyBub3QgcmVtb3ZlIGZyb20gYXJyYXksIG9yIGl0IHdpbGwgZGlzdHVyYlxuICAgICAgICAgICAgLy8gaW5kZXhpbmcgb2Ygb3RoZXIgZWxlbWVudHMuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlW2luZGV4XSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBydW5NaWRkbGV3YXJlKG5leHRVc2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dGguY3VycmVudFVzZXIgPT09IG5leHRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hpbGUgcnVubmluZyB0aGUgbWlkZGxld2FyZSwgYnVpbGQgYSB0ZW1wb3Jhcnkgc3RhY2sgb2Ygb25BYm9ydFxuICAgICAgICAvLyBjYWxsYmFja3MgdG8gY2FsbCBpZiBvbmUgbWlkZGxld2FyZSBjYWxsYmFjayByZWplY3RzLlxuICAgICAgICBjb25zdCBvbkFib3J0U3RhY2sgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmVmb3JlU3RhdGVDYWxsYmFjayBvZiB0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmVmb3JlU3RhdGVDYWxsYmFjayhuZXh0VXNlcik7XG4gICAgICAgICAgICAgICAgLy8gT25seSBwdXNoIHRoZSBvbkFib3J0IGlmIHRoZSBjYWxsYmFjayBzdWNjZWVkc1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmVTdGF0ZUNhbGxiYWNrLm9uQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25BYm9ydFN0YWNrLnB1c2goYmVmb3JlU3RhdGVDYWxsYmFjay5vbkFib3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFJ1biBhbGwgb25BYm9ydCwgd2l0aCBzZXBhcmF0ZSB0cnkvY2F0Y2ggdG8gaWdub3JlIGFueSBlcnJvcnMgYW5kXG4gICAgICAgICAgICAvLyBjb250aW51ZVxuICAgICAgICAgICAgb25BYm9ydFN0YWNrLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb25BYm9ydCBvZiBvbkFib3J0U3RhY2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvbkFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHN3YWxsb3cgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmF1dGguX2Vycm9yRmFjdG9yeS5jcmVhdGUoXCJsb2dpbi1ibG9ja2VkXCIgLyogQXV0aEVycm9yQ29kZS5MT0dJTl9CTE9DS0VEICovLCB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIzIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEZldGNoZXMgdGhlIHBhc3N3b3JkIHBvbGljeSBmb3IgdGhlIGN1cnJlbnRseSBzZXQgdGVuYW50IG9yIHRoZSBwcm9qZWN0IGlmIG5vIHRlbmFudCBpcyBzZXQuXG4gKlxuICogQHBhcmFtIGF1dGggQXV0aCBvYmplY3QuXG4gKiBAcGFyYW0gcmVxdWVzdCBQYXNzd29yZCBwb2xpY3kgcmVxdWVzdC5cbiAqIEByZXR1cm5zIFBhc3N3b3JkIHBvbGljeSByZXNwb25zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2dldFBhc3N3b3JkUG9saWN5KGF1dGgsIHJlcXVlc3QgPSB7fSkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJHRVRcIiAvKiBIdHRwTWV0aG9kLkdFVCAqLywgXCIvdjIvcGFzc3dvcmRQb2xpY3lcIiAvKiBFbmRwb2ludC5HRVRfUEFTU1dPUkRfUE9MSUNZICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gTWluaW11bSBtaW4gcGFzc3dvcmQgbGVuZ3RoIGVuZm9yY2VkIGJ5IHRoZSBiYWNrZW5kLCBldmVuIGlmIG5vIG1pbmltdW0gbGVuZ3RoIGlzIHNldC5cbmNvbnN0IE1JTklNVU1fTUlOX1BBU1NXT1JEX0xFTkdUSCA9IDY7XG4vKipcbiAqIFN0b3JlcyBwYXNzd29yZCBwb2xpY3kgcmVxdWlyZW1lbnRzIGFuZCBwcm92aWRlcyBwYXNzd29yZCB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIHBvbGljeS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGFzc3dvcmRQb2xpY3lJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZSBjdXN0b20gc3RyZW5ndGggb3B0aW9ucyBkZWZpbmVkIGluIHRoZSByZXNwb25zZS5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VPcHRpb25zID0gcmVzcG9uc2UuY3VzdG9tU3RyZW5ndGhPcHRpb25zO1xuICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgb25jZSB0aGUgYmFja2VuZCBpcyB1cGRhdGVkIHRvIGluY2x1ZGUgdGhlIG1pbmltdW0gbWluIHBhc3N3b3JkIGxlbmd0aCBpbnN0ZWFkIG9mIHVuZGVmaW5lZCB3aGVuIHRoZXJlIGlzIG5vIG1pbmltdW0gbGVuZ3RoIHNldC5cbiAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGggPVxuICAgICAgICAgICAgKF9hID0gcmVzcG9uc2VPcHRpb25zLm1pblBhc3N3b3JkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBNSU5JTVVNX01JTl9QQVNTV09SRF9MRU5HVEg7XG4gICAgICAgIGlmIChyZXNwb25zZU9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLm1heFBhc3N3b3JkTGVuZ3RoID1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUxldHRlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZU9wdGlvbnMuY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgPVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc1VwcGVyY2FzZUNoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXIgPVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9ucy5jb250YWluc051bWVyaWNDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciA9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9IHJlc3BvbnNlLmVuZm9yY2VtZW50U3RhdGU7XG4gICAgICAgIGlmICh0aGlzLmVuZm9yY2VtZW50U3RhdGUgPT09ICdFTkZPUkNFTUVOVF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgICAgIHRoaXMuZW5mb3JjZW1lbnRTdGF0ZSA9ICdPRkYnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gbm9uLWFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzID1cbiAgICAgICAgICAgIChfYyA9IChfYiA9IHJlc3BvbnNlLmFsbG93ZWROb25BbHBoYW51bWVyaWNDaGFyYWN0ZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuam9pbignJykpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnO1xuICAgICAgICB0aGlzLmZvcmNlVXBncmFkZU9uU2lnbmluID0gKF9kID0gcmVzcG9uc2UuZm9yY2VVcGdyYWRlT25TaWduaW4pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVtYVZlcnNpb24gPSByZXNwb25zZS5zY2hlbWFWZXJzaW9uO1xuICAgIH1cbiAgICB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgcGFzc3dvcmRQb2xpY3k6IHRoaXNcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHBhc3N3b3JkIGxlbmd0aCBhbmQgY2hhcmFjdGVyIG9wdGlvbnMuXG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZExlbmd0aE9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cyk7XG4gICAgICAgIC8vIENvbWJpbmUgdGhlIHN0YXR1cyBpbnRvIHNpbmdsZSBpc1ZhbGlkIHByb3BlcnR5LlxuICAgICAgICBzdGF0dXMuaXNWYWxpZCAmJiAoc3RhdHVzLmlzVmFsaWQgPSAoX2EgPSBzdGF0dXMubWVldHNNaW5QYXNzd29yZExlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSk7XG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfYiA9IHN0YXR1cy5tZWV0c01heFBhc3N3b3JkTGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9jID0gc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9kID0gc3RhdHVzLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKTtcbiAgICAgICAgc3RhdHVzLmlzVmFsaWQgJiYgKHN0YXR1cy5pc1ZhbGlkID0gKF9lID0gc3RhdHVzLmNvbnRhaW5zTnVtZXJpY0NoYXJhY3RlcikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdHJ1ZSk7XG4gICAgICAgIHN0YXR1cy5pc1ZhbGlkICYmIChzdGF0dXMuaXNWYWxpZCA9IChfZiA9IHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlcikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwYXNzd29yZCBtZWV0cyB0aGUgbGVuZ3RoIG9wdGlvbnMgZm9yIHRoZSBwb2xpY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgUGFzc3dvcmQgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHN0YXR1cyBWYWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBhc3N3b3JkTGVuZ3RoT3B0aW9ucyhwYXNzd29yZCwgc3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IG1pblBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWluUGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIGNvbnN0IG1heFBhc3N3b3JkTGVuZ3RoID0gdGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMubWF4UGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIGlmIChtaW5QYXNzd29yZExlbmd0aCkge1xuICAgICAgICAgICAgc3RhdHVzLm1lZXRzTWluUGFzc3dvcmRMZW5ndGggPSBwYXNzd29yZC5sZW5ndGggPj0gbWluUGFzc3dvcmRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFBhc3N3b3JkTGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0dXMubWVldHNNYXhQYXNzd29yZExlbmd0aCA9IHBhc3N3b3JkLmxlbmd0aCA8PSBtYXhQYXNzd29yZExlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgcGFzc3dvcmQgbWVldHMgdGhlIGNoYXJhY3RlciBvcHRpb25zIGZvciB0aGUgcG9saWN5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSBzdGF0dXMgVmFsaWRhdGlvbiBzdGF0dXMuXG4gICAgICovXG4gICAgdmFsaWRhdGVQYXNzd29yZENoYXJhY3Rlck9wdGlvbnMocGFzc3dvcmQsIHN0YXR1cykge1xuICAgICAgICAvLyBBc3NpZ24gc3RhdHVzZXMgZm9yIHJlcXVpcmVtZW50cyBldmVuIGlmIHRoZSBwYXNzd29yZCBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgIHRoaXMudXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBcbiAgICAgICAgLyogY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXI9ICovIGZhbHNlLCBcbiAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSwgXG4gICAgICAgIC8qIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyPSAqLyBmYWxzZSk7XG4gICAgICAgIGxldCBwYXNzd29yZENoYXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA9IHBhc3N3b3JkLmNoYXJBdChpKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFzc3dvcmRDaGFyYWN0ZXJPcHRpb25zU3RhdHVzZXMoc3RhdHVzLCBcbiAgICAgICAgICAgIC8qIGNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJ2EnICYmXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICd6JywgXG4gICAgICAgICAgICAvKiBjb250YWluc1VwcGVyY2FzZUNoYXJhY3Rlcj0gKi8gcGFzc3dvcmRDaGFyID49ICdBJyAmJlxuICAgICAgICAgICAgICAgIHBhc3N3b3JkQ2hhciA8PSAnWicsIFxuICAgICAgICAgICAgLyogY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyPSAqLyBwYXNzd29yZENoYXIgPj0gJzAnICYmXG4gICAgICAgICAgICAgICAgcGFzc3dvcmRDaGFyIDw9ICc5JywgXG4gICAgICAgICAgICAvKiBjb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3Rlcj0gKi8gdGhpcy5hbGxvd2VkTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVycy5pbmNsdWRlcyhwYXNzd29yZENoYXIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBydW5uaW5nIHZhbGlkYXRpb24gc3RhdHVzIHdpdGggdGhlIHN0YXR1c2VzIGZvciB0aGUgY2hhcmFjdGVyIG9wdGlvbnMuXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgY2FsbGVkIGVhY2ggdGltZSBhIGNoYXJhY3RlciBpcyBwcm9jZXNzZWQgdG8gdXBkYXRlIGVhY2ggb3B0aW9uIHN0YXR1c1xuICAgICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXMgVmFsaWRhdGlvbiBzdGF0dXMuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTG93ZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhIGxvd2VyY2FzZSBsZXR0ZXIuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhbiB1cHBlcmNhc2UgbGV0dGVyLlxuICAgICAqIEBwYXJhbSBjb250YWluc051bWVyaWNDaGFyYWN0ZXIgV2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbnVtZXJpYyBjaGFyYWN0ZXIuXG4gICAgICogQHBhcmFtIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyIFdoZXRoZXIgdGhlIGNoYXJhY3RlciBpcyBhIG5vbi1hbHBoYW51bWVyaWMgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIHVwZGF0ZVBhc3N3b3JkQ2hhcmFjdGVyT3B0aW9uc1N0YXR1c2VzKHN0YXR1cywgY29udGFpbnNMb3dlcmNhc2VDaGFyYWN0ZXIsIGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyLCBjb250YWluc051bWVyaWNDaGFyYWN0ZXIsIGNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbVN0cmVuZ3RoT3B0aW9ucy5jb250YWluc0xvd2VyY2FzZUxldHRlcikge1xuICAgICAgICAgICAgc3RhdHVzLmNvbnRhaW5zTG93ZXJjYXNlTGV0dGVyIHx8IChzdGF0dXMuY29udGFpbnNMb3dlcmNhc2VMZXR0ZXIgPSBjb250YWluc0xvd2VyY2FzZUNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3RyZW5ndGhPcHRpb25zLmNvbnRhaW5zVXBwZXJjYXNlTGV0dGVyKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNVcHBlcmNhc2VMZXR0ZXIgfHwgKHN0YXR1cy5jb250YWluc1VwcGVyY2FzZUxldHRlciA9IGNvbnRhaW5zVXBwZXJjYXNlQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyIHx8IChzdGF0dXMuY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOdW1lcmljQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXN0b21TdHJlbmd0aE9wdGlvbnMuY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb250YWluc05vbkFscGhhbnVtZXJpY0NoYXJhY3RlciB8fCAoc3RhdHVzLmNvbnRhaW5zTm9uQWxwaGFudW1lcmljQ2hhcmFjdGVyID0gY29udGFpbnNOb25BbHBoYW51bWVyaWNDaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQXV0aEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciA9IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlcjtcbiAgICAgICAgdGhpcy5hcHBDaGVja1NlcnZpY2VQcm92aWRlciA9IGFwcENoZWNrU2VydmljZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW11bGF0b3JDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLmlkVG9rZW5TdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMpO1xuICAgICAgICB0aGlzLmJlZm9yZVN0YXRlUXVldWUgPSBuZXcgQXV0aE1pZGRsZXdhcmVRdWV1ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gPSAxO1xuICAgICAgICAvLyBBbnkgbmV0d29yayBjYWxscyB3aWxsIHNldCB0aGlzIHRvIHRydWUgYW5kIHByZXZlbnQgc3Vic2VxdWVudCBlbXVsYXRvclxuICAgICAgICAvLyBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLl9jYW5Jbml0RW11bGF0b3IgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXJyb3JGYWN0b3J5ID0gX0RFRkFVTFRfQVVUSF9FUlJPUl9GQUNUT1JZO1xuICAgICAgICB0aGlzLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcHJvamVjdFBhc3N3b3JkUG9saWN5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llcyA9IHt9O1xuICAgICAgICAvLyBUcmFja3MgdGhlIGxhc3Qgbm90aWZpZWQgVUlEIGZvciBzdGF0ZSBjaGFuZ2UgbGlzdGVuZXJzIHRvIHByZXZlbnRcbiAgICAgICAgLy8gcmVwZWF0ZWQgY2FsbHMgdG8gdGhlIGNhbGxiYWNrcy4gVW5kZWZpbmVkIG1lYW5zIGl0J3MgbmV2ZXIgYmVlblxuICAgICAgICAvLyBjYWxsZWQsIHdoZXJlYXMgbnVsbCBtZWFucyBpdCdzIGJlZW4gY2FsbGVkIHdpdGggYSBzaWduZWQgb3V0IHVzZXJcbiAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7IGFwcFZlcmlmaWNhdGlvbkRpc2FibGVkRm9yVGVzdGluZzogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5mcmFtZXdvcmtzID0gW107XG4gICAgICAgIHRoaXMubmFtZSA9IGFwcC5uYW1lO1xuICAgICAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBjb25maWcuc2RrQ2xpZW50VmVyc2lvbjtcbiAgICB9XG4gICAgX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UocGVyc2lzdGVuY2VIaWVyYXJjaHksIHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICBpZiAocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIgPSBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBhcHAgZGVsZXRpb24gdGhyb3VnaG91dCBpbml0aWFsaXphdGlvbiAoYWZ0ZXIgZWFjaFxuICAgICAgICAvLyBwcm9taXNlIHJlc29sdXRpb24pXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemF0aW9uUHJvbWlzZSA9IHRoaXMucXVldWUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZU1hbmFnZXIgPSBhd2FpdCBQZXJzaXN0ZW5jZVVzZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLCBwZXJzaXN0ZW5jZUhpZXJhcmNoeSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlc29sdmVyIGVhcmx5IGlmIG5lY2Vzc2FyeSAob25seSBhcHBsaWNhYmxlIHRvIHdlYjpcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBjYXVzZSB0aGUgaWZyYW1lIHRvIGxvYWQgaW1tZWRpYXRlbHkgaW4gY2VydGFpbiBjYXNlcylcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fc2hvdWxkSW5pdFByb2FjdGl2ZWx5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgZG9uJ3QgaGFsdCBhdXRoIGxvYWRpbmdcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIuX2luaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElnbm9yZSB0aGUgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVDdXJyZW50VXNlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Tm90aWZpZWRVaWQgPSAoKF9iID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVpZCkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGVyc2lzdGVuY2UgaXMgY2hhbmdlZCBpbiBhbm90aGVyIHdpbmRvdywgdGhlIHVzZXIgbWFuYWdlciB3aWxsIGxldCB1cyBrbm93XG4gICAgICovXG4gICAgYXN5bmMgX29uU3RvcmFnZUV2ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2UuZ2V0Q3VycmVudFVzZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRVc2VyICYmICF1c2VyKSB7XG4gICAgICAgICAgICAvLyBObyBjaGFuZ2UsIGRvIG5vdGhpbmcgKHdhcyBzaWduZWQgb3V0IGFuZCByZW1haW5lZCBzaWduZWQgb3V0KS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc2FtZSB1c2VyIGlzIHRvIGJlIHN5bmNocm9uaXplZC5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIgJiYgdXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyLnVpZCA9PT0gdXNlci51aWQpIHtcbiAgICAgICAgICAgIC8vIERhdGEgdXBkYXRlLCBzaW1wbHkgY29weSBkYXRhIGNoYW5nZXMuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fYXNzaWduKHVzZXIpO1xuICAgICAgICAgICAgLy8gSWYgdG9rZW5zIGNoYW5nZWQgZnJvbSBwcmV2aW91cyB1c2VyIHRva2VucywgdGhpcyB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIG5vdGlmeUF1dGhMaXN0ZW5lcnNfLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgQXV0aCBzdGF0ZS4gRWl0aGVyIGEgbmV3IGxvZ2luIG9yIGxvZ291dC5cbiAgICAgICAgLy8gU2tpcCBibG9ja2luZyBjYWxsYmFja3MsIHRoZXkgc2hvdWxkIG5vdCBhcHBseSB0byBhIGNoYW5nZSBpbiBhbm90aGVyIHRhYi5cbiAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIodXNlciwgLyogc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzICovIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXJGcm9tSWRUb2tlbihpZFRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEFjY291bnRJbmZvKHRoaXMsIHsgaWRUb2tlbiB9KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VySW1wbC5fZnJvbUdldEFjY291bnRJbmZvUmVzcG9uc2UodGhpcywgcmVzcG9uc2UsIGlkVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmlyZWJhc2VTZXJ2ZXJBcHAgY291bGQgbm90IGxvZ2luIHVzZXIgd2l0aCBwcm92aWRlZCBhdXRoSWRUb2tlbjogJywgZXJyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplQ3VycmVudFVzZXIocG9wdXBSZWRpcmVjdFJlc29sdmVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgY29uc3QgaWRUb2tlbiA9IHRoaXMuYXBwLnNldHRpbmdzLmF1dGhJZFRva2VuO1xuICAgICAgICAgICAgaWYgKGlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgYXV0aCBvcGVyYXRpb24gaW4gdGhlIG5leHQgdGljayB0byBhbGxvdyBhIG1vbWVudCBmb3IgdGhlIGN1c3RvbWVyJ3MgYXBwIHRvXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoIGFuIGVtdWxhdG9yLCBpZiBkZXNpcmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluaXRpYWxpemVDdXJyZW50VXNlckZyb21JZFRva2VuKGlkVG9rZW4pLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHBlbmRpbmcgcmVkaXJlY3QgZXZlbnQuXG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTdG9yZWRVc2VyID0gKGF3YWl0IHRoaXMuYXNzZXJ0ZWRQZXJzaXN0ZW5jZS5nZXRDdXJyZW50VXNlcigpKTtcbiAgICAgICAgbGV0IGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgIGxldCBuZWVkc1RvY2hlY2tNaWRkbGV3YXJlID0gZmFsc2U7XG4gICAgICAgIGlmIChwb3B1cFJlZGlyZWN0UmVzb2x2ZXIgJiYgdGhpcy5jb25maWcuYXV0aERvbWFpbikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVkaXJlY3RVc2VyRXZlbnRJZCA9IChfYSA9IHRoaXMucmVkaXJlY3RVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX3JlZGlyZWN0RXZlbnRJZDtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFVzZXJFdmVudElkID0gZnV0dXJlQ3VycmVudFVzZXIgPT09IG51bGwgfHwgZnV0dXJlQ3VycmVudFVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQ7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnRyeVJlZGlyZWN0U2lnbkluKHBvcHVwUmVkaXJlY3RSZXNvbHZlcik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIHVzZXIgKGkuZS4gdGhlIG9sZCBcImN1cnJlbnRVc2VyXCIpIGhhcyBhIHJlZGlyZWN0SWQgdGhhdFxuICAgICAgICAgICAgLy8gbWF0Y2hlcyB0aGUgcmVkaXJlY3QgdXNlciwgdGhlbiB3ZSB3YW50IHRvIGluaXRpYWxseSBzaWduIGluIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBuZXcgdXNlciBvYmplY3QgZnJvbSByZXN1bHQuXG4gICAgICAgICAgICAvLyBUT0RPKHNhbWdobyk6IE1vcmUgdGhvcm91Z2hseSB0ZXN0IGFsbCBvZiB0aGlzXG4gICAgICAgICAgICBpZiAoKCFyZWRpcmVjdFVzZXJFdmVudElkIHx8IHJlZGlyZWN0VXNlckV2ZW50SWQgPT09IHN0b3JlZFVzZXJFdmVudElkKSAmJlxuICAgICAgICAgICAgICAgIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQudXNlcikpIHtcbiAgICAgICAgICAgICAgICBmdXR1cmVDdXJyZW50VXNlciA9IHJlc3VsdC51c2VyO1xuICAgICAgICAgICAgICAgIG5lZWRzVG9jaGVja01pZGRsZXdhcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHVzZXIgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGlzIG5vIGN1cnJlbnQgdXNlci4gU2V0IHRvIG51bGwuXG4gICAgICAgIGlmICghZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdXR1cmVDdXJyZW50VXNlci5fcmVkaXJlY3RFdmVudElkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzbid0IGEgcmVkaXJlY3QgbGluayBvcGVyYXRpb24sIHdlIGNhbiByZWxvYWQgYW5kIGJhaWwuXG4gICAgICAgICAgICAvLyBGaXJzdCB0aG91Z2gsIGVuc3VyZSB0aGF0IHdlIGNoZWNrIHRoZSBtaWRkbGV3YXJlIGlzIGhhcHB5LlxuICAgICAgICAgICAgaWYgKG5lZWRzVG9jaGVja01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1dHVyZUN1cnJlbnRVc2VyID0gcHJldmlvdXNseVN0b3JlZFVzZXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyBpcyBhdmFpbGFibGUgc2luY2UgdGhlIGJpdCBpcyBvbmx5IHNldCB3aGVuIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlciBpcyBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9vdmVycmlkZVJlZGlyZWN0UmVzdWx0KHRoaXMsICgpID0+IFByb21pc2UucmVqZWN0KGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnV0dXJlQ3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcihudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfYXNzZXJ0KHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciwgdGhpcywgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICBhd2FpdCB0aGlzLmdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKCk7XG4gICAgICAgIC8vIElmIHRoZSByZWRpcmVjdCB1c2VyJ3MgZXZlbnQgSUQgbWF0Y2hlcyB0aGUgY3VycmVudCB1c2VyJ3MgZXZlbnQgSUQsXG4gICAgICAgIC8vIERPIE5PVCByZWxvYWQgdGhlIGN1cnJlbnQgdXNlciwgb3RoZXJ3aXNlIHRoZXknbGwgYmUgY2xlYXJlZCBmcm9tIHN0b3JhZ2UuXG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciB0aGUgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QoKSBmbG93LlxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFVzZXIgJiZcbiAgICAgICAgICAgIHRoaXMucmVkaXJlY3RVc2VyLl9yZWRpcmVjdEV2ZW50SWQgPT09IGZ1dHVyZUN1cnJlbnRVc2VyLl9yZWRpcmVjdEV2ZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIoZnV0dXJlQ3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbG9hZEFuZFNldEN1cnJlbnRVc2VyT3JDbGVhcihmdXR1cmVDdXJyZW50VXNlcik7XG4gICAgfVxuICAgIGFzeW5jIHRyeVJlZGlyZWN0U2lnbkluKHJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgLy8gVGhlIHJlZGlyZWN0IHVzZXIgbmVlZHMgdG8gYmUgY2hlY2tlZCAoYW5kIHNpZ25lZCBpbiBpZiBhdmFpbGFibGUpXG4gICAgICAgIC8vIGR1cmluZyBhdXRoIGluaXRpYWxpemF0aW9uLiBBbGwgb2YgdGhlIG5vcm1hbCBzaWduIGluIGFuZCBsaW5rL3JlYXV0aFxuICAgICAgICAvLyBmbG93cyBjYWxsIGJhY2sgaW50byBhdXRoIGFuZCBwdXNoIHRoaW5ncyBvbnRvIHRoZSBwcm9taXNlIHF1ZXVlLiBXZVxuICAgICAgICAvLyBuZWVkIHRvIGF3YWl0IHRoZSByZXN1bHQgb2YgdGhlIHJlZGlyZWN0IHNpZ24gaW4gKmluc2lkZSB0aGUgcHJvbWlzZVxuICAgICAgICAvLyBxdWV1ZSouIFRoaXMgcHJlc2VudHMgYSBwcm9ibGVtOiB3ZSBydW4gaW50byBkZWFkbG9jay4gU2VlOlxuICAgICAgICAvLyAgICDilIw+IFtJbml0aWFsaXphdGlvbl0g4pSA4pSA4pSA4pSA4pSA4pSQXG4gICAgICAgIC8vICAgIOKUjD4gWzxvdGhlciBxdWV1ZSB0YXNrcz5dIOKUglxuICAgICAgICAvLyAgICDilJTilIAgW2dldFJlZGlyZWN0UmVzdWx0XSA84pSA4pSYXG4gICAgICAgIC8vICAgIHdoZXJlIFtdIGFyZSB0YXNrcyBvbiB0aGUgcXVldWUgYW5kIGFycm93cyBkZW5vdGUgYXdhaXRzXG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uIHdpbGwgbmV2ZXIgY29tcGxldGUgYmVjYXVzZSBpdCdzIHdhaXRpbmcgb24gc29tZXRoaW5nXG4gICAgICAgIC8vIHRoYXQncyB3YWl0aW5nIGZvciBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZSFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW5zdGVhZCwgdGhpcyBtZXRob2QgY2FsbHMgZ2V0UmVkaXJlY3RSZXN1bHQoKSAoc3RvcmVkIGluXG4gICAgICAgIC8vIF9jb21wbGV0ZVJlZGlyZWN0Rm4pIHdpdGggYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRoYXQgaW5zdHJ1Y3RzIGFsbCBvZlxuICAgICAgICAvLyB0aGUgdW5kZXJseWluZyBhdXRoIG9wZXJhdGlvbnMgdG8gc2tpcCBhbnl0aGluZyB0aGF0IG11dGF0ZXMgYXV0aCBzdGF0ZS5cbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBrbm93IHRoaXMuX3BvcHVwUmVkaXJlY3RSZXNvbHZlciBpcyBzZXQgc2luY2UgcmVkaXJlY3RSZXNvbHZlclxuICAgICAgICAgICAgLy8gaXMgcGFzc2VkIGluLiBUaGUgX2NvbXBsZXRlUmVkaXJlY3RGbiBleHBlY3RzIHRoZSB1bndyYXBwZWQgZXh0ZXJuLlxuICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5fcG9wdXBSZWRpcmVjdFJlc29sdmVyLl9jb21wbGV0ZVJlZGlyZWN0Rm4odGhpcywgcmVkaXJlY3RSZXNvbHZlciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgYW55IGVycm9ycyBoZXJlOyB0aGUgY29kZSBjYW4gcmV0cmlldmUgdGhlbSBpblxuICAgICAgICAgICAgLy8gZ2V0UmVkaXJlY3RSZXN1bHQoKS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyByZWxvYWRBbmRTZXRDdXJyZW50VXNlck9yQ2xlYXIodXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlbG9hZFdpdGhvdXRTYXZpbmcodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNvZGUpICE9PVxuICAgICAgICAgICAgICAgIGBhdXRoLyR7XCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIgLyogQXV0aEVycm9yQ29kZS5ORVRXT1JLX1JFUVVFU1RfRkFJTEVEICovfWApIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcncyB3cm9uZyB3aXRoIHRoZSB1c2VyJ3MgdG9rZW4uIExvZyB0aGVtIG91dCBhbmQgcmVtb3ZlXG4gICAgICAgICAgICAgICAgLy8gdGhlbSBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RseVNldEN1cnJlbnRVc2VyKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgfVxuICAgIHVzZURldmljZUxhbmd1YWdlKCkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlQ29kZSA9IF9nZXRVc2VyTGFuZ3VhZ2UoKTtcbiAgICB9XG4gICAgYXN5bmMgX2RlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUN1cnJlbnRVc2VyKHVzZXJFeHRlcm4pIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcHVibGljIHVwZGF0ZUN1cnJlbnRVc2VyIG1ldGhvZCBuZWVkcyB0byBtYWtlIGEgY29weSBvZiB0aGUgdXNlcixcbiAgICAgICAgLy8gYW5kIGFsc28gY2hlY2sgdGhhdCB0aGUgcHJvamVjdCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRXh0ZXJuXG4gICAgICAgICAgICA/IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyRXh0ZXJuKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgX2Fzc2VydCh1c2VyLmF1dGguY29uZmlnLmFwaUtleSA9PT0gdGhpcy5jb25maWcuYXBpS2V5LCB0aGlzLCBcImludmFsaWQtdXNlci10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BVVRIICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlQ3VycmVudFVzZXIodXNlciAmJiB1c2VyLl9jbG9uZSh0aGlzKSk7XG4gICAgfVxuICAgIGFzeW5jIF91cGRhdGVDdXJyZW50VXNlcih1c2VyLCBza2lwQmVmb3JlU3RhdGVDYWxsYmFja3MgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fZGVsZXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICBfYXNzZXJ0KHRoaXMudGVuYW50SWQgPT09IHVzZXIudGVuYW50SWQsIHRoaXMsIFwidGVuYW50LWlkLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5URU5BTlRfSURfTUlTTUFUQ0ggKi8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEJlZm9yZVN0YXRlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZSh1c2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUF1dGhMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ25PdXQoKSB7XG4gICAgICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcCh0aGlzLmFwcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfc2VydmVyQXBwQ3VycmVudFVzZXJPcGVyYXRpb25Ob3RTdXBwb3J0ZWRFcnJvcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVuIGZpcnN0LCB0byBibG9jayBfc2V0UmVkaXJlY3RVc2VyKCkgaWYgYW55IGNhbGxiYWNrcyBmYWlsLlxuICAgICAgICBhd2FpdCB0aGlzLmJlZm9yZVN0YXRlUXVldWUucnVuTWlkZGxld2FyZShudWxsKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZGlyZWN0IHVzZXIgd2hlbiBzaWduT3V0IGlzIGNhbGxlZFxuICAgICAgICBpZiAodGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlciB8fCB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldFJlZGlyZWN0VXNlcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGNhbGxiYWNrcyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBpbiBfdXBkYXRlQ3VycmVudFVzZXIsIGFzXG4gICAgICAgIC8vIHRoZXkgd2VyZSBhbHJlYWR5IGNhbGxlZCBpbiB0aGUgZmlyc3QgbGluZS5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUN1cnJlbnRVc2VyKG51bGwsIC8qIHNraXBCZWZvcmVTdGF0ZUNhbGxiYWNrcyAqLyB0cnVlKTtcbiAgICB9XG4gICAgc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpIHtcbiAgICAgICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKHRoaXMuYXBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydGVkUGVyc2lzdGVuY2Uuc2V0UGVyc2lzdGVuY2UoX2dldEluc3RhbmNlKHBlcnNpc3RlbmNlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UmVjYXB0Y2hhQ29uZmlnKCkge1xuICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWdlbnRSZWNhcHRjaGFDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1t0aGlzLnRlbmFudElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgICAgIGlmICghdGhpcy5fZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVQYXNzd29yZFBvbGljeSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhc3N3b3JkIHBvbGljeSB3aWxsIGJlIGRlZmluZWQgYWZ0ZXIgZmV0Y2hpbmcuXG4gICAgICAgIGNvbnN0IHBhc3N3b3JkUG9saWN5ID0gdGhpcy5fZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBwb2xpY3kgc2NoZW1hIHZlcnNpb24gaXMgc3VwcG9ydGVkIGJ5IHRoZSBTREsuXG4gICAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIGxvZ2ljIHRvIHVzZSBhIG1heCBzdXBwb3J0ZWQgcG9saWN5IHNjaGVtYSB2ZXJzaW9uIG9uY2Ugd2UgaGF2ZSBtdWx0aXBsZSBzY2hlbWEgdmVyc2lvbnMuXG4gICAgICAgIGlmIChwYXNzd29yZFBvbGljeS5zY2hlbWFWZXJzaW9uICE9PVxuICAgICAgICAgICAgdGhpcy5FWFBFQ1RFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLl9lcnJvckZhY3RvcnkuY3JlYXRlKFwidW5zdXBwb3J0ZWQtcGFzc3dvcmQtcG9saWN5LXNjaGVtYS12ZXJzaW9uXCIgLyogQXV0aEVycm9yQ29kZS5VTlNVUFBPUlRFRF9QQVNTV09SRF9QT0xJQ1lfU0NIRU1BX1ZFUlNJT04gKi8sIHt9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhc3N3b3JkUG9saWN5LnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIH1cbiAgICBfZ2V0UGFzc3dvcmRQb2xpY3lJbnRlcm5hbCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGVuYW50SWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9qZWN0UGFzc3dvcmRQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVuYW50UGFzc3dvcmRQb2xpY2llc1t0aGlzLnRlbmFudElkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlUGFzc3dvcmRQb2xpY3koKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2dldFBhc3N3b3JkUG9saWN5KHRoaXMpO1xuICAgICAgICBjb25zdCBwYXNzd29yZFBvbGljeSA9IG5ldyBQYXNzd29yZFBvbGljeUltcGwocmVzcG9uc2UpO1xuICAgICAgICBpZiAodGhpcy50ZW5hbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcHJvamVjdFBhc3N3b3JkUG9saWN5ID0gcGFzc3dvcmRQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90ZW5hbnRQYXNzd29yZFBvbGljaWVzW3RoaXMudGVuYW50SWRdID0gcGFzc3dvcmRQb2xpY3k7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFBlcnNpc3RlbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnBlcnNpc3RlbmNlLnR5cGU7XG4gICAgfVxuICAgIF91cGRhdGVFcnJvck1hcChlcnJvck1hcCkge1xuICAgICAgICB0aGlzLl9lcnJvckZhY3RvcnkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhdXRoJywgJ0ZpcmViYXNlJywgZXJyb3JNYXAoKSk7XG4gICAgfVxuICAgIG9uQXV0aFN0YXRlQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclN0YXRlTGlzdGVuZXIodGhpcy5hdXRoU3RhdGVTdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICB9XG4gICAgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaywgb25BYm9ydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTdGF0ZVF1ZXVlLnB1c2hDYWxsYmFjayhjYWxsYmFjaywgb25BYm9ydCk7XG4gICAgfVxuICAgIG9uSWRUb2tlbkNoYW5nZWQobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTdGF0ZUxpc3RlbmVyKHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpO1xuICAgIH1cbiAgICBhdXRoU3RhdGVSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLm9uQXV0aFN0YXRlQ2hhbmdlZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyB0aGUgZ2l2ZW4gYWNjZXNzIHRva2VuLiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBBcHBsZSBPQXV0aCBhY2Nlc3MgdG9rZW5zLlxuICAgICAqL1xuICAgIGFzeW5jIHJldm9rZUFjY2Vzc1Rva2VuKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG4gICAgICAgICAgICAvLyBHZW5lcmFsaXplIHRoaXMgdG8gYWNjZXB0IG90aGVyIHByb3ZpZGVycyBvbmNlIHN1cHBvcnRlZC5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJJZDogJ2FwcGxlLmNvbScsXG4gICAgICAgICAgICAgICAgdG9rZW5UeXBlOiBcIkFDQ0VTU19UT0tFTlwiIC8qIFRva2VuVHlwZS5BQ0NFU1NfVE9LRU4gKi8sXG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgaWRUb2tlblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbmFudElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRlbmFudElkID0gdGhpcy50ZW5hbnRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJldm9rZVRva2VuKHRoaXMsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmNvbmZpZy5hcGlLZXksXG4gICAgICAgICAgICBhdXRoRG9tYWluOiB0aGlzLmNvbmZpZy5hdXRoRG9tYWluLFxuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgY3VycmVudFVzZXI6IChfYSA9IHRoaXMuX2N1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9KU09OKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldFJlZGlyZWN0VXNlcih1c2VyLCBwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RNYW5hZ2VyID0gYXdhaXQgdGhpcy5nZXRPckluaXRSZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlcihwb3B1cFJlZGlyZWN0UmVzb2x2ZXIpO1xuICAgICAgICByZXR1cm4gdXNlciA9PT0gbnVsbFxuICAgICAgICAgICAgPyByZWRpcmVjdE1hbmFnZXIucmVtb3ZlQ3VycmVudFVzZXIoKVxuICAgICAgICAgICAgOiByZWRpcmVjdE1hbmFnZXIuc2V0Q3VycmVudFVzZXIodXNlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldE9ySW5pdFJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyKHBvcHVwUmVkaXJlY3RSZXNvbHZlcikge1xuICAgICAgICBpZiAoIXRoaXMucmVkaXJlY3RQZXJzaXN0ZW5jZU1hbmFnZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gKHBvcHVwUmVkaXJlY3RSZXNvbHZlciAmJiBfZ2V0SW5zdGFuY2UocG9wdXBSZWRpcmVjdFJlc29sdmVyKSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3B1cFJlZGlyZWN0UmVzb2x2ZXI7XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc29sdmVyLCB0aGlzLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyID0gYXdhaXQgUGVyc2lzdGVuY2VVc2VyTWFuYWdlci5jcmVhdGUodGhpcywgW19nZXRJbnN0YW5jZShyZXNvbHZlci5fcmVkaXJlY3RQZXJzaXN0ZW5jZSldLCBcInJlZGlyZWN0VXNlclwiIC8qIEtleU5hbWUuUkVESVJFQ1RfVVNFUiAqLyk7XG4gICAgICAgICAgICB0aGlzLnJlZGlyZWN0VXNlciA9XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWRpcmVjdFBlcnNpc3RlbmNlTWFuYWdlci5nZXRDdXJyZW50VXNlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0UGVyc2lzdGVuY2VNYW5hZ2VyO1xuICAgIH1cbiAgICBhc3luYyBfcmVkaXJlY3RVc2VyRm9ySWQoaWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIGNsZWFyZWQgYW55IHBlbmRpbmcgcGVyc2lzdGVuY2UgYWN0aW9ucyBpZiB3ZSdyZSBub3QgaW5cbiAgICAgICAgLy8gdGhlIGluaXRpYWxpemVyXG4gICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9yZWRpcmVjdEV2ZW50SWQpID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRVc2VyO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9iID0gdGhpcy5yZWRpcmVjdFVzZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5fcmVkaXJlY3RFdmVudElkKSA9PT0gaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0VXNlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgX3BlcnNpc3RVc2VySWZDdXJyZW50KHVzZXIpIHtcbiAgICAgICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlKGFzeW5jICgpID0+IHRoaXMuZGlyZWN0bHlTZXRDdXJyZW50VXNlcih1c2VyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIE5vdGlmaWVzIGxpc3RlbmVycyBvbmx5IGlmIHRoZSB1c2VyIGlzIGN1cnJlbnQgKi9cbiAgICBfbm90aWZ5TGlzdGVuZXJzSWZDdXJyZW50KHVzZXIpIHtcbiAgICAgICAgaWYgKHVzZXIgPT09IHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5QXV0aExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9rZXkoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbmZpZy5hdXRoRG9tYWlufToke3RoaXMuY29uZmlnLmFwaUtleX06JHt0aGlzLm5hbWV9YDtcbiAgICB9XG4gICAgX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5pc1Byb2FjdGl2ZVJlZnJlc2hFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRVc2VyLl9zdGFydFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RvcFByb2FjdGl2ZVJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuaXNQcm9hY3RpdmVSZWZyZXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlcikge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFVzZXIuX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGN1cnJlbnQgdXNlciBjYXN0IGFzIHRoZSBpbnRlcm5hbCB0eXBlICovXG4gICAgZ2V0IF9jdXJyZW50VXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFVzZXI7XG4gICAgfVxuICAgIG5vdGlmeUF1dGhMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWRUb2tlblN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICBjb25zdCBjdXJyZW50VWlkID0gKF9iID0gKF9hID0gdGhpcy5jdXJyZW50VXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubGFzdE5vdGlmaWVkVWlkICE9PSBjdXJyZW50VWlkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3ROb3RpZmllZFVpZCA9IGN1cnJlbnRVaWQ7XG4gICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZVN1YnNjcmlwdGlvbi5uZXh0KHRoaXMuY3VycmVudFVzZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2lzdGVyU3RhdGVMaXN0ZW5lcihzdWJzY3JpcHRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNiID0gdHlwZW9mIG5leHRPck9ic2VydmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IG5leHRPck9ic2VydmVyXG4gICAgICAgICAgICA6IG5leHRPck9ic2VydmVyLm5leHQuYmluZChuZXh0T3JPYnNlcnZlcik7XG4gICAgICAgIGxldCBpc1Vuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5faXNJbml0aWFsaXplZFxuICAgICAgICAgICAgPyBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgOiB0aGlzLl9pbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgICAgIF9hc3NlcnQocHJvbWlzZSwgdGhpcywgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICAvLyBUaGUgY2FsbGJhY2sgbmVlZHMgdG8gYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IHBlciB0aGUgc3BlYy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IodGhpcy5jdXJyZW50VXNlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIG5leHRPck9ic2VydmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN1YnNjcmlwdGlvbi5hZGRPYnNlcnZlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gc3Vic2NyaXB0aW9uLmFkZE9ic2VydmVyKG5leHRPck9ic2VydmVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXNVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucHJvdGVjdGVkIChmcm9tIHJhY2UgY29uZGl0aW9ucykgbWV0aG9kIHRvIHNldCB0aGUgY3VycmVudCB1c2VyLiBUaGlzXG4gICAgICogc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgcXVldWVkIGNhbGxiYWNrLiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgICAqIGJlY2F1c2UgdGhlIHF1ZXVlIHNob3VsZG4ndCByZWx5IG9uIGFub3RoZXIgcXVldWVkIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIGFzeW5jIGRpcmVjdGx5U2V0Q3VycmVudFVzZXIodXNlcikge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VXNlciAmJiB0aGlzLmN1cnJlbnRVc2VyICE9PSB1c2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VXNlci5fc3RvcFByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlciAmJiB0aGlzLmlzUHJvYWN0aXZlUmVmcmVzaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHVzZXIuX3N0YXJ0UHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFVzZXIgPSB1c2VyO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnNldEN1cnJlbnRVc2VyKHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnRlZFBlcnNpc3RlbmNlLnJlbW92ZUN1cnJlbnRVc2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUoYWN0aW9uKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugc29tZXRoaW5nIGVycm9ycywgdGhlIGNhbGxiYWNrIHN0aWxsIHNob3VsZCBiZSBjYWxsZWQgaW4gb3JkZXJcbiAgICAgICAgLy8gdG8ga2VlcCB0aGUgcHJvbWlzZSBjaGFpbiBhbGl2ZVxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSB0aGlzLm9wZXJhdGlvbnMudGhlbihhY3Rpb24sIGFjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnM7XG4gICAgfVxuICAgIGdldCBhc3NlcnRlZFBlcnNpc3RlbmNlKCkge1xuICAgICAgICBfYXNzZXJ0KHRoaXMucGVyc2lzdGVuY2VNYW5hZ2VyLCB0aGlzLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcnNpc3RlbmNlTWFuYWdlcjtcbiAgICB9XG4gICAgX2xvZ0ZyYW1ld29yayhmcmFtZXdvcmspIHtcbiAgICAgICAgaWYgKCFmcmFtZXdvcmsgfHwgdGhpcy5mcmFtZXdvcmtzLmluY2x1ZGVzKGZyYW1ld29yaykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1ld29ya3MucHVzaChmcmFtZXdvcmspO1xuICAgICAgICAvLyBTb3J0IGFscGhhYmV0aWNhbGx5IHNvIHRoYXQgXCJGaXJlYmFzZUNvcmUtd2ViLEZpcmViYXNlVUktd2ViXCIgYW5kXG4gICAgICAgIC8vIFwiRmlyZWJhc2VVSS13ZWIsRmlyZWJhc2VDb3JlLXdlYlwiIGFyZW4ndCB2aWV3ZWQgYXMgZGlmZmVyZW50LlxuICAgICAgICB0aGlzLmZyYW1ld29ya3Muc29ydCgpO1xuICAgICAgICB0aGlzLmNsaWVudFZlcnNpb24gPSBfZ2V0Q2xpZW50VmVyc2lvbih0aGlzLmNvbmZpZy5jbGllbnRQbGF0Zm9ybSwgdGhpcy5fZ2V0RnJhbWV3b3JrcygpKTtcbiAgICB9XG4gICAgX2dldEZyYW1ld29ya3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyYW1ld29ya3M7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBZGRpdGlvbmFsSGVhZGVycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBBZGRpdGlvbmFsIGhlYWRlcnMgb24gZXZlcnkgcmVxdWVzdFxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgW1wiWC1DbGllbnQtVmVyc2lvblwiIC8qIEh0dHBIZWFkZXIuWF9DTElFTlRfVkVSU0lPTiAqL106IHRoaXMuY2xpZW50VmVyc2lvblxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcHAub3B0aW9ucy5hcHBJZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtRmlyZWJhc2UtZ21waWRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfR01QSUQgKi9dID0gdGhpcy5hcHAub3B0aW9ucy5hcHBJZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmdcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0c0hlYWRlciA9IGF3YWl0ICgoX2EgPSB0aGlzLmhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlclxuICAgICAgICAgICAgLmdldEltbWVkaWF0ZSh7XG4gICAgICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgICB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEhlYXJ0YmVhdHNIZWFkZXIoKSk7XG4gICAgICAgIGlmIChoZWFydGJlYXRzSGVhZGVyKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1GaXJlYmFzZS1DbGllbnRcIiAvKiBIdHRwSGVhZGVyLlhfRklSRUJBU0VfQ0xJRU5UICovXSA9IGhlYXJ0YmVhdHNIZWFkZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIEFwcCBDaGVjayBzZXJ2aWNlIGV4aXN0cywgYWRkIHRoZSBBcHAgQ2hlY2sgdG9rZW4gaW4gdGhlIGhlYWRlcnNcbiAgICAgICAgY29uc3QgYXBwQ2hlY2tUb2tlbiA9IGF3YWl0IHRoaXMuX2dldEFwcENoZWNrVG9rZW4oKTtcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLUZpcmViYXNlLUFwcENoZWNrXCIgLyogSHR0cEhlYWRlci5YX0ZJUkVCQVNFX0FQUF9DSEVDSyAqL10gPSBhcHBDaGVja1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXBwQ2hlY2tUb2tlbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhcHBDaGVja1Rva2VuUmVzdWx0ID0gYXdhaXQgKChfYSA9IHRoaXMuYXBwQ2hlY2tTZXJ2aWNlUHJvdmlkZXJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRva2VuKCkpO1xuICAgICAgICBpZiAoYXBwQ2hlY2tUb2tlblJlc3VsdCA9PT0gbnVsbCB8fCBhcHBDaGVja1Rva2VuUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Rva2VuUmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAvLyBDb250ZXh0OiBhcHBDaGVjay5nZXRUb2tlbigpIHdpbGwgbmV2ZXIgdGhyb3cgZXZlbiBpZiBhbiBlcnJvciBoYXBwZW5lZC5cbiAgICAgICAgICAgIC8vIEluIHRoZSBlcnJvciBjYXNlLCBhIGR1bW15IHRva2VuIHdpbGwgYmUgcmV0dXJuZWQgYWxvbmcgd2l0aCBhbiBlcnJvciBmaWVsZCBkZXNjcmliaW5nXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IuIEluIGdlbmVyYWwsIHdlIHNob3VsZG4ndCBjYXJlIGFib3V0IHRoZSBlcnJvciBjb25kaXRpb24gYW5kIGp1c3QgdXNlXG4gICAgICAgICAgICAvLyB0aGUgdG9rZW4gKGFjdHVhbCBvciBkdW1teSkgdG8gc2VuZCByZXF1ZXN0cy5cbiAgICAgICAgICAgIF9sb2dXYXJuKGBFcnJvciB3aGlsZSByZXRyaWV2aW5nIEFwcCBDaGVjayB0b2tlbjogJHthcHBDaGVja1Rva2VuUmVzdWx0LmVycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBDaGVja1Rva2VuUmVzdWx0ID09PSBudWxsIHx8IGFwcENoZWNrVG9rZW5SZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrVG9rZW5SZXN1bHQudG9rZW47XG4gICAgfVxufVxuLyoqXG4gKiBNZXRob2QgdG8gYmUgdXNlZCB0byBjYXN0IGRvd24gdG8gb3VyIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2YgQXV0aC5cbiAqIEl0IHdpbGwgYWxzbyBoYW5kbGUgdW53cmFwcGluZyBmcm9tIHRoZSBjb21wYXQgdHlwZSBpZiBuZWNlc3NhcnlcbiAqXG4gKiBAcGFyYW0gYXV0aCBBdXRoIG9iamVjdCBwYXNzZWQgaW4gZnJvbSBkZXZlbG9wZXJcbiAqL1xuZnVuY3Rpb24gX2Nhc3RBdXRoKGF1dGgpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xufVxuLyoqIEhlbHBlciBjbGFzcyB0byB3cmFwIHN1YnNjcmliZXIgbG9naWMgKi9cbmNsYXNzIFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYXV0aCkge1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZGRPYnNlcnZlciA9IGNyZWF0ZVN1YnNjcmliZShvYnNlcnZlciA9PiAodGhpcy5vYnNlcnZlciA9IG9ic2VydmVyKSk7XG4gICAgfVxuICAgIGdldCBuZXh0KCkge1xuICAgICAgICBfYXNzZXJ0KHRoaXMub2JzZXJ2ZXIsIHRoaXMuYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlci5uZXh0LmJpbmQodGhpcy5vYnNlcnZlcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubGV0IGV4dGVybmFsSlNQcm92aWRlciA9IHtcbiAgICBhc3luYyBsb2FkSlMoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvYWQgZXh0ZXJuYWwgc2NyaXB0cycpO1xuICAgIH0sXG4gICAgcmVjYXB0Y2hhVjJTY3JpcHQ6ICcnLFxuICAgIHJlY2FwdGNoYUVudGVycHJpc2VTY3JpcHQ6ICcnLFxuICAgIGdhcGlTY3JpcHQ6ICcnXG59O1xuZnVuY3Rpb24gX2xvYWRKUyh1cmwpIHtcbiAgICByZXR1cm4gZXh0ZXJuYWxKU1Byb3ZpZGVyLmxvYWRKUyh1cmwpO1xufVxuZnVuY3Rpb24gX3JlY2FwdGNoYUVudGVycHJpc2VTY3JpcHRVcmwoKSB7XG4gICAgcmV0dXJuIGV4dGVybmFsSlNQcm92aWRlci5yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTW9ja0dyZUNBUFRDSEFUb3BMZXZlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJwcmlzZSA9IG5ldyBNb2NrR3JlQ0FQVENIQSgpO1xuICAgIH1cbiAgICByZWFkeShjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBleGVjdXRlKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfc2l0ZUtleSwgX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgndG9rZW4nKTtcbiAgICB9XG4gICAgcmVuZGVyKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBfY29udGFpbmVyLCBfcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuY2xhc3MgTW9ja0dyZUNBUFRDSEEge1xuICAgIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGV4ZWN1dGUoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9zaXRlS2V5LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0b2tlbicpO1xuICAgIH1cbiAgICByZW5kZXIoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9jb250YWluZXIsIF9wYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbmNvbnN0IFJFQ0FQVENIQV9FTlRFUlBSSVNFX1ZFUklGSUVSX1RZUEUgPSAncmVjYXB0Y2hhLWVudGVycHJpc2UnO1xuY29uc3QgRkFLRV9UT0tFTiA9ICdOT19SRUNBUFRDSEEnO1xuY2xhc3MgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdXRoRXh0ZXJuIC0gVGhlIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2Uge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXV0aEV4dGVybikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllcyB0aGUgdHlwZSBvZiBhcHBsaWNhdGlvbiB2ZXJpZmllciAoZS5nLiBcInJlY2FwdGNoYS1lbnRlcnByaXNlXCIpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gUkVDQVBUQ0hBX0VOVEVSUFJJU0VfVkVSSUZJRVJfVFlQRTtcbiAgICAgICAgdGhpcy5hdXRoID0gX2Nhc3RBdXRoKGF1dGhFeHRlcm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgdmVyaWZpY2F0aW9uIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIGEgdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBhc3NlcnQgdGhlIHZhbGlkaXR5IG9mIGEgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyB2ZXJpZnkoYWN0aW9uID0gJ3ZlcmlmeScsIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJldHJpZXZlU2l0ZUtleShhdXRoKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgIGlmIChhdXRoLnRlbmFudElkID09IG51bGwgJiYgYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcuc2l0ZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF1dGgudGVuYW50SWQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGguX3RlbmFudFJlY2FwdGNoYUNvbmZpZ3NbYXV0aC50ZW5hbnRJZF0uc2l0ZUtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGdldFJlY2FwdGNoYUNvbmZpZyhhdXRoLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi8sXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZWNhcHRjaGFLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigncmVjYXB0Y2hhIEVudGVycHJpc2Ugc2l0ZSBrZXkgdW5kZWZpbmVkJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IFJlY2FwdGNoYUNvbmZpZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0aC50ZW5hbnRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aC5fYWdlbnRSZWNhcHRjaGFDb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoLl90ZW5hbnRSZWNhcHRjaGFDb25maWdzW2F1dGgudGVuYW50SWRdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29uZmlnLnNpdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBncmVjYXB0Y2hhID0gd2luZG93LmdyZWNhcHRjaGE7XG4gICAgICAgICAgICBpZiAoaXNFbnRlcnByaXNlKGdyZWNhcHRjaGEpKSB7XG4gICAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlLnJlYWR5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5lbnRlcnByaXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlY3V0ZShzaXRlS2V5LCB7IGFjdGlvbiB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShGQUtFX1RPS0VOKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoRXJyb3IoJ05vIHJlQ0FQVENIQSBlbnRlcnByaXNlIHNjcmlwdCBsb2FkZWQuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybnMgUHJvbWlzZSBmb3IgYSBtb2NrIHRva2VuIHdoZW4gYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nIGlzIHRydWUuXG4gICAgICAgIGlmICh0aGlzLmF1dGguc2V0dGluZ3MuYXBwVmVyaWZpY2F0aW9uRGlzYWJsZWRGb3JUZXN0aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtb2NrUmVjYXB0Y2hhID0gbmV3IE1vY2tHcmVDQVBUQ0hBVG9wTGV2ZWwoKTtcbiAgICAgICAgICAgIHJldHVybiBtb2NrUmVjYXB0Y2hhLmV4ZWN1dGUoJ3NpdGVLZXknLCB7IGFjdGlvbjogJ3ZlcmlmeScgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJldHJpZXZlU2l0ZUtleSh0aGlzLmF1dGgpXG4gICAgICAgICAgICAgICAgLnRoZW4oc2l0ZUtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgaXNFbnRlcnByaXNlKHdpbmRvdy5ncmVjYXB0Y2hhKSkge1xuICAgICAgICAgICAgICAgICAgICByZXRyaWV2ZVJlY2FwdGNoYVRva2VuKHNpdGVLZXksIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1JlY2FwdGNoYVZlcmlmaWVyIGlzIG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHVybCA9IF9yZWNhcHRjaGFFbnRlcnByaXNlU2NyaXB0VXJsKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmwubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gc2l0ZUtleTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfbG9hZEpTKHVybClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZXZlUmVjYXB0Y2hhVG9rZW4oc2l0ZUtleSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aCwgcmVxdWVzdCwgYWN0aW9uLCBpc0NhcHRjaGFSZXNwID0gZmFsc2UsIGlzRmFrZVRva2VuID0gZmFsc2UpIHtcbiAgICBjb25zdCB2ZXJpZmllciA9IG5ldyBSZWNhcHRjaGFFbnRlcnByaXNlVmVyaWZpZXIoYXV0aCk7XG4gICAgbGV0IGNhcHRjaGFSZXNwb25zZTtcbiAgICBpZiAoaXNGYWtlVG9rZW4pIHtcbiAgICAgICAgY2FwdGNoYVJlc3BvbnNlID0gRkFLRV9UT0tFTjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYXB0Y2hhUmVzcG9uc2UgPSBhd2FpdCB2ZXJpZmllci52ZXJpZnkoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHRjaGFSZXNwb25zZSA9IGF3YWl0IHZlcmlmaWVyLnZlcmlmeShhY3Rpb24sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld1JlcXVlc3QgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KTtcbiAgICBpZiAoYWN0aW9uID09PSBcIm1mYVNtc0Vucm9sbG1lbnRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLk1GQV9TTVNfRU5ST0xMTUVOVCAqLyB8fFxuICAgICAgICBhY3Rpb24gPT09IFwibWZhU21zU2lnbkluXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5NRkFfU01TX1NJR05JTiAqLykge1xuICAgICAgICBpZiAoJ3Bob25lRW5yb2xsbWVudEluZm8nIGluIG5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHBob25lTnVtYmVyID0gbmV3UmVxdWVzdC5waG9uZUVucm9sbG1lbnRJbmZvLnBob25lTnVtYmVyO1xuICAgICAgICAgICAgY29uc3QgcmVjYXB0Y2hhVG9rZW4gPSBuZXdSZXF1ZXN0LnBob25lRW5yb2xsbWVudEluZm8ucmVjYXB0Y2hhVG9rZW47XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAncGhvbmVFbnJvbGxtZW50SW5mbyc6IHtcbiAgICAgICAgICAgICAgICAgICAgcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlY2FwdGNoYVRva2VuLFxuICAgICAgICAgICAgICAgICAgICBjYXB0Y2hhUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICdjbGllbnRUeXBlJzogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgICAgICAgICAgICAgJ3JlY2FwdGNoYVZlcnNpb24nOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3Bob25lU2lnbkluSW5mbycgaW4gbmV3UmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcmVjYXB0Y2hhVG9rZW4gPSBuZXdSZXF1ZXN0LnBob25lU2lnbkluSW5mby5yZWNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3UmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICdwaG9uZVNpZ25JbkluZm8nOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2FwdGNoYVRva2VuLFxuICAgICAgICAgICAgICAgICAgICBjYXB0Y2hhUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICdjbGllbnRUeXBlJzogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyxcbiAgICAgICAgICAgICAgICAgICAgJ3JlY2FwdGNoYVZlcnNpb24nOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1JlcXVlc3Q7XG4gICAgfVxuICAgIGlmICghaXNDYXB0Y2hhUmVzcCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHsgY2FwdGNoYVJlc3BvbnNlIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7ICdjYXB0Y2hhUmVzcCc6IGNhcHRjaGFSZXNwb25zZSB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihuZXdSZXF1ZXN0LCB7ICdjbGllbnRUeXBlJzogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqLyB9KTtcbiAgICBPYmplY3QuYXNzaWduKG5ld1JlcXVlc3QsIHtcbiAgICAgICAgJ3JlY2FwdGNoYVZlcnNpb24nOiBcIlJFQ0FQVENIQV9FTlRFUlBSSVNFXCIgLyogUmVjYXB0Y2hhVmVyc2lvbi5FTlRFUlBSSVNFICovXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1JlcXVlc3Q7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSwgYWN0aW9uTWV0aG9kLCByZWNhcHRjaGFBdXRoUHJvdmlkZXIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChyZWNhcHRjaGFBdXRoUHJvdmlkZXIgPT09IFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pIHtcbiAgICAgICAgaWYgKChfYSA9IGF1dGhJbnN0YW5jZVxuICAgICAgICAgICAgLl9nZXRSZWNhcHRjaGFDb25maWcoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUHJvdmlkZXJFbmFibGVkKFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYSA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGFjdGlvbk5hbWUgPT09IFwiZ2V0T29iQ29kZVwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuR0VUX09PQl9DT0RFICovKTtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uTWV0aG9kKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCkuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJtaXNzaW5nLXJlY2FwdGNoYS10b2tlblwiIC8qIEF1dGhFcnJvckNvZGUuTUlTU0lOR19SRUNBUFRDSEFfVE9LRU4gKi99YCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHthY3Rpb25OYW1lfSBpcyBwcm90ZWN0ZWQgYnkgcmVDQVBUQ0hBIEVudGVycHJpc2UgZm9yIHRoaXMgcHJvamVjdC4gQXV0b21hdGljYWxseSB0cmlnZ2VyaW5nIHRoZSByZUNBUFRDSEEgZmxvdyBhbmQgcmVzdGFydGluZyB0aGUgZmxvdy5gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGEgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBhY3Rpb25OYW1lID09PSBcImdldE9vYkNvZGVcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlY2FwdGNoYUF1dGhQcm92aWRlciA9PT0gXCJQSE9ORV9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5QSE9ORV9QUk9WSURFUiAqLykge1xuICAgICAgICBpZiAoKF9iID0gYXV0aEluc3RhbmNlXG4gICAgICAgICAgICAuX2dldFJlY2FwdGNoYUNvbmZpZygpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNQcm92aWRlckVuYWJsZWQoXCJQSE9ORV9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5QSE9ORV9QUk9WSURFUiAqLykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoUmVjYXB0Y2hhID0gYXdhaXQgaW5qZWN0UmVjYXB0Y2hhRmllbGRzKGF1dGhJbnN0YW5jZSwgcmVxdWVzdCwgYWN0aW9uTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uTWV0aG9kKGF1dGhJbnN0YW5jZSwgcmVxdWVzdFdpdGhSZWNhcHRjaGEpLmNhdGNoKGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IGF1dGhJbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAuX2dldFJlY2FwdGNoYUNvbmZpZygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvdmlkZXJFbmZvcmNlbWVudFN0YXRlKFwiUEhPTkVfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuUEhPTkVfUFJPVklERVIgKi8pKSA9PT0gXCJBVURJVFwiIC8qIEVuZm9yY2VtZW50U3RhdGUuQVVESVQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQVVESVQgbW9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gYGF1dGgvJHtcIm1pc3NpbmctcmVjYXB0Y2hhLXRva2VuXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX1JFQ0FQVENIQV9UT0tFTiAqL31gIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID09PSBgYXV0aC8ke1wiaW52YWxpZC1hcHAtY3JlZGVudGlhbFwiIC8qIEF1dGhFcnJvckNvZGUuSU5WQUxJRF9BUFBfQ1JFREVOVElBTCAqL31gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIHZlcmlmeSB3aXRoIHJlQ0FQVENIQSBFbnRlcnByaXNlLiBBdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIHJlQ0FQVENIQSB2MiBmbG93IHRvIGNvbXBsZXRlIHRoZSAke2FjdGlvbk5hbWV9IGZsb3cuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZUNBUFRDSEEgRW50ZXJwcmlzZSB0b2tlbiBpcyBtaXNzaW5nIG9yIHJlQ0FQVENIQSBFbnRlcnByaXNlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmYWlscy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHJlQ0FQVENIQSB2MiBmbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdFdpdGhSZWNhcHRjaGFGaWVsZHMgPSBhd2FpdCBpbmplY3RSZWNhcHRjaGFGaWVsZHMoYXV0aEluc3RhbmNlLCByZXF1ZXN0LCBhY3Rpb25OYW1lLCBmYWxzZSwgLy8gaXNDYXB0Y2hhUmVzcFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSAvLyBpc0Zha2VUb2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBjYWxsIHRoZSBQaG9uZUFwaUNhbGxlciB0byBmZXRjaCBhbmQgaW5qZWN0IHJlQ0FQVENIQSB2MiB0b2tlbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25NZXRob2QoYXV0aEluc3RhbmNlLCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRU5GT1JDRSBtb2RlIG9yIEFVRElUIG1vZGUgd2l0aCBhbnkgb3RoZXIgZXJyb3IuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRG8gcmVDQVBUQ0hBIHYyIGZsb3cuXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0V2l0aFJlY2FwdGNoYUZpZWxkcyA9IGF3YWl0IGluamVjdFJlY2FwdGNoYUZpZWxkcyhhdXRoSW5zdGFuY2UsIHJlcXVlc3QsIGFjdGlvbk5hbWUsIGZhbHNlLCAvLyBpc0NhcHRjaGFSZXNwXG4gICAgICAgICAgICB0cnVlIC8vIGlzRmFrZVRva2VuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhbGwgdGhlIFBob25lQXBpQ2FsbGVyIHRvIGZldGNoIGFuZCBpbmplY3QgdjIgdG9rZW4uXG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uTWV0aG9kKGF1dGhJbnN0YW5jZSwgcmVxdWVzdFdpdGhSZWNhcHRjaGFGaWVsZHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVjYXB0Y2hhQXV0aFByb3ZpZGVyICsgJyBwcm92aWRlciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIF9pbml0aWFsaXplUmVjYXB0Y2hhQ29uZmlnKGF1dGgpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRSZWNhcHRjaGFDb25maWcoYXV0aEludGVybmFsLCB7XG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi8sXG4gICAgICAgIHZlcnNpb246IFwiUkVDQVBUQ0hBX0VOVEVSUFJJU0VcIiAvKiBSZWNhcHRjaGFWZXJzaW9uLkVOVEVSUFJJU0UgKi9cbiAgICB9KTtcbiAgICBjb25zdCBjb25maWcgPSBuZXcgUmVjYXB0Y2hhQ29uZmlnKHJlc3BvbnNlKTtcbiAgICBpZiAoYXV0aEludGVybmFsLnRlbmFudElkID09IG51bGwpIHtcbiAgICAgICAgYXV0aEludGVybmFsLl9hZ2VudFJlY2FwdGNoYUNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhJbnRlcm5hbC5fdGVuYW50UmVjYXB0Y2hhQ29uZmlnc1thdXRoSW50ZXJuYWwudGVuYW50SWRdID0gY29uZmlnO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmlzQW55UHJvdmlkZXJFbmFibGVkKCkpIHtcbiAgICAgICAgY29uc3QgdmVyaWZpZXIgPSBuZXcgUmVjYXB0Y2hhRW50ZXJwcmlzZVZlcmlmaWVyKGF1dGhJbnRlcm5hbCk7XG4gICAgICAgIHZvaWQgdmVyaWZpZXIudmVyaWZ5KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbml0aWFsaXplcyBhbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2Ugd2l0aCBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gKiB7QGxpbmsgRGVwZW5kZW5jaWVzfS5cbiAqXG4gKiBAcmVtYXJrc1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIG1vcmUgY29udHJvbCBvdmVyIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdGhhblxuICoge0BsaW5rIGdldEF1dGh9LiBgZ2V0QXV0aGAgdXNlcyBwbGF0Zm9ybS1zcGVjaWZpYyBkZWZhdWx0cyB0byBzdXBwbHlcbiAqIHRoZSB7QGxpbmsgRGVwZW5kZW5jaWVzfS4gSW4gZ2VuZXJhbCwgYGdldEF1dGhgIGlzIHRoZSBlYXNpZXN0IHdheSB0b1xuICogaW5pdGlhbGl6ZSBBdXRoIGFuZCB3b3JrcyBmb3IgbW9zdCB1c2UgY2FzZXMuIFVzZSBgaW5pdGlhbGl6ZUF1dGhgIGlmIHlvdVxuICogbmVlZCBjb250cm9sIG92ZXIgd2hpY2ggcGVyc2lzdGVuY2UgbGF5ZXIgaXMgdXNlZCwgb3IgdG8gbWluaW1pemUgYnVuZGxlXG4gKiBzaXplIGlmIHlvdSdyZSBub3QgdXNpbmcgZWl0aGVyIGBzaWduSW5XaXRoUG9wdXBgIG9yIGBzaWduSW5XaXRoUmVkaXJlY3RgLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3VyIGFwcCBvbmx5IHVzZXMgYW5vbnltb3VzIGFjY291bnRzIGFuZCB5b3Ugb25seSB3YW50XG4gKiBhY2NvdW50cyBzYXZlZCBmb3IgdGhlIGN1cnJlbnQgc2Vzc2lvbiwgaW5pdGlhbGl6ZSBgQXV0aGAgd2l0aDpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYXV0aCA9IGluaXRpYWxpemVBdXRoKGFwcCwge1xuICogICBwZXJzaXN0ZW5jZTogYnJvd3NlclNlc3Npb25QZXJzaXN0ZW5jZSxcbiAqICAgcG9wdXBSZWRpcmVjdFJlc29sdmVyOiB1bmRlZmluZWQsXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUF1dGgoYXBwLCBkZXBzKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnYXV0aCcpO1xuICAgIGlmIChwcm92aWRlci5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgY29uc3QgYXV0aCA9IHByb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xuICAgICAgICBjb25zdCBpbml0aWFsT3B0aW9ucyA9IHByb3ZpZGVyLmdldE9wdGlvbnMoKTtcbiAgICAgICAgaWYgKGRlZXBFcXVhbChpbml0aWFsT3B0aW9ucywgZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB2b2lkIDAgPyBkZXBzIDoge30pKSB7XG4gICAgICAgICAgICByZXR1cm4gYXV0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiYWxyZWFkeS1pbml0aWFsaXplZFwiIC8qIEF1dGhFcnJvckNvZGUuQUxSRUFEWV9JTklUSUFMSVpFRCAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXV0aCA9IHByb3ZpZGVyLmluaXRpYWxpemUoeyBvcHRpb25zOiBkZXBzIH0pO1xuICAgIHJldHVybiBhdXRoO1xufVxuZnVuY3Rpb24gX2luaXRpYWxpemVBdXRoSW5zdGFuY2UoYXV0aCwgZGVwcykge1xuICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gKGRlcHMgPT09IG51bGwgfHwgZGVwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVwcy5wZXJzaXN0ZW5jZSkgfHwgW107XG4gICAgY29uc3QgaGllcmFyY2h5ID0gKEFycmF5LmlzQXJyYXkocGVyc2lzdGVuY2UpID8gcGVyc2lzdGVuY2UgOiBbcGVyc2lzdGVuY2VdKS5tYXAoX2dldEluc3RhbmNlKTtcbiAgICBpZiAoZGVwcyA9PT0gbnVsbCB8fCBkZXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXBzLmVycm9yTWFwKSB7XG4gICAgICAgIGF1dGguX3VwZGF0ZUVycm9yTWFwKGRlcHMuZXJyb3JNYXApO1xuICAgIH1cbiAgICAvLyBUaGlzIHByb21pc2UgaXMgaW50ZW5kZWQgdG8gZmxvYXQ7IGF1dGggaW5pdGlhbGl6YXRpb24gaGFwcGVucyBpbiB0aGVcbiAgICAvLyBiYWNrZ3JvdW5kLCBtZWFud2hpbGUgdGhlIGF1dGggb2JqZWN0IG1heSBiZSB1c2VkIGJ5IHRoZSBhcHAuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgIGF1dGguX2luaXRpYWxpemVXaXRoUGVyc2lzdGVuY2UoaGllcmFyY2h5LCBkZXBzID09PSBudWxsIHx8IGRlcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlcHMucG9wdXBSZWRpcmVjdFJlc29sdmVyKTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgRmlyZWJhc2UgQXV0aCBFbXVsYXRvciwgaW5zdGVhZCBvZiBwcm9kdWN0aW9uXG4gKiBGaXJlYmFzZSBBdXRoIHNlcnZpY2VzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG11c3QgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgaW1tZWRpYXRlbHkgZm9sbG93aW5nIHRoZSBmaXJzdCBjYWxsIHRvXG4gKiB7QGxpbmsgaW5pdGlhbGl6ZUF1dGh9LiAgRG8gbm90IHVzZSB3aXRoIHByb2R1Y3Rpb24gY3JlZGVudGlhbHMgYXMgZW11bGF0b3JcbiAqIHRyYWZmaWMgaXMgbm90IGVuY3J5cHRlZC5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbm5lY3RBdXRoRW11bGF0b3IoYXV0aCwgJ2h0dHA6Ly8xMjcuMC4wLjE6OTA5OScsIHsgZGlzYWJsZVdhcm5pbmdzOiB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgYXQgd2hpY2ggdGhlIGVtdWxhdG9yIGlzIHJ1bm5pbmcgKGVnLCAnaHR0cDovL2xvY2FsaG9zdDo5MDk5JykuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBgb3B0aW9ucy5kaXNhYmxlV2FybmluZ3NgIGRlZmF1bHRzIHRvIGBmYWxzZWAuIFNldCBpdCB0b1xuICogYHRydWVgIHRvIGRpc2FibGUgdGhlIHdhcm5pbmcgYmFubmVyIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjb25uZWN0QXV0aEVtdWxhdG9yKGF1dGgsIHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBfYXNzZXJ0KGF1dGhJbnRlcm5hbC5fY2FuSW5pdEVtdWxhdG9yLCBhdXRoSW50ZXJuYWwsIFwiZW11bGF0b3ItY29uZmlnLWZhaWxlZFwiIC8qIEF1dGhFcnJvckNvZGUuRU1VTEFUT1JfQ09ORklHX0ZBSUxFRCAqLyk7XG4gICAgX2Fzc2VydCgvXmh0dHBzPzpcXC9cXC8vLnRlc3QodXJsKSwgYXV0aEludGVybmFsLCBcImludmFsaWQtZW11bGF0b3Itc2NoZW1lXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0VNVUxBVE9SX1NDSEVNRSAqLyk7XG4gICAgY29uc3QgZGlzYWJsZVdhcm5pbmdzID0gISEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpc2FibGVXYXJuaW5ncyk7XG4gICAgY29uc3QgcHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2wodXJsKTtcbiAgICBjb25zdCB7IGhvc3QsIHBvcnQgfSA9IGV4dHJhY3RIb3N0QW5kUG9ydCh1cmwpO1xuICAgIGNvbnN0IHBvcnRTdHIgPSBwb3J0ID09PSBudWxsID8gJycgOiBgOiR7cG9ydH1gO1xuICAgIC8vIEFsd2F5cyByZXBsYWNlIHBhdGggd2l0aCBcIi9cIiAoZXZlbiBpZiBpbnB1dCB1cmwgaGFkIG5vIHBhdGggYXQgYWxsLCBvciBoYWQgYSBkaWZmZXJlbnQgb25lKS5cbiAgICBhdXRoSW50ZXJuYWwuY29uZmlnLmVtdWxhdG9yID0geyB1cmw6IGAke3Byb3RvY29sfS8vJHtob3N0fSR7cG9ydFN0cn0vYCB9O1xuICAgIGF1dGhJbnRlcm5hbC5zZXR0aW5ncy5hcHBWZXJpZmljYXRpb25EaXNhYmxlZEZvclRlc3RpbmcgPSB0cnVlO1xuICAgIGF1dGhJbnRlcm5hbC5lbXVsYXRvckNvbmZpZyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0LFxuICAgICAgICBwcm90b2NvbDogcHJvdG9jb2wucmVwbGFjZSgnOicsICcnKSxcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmZyZWV6ZSh7IGRpc2FibGVXYXJuaW5ncyB9KVxuICAgIH0pO1xuICAgIGlmICghZGlzYWJsZVdhcm5pbmdzKSB7XG4gICAgICAgIGVtaXRFbXVsYXRvcldhcm5pbmcoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2wodXJsKSB7XG4gICAgY29uc3QgcHJvdG9jb2xFbmQgPSB1cmwuaW5kZXhPZignOicpO1xuICAgIHJldHVybiBwcm90b2NvbEVuZCA8IDAgPyAnJyA6IHVybC5zdWJzdHIoMCwgcHJvdG9jb2xFbmQgKyAxKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RIb3N0QW5kUG9ydCh1cmwpIHtcbiAgICBjb25zdCBwcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbCh1cmwpO1xuICAgIGNvbnN0IGF1dGhvcml0eSA9IC8oXFwvXFwvKT8oW14/Iy9dKykvLmV4ZWModXJsLnN1YnN0cihwcm90b2NvbC5sZW5ndGgpKTsgLy8gQmV0d2VlbiAvLyBhbmQgLywgPyBvciAjLlxuICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICAgIHJldHVybiB7IGhvc3Q6ICcnLCBwb3J0OiBudWxsIH07XG4gICAgfVxuICAgIGNvbnN0IGhvc3RBbmRQb3J0ID0gYXV0aG9yaXR5WzJdLnNwbGl0KCdAJykucG9wKCkgfHwgJyc7IC8vIFN0cmlwIG91dCBcInVzZXJuYW1lOnBhc3N3b3JkQFwiLlxuICAgIGNvbnN0IGJyYWNrZXRlZElQdjYgPSAvXihcXFtbXlxcXV0rXFxdKSg6fCQpLy5leGVjKGhvc3RBbmRQb3J0KTtcbiAgICBpZiAoYnJhY2tldGVkSVB2Nikge1xuICAgICAgICBjb25zdCBob3N0ID0gYnJhY2tldGVkSVB2NlsxXTtcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KGhvc3RBbmRQb3J0LnN1YnN0cihob3N0Lmxlbmd0aCArIDEpKSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW2hvc3QsIHBvcnRdID0gaG9zdEFuZFBvcnQuc3BsaXQoJzonKTtcbiAgICAgICAgcmV0dXJuIHsgaG9zdCwgcG9ydDogcGFyc2VQb3J0KHBvcnQpIH07XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQb3J0KHBvcnRTdHIpIHtcbiAgICBpZiAoIXBvcnRTdHIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHBvcnQgPSBOdW1iZXIocG9ydFN0cik7XG4gICAgaWYgKGlzTmFOKHBvcnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcG9ydDtcbn1cbmZ1bmN0aW9uIGVtaXRFbXVsYXRvcldhcm5pbmcoKSB7XG4gICAgZnVuY3Rpb24gYXR0YWNoQmFubmVyKCkge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAgICAgY29uc3Qgc3R5ID0gZWwuc3R5bGU7XG4gICAgICAgIGVsLmlubmVyVGV4dCA9XG4gICAgICAgICAgICAnUnVubmluZyBpbiBlbXVsYXRvciBtb2RlLiBEbyBub3QgdXNlIHdpdGggcHJvZHVjdGlvbiBjcmVkZW50aWFscy4nO1xuICAgICAgICBzdHkucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICBzdHkud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHN0eS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZmZmZic7XG4gICAgICAgIHN0eS5ib3JkZXIgPSAnLjFlbSBzb2xpZCAjMDAwMDAwJztcbiAgICAgICAgc3R5LmNvbG9yID0gJyNiNTAwMDAnO1xuICAgICAgICBzdHkuYm90dG9tID0gJzBweCc7XG4gICAgICAgIHN0eS5sZWZ0ID0gJzBweCc7XG4gICAgICAgIHN0eS5tYXJnaW4gPSAnMHB4JztcbiAgICAgICAgc3R5LnpJbmRleCA9ICcxMDAwMCc7XG4gICAgICAgIHN0eS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnZmlyZWJhc2UtZW11bGF0b3Itd2FybmluZycpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5pbmZvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnV0FSTklORzogWW91IGFyZSB1c2luZyB0aGUgQXV0aCBFbXVsYXRvciwnICtcbiAgICAgICAgICAgICcgd2hpY2ggaXMgaW50ZW5kZWQgZm9yIGxvY2FsIHRlc3Rpbmcgb25seS4gIERvIG5vdCB1c2Ugd2l0aCcgK1xuICAgICAgICAgICAgJyBwcm9kdWN0aW9uIGNyZWRlbnRpYWxzLicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGF0dGFjaEJhbm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRhY2hCYW5uZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogSW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIEF1dGhQcm92aWRlcn0uXG4gKlxuICogQHJlbWFya3NcbiAqIEltcGxlbWVudGF0aW9ucyBzcGVjaWZ5IHRoZSBkZXRhaWxzIGFib3V0IGVhY2ggYXV0aCBwcm92aWRlcidzIGNyZWRlbnRpYWwgcmVxdWlyZW1lbnRzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgQXV0aENyZWRlbnRpYWwge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgSUQgZm9yIHRoZSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgZXhhbXBsZSwgJ2ZhY2Vib29rLmNvbScsIG9yICdnb29nbGUuY29tJy5cbiAgICAgKi9cbiAgICBwcm92aWRlcklkLCBcbiAgICAvKipcbiAgICAgKiBUaGUgYXV0aGVudGljYXRpb24gc2lnbiBpbiBtZXRob2QgZm9yIHRoZSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBGb3IgZXhhbXBsZSwge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfUEFTU1dPUkQsIG9yXG4gICAgICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy4gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgc2lnbi1pbiBtZXRob2RcbiAgICAgKiBpZGVudGlmaWVyIGFzIHJldHVybmVkIGluIHtAbGluayBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbH0uXG4gICAgICovXG4gICAgc2lnbkluTWV0aG9kKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgICAgIHRoaXMuc2lnbkluTWV0aG9kID0gc2lnbkluTWV0aG9kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIGRlYnVnRmFpbCgnbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0SWRUb2tlblJlc3BvbnNlKF9hdXRoKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2xpbmtUb0lkVG9rZW4oX2F1dGgsIF9pZFRva2VuKSB7XG4gICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihfYXV0aCkge1xuICAgICAgICByZXR1cm4gZGVidWdGYWlsKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNldFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6cmVzZXRQYXNzd29yZFwiIC8qIEVuZHBvaW50LlJFU0VUX1BBU1NXT1JEICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnVwZGF0ZVwiIC8qIEVuZHBvaW50LlNFVF9BQ0NPVU5UX0lORk8gKi8sIHJlcXVlc3QpO1xufVxuLy8gVXNlZCBmb3IgbGlua2luZyBhbiBlbWFpbC9wYXNzd29yZCBhY2NvdW50IHRvIGFuIGV4aXN0aW5nIGlkVG9rZW4uIFVzZXMgdGhlIHNhbWUgcmVxdWVzdC9yZXNwb25zZVxuLy8gZm9ybWF0IGFzIHVwZGF0ZUVtYWlsUGFzc3dvcmQuXG5hc3luYyBmdW5jdGlvbiBsaW5rRW1haWxQYXNzd29yZChhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25VcFwiIC8qIEVuZHBvaW50LlNJR05fVVAgKi8sIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aFBhc3N3b3JkXCIgLyogRW5kcG9pbnQuU0lHTl9JTl9XSVRIX1BBU1NXT1JEICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzZW5kT29iQ29kZVwiIC8qIEVuZHBvaW50LlNFTkRfT09CX0NPREUgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kRW1haWxWZXJpZmljYXRpb24kMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VuZFBhc3N3b3JkUmVzZXRFbWFpbCQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gc2VuZE9vYkNvZGUoYXV0aCwgcmVxdWVzdCk7XG59XG5hc3luYyBmdW5jdGlvbiBzZW5kU2lnbkluTGlua1RvRW1haWwkMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHNlbmRPb2JDb2RlKGF1dGgsIHJlcXVlc3QpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5QW5kQ2hhbmdlRW1haWwoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBzZW5kT29iQ29kZShhdXRoLCByZXF1ZXN0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmskMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhFbWFpbExpbmtcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfRU1BSUxfTElOSyAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmtGb3JMaW5raW5nKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aEVtYWlsTGlua1wiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9FTUFJTF9MSU5LICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBJbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSB7QGxpbmsgRW1haWxBdXRoUHJvdmlkZXJ9IGZvclxuICoge0BsaW5rIFByb3ZpZGVySWR9LlBBU1NXT1JEXG4gKlxuICogQHJlbWFya3NcbiAqIENvdmVycyBib3RoIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX1BBU1NXT1JEIGFuZFxuICoge0BsaW5rIFNpZ25Jbk1ldGhvZH0uRU1BSUxfTElOSy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEVtYWlsQXV0aENyZWRlbnRpYWwgZXh0ZW5kcyBBdXRoQ3JlZGVudGlhbCB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZW1haWwsIFxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcGFzc3dvcmQsIHNpZ25Jbk1ldGhvZCwgXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90ZW5hbnRJZCA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoXCJwYXNzd29yZFwiIC8qIFByb3ZpZGVySWQuUEFTU1dPUkQgKi8sIHNpZ25Jbk1ldGhvZCk7XG4gICAgICAgIHRoaXMuX2VtYWlsID0gX2VtYWlsO1xuICAgICAgICB0aGlzLl9wYXNzd29yZCA9IF9wYXNzd29yZDtcbiAgICAgICAgdGhpcy5fdGVuYW50SWQgPSBfdGVuYW50SWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21FbWFpbEFuZFBhc3N3b3JkKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtYWlsQXV0aENyZWRlbnRpYWwoZW1haWwsIHBhc3N3b3JkLCBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVtYWlsQW5kQ29kZShlbWFpbCwgb29iQ29kZSwgdGVuYW50SWQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1haWxBdXRoQ3JlZGVudGlhbChlbWFpbCwgb29iQ29kZSwgXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLywgdGVuYW50SWQpO1xuICAgIH1cbiAgICAvKioge0Bpbmhlcml0ZG9jIEF1dGhDcmVkZW50aWFsLnRvSlNPTn0gKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5fcGFzc3dvcmQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kLFxuICAgICAgICAgICAgdGVuYW50SWQ6IHRoaXMuX3RlbmFudElkXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QgdG8gZGVzZXJpYWxpemUgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdCBpbnRvIGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBFaXRoZXIgYG9iamVjdGAgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuIFdoZW4gc3RyaW5nIGlzXG4gICAgICogcHJvdmlkZWQsIGBKU09OLnBhcnNlYCB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBjb25zdCBvYmogPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgICAgICAgaWYgKChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmouZW1haWwpICYmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoucGFzc3dvcmQpKSB7XG4gICAgICAgICAgICBpZiAob2JqLnNpZ25Jbk1ldGhvZCA9PT0gXCJwYXNzd29yZFwiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9QQVNTV09SRCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mcm9tRW1haWxBbmRQYXNzd29yZChvYmouZW1haWwsIG9iai5wYXNzd29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmouc2lnbkluTWV0aG9kID09PSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zyb21FbWFpbEFuZENvZGUob2JqLmVtYWlsLCBvYmoucGFzc3dvcmQsIG9iai50ZW5hbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfZ2V0SWRUb2tlblJlc3BvbnNlKGF1dGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduSW5XaXRoUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fSU5fV0lUSF9QQVNTV09SRCAqLywgc2lnbkluV2l0aFBhc3N3b3JkLCBcIkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSXCIgLyogUmVjYXB0Y2hhQXV0aFByb3ZpZGVyLkVNQUlMX1BBU1NXT1JEX1BST1ZJREVSICovKTtcbiAgICAgICAgICAgIGNhc2UgXCJlbWFpbExpbmtcIiAvKiBTaWduSW5NZXRob2QuRU1BSUxfTElOSyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbkluV2l0aEVtYWlsTGluayQxKGF1dGgsIHtcbiAgICAgICAgICAgICAgICAgICAgZW1haWw6IHRoaXMuX2VtYWlsLFxuICAgICAgICAgICAgICAgICAgICBvb2JDb2RlOiB0aGlzLl9wYXNzd29yZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfZmFpbChhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpZ25Jbk1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovOlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbWFpbDogdGhpcy5fZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLl9wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50VHlwZTogXCJDTElFTlRfVFlQRV9XRUJcIiAvKiBSZWNhcHRjaGFDbGllbnRUeXBlLldFQiAqL1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aCwgcmVxdWVzdCwgXCJzaWduVXBQYXNzd29yZFwiIC8qIFJlY2FwdGNoYUFjdGlvbk5hbWUuU0lHTl9VUF9QQVNTV09SRCAqLywgbGlua0VtYWlsUGFzc3dvcmQsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xuICAgICAgICAgICAgY2FzZSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduSW5XaXRoRW1haWxMaW5rRm9yTGlua2luZyhhdXRoLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB0aGlzLl9lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgb29iQ29kZTogdGhpcy5fcGFzc3dvcmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgX2ZhaWwoYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0UmVhdXRoZW50aWNhdGlvblJlc29sdmVyKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldElkVG9rZW5SZXNwb25zZShhdXRoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1TaWduSW5SZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjEvYWNjb3VudHM6c2lnbkluV2l0aElkcFwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9JRFAgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkkMSA9ICdodHRwOi8vbG9jYWxob3N0Jztcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgT0F1dGggY3JlZGVudGlhbHMgcmV0dXJuZWQgYnkgYW4ge0BsaW5rIE9BdXRoUHJvdmlkZXJ9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBsZW1lbnRhdGlvbnMgc3BlY2lmeSB0aGUgZGV0YWlscyBhYm91dCBlYWNoIGF1dGggcHJvdmlkZXIncyBjcmVkZW50aWFsIHJlcXVpcmVtZW50cy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE9BdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVG9rZW4gPSBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9mcm9tUGFyYW1zKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjcmVkID0gbmV3IE9BdXRoQ3JlZGVudGlhbChwYXJhbXMucHJvdmlkZXJJZCwgcGFyYW1zLnNpZ25Jbk1ldGhvZCk7XG4gICAgICAgIGlmIChwYXJhbXMuaWRUb2tlbiB8fCBwYXJhbXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIE9BdXRoIDIgYW5kIGVpdGhlciBJRCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4uXG4gICAgICAgICAgICBpZiAocGFyYW1zLmlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLmlkVG9rZW4gPSBwYXJhbXMuaWRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcGFyYW1zLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIG5vbmNlIGlmIGF2YWlsYWJsZSBhbmQgbm8gcGVuZGluZ1Rva2VuIGlzIHByZXNlbnQuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm5vbmNlICYmICFwYXJhbXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgY3JlZC5ub25jZSA9IHBhcmFtcy5ub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgY3JlZC5wZW5kaW5nVG9rZW4gPSBwYXJhbXMucGVuZGluZ1Rva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5vYXV0aFRva2VuICYmIHBhcmFtcy5vYXV0aFRva2VuU2VjcmV0KSB7XG4gICAgICAgICAgICAvLyBPQXV0aCAxIGFuZCBPQXV0aCB0b2tlbiB3aXRoIHRva2VuIHNlY3JldFxuICAgICAgICAgICAgY3JlZC5hY2Nlc3NUb2tlbiA9IHBhcmFtcy5vYXV0aFRva2VuO1xuICAgICAgICAgICAgY3JlZC5zZWNyZXQgPSBwYXJhbXMub2F1dGhUb2tlblNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mYWlsKFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlZDtcbiAgICB9XG4gICAgLyoqIHtAaW5oZXJpdGRvYyBBdXRoQ3JlZGVudGlhbC50b0pTT059ICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkVG9rZW46IHRoaXMuaWRUb2tlbixcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgc2VjcmV0OiB0aGlzLnNlY3JldCxcbiAgICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlbixcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCxcbiAgICAgICAgICAgIHNpZ25Jbk1ldGhvZDogdGhpcy5zaWduSW5NZXRob2RcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIG1ldGhvZCB0byBkZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0IGludG8gYW5cbiAgICAgKiB7QGxpbmsgIEF1dGhDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqc29uIC0gSW5wdXQgY2FuIGJlIGVpdGhlciBPYmplY3Qgb3IgdGhlIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXG4gICAgICogV2hlbiBzdHJpbmcgaXMgcHJvdmlkZWQsIEpTT04ucGFyc2Ugd291bGQgYmUgY2FsbGVkIGZpcnN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgSWYgdGhlIEpTT04gaW5wdXQgZG9lcyBub3QgcmVwcmVzZW50IGFuIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBjb25zdCB7IHByb3ZpZGVySWQsIHNpZ25Jbk1ldGhvZCB9ID0gb2JqLCByZXN0ID0gX19yZXN0KG9iaiwgW1wicHJvdmlkZXJJZFwiLCBcInNpZ25Jbk1ldGhvZFwiXSk7XG4gICAgICAgIGlmICghcHJvdmlkZXJJZCB8fCAhc2lnbkluTWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVkID0gbmV3IE9BdXRoQ3JlZGVudGlhbChwcm92aWRlcklkLCBzaWduSW5NZXRob2QpO1xuICAgICAgICBjcmVkLmlkVG9rZW4gPSByZXN0LmlkVG9rZW4gfHwgdW5kZWZpbmVkO1xuICAgICAgICBjcmVkLmFjY2Vzc1Rva2VuID0gcmVzdC5hY2Nlc3NUb2tlbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGNyZWQuc2VjcmV0ID0gcmVzdC5zZWNyZXQ7XG4gICAgICAgIGNyZWQubm9uY2UgPSByZXN0Lm5vbmNlO1xuICAgICAgICBjcmVkLnBlbmRpbmdUb2tlbiA9IHJlc3QucGVuZGluZ1Rva2VuIHx8IG51bGw7XG4gICAgICAgIHJldHVybiBjcmVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIGJ1aWxkUmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHJlcXVlc3RVcmk6IElEUF9SRVFVRVNUX1VSSSQxLFxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnBlbmRpbmdUb2tlbiA9IHRoaXMucGVuZGluZ1Rva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zdEJvZHkgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBwb3N0Qm9keVsnaWRfdG9rZW4nXSA9IHRoaXMuaWRUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgcG9zdEJvZHlbJ2FjY2Vzc190b2tlbiddID0gdGhpcy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNlY3JldCkge1xuICAgICAgICAgICAgICAgIHBvc3RCb2R5WydvYXV0aF90b2tlbl9zZWNyZXQnXSA9IHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zdEJvZHlbJ3Byb3ZpZGVySWQnXSA9IHRoaXMucHJvdmlkZXJJZDtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vbmNlICYmICF0aGlzLnBlbmRpbmdUb2tlbikge1xuICAgICAgICAgICAgICAgIHBvc3RCb2R5Wydub25jZSddID0gdGhpcy5ub25jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QucG9zdEJvZHkgPSBxdWVyeXN0cmluZyhwb3N0Qm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2lnbkluV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGhvbmVOdW1iZXJcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhQaG9uZU51bWJlciQxKGF1dGgsIHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhQaG9uZU51bWJlclwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9QSE9ORV9OVU1CRVIgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG4gICAgaWYgKHJlc3BvbnNlLnRlbXBvcmFyeVByb29mKSB7XG4gICAgICAgIHRocm93IF9tYWtlVGFnZ2VkRXJyb3IoYXV0aCwgXCJhY2NvdW50LWV4aXN0cy13aXRoLWRpZmZlcmVudC1jcmVkZW50aWFsXCIgLyogQXV0aEVycm9yQ29kZS5ORUVEX0NPTkZJUk1BVElPTiAqLywgcmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5jb25zdCBWRVJJRllfUEhPTkVfTlVNQkVSX0ZPUl9FWElTVElOR19FUlJPUl9NQVBfID0ge1xuICAgIFtcIlVTRVJfTk9UX0ZPVU5EXCIgLyogU2VydmVyRXJyb3IuVVNFUl9OT1RfRk9VTkQgKi9dOiBcInVzZXItbm90LWZvdW5kXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX0RFTEVURUQgKi9cbn07XG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nKGF1dGgsIHJlcXVlc3QpIHtcbiAgICBjb25zdCBhcGlSZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBvcGVyYXRpb246ICdSRUFVVEgnIH0pO1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduSW5XaXRoUGhvbmVOdW1iZXJcIiAvKiBFbmRwb2ludC5TSUdOX0lOX1dJVEhfUEhPTkVfTlVNQkVSICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgYXBpUmVxdWVzdCksIFZFUklGWV9QSE9ORV9OVU1CRVJfRk9SX0VYSVNUSU5HX0VSUk9SX01BUF8pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSB7QGxpbmsgUGhvbmVBdXRoUHJvdmlkZXJ9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUGhvbmVBdXRoQ3JlZGVudGlhbCBleHRlbmRzIEF1dGhDcmVkZW50aWFsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8sIFwicGhvbmVcIiAvKiBTaWduSW5NZXRob2QuUEhPTkUgKi8pO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbVZlcmlmaWNhdGlvbih2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBob25lQXV0aENyZWRlbnRpYWwoeyB2ZXJpZmljYXRpb25JZCwgdmVyaWZpY2F0aW9uQ29kZSB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbVRva2VuUmVzcG9uc2UocGhvbmVOdW1iZXIsIHRlbXBvcmFyeVByb29mKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGhvbmVBdXRoQ3JlZGVudGlhbCh7IHBob25lTnVtYmVyLCB0ZW1wb3JhcnlQcm9vZiB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCkge1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfbGlua1RvSWRUb2tlbihhdXRoLCBpZFRva2VuKSB7XG4gICAgICAgIHJldHVybiBsaW5rV2l0aFBob25lTnVtYmVyJDEoYXV0aCwgT2JqZWN0LmFzc2lnbih7IGlkVG9rZW4gfSwgdGhpcy5fbWFrZVZlcmlmaWNhdGlvblJlcXVlc3QoKSkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XG4gICAgICAgIHJldHVybiB2ZXJpZnlQaG9uZU51bWJlckZvckV4aXN0aW5nKGF1dGgsIHRoaXMuX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX21ha2VWZXJpZmljYXRpb25SZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCB7IHRlbXBvcmFyeVByb29mLCBwaG9uZU51bWJlciwgdmVyaWZpY2F0aW9uSWQsIHZlcmlmaWNhdGlvbkNvZGUgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgICBpZiAodGVtcG9yYXJ5UHJvb2YgJiYgcGhvbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHRlbXBvcmFyeVByb29mLCBwaG9uZU51bWJlciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXNzaW9uSW5mbzogdmVyaWZpY2F0aW9uSWQsXG4gICAgICAgICAgICBjb2RlOiB2ZXJpZmljYXRpb25Db2RlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5waG9uZU51bWJlcikge1xuICAgICAgICAgICAgb2JqLnBob25lTnVtYmVyID0gdGhpcy5wYXJhbXMucGhvbmVOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyYW1zLnRlbXBvcmFyeVByb29mKSB7XG4gICAgICAgICAgICBvYmoudGVtcG9yYXJ5UHJvb2YgPSB0aGlzLnBhcmFtcy50ZW1wb3JhcnlQcm9vZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uQ29kZSkge1xuICAgICAgICAgICAgb2JqLnZlcmlmaWNhdGlvbkNvZGUgPSB0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25Db2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy52ZXJpZmljYXRpb25JZCkge1xuICAgICAgICAgICAgb2JqLnZlcmlmaWNhdGlvbklkID0gdGhpcy5wYXJhbXMudmVyaWZpY2F0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqIEdlbmVyYXRlcyBhIHBob25lIGNyZWRlbnRpYWwgYmFzZWQgb24gYSBwbGFpbiBvYmplY3Qgb3IgYSBKU09OIHN0cmluZy4gKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBqc29uID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHZlcmlmaWNhdGlvbklkLCB2ZXJpZmljYXRpb25Db2RlLCBwaG9uZU51bWJlciwgdGVtcG9yYXJ5UHJvb2YgfSA9IGpzb247XG4gICAgICAgIGlmICghdmVyaWZpY2F0aW9uQ29kZSAmJlxuICAgICAgICAgICAgIXZlcmlmaWNhdGlvbklkICYmXG4gICAgICAgICAgICAhcGhvbmVOdW1iZXIgJiZcbiAgICAgICAgICAgICF0ZW1wb3JhcnlQcm9vZikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZUF1dGhDcmVkZW50aWFsKHtcbiAgICAgICAgICAgIHZlcmlmaWNhdGlvbklkLFxuICAgICAgICAgICAgdmVyaWZpY2F0aW9uQ29kZSxcbiAgICAgICAgICAgIHBob25lTnVtYmVyLFxuICAgICAgICAgICAgdGVtcG9yYXJ5UHJvb2ZcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBNYXBzIHRoZSBtb2RlIHN0cmluZyBpbiBhY3Rpb24gY29kZSBVUkwgdG8gQWN0aW9uIENvZGUgSW5mbyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIG1vZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VNb2RlKG1vZGUpIHtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAncmVjb3ZlckVtYWlsJzpcbiAgICAgICAgICAgIHJldHVybiBcIlJFQ09WRVJfRU1BSUxcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlJFQ09WRVJfRU1BSUwgKi87XG4gICAgICAgIGNhc2UgJ3Jlc2V0UGFzc3dvcmQnOlxuICAgICAgICAgICAgcmV0dXJuIFwiUEFTU1dPUkRfUkVTRVRcIiAvKiBBY3Rpb25Db2RlT3BlcmF0aW9uLlBBU1NXT1JEX1JFU0VUICovO1xuICAgICAgICBjYXNlICdzaWduSW4nOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi87XG4gICAgICAgIGNhc2UgJ3ZlcmlmeUVtYWlsJzpcbiAgICAgICAgICAgIHJldHVybiBcIlZFUklGWV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0VNQUlMICovO1xuICAgICAgICBjYXNlICd2ZXJpZnlBbmRDaGFuZ2VFbWFpbCc6XG4gICAgICAgICAgICByZXR1cm4gXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi87XG4gICAgICAgIGNhc2UgJ3JldmVydFNlY29uZEZhY3RvckFkZGl0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBcIlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5SRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTiAqLztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogSGVscGVyIHRvIHBhcnNlIEZETCBsaW5rc1xuICpcbiAqIEBwYXJhbSB1cmxcbiAqL1xuZnVuY3Rpb24gcGFyc2VEZWVwTGluayh1cmwpIHtcbiAgICBjb25zdCBsaW5rID0gcXVlcnlzdHJpbmdEZWNvZGUoZXh0cmFjdFF1ZXJ5c3RyaW5nKHVybCkpWydsaW5rJ107XG4gICAgLy8gRG91YmxlIGxpbmsgY2FzZSAoYXV0b21hdGljIHJlZGlyZWN0KS5cbiAgICBjb25zdCBkb3VibGVEZWVwTGluayA9IGxpbmtcbiAgICAgICAgPyBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcobGluaykpWydkZWVwX2xpbmtfaWQnXVxuICAgICAgICA6IG51bGw7XG4gICAgLy8gaU9TIGN1c3RvbSBzY2hlbWUgbGlua3MuXG4gICAgY29uc3QgaU9TRGVlcExpbmsgPSBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcodXJsKSlbJ2RlZXBfbGlua19pZCddO1xuICAgIGNvbnN0IGlPU0RvdWJsZURlZXBMaW5rID0gaU9TRGVlcExpbmtcbiAgICAgICAgPyBxdWVyeXN0cmluZ0RlY29kZShleHRyYWN0UXVlcnlzdHJpbmcoaU9TRGVlcExpbmspKVsnbGluayddXG4gICAgICAgIDogbnVsbDtcbiAgICByZXR1cm4gaU9TRG91YmxlRGVlcExpbmsgfHwgaU9TRGVlcExpbmsgfHwgZG91YmxlRGVlcExpbmsgfHwgbGluayB8fCB1cmw7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBwYXJzZSBlbWFpbCBhY3Rpb24gVVJMcyBzdWNoIGFzIHBhc3N3b3JkIHJlc2V0LCBlbWFpbCB2ZXJpZmljYXRpb24sXG4gKiBlbWFpbCBsaW5rIHNpZ24gaW4sIGV0Yy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEFjdGlvbkNvZGVVUkwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhY3Rpb25MaW5rIC0gVGhlIGxpbmsgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBVUkwuXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFjdGlvbkxpbmspIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IHF1ZXJ5c3RyaW5nRGVjb2RlKGV4dHJhY3RRdWVyeXN0cmluZyhhY3Rpb25MaW5rKSk7XG4gICAgICAgIGNvbnN0IGFwaUtleSA9IChfYSA9IHNlYXJjaFBhcmFtc1tcImFwaUtleVwiIC8qIFF1ZXJ5RmllbGQuQVBJX0tFWSAqL10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGNvZGUgPSAoX2IgPSBzZWFyY2hQYXJhbXNbXCJvb2JDb2RlXCIgLyogUXVlcnlGaWVsZC5DT0RFICovXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyc2VNb2RlKChfYyA9IHNlYXJjaFBhcmFtc1tcIm1vZGVcIiAvKiBRdWVyeUZpZWxkLk1PREUgKi9dKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgQVBJIGtleSwgY29kZSBhbmQgbW9kZS5cbiAgICAgICAgX2Fzc2VydChhcGlLZXkgJiYgY29kZSAmJiBvcGVyYXRpb24sIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmNvbnRpbnVlVXJsID0gKF9kID0gc2VhcmNoUGFyYW1zW1wiY29udGludWVVcmxcIiAvKiBRdWVyeUZpZWxkLkNPTlRJTlVFX1VSTCAqL10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGw7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2VDb2RlID0gKF9lID0gc2VhcmNoUGFyYW1zW1wibGFuZ3VhZ2VDb2RlXCIgLyogUXVlcnlGaWVsZC5MQU5HVUFHRV9DT0RFICovXSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbDtcbiAgICAgICAgdGhpcy50ZW5hbnRJZCA9IChfZiA9IHNlYXJjaFBhcmFtc1tcInRlbmFudElkXCIgLyogUXVlcnlGaWVsZC5URU5BTlRfSUQgKi9dKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGVtYWlsIGFjdGlvbiBsaW5rIHN0cmluZyBhbmQgcmV0dXJucyBhbiB7QGxpbmsgQWN0aW9uQ29kZVVSTH0gaWYgdGhlIGxpbmsgaXMgdmFsaWQsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaW5rICAtIFRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcuXG4gICAgICogQHJldHVybnMgVGhlIHtAbGluayBBY3Rpb25Db2RlVVJMfSBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGxpbmsgaXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VMaW5rKGxpbmspIHtcbiAgICAgICAgY29uc3QgYWN0aW9uTGluayA9IHBhcnNlRGVlcExpbmsobGluayk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbkNvZGVVUkwoYWN0aW9uTGluayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIHRoZSBlbWFpbCBhY3Rpb24gbGluayBzdHJpbmcgYW5kIHJldHVybnMgYW4ge0BsaW5rIEFjdGlvbkNvZGVVUkx9IGlmXG4gKiB0aGUgbGluayBpcyB2YWxpZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQWN0aW9uQ29kZVVSTChsaW5rKSB7XG4gICAgcmV0dXJuIEFjdGlvbkNvZGVVUkwucGFyc2VMaW5rKGxpbmspO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyB7QGxpbmsgRW1haWxBdXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBFbWFpbEF1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QQVNTV09SRCwgZXZlbiBmb3IgZW1haWwgbGluay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IEVtYWlsQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFuIHtAbGluayBBdXRoQ3JlZGVudGlhbH0gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogY29uc3QgYXV0aENyZWRlbnRpYWwgPSBFbWFpbEF1dGhQcm92aWRlci5jcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBhdXRoQ3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKGF1dGgsIGVtYWlsLCBwYXNzd29yZCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgLSBFbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFVzZXIgYWNjb3VudCBwYXNzd29yZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXV0aCBwcm92aWRlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsKGVtYWlsLCBwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gRW1haWxBdXRoQ3JlZGVudGlhbC5fZnJvbUVtYWlsQW5kUGFzc3dvcmQoZW1haWwsIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhbiB7QGxpbmsgQXV0aENyZWRlbnRpYWx9IHVzaW5nIGFuIGVtYWlsIGFuZCBhbiBlbWFpbCBsaW5rIGFmdGVyIGEgc2lnbiBpbiB3aXRoXG4gICAgICogZW1haWwgbGluayBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBjb25zdCBhdXRoQ3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhhdXRoLCBlbWFpbCwgZW1haWxMaW5rKTtcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGF1dGhDcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGF3YWl0IHNlbmRTaWduSW5MaW5rVG9FbWFpbChhdXRoLCBlbWFpbCk7XG4gICAgICogLy8gT2J0YWluIGVtYWlsTGluayBmcm9tIHVzZXIuXG4gICAgICogY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBzaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsLCBlbWFpbExpbmspO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIHVzZWQgdG8gdmVyaWZ5IHRoZSBsaW5rLlxuICAgICAqIEBwYXJhbSBlbWFpbCAtIEVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsTGluayAtIFNpZ24taW4gZW1haWwgbGluay5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSBhdXRoIHByb3ZpZGVyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxXaXRoTGluayhlbWFpbCwgZW1haWxMaW5rKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbkNvZGVVcmwgPSBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhlbWFpbExpbmspO1xuICAgICAgICBfYXNzZXJ0KGFjdGlvbkNvZGVVcmwsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIEVtYWlsQXV0aENyZWRlbnRpYWwuX2Zyb21FbWFpbEFuZENvZGUoZW1haWwsIGFjdGlvbkNvZGVVcmwuY29kZSwgYWN0aW9uQ29kZVVybC50ZW5hbnRJZCk7XG4gICAgfVxufVxuLyoqXG4gKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5QQVNTV09SRCwgZXZlbiBmb3IgZW1haWwgbGluay5cbiAqL1xuRW1haWxBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQgPSBcInBhc3N3b3JkXCIgLyogUHJvdmlkZXJJZC5QQVNTV09SRCAqLztcbi8qKlxuICogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRC5cbiAqL1xuRW1haWxBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfU0lHTl9JTl9NRVRIT0QgPSBcInBhc3N3b3JkXCIgLyogU2lnbkluTWV0aG9kLkVNQUlMX1BBU1NXT1JEICovO1xuLyoqXG4gKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX0xJTksuXG4gKi9cbkVtYWlsQXV0aFByb3ZpZGVyLkVNQUlMX0xJTktfU0lHTl9JTl9NRVRIT0QgPSBcImVtYWlsTGlua1wiIC8qIFNpZ25Jbk1ldGhvZC5FTUFJTF9MSU5LICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIEZlZGVyYXRlZCBwcm92aWRlcnMgKE9BdXRoIChpbmNsdWRpbmcgT0lEQyksIFNBTUwpLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgbm90IG1lYW50IHRvIGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEZlZGVyYXRlZEF1dGhQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIGdlbmVyaWMgT0F1dGggcHJvdmlkZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBQcm92aWRlciBmb3Igd2hpY2ggY3JlZGVudGlhbHMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0TGFuZ3VhZ2VDb2RlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmN1c3RvbVBhcmFtZXRlcnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsYW5ndWFnZSBnb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxhbmd1YWdlQ29kZSAtIGxhbmd1YWdlIGNvZGVcbiAgICAgKi9cbiAgICBzZXREZWZhdWx0TGFuZ3VhZ2UobGFuZ3VhZ2VDb2RlKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdExhbmd1YWdlQ29kZSA9IGxhbmd1YWdlQ29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgT0F1dGggY3VzdG9tIHBhcmFtZXRlcnMgdG8gcGFzcyBpbiBhbiBPQXV0aCByZXF1ZXN0IGZvciBwb3B1cCBhbmQgcmVkaXJlY3Qgc2lnbi1pblxuICAgICAqIG9wZXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEZvciBhIGRldGFpbGVkIGxpc3QsIGNoZWNrIHRoZSByZXNlcnZlZCByZXF1aXJlZCBPQXV0aCAyLjAgcGFyYW1ldGVycyBzdWNoIGFzIGBjbGllbnRfaWRgLFxuICAgICAqIGByZWRpcmVjdF91cmlgLCBgc2NvcGVgLCBgcmVzcG9uc2VfdHlwZWAsIGFuZCBgc3RhdGVgIGFyZSBub3QgYWxsb3dlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1c3RvbU9BdXRoUGFyYW1ldGVycyAtIFRoZSBjdXN0b20gT0F1dGggcGFyYW1ldGVycyB0byBwYXNzIGluIHRoZSBPQXV0aCByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNldEN1c3RvbVBhcmFtZXRlcnMoY3VzdG9tT0F1dGhQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1ldGVycyA9IGN1c3RvbU9BdXRoUGFyYW1ldGVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEN1c3RvbVBhcmFtZXRlcnN9LlxuICAgICAqL1xuICAgIGdldEN1c3RvbVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVBhcmFtZXRlcnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21tb24gY29kZSB0byBhbGwgT0F1dGggcHJvdmlkZXJzLiBUaGlzIGlzIHNlcGFyYXRlIGZyb20gdGhlXG4gKiB7QGxpbmsgT0F1dGhQcm92aWRlcn0gc28gdGhhdCBjaGlsZCBwcm92aWRlcnMgKGxpa2VcbiAqIHtAbGluayBHb29nbGVBdXRoUHJvdmlkZXJ9KSBkb24ndCBpbmhlcml0IHRoZSBgY3JlZGVudGlhbGAgaW5zdGFuY2UgbWV0aG9kLlxuICogSW5zdGVhZCwgdGhleSByZWx5IG9uIGEgc3RhdGljIGBjcmVkZW50aWFsYCBtZXRob2QuXG4gKi9cbmNsYXNzIEJhc2VPQXV0aFByb3ZpZGVyIGV4dGVuZHMgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gT0F1dGggc2NvcGUgdG8gdGhlIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NvcGUgLSBQcm92aWRlciBPQXV0aCBzY29wZSB0byBhZGQuXG4gICAgICovXG4gICAgYWRkU2NvcGUoc2NvcGUpIHtcbiAgICAgICAgLy8gSWYgbm90IGFscmVhZHkgYWRkZWQsIGFkZCBzY29wZSB0byBsaXN0LlxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVzLmluY2x1ZGVzKHNjb3BlKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50IGxpc3Qgb2YgT0F1dGggc2NvcGVzLlxuICAgICAqL1xuICAgIGdldFNjb3BlcygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLnNjb3Blc107XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBnZW5lcmljIHtAbGluayBPQXV0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcmVkaXJlY3QuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IHByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KGF1dGgsIHJlc3VsdCk7XG4gKiAgIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBPQXV0aFByb3ZpZGVyKCdnb29nbGUuY29tJyk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBPQXV0aCBBY2Nlc3MgVG9rZW4gZm9yIHRoZSBwcm92aWRlci5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChhdXRoLCByZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE9BdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICAgICAgICBfYXNzZXJ0KCdwcm92aWRlcklkJyBpbiBvYmogJiYgJ3NpZ25Jbk1ldGhvZCcgaW4gb2JqLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMob2JqKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSBnZW5lcmljIE9BdXRoIHByb3ZpZGVyJ3MgYWNjZXNzIHRva2VuIG9yIElEIHRva2VuLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgcmF3IG5vbmNlIGlzIHJlcXVpcmVkIHdoZW4gYW4gSUQgdG9rZW4gd2l0aCBhIG5vbmNlIGZpZWxkIGlzIHByb3ZpZGVkLiBUaGUgU0hBLTI1NiBoYXNoIG9mXG4gICAgICogdGhlIHJhdyBub25jZSBtdXN0IG1hdGNoIHRoZSBub25jZSBmaWVsZCBpbiB0aGUgSUQgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiAvLyBgZ29vZ2xlVXNlcmAgZnJvbSB0aGUgb25zdWNjZXNzIEdvb2dsZSBTaWduIEluIGNhbGxiYWNrLlxuICAgICAqIC8vIEluaXRpYWxpemUgYSBnZW5lcmF0ZSBPQXV0aCBwcm92aWRlciB3aXRoIGEgYGdvb2dsZS5jb21gIHByb3ZpZGVySWQuXG4gICAgICogY29uc3QgcHJvdmlkZXIgPSBuZXcgT0F1dGhQcm92aWRlcignZ29vZ2xlLmNvbScpO1xuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBwcm92aWRlci5jcmVkZW50aWFsKHtcbiAgICAgKiAgIGlkVG9rZW46IGdvb2dsZVVzZXIuZ2V0QXV0aFJlc3BvbnNlKCkuaWRfdG9rZW4sXG4gICAgICogfSk7XG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aENyZWRlbnRpYWwoY3JlZGVudGlhbCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gRWl0aGVyIHRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBJRCB0b2tlbiwgYWNjZXNzIHRva2VuIGFuZCByYXcgbm9uY2VcbiAgICAgKiBvciB0aGUgSUQgdG9rZW4gc3RyaW5nLlxuICAgICAqL1xuICAgIGNyZWRlbnRpYWwocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVkZW50aWFsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBub25jZTogcGFyYW1zLnJhd05vbmNlIH0pKTtcbiAgICB9XG4gICAgLyoqIEFuIGludGVybmFsIGNyZWRlbnRpYWwgbWV0aG9kIHRoYXQgYWNjZXB0cyBtb3JlIHBlcm1pc3NpdmUgb3B0aW9ucyAqL1xuICAgIF9jcmVkZW50aWFsKHBhcmFtcykge1xuICAgICAgICBfYXNzZXJ0KHBhcmFtcy5pZFRva2VuIHx8IHBhcmFtcy5hY2Nlc3NUb2tlbiwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICAvLyBGb3IgT0F1dGhDcmVkZW50aWFsLCBzaWduIGluIG1ldGhvZCBpcyBzYW1lIGFzIHByb3ZpZGVySWQuXG4gICAgICAgIHJldHVybiBPQXV0aENyZWRlbnRpYWwuX2Zyb21QYXJhbXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHByb3ZpZGVySWQ6IHRoaXMucHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kOiB0aGlzLnByb3ZpZGVySWQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gT0F1dGhQcm92aWRlci5vYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHVzZXJDcmVkZW50aWFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgQXV0aEVycm9yfSB3aGljaCB3YXNcbiAgICAgKiB0aHJvd24gZHVyaW5nIGEgc2lnbi1pbiwgbGluaywgb3IgcmVhdXRoZW50aWNhdGUgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4gT0F1dGhQcm92aWRlci5vYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBvYXV0aENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0LCBwZW5kaW5nVG9rZW4sIG5vbmNlLCBwcm92aWRlcklkIH0gPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICBpZiAoIW9hdXRoQWNjZXNzVG9rZW4gJiZcbiAgICAgICAgICAgICFvYXV0aFRva2VuU2VjcmV0ICYmXG4gICAgICAgICAgICAhb2F1dGhJZFRva2VuICYmXG4gICAgICAgICAgICAhcGVuZGluZ1Rva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb3ZpZGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9BdXRoUHJvdmlkZXIocHJvdmlkZXJJZCkuX2NyZWRlbnRpYWwoe1xuICAgICAgICAgICAgICAgIGlkVG9rZW46IG9hdXRoSWRUb2tlbixcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogb2F1dGhBY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBwZW5kaW5nVG9rZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5GQUNFQk9PSy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIC8vIFN0YXJ0IGEgc2lnbiBpbiBwcm9jZXNzIGZvciBhbiB1bmF1dGhlbnRpY2F0ZWQgdXNlci5cbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiBhd2FpdCBzaWduSW5XaXRoUmVkaXJlY3QoYXV0aCwgcHJvdmlkZXIpO1xuICogLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSBmdWxsIHBhZ2UgcmVkaXJlY3QgYXdheSBmcm9tIHlvdXIgYXBwXG4gKlxuICogLy8gQWZ0ZXIgcmV0dXJuaW5nIGZyb20gdGhlIHJlZGlyZWN0IHdoZW4geW91ciBhcHAgaW5pdGlhbGl6ZXMgeW91IGNhbiBvYnRhaW4gdGhlIHJlc3VsdFxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UmVkaXJlY3RSZXN1bHQoYXV0aCk7XG4gKiBpZiAocmVzdWx0KSB7XG4gKiAgIC8vIFRoaXMgaXMgdGhlIHNpZ25lZC1pbiB1c2VyXG4gKiAgIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqICAgLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiAgIGNvbnN0IGNyZWRlbnRpYWwgPSBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tBdXRoUHJvdmlkZXIoKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCd1c2VyX2JpcnRoZGF5Jyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBGYWNlYm9vayBBY2Nlc3MgVG9rZW4uXG4gKiBjb25zdCBjcmVkZW50aWFsID0gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRmFjZWJvb2tBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIGZvciBGYWNlYm9vay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIC8vIGBldmVudGAgZnJvbSB0aGUgRmFjZWJvb2sgYXV0aC5hdXRoUmVzcG9uc2VDaGFuZ2UgY2FsbGJhY2suXG4gICAgICogY29uc3QgY3JlZGVudGlhbCA9IEZhY2Vib29rQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwoZXZlbnQuYXV0aFJlc3BvbnNlLmFjY2Vzc1Rva2VuKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEZhY2Vib29rIGFjY2VzcyB0b2tlbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbChhY2Nlc3NUb2tlbikge1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IEZhY2Vib29rQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lELFxuICAgICAgICAgICAgc2lnbkluTWV0aG9kOiBGYWNlYm9va0F1dGhQcm92aWRlci5GQUNFQk9PS19TSUdOX0lOX01FVEhPRCxcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBGYWNlYm9va0F1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRmFjZWJvb2tBdXRoUHJvdmlkZXIuY3JlZGVudGlhbCh0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgU2lnbkluTWV0aG9kfS5GQUNFQk9PSy4gKi9cbkZhY2Vib29rQXV0aFByb3ZpZGVyLkZBQ0VCT09LX1NJR05fSU5fTUVUSE9EID0gXCJmYWNlYm9vay5jb21cIiAvKiBTaWduSW5NZXRob2QuRkFDRUJPT0sgKi87XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uRkFDRUJPT0suICovXG5GYWNlYm9va0F1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUHJvdmlkZXIgZm9yIGdlbmVyYXRpbmcgYW4ge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZm9yIHtAbGluayBQcm92aWRlcklkfS5HT09HTEUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIC8vIFNpZ24gaW4gdXNpbmcgYSByZWRpcmVjdC5cbiAqIGNvbnN0IHByb3ZpZGVyID0gbmV3IEdvb2dsZUF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogcHJvdmlkZXIuYWRkU2NvcGUoJ3Byb2ZpbGUnKTtcbiAqIHByb3ZpZGVyLmFkZFNjb3BlKCdlbWFpbCcpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR29vZ2xlIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR29vZ2xlQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncHJvZmlsZScpO1xuICogcHJvdmlkZXIuYWRkU2NvcGUoJ2VtYWlsJyk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBHb29nbGUgQWNjZXNzIFRva2VuLlxuICogY29uc3QgY3JlZGVudGlhbCA9IEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHb29nbGVBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovKTtcbiAgICAgICAgdGhpcy5hZGRTY29wZSgncHJvZmlsZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBmb3IgR29vZ2xlLiBBdCBsZWFzdCBvbmUgb2YgSUQgdG9rZW4gYW5kIGFjY2VzcyB0b2tlbiBpcyByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIC8vIFxcYGdvb2dsZVVzZXJcXGAgZnJvbSB0aGUgb25zdWNjZXNzIEdvb2dsZSBTaWduIEluIGNhbGxiYWNrLlxuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChnb29nbGVVc2VyLmdldEF1dGhSZXNwb25zZSgpLmlkX3Rva2VuKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoQ3JlZGVudGlhbChjcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZFRva2VuIC0gR29vZ2xlIElEIHRva2VuLlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdvb2dsZSBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoaWRUb2tlbiwgYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBHb29nbGVBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QsXG4gICAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgICAgYWNjZXNzVG9rZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QodXNlckNyZWRlbnRpYWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBBdXRoRXJyb3J9IHdoaWNoIHdhc1xuICAgICAqIHRocm93biBkdXJpbmcgYSBzaWduLWluLCBsaW5rLCBvciByZWF1dGhlbnRpY2F0ZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBHb29nbGVBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb2F1dGhJZFRva2VuLCBvYXV0aEFjY2Vzc1Rva2VuIH0gPSB0b2tlblJlc3BvbnNlO1xuICAgICAgICBpZiAoIW9hdXRoSWRUb2tlbiAmJiAhb2F1dGhBY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBvYXV0aCAxIGNyZWRlbnRpYWwgb3IgYSBwaG9uZSBjcmVkZW50aWFsXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEdvb2dsZUF1dGhQcm92aWRlci5jcmVkZW50aWFsKG9hdXRoSWRUb2tlbiwgb2F1dGhBY2Nlc3NUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBTaWduSW5NZXRob2R9LkdPT0dMRS4gKi9cbkdvb2dsZUF1dGhQcm92aWRlci5HT09HTEVfU0lHTl9JTl9NRVRIT0QgPSBcImdvb2dsZS5jb21cIiAvKiBTaWduSW5NZXRob2QuR09PR0xFICovO1xuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFByb3ZpZGVySWR9LkdPT0dMRS4gKi9cbkdvb2dsZUF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhbiB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmb3Ige0BsaW5rIFByb3ZpZGVySWR9LkdJVEhVQi5cbiAqXG4gKiBAcmVtYXJrc1xuICogR2l0SHViIHJlcXVpcmVzIGFuIE9BdXRoIDIuMCByZWRpcmVjdCwgc28geW91IGNhbiBlaXRoZXIgaGFuZGxlIHRoZSByZWRpcmVjdCBkaXJlY3RseSwgb3IgdXNlXG4gKiB0aGUge0BsaW5rIHNpZ25JbldpdGhQb3B1cH0gaGFuZGxlcjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XG4gKiAvLyBTdGFydCBhIHNpZ24gaW4gcHJvY2VzcyBmb3IgYW4gdW5hdXRoZW50aWNhdGVkIHVzZXIuXG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0SHViIEFjY2VzcyBUb2tlbi5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVJlc3VsdChyZXN1bHQpO1xuICogICBjb25zdCB0b2tlbiA9IGNyZWRlbnRpYWwuYWNjZXNzVG9rZW47XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHBvcHVwLlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgR2l0aHViQXV0aFByb3ZpZGVyKCk7XG4gKiBwcm92aWRlci5hZGRTY29wZSgncmVwbycpO1xuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgc2lnbkluV2l0aFBvcHVwKGF1dGgsIHByb3ZpZGVyKTtcbiAqXG4gKiAvLyBUaGUgc2lnbmVkLWluIHVzZXIgaW5mby5cbiAqIGNvbnN0IHVzZXIgPSByZXN1bHQudXNlcjtcbiAqIC8vIFRoaXMgZ2l2ZXMgeW91IGEgR2l0SHViIEFjY2VzcyBUb2tlbi5cbiAqIGNvbnN0IGNyZWRlbnRpYWwgPSBHaXRodWJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG5jbGFzcyBHaXRodWJBdXRoUHJvdmlkZXIgZXh0ZW5kcyBCYXNlT0F1dGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZ2l0aHViLmNvbVwiIC8qIFByb3ZpZGVySWQuR0lUSFVCICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIEdpdEh1Yi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiAtIEdpdEh1YiBhY2Nlc3MgdG9rZW4uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIE9BdXRoQ3JlZGVudGlhbC5fZnJvbVBhcmFtcyh7XG4gICAgICAgICAgICBwcm92aWRlcklkOiBHaXRodWJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IEdpdGh1YkF1dGhQcm92aWRlci5HSVRIVUJfU0lHTl9JTl9NRVRIT0QsXG4gICAgICAgICAgICBhY2Nlc3NUb2tlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBleHRyYWN0IHRoZSB1bmRlcmx5aW5nIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZyb20gYSB7QGxpbmsgVXNlckNyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZXJDcmVkZW50aWFsIC0gVGhlIHVzZXIgY3JlZGVudGlhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21SZXN1bHQodXNlckNyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIEdpdGh1YkF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCgoZXJyb3IuY3VzdG9tRGF0YSB8fCB7fSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoeyBfdG9rZW5SZXNwb25zZTogdG9rZW5SZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghdG9rZW5SZXNwb25zZSB8fCAhKCdvYXV0aEFjY2Vzc1Rva2VuJyBpbiB0b2tlblJlc3BvbnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlLm9hdXRoQWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gR2l0aHViQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWwodG9rZW5SZXNwb25zZS5vYXV0aEFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uR0lUSFVCLiAqL1xuR2l0aHViQXV0aFByb3ZpZGVyLkdJVEhVQl9TSUdOX0lOX01FVEhPRCA9IFwiZ2l0aHViLmNvbVwiIC8qIFNpZ25Jbk1ldGhvZC5HSVRIVUIgKi87XG4vKiogQWx3YXlzIHNldCB0byB7QGxpbmsgUHJvdmlkZXJJZH0uR0lUSFVCLiAqL1xuR2l0aHViQXV0aFByb3ZpZGVyLlBST1ZJREVSX0lEID0gXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBJRFBfUkVRVUVTVF9VUkkgPSAnaHR0cDovL2xvY2FsaG9zdCc7XG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgU0FNTEF1dGhDcmVkZW50aWFsIGV4dGVuZHMgQXV0aENyZWRlbnRpYWwge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgc3VwZXIocHJvdmlkZXJJZCwgcHJvdmlkZXJJZCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1Rva2VuID0gcGVuZGluZ1Rva2VuO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldElkVG9rZW5SZXNwb25zZShhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gc2lnbkluV2l0aElkcChhdXRoLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9saW5rVG9JZFRva2VuKGF1dGgsIGlkVG9rZW4pIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYnVpbGRSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3QuaWRUb2tlbiA9IGlkVG9rZW47XG4gICAgICAgIHJldHVybiBzaWduSW5XaXRoSWRwKGF1dGgsIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFJlYXV0aGVudGljYXRpb25SZXNvbHZlcihhdXRoKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmJ1aWxkUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0LmF1dG9DcmVhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZ25JbldpdGhJZHAoYXV0aCwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKiB7QGluaGVyaXRkb2MgQXV0aENyZWRlbnRpYWwudG9KU09OfSAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IHRoaXMuc2lnbkluTWV0aG9kLFxuICAgICAgICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgICAgICAgcGVuZGluZ1Rva2VuOiB0aGlzLnBlbmRpbmdUb2tlblxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgbWV0aG9kIHRvIGRlc2VyaWFsaXplIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3QgaW50byBhblxuICAgICAqIHtAbGluayAgQXV0aENyZWRlbnRpYWx9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBJbnB1dCBjYW4gYmUgZWl0aGVyIE9iamVjdCBvciB0aGUgc3RyaW5naWZpZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdC5cbiAgICAgKiBXaGVuIHN0cmluZyBpcyBwcm92aWRlZCwgSlNPTi5wYXJzZSB3b3VsZCBiZSBjYWxsZWQgZmlyc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgSlNPTiBpbnB1dCBkb2VzIG5vdCByZXByZXNlbnQgYW4ge0BsaW5rICBBdXRoQ3JlZGVudGlhbH0sIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb247XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXJJZCwgc2lnbkluTWV0aG9kLCBwZW5kaW5nVG9rZW4gfSA9IG9iajtcbiAgICAgICAgaWYgKCFwcm92aWRlcklkIHx8XG4gICAgICAgICAgICAhc2lnbkluTWV0aG9kIHx8XG4gICAgICAgICAgICAhcGVuZGluZ1Rva2VuIHx8XG4gICAgICAgICAgICBwcm92aWRlcklkICE9PSBzaWduSW5NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU0FNTEF1dGhDcmVkZW50aWFsKHByb3ZpZGVySWQsIHBlbmRpbmdUb2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBzdGF0aWMgbWV0aG9kIHRvIGF2b2lkIGV4cG9zaW5nIHRoZSBjb25zdHJ1Y3RvciB0byBlbmQgdXNlcnMuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NyZWF0ZShwcm92aWRlcklkLCBwZW5kaW5nVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTQU1MQXV0aENyZWRlbnRpYWwocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgICB9XG4gICAgYnVpbGRSZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdFVyaTogSURQX1JFUVVFU1RfVVJJLFxuICAgICAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWUsXG4gICAgICAgICAgICBwZW5kaW5nVG9rZW46IHRoaXMucGVuZGluZ1Rva2VuXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgU0FNTF9QUk9WSURFUl9QUkVGSVggPSAnc2FtbC4nO1xuLyoqXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBmb3IgU0FNTC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFNBTUxBdXRoUHJvdmlkZXIgZXh0ZW5kcyBGZWRlcmF0ZWRBdXRoUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLiBUaGUgcHJvdmlkZXJJZCBtdXN0IHN0YXJ0IHdpdGggXCJzYW1sLlwiXG4gICAgICogQHBhcmFtIHByb3ZpZGVySWQgLSBTQU1MIHByb3ZpZGVyIElELlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVySWQpIHtcbiAgICAgICAgX2Fzc2VydChwcm92aWRlcklkLnN0YXJ0c1dpdGgoU0FNTF9QUk9WSURFUl9QUkVGSVgpLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVySWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIFVzZXJDcmVkZW50aWFsfSBhZnRlciBhXG4gICAgICogc3VjY2Vzc2Z1bCBTQU1MIGZsb3cgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSwgeW91IGNvdWxkIHdyaXRlIHRoZVxuICAgICAqIGZvbGxvd2luZyBjb2RlOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB1c2VyQ3JlZGVudGlhbCA9IGF3YWl0IHNpZ25JbldpdGhQb3B1cChhdXRoLCBzYW1sUHJvdmlkZXIpO1xuICAgICAqIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tUmVzdWx0KHVzZXJDcmVkZW50aWFsKSB7XG4gICAgICAgIHJldHVybiBTQU1MQXV0aFByb3ZpZGVyLnNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFNBTUxBdXRoUHJvdmlkZXIuc2FtbENyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KChlcnJvci5jdXN0b21EYXRhIHx8IHt9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4ge0BsaW5rIEF1dGhDcmVkZW50aWFsfSBmcm9tIGEgSlNPTiBzdHJpbmcgb3IgYSBwbGFpbiBvYmplY3QuXG4gICAgICogQHBhcmFtIGpzb24gLSBBIHBsYWluIG9iamVjdCBvciBhIEpTT04gc3RyaW5nXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWwgPSBTQU1MQXV0aENyZWRlbnRpYWwuZnJvbUpTT04oanNvbik7XG4gICAgICAgIF9hc3NlcnQoY3JlZGVudGlhbCwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgICAgICByZXR1cm4gY3JlZGVudGlhbDtcbiAgICB9XG4gICAgc3RhdGljIHNhbWxDcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh7IF90b2tlblJlc3BvbnNlOiB0b2tlblJlc3BvbnNlIH0pIHtcbiAgICAgICAgaWYgKCF0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHBlbmRpbmdUb2tlbiwgcHJvdmlkZXJJZCB9ID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgaWYgKCFwZW5kaW5nVG9rZW4gfHwgIXByb3ZpZGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU0FNTEF1dGhDcmVkZW50aWFsLl9jcmVhdGUocHJvdmlkZXJJZCwgcGVuZGluZ1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGFuIHtAbGluayBPQXV0aENyZWRlbnRpYWx9IGZvciB7QGxpbmsgUHJvdmlkZXJJZH0uVFdJVFRFUi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogLy8gU2lnbiBpbiB1c2luZyBhIHJlZGlyZWN0LlxuICogY29uc3QgcHJvdmlkZXIgPSBuZXcgVHdpdHRlckF1dGhQcm92aWRlcigpO1xuICogLy8gU3RhcnQgYSBzaWduIGluIHByb2Nlc3MgZm9yIGFuIHVuYXV0aGVudGljYXRlZCB1c2VyLlxuICogYXdhaXQgc2lnbkluV2l0aFJlZGlyZWN0KGF1dGgsIHByb3ZpZGVyKTtcbiAqIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgZnVsbCBwYWdlIHJlZGlyZWN0IGF3YXkgZnJvbSB5b3VyIGFwcFxuICpcbiAqIC8vIEFmdGVyIHJldHVybmluZyBmcm9tIHRoZSByZWRpcmVjdCB3aGVuIHlvdXIgYXBwIGluaXRpYWxpemVzIHlvdSBjYW4gb2J0YWluIHRoZSByZXN1bHRcbiAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFJlZGlyZWN0UmVzdWx0KGF1dGgpO1xuICogaWYgKHJlc3VsdCkge1xuICogICAvLyBUaGlzIGlzIHRoZSBzaWduZWQtaW4gdXNlclxuICogICBjb25zdCB1c2VyID0gcmVzdWx0LnVzZXI7XG4gKiAgIC8vIFRoaXMgZ2l2ZXMgeW91IGEgVHdpdHRlciBBY2Nlc3MgVG9rZW4gYW5kIFNlY3JldC5cbiAqICAgY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqICAgY29uc3QgdG9rZW4gPSBjcmVkZW50aWFsLmFjY2Vzc1Rva2VuO1xuICogICBjb25zdCBzZWNyZXQgPSBjcmVkZW50aWFsLnNlY3JldDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBTaWduIGluIHVzaW5nIGEgcG9wdXAuXG4gKiBjb25zdCBwcm92aWRlciA9IG5ldyBUd2l0dGVyQXV0aFByb3ZpZGVyKCk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzaWduSW5XaXRoUG9wdXAoYXV0aCwgcHJvdmlkZXIpO1xuICpcbiAqIC8vIFRoZSBzaWduZWQtaW4gdXNlciBpbmZvLlxuICogY29uc3QgdXNlciA9IHJlc3VsdC51c2VyO1xuICogLy8gVGhpcyBnaXZlcyB5b3UgYSBUd2l0dGVyIEFjY2VzcyBUb2tlbiBhbmQgU2VjcmV0LlxuICogY29uc3QgY3JlZGVudGlhbCA9IFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21SZXN1bHQocmVzdWx0KTtcbiAqIGNvbnN0IHRva2VuID0gY3JlZGVudGlhbC5hY2Nlc3NUb2tlbjtcbiAqIGNvbnN0IHNlY3JldCA9IGNyZWRlbnRpYWwuc2VjcmV0O1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUd2l0dGVyQXV0aFByb3ZpZGVyIGV4dGVuZHMgQmFzZU9BdXRoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNyZWRlbnRpYWwgZm9yIFR3aXR0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUd2l0dGVyIGFjY2VzcyB0b2tlbi5cbiAgICAgKiBAcGFyYW0gc2VjcmV0IC0gVHdpdHRlciBzZWNyZXQuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWwodG9rZW4sIHNlY3JldCkge1xuICAgICAgICByZXR1cm4gT0F1dGhDcmVkZW50aWFsLl9mcm9tUGFyYW1zKHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuUFJPVklERVJfSUQsXG4gICAgICAgICAgICBzaWduSW5NZXRob2Q6IFR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCxcbiAgICAgICAgICAgIG9hdXRoVG9rZW46IHRva2VuLFxuICAgICAgICAgICAgb2F1dGhUb2tlblNlY3JldDogc2VjcmV0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGV4dHJhY3QgdGhlIHVuZGVybHlpbmcge0BsaW5rIE9BdXRoQ3JlZGVudGlhbH0gZnJvbSBhIHtAbGluayBVc2VyQ3JlZGVudGlhbH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVkZW50aWFsRnJvbVJlc3VsdCh1c2VyQ3JlZGVudGlhbCkge1xuICAgICAgICByZXR1cm4gVHdpdHRlckF1dGhQcm92aWRlci5jcmVkZW50aWFsRnJvbVRhZ2dlZE9iamVjdCh1c2VyQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgdW5kZXJseWluZyB7QGxpbmsgT0F1dGhDcmVkZW50aWFsfSBmcm9tIGEge0BsaW5rIEF1dGhFcnJvcn0gd2hpY2ggd2FzXG4gICAgICogdGhyb3duIGR1cmluZyBhIHNpZ24taW4sIGxpbmssIG9yIHJlYXV0aGVudGljYXRlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyQ3JlZGVudGlhbCAtIFRoZSB1c2VyIGNyZWRlbnRpYWwuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbEZyb21UYWdnZWRPYmplY3QoKGVycm9yLmN1c3RvbURhdGEgfHwge30pKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWRlbnRpYWxGcm9tVGFnZ2VkT2JqZWN0KHsgX3Rva2VuUmVzcG9uc2U6IHRva2VuUmVzcG9uc2UgfSkge1xuICAgICAgICBpZiAoIXRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb2F1dGhBY2Nlc3NUb2tlbiwgb2F1dGhUb2tlblNlY3JldCB9ID0gdG9rZW5SZXNwb25zZTtcbiAgICAgICAgaWYgKCFvYXV0aEFjY2Vzc1Rva2VuIHx8ICFvYXV0aFRva2VuU2VjcmV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFR3aXR0ZXJBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChvYXV0aEFjY2Vzc1Rva2VuLCBvYXV0aFRva2VuU2VjcmV0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEFsd2F5cyBzZXQgdG8ge0BsaW5rIFNpZ25Jbk1ldGhvZH0uVFdJVFRFUi4gKi9cblR3aXR0ZXJBdXRoUHJvdmlkZXIuVFdJVFRFUl9TSUdOX0lOX01FVEhPRCA9IFwidHdpdHRlci5jb21cIiAvKiBTaWduSW5NZXRob2QuVFdJVFRFUiAqLztcbi8qKiBBbHdheXMgc2V0IHRvIHtAbGluayBQcm92aWRlcklkfS5UV0lUVEVSLiAqL1xuVHdpdHRlckF1dGhQcm92aWRlci5QUk9WSURFUl9JRCA9IFwidHdpdHRlci5jb21cIiAvKiBQcm92aWRlcklkLlRXSVRURVIgKi87XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduVXAoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybVNpZ25JblJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czpzaWduVXBcIiAvKiBFbmRwb2ludC5TSUdOX1VQICovLCBfYWRkVGlkSWZOZWNlc3NhcnkoYXV0aCwgcmVxdWVzdCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgVXNlckNyZWRlbnRpYWxJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy51c2VyID0gcGFyYW1zLnVzZXI7XG4gICAgICAgIHRoaXMucHJvdmlkZXJJZCA9IHBhcmFtcy5wcm92aWRlcklkO1xuICAgICAgICB0aGlzLl90b2tlblJlc3BvbnNlID0gcGFyYW1zLl90b2tlblJlc3BvbnNlO1xuICAgICAgICB0aGlzLm9wZXJhdGlvblR5cGUgPSBwYXJhbXMub3BlcmF0aW9uVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIF9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIG9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlckltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgaWRUb2tlblJlc3BvbnNlLCBpc0Fub255bW91cyk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVySWQgPSBwcm92aWRlcklkRm9yUmVzcG9uc2UoaWRUb2tlblJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgdXNlckNyZWQgPSBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICBwcm92aWRlcklkLFxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IGlkVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1c2VyQ3JlZDtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIF9mb3JPcGVyYXRpb24odXNlciwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpIHtcbiAgICAgICAgYXdhaXQgdXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UsIC8qIHJlbG9hZCAqLyB0cnVlKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJJZCA9IHByb3ZpZGVySWRGb3JSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICBwcm92aWRlcklkLFxuICAgICAgICAgICAgX3Rva2VuUmVzcG9uc2U6IHJlc3BvbnNlLFxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm92aWRlcklkRm9yUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2UucHJvdmlkZXJJZCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UucHJvdmlkZXJJZDtcbiAgICB9XG4gICAgaWYgKCdwaG9uZU51bWJlcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIFwicGhvbmVcIiAvKiBQcm92aWRlcklkLlBIT05FICovO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gYXMgYW4gYW5vbnltb3VzIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZXJlIGlzIGFscmVhZHkgYW4gYW5vbnltb3VzIHVzZXIgc2lnbmVkIGluLCB0aGF0IHVzZXIgd2lsbCBiZSByZXR1cm5lZDsgb3RoZXJ3aXNlLCBhXG4gKiBuZXcgYW5vbnltb3VzIHVzZXIgaWRlbnRpdHkgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5Bbm9ueW1vdXNseShhdXRoKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5faW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIGlmICgoX2EgPSBhdXRoSW50ZXJuYWwuY3VycmVudFVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Fub255bW91cykge1xuICAgICAgICAvLyBJZiBhbiBhbm9ueW1vdXMgdXNlciBpcyBhbHJlYWR5IHNpZ25lZCBpbiwgbm8gbmVlZCB0byBzaWduIHRoZW0gaW4gYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXcgVXNlckNyZWRlbnRpYWxJbXBsKHtcbiAgICAgICAgICAgIHVzZXI6IGF1dGhJbnRlcm5hbC5jdXJyZW50VXNlcixcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IG51bGwsXG4gICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqL1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaWduVXAoYXV0aEludGVybmFsLCB7XG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aEludGVybmFsLCBcInNpZ25JblwiIC8qIE9wZXJhdGlvblR5cGUuU0lHTl9JTiAqLywgcmVzcG9uc2UsIHRydWUpO1xuICAgIGF3YWl0IGF1dGhJbnRlcm5hbC5fdXBkYXRlQ3VycmVudFVzZXIodXNlckNyZWRlbnRpYWwudXNlcik7XG4gICAgcmV0dXJuIHVzZXJDcmVkZW50aWFsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTXVsdGlGYWN0b3JFcnJvciBleHRlbmRzIEZpcmViYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGF1dGgsIGVycm9yLCBvcGVyYXRpb25UeXBlLCB1c2VyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoZXJyb3IuY29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uVHlwZSA9IG9wZXJhdGlvblR5cGU7XG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBNdWx0aUZhY3RvckVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIHRoaXMuY3VzdG9tRGF0YSA9IHtcbiAgICAgICAgICAgIGFwcE5hbWU6IGF1dGgubmFtZSxcbiAgICAgICAgICAgIHRlbmFudElkOiAoX2EgPSBhdXRoLnRlbmFudElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfc2VydmVyUmVzcG9uc2U6IGVycm9yLmN1c3RvbURhdGEuX3NlcnZlclJlc3BvbnNlLFxuICAgICAgICAgICAgb3BlcmF0aW9uVHlwZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21FcnJvckFuZE9wZXJhdGlvbihhdXRoLCBlcnJvciwgb3BlcmF0aW9uVHlwZSwgdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpRmFjdG9yRXJyb3IoYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9wcm9jZXNzQ3JlZGVudGlhbFNhdmluZ01mYUNvbnRleHRJZk5lY2Vzc2FyeShhdXRoLCBvcGVyYXRpb25UeXBlLCBjcmVkZW50aWFsLCB1c2VyKSB7XG4gICAgY29uc3QgaWRUb2tlblByb3ZpZGVyID0gb3BlcmF0aW9uVHlwZSA9PT0gXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi9cbiAgICAgICAgPyBjcmVkZW50aWFsLl9nZXRSZWF1dGhlbnRpY2F0aW9uUmVzb2x2ZXIoYXV0aClcbiAgICAgICAgOiBjcmVkZW50aWFsLl9nZXRJZFRva2VuUmVzcG9uc2UoYXV0aCk7XG4gICAgcmV0dXJuIGlkVG9rZW5Qcm92aWRlci5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wibXVsdGktZmFjdG9yLWF1dGgtcmVxdWlyZWRcIiAvKiBBdXRoRXJyb3JDb2RlLk1GQV9SRVFVSVJFRCAqL31gKSB7XG4gICAgICAgICAgICB0aHJvdyBNdWx0aUZhY3RvckVycm9yLl9mcm9tRXJyb3JBbmRPcGVyYXRpb24oYXV0aCwgZXJyb3IsIG9wZXJhdGlvblR5cGUsIHVzZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiBVc2VySW5mbyBwcm92aWRlciBkYXRhIGFuZCBjb252ZXJ0cyBpdCB0byBhIHNldCBvZiBuYW1lc1xuICovXG5mdW5jdGlvbiBwcm92aWRlckRhdGFBc05hbWVzKHByb3ZpZGVyRGF0YSkge1xuICAgIHJldHVybiBuZXcgU2V0KHByb3ZpZGVyRGF0YVxuICAgICAgICAubWFwKCh7IHByb3ZpZGVySWQgfSkgPT4gcHJvdmlkZXJJZClcbiAgICAgICAgLmZpbHRlcihwaWQgPT4gISFwaWQpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVW5saW5rcyBhIHByb3ZpZGVyIGZyb20gYSB1c2VyIGFjY291bnQuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwcm92aWRlcklkIC0gVGhlIHByb3ZpZGVyIHRvIHVubGluay5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVubGluayh1c2VyLCBwcm92aWRlcklkKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGF3YWl0IF9hc3NlcnRMaW5rZWRTdGF0dXModHJ1ZSwgdXNlckludGVybmFsLCBwcm92aWRlcklkKTtcbiAgICBjb25zdCB7IHByb3ZpZGVyVXNlckluZm8gfSA9IGF3YWl0IGRlbGV0ZUxpbmtlZEFjY291bnRzKHVzZXJJbnRlcm5hbC5hdXRoLCB7XG4gICAgICAgIGlkVG9rZW46IGF3YWl0IHVzZXJJbnRlcm5hbC5nZXRJZFRva2VuKCksXG4gICAgICAgIGRlbGV0ZVByb3ZpZGVyOiBbcHJvdmlkZXJJZF1cbiAgICB9KTtcbiAgICBjb25zdCBwcm92aWRlcnNMZWZ0ID0gcHJvdmlkZXJEYXRhQXNOYW1lcyhwcm92aWRlclVzZXJJbmZvIHx8IFtdKTtcbiAgICB1c2VySW50ZXJuYWwucHJvdmlkZXJEYXRhID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maWx0ZXIocGQgPT4gcHJvdmlkZXJzTGVmdC5oYXMocGQucHJvdmlkZXJJZCkpO1xuICAgIGlmICghcHJvdmlkZXJzTGVmdC5oYXMoXCJwaG9uZVwiIC8qIFByb3ZpZGVySWQuUEhPTkUgKi8pKSB7XG4gICAgICAgIHVzZXJJbnRlcm5hbC5waG9uZU51bWJlciA9IG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5hdXRoLl9wZXJzaXN0VXNlcklmQ3VycmVudCh1c2VySW50ZXJuYWwpO1xuICAgIHJldHVybiB1c2VySW50ZXJuYWw7XG59XG5hc3luYyBmdW5jdGlvbiBfbGluayh1c2VyLCBjcmVkZW50aWFsLCBieXBhc3NBdXRoU3RhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2xvZ291dElmSW52YWxpZGF0ZWQodXNlciwgY3JlZGVudGlhbC5fbGlua1RvSWRUb2tlbih1c2VyLmF1dGgsIGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpKSwgYnlwYXNzQXV0aFN0YXRlKTtcbiAgICByZXR1cm4gVXNlckNyZWRlbnRpYWxJbXBsLl9mb3JPcGVyYXRpb24odXNlciwgXCJsaW5rXCIgLyogT3BlcmF0aW9uVHlwZS5MSU5LICovLCByZXNwb25zZSk7XG59XG5hc3luYyBmdW5jdGlvbiBfYXNzZXJ0TGlua2VkU3RhdHVzKGV4cGVjdGVkLCB1c2VyLCBwcm92aWRlcikge1xuICAgIGF3YWl0IF9yZWxvYWRXaXRob3V0U2F2aW5nKHVzZXIpO1xuICAgIGNvbnN0IHByb3ZpZGVySWRzID0gcHJvdmlkZXJEYXRhQXNOYW1lcyh1c2VyLnByb3ZpZGVyRGF0YSk7XG4gICAgY29uc3QgY29kZSA9IGV4cGVjdGVkID09PSBmYWxzZVxuICAgICAgICA/IFwicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIiAvKiBBdXRoRXJyb3JDb2RlLlBST1ZJREVSX0FMUkVBRFlfTElOS0VEICovXG4gICAgICAgIDogXCJuby1zdWNoLXByb3ZpZGVyXCIgLyogQXV0aEVycm9yQ29kZS5OT19TVUNIX1BST1ZJREVSICovO1xuICAgIF9hc3NlcnQocHJvdmlkZXJJZHMuaGFzKHByb3ZpZGVyKSA9PT0gZXhwZWN0ZWQsIHVzZXIuYXV0aCwgY29kZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVhdXRoZW50aWNhdGUodXNlciwgY3JlZGVudGlhbCwgYnlwYXNzQXV0aFN0YXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGF1dGggfSA9IHVzZXI7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gXCJyZWF1dGhlbnRpY2F0ZVwiIC8qIE9wZXJhdGlvblR5cGUuUkVBVVRIRU5USUNBVEUgKi87XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCwgdXNlciksIGJ5cGFzc0F1dGhTdGF0ZSk7XG4gICAgICAgIF9hc3NlcnQocmVzcG9uc2UuaWRUb2tlbiwgYXV0aCwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBfcGFyc2VUb2tlbihyZXNwb25zZS5pZFRva2VuKTtcbiAgICAgICAgX2Fzc2VydChwYXJzZWQsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgeyBzdWI6IGxvY2FsSWQgfSA9IHBhcnNlZDtcbiAgICAgICAgX2Fzc2VydCh1c2VyLnVpZCA9PT0gbG9jYWxJZCwgYXV0aCwgXCJ1c2VyLW1pc21hdGNoXCIgLyogQXV0aEVycm9yQ29kZS5VU0VSX01JU01BVENIICovKTtcbiAgICAgICAgcmV0dXJuIFVzZXJDcmVkZW50aWFsSW1wbC5fZm9yT3BlcmF0aW9uKHVzZXIsIG9wZXJhdGlvblR5cGUsIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ29udmVydCB1c2VyIGRlbGV0ZWQgZXJyb3IgaW50byB1c2VyIG1pc21hdGNoXG4gICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmNvZGUpID09PSBgYXV0aC8ke1widXNlci1ub3QtZm91bmRcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfREVMRVRFRCAqL31gKSB7XG4gICAgICAgICAgICBfZmFpbChhdXRoLCBcInVzZXItbWlzbWF0Y2hcIiAvKiBBdXRoRXJyb3JDb2RlLlVTRVJfTUlTTUFUQ0ggKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3NpZ25JbldpdGhDcmVkZW50aWFsKGF1dGgsIGNyZWRlbnRpYWwsIGJ5cGFzc0F1dGhTdGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKF9pc0ZpcmViYXNlU2VydmVyQXBwKGF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IoYXV0aCkpO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRpb25UeXBlID0gXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi87XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcHJvY2Vzc0NyZWRlbnRpYWxTYXZpbmdNZmFDb250ZXh0SWZOZWNlc3NhcnkoYXV0aCwgb3BlcmF0aW9uVHlwZSwgY3JlZGVudGlhbCk7XG4gICAgY29uc3QgdXNlckNyZWRlbnRpYWwgPSBhd2FpdCBVc2VyQ3JlZGVudGlhbEltcGwuX2Zyb21JZFRva2VuUmVzcG9uc2UoYXV0aCwgb3BlcmF0aW9uVHlwZSwgcmVzcG9uc2UpO1xuICAgIGlmICghYnlwYXNzQXV0aFN0YXRlKSB7XG4gICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY3JlZGVudGlhbC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3JlZGVudGlhbChhdXRoLCBjcmVkZW50aWFsKSB7XG4gICAgcmV0dXJuIF9zaWduSW5XaXRoQ3JlZGVudGlhbChfY2FzdEF1dGgoYXV0aCksIGNyZWRlbnRpYWwpO1xufVxuLyoqXG4gKiBMaW5rcyB0aGUgdXNlciBhY2NvdW50IHdpdGggdGhlIGdpdmVuIGNyZWRlbnRpYWxzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBbiB7QGxpbmsgQXV0aFByb3ZpZGVyfSBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY3JlZGVudGlhbC5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGNyZWRlbnRpYWwgLSBUaGUgYXV0aCBjcmVkZW50aWFsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlua1dpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgYXdhaXQgX2Fzc2VydExpbmtlZFN0YXR1cyhmYWxzZSwgdXNlckludGVybmFsLCBjcmVkZW50aWFsLnByb3ZpZGVySWQpO1xuICAgIHJldHVybiBfbGluayh1c2VySW50ZXJuYWwsIGNyZWRlbnRpYWwpO1xufVxuLyoqXG4gKiBSZS1hdXRoZW50aWNhdGVzIGEgdXNlciB1c2luZyBhIGZyZXNoIGNyZWRlbnRpYWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFVzZSBiZWZvcmUgb3BlcmF0aW9ucyBzdWNoIGFzIHtAbGluayB1cGRhdGVQYXNzd29yZH0gdGhhdCByZXF1aXJlIHRva2VucyBmcm9tIHJlY2VudCBzaWduLWluXG4gKiBhdHRlbXB0cy4gVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gcmVjb3ZlciBmcm9tIGEgYENSRURFTlRJQUxfVE9PX09MRF9MT0dJTl9BR0FJTmAgZXJyb3JcbiAqIG9yIGEgYFRPS0VOX0VYUElSRURgIGVycm9yLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgb24gYW55IHtAbGluayBVc2VyfSBzaWduZWQgaW4gYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlc1xuICogY3JlYXRlZCB3aXRoIGEge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gY3JlZGVudGlhbCAtIFRoZSBhdXRoIGNyZWRlbnRpYWwuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsKHVzZXIsIGNyZWRlbnRpYWwpIHtcbiAgICByZXR1cm4gX3JlYXV0aGVudGljYXRlKGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKSwgY3JlZGVudGlhbCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiBzaWduSW5XaXRoQ3VzdG9tVG9rZW4kMShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtU2lnbkluUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOnNpZ25JbldpdGhDdXN0b21Ub2tlblwiIC8qIEVuZHBvaW50LlNJR05fSU5fV0lUSF9DVVNUT01fVE9LRU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGEgY3VzdG9tIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBDdXN0b20gdG9rZW5zIGFyZSB1c2VkIHRvIGludGVncmF0ZSBGaXJlYmFzZSBBdXRoIHdpdGggZXhpc3RpbmcgYXV0aCBzeXN0ZW1zLCBhbmQgbXVzdFxuICogYmUgZ2VuZXJhdGVkIGJ5IGFuIGF1dGggYmFja2VuZCB1c2luZyB0aGVcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9yZWZlcmVuY2UvYWRtaW4vbm9kZS9hZG1pbi5hdXRoLkF1dGgjY3JlYXRlY3VzdG9tdG9rZW4gfCBjcmVhdGVDdXN0b21Ub2tlbn1cbiAqIG1ldGhvZCBpbiB0aGUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2F1dGgvYWRtaW4gfCBBZG1pbiBTREt9IC5cbiAqXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSB0b2tlbiBpcyBpbnZhbGlkLCBleHBpcmVkLCBvciBub3QgYWNjZXB0ZWQgYnkgdGhlIEZpcmViYXNlIEF1dGggc2VydmljZS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gY3VzdG9tVG9rZW4gLSBUaGUgY3VzdG9tIHRva2VuIHRvIHNpZ24gaW4gd2l0aC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhDdXN0b21Ub2tlbihhdXRoLCBjdXN0b21Ub2tlbikge1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2lnbkluV2l0aEN1c3RvbVRva2VuJDEoYXV0aEludGVybmFsLCB7XG4gICAgICAgIHRva2VuOiBjdXN0b21Ub2tlbixcbiAgICAgICAgcmV0dXJuU2VjdXJlVG9rZW46IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBjcmVkID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGhJbnRlcm5hbCwgXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi8sIHJlc3BvbnNlKTtcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKGNyZWQudXNlcik7XG4gICAgcmV0dXJuIGNyZWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3JJZCwgcmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xuICAgICAgICB0aGlzLnVpZCA9IHJlc3BvbnNlLm1mYUVucm9sbG1lbnRJZDtcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50VGltZSA9IG5ldyBEYXRlKHJlc3BvbnNlLmVucm9sbGVkQXQpLnRvVVRDU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuZGlzcGxheU5hbWUgPSByZXNwb25zZS5kaXNwbGF5TmFtZTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCkge1xuICAgICAgICBpZiAoJ3Bob25lSW5mbycgaW4gZW5yb2xsbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFBob25lTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKGF1dGgsIGVucm9sbG1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCd0b3RwSW5mbycgaW4gZW5yb2xsbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UoYXV0aCwgZW5yb2xsbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICB9XG59XG5jbGFzcyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBzdXBlcihcInBob25lXCIgLyogRmFjdG9ySWQuUEhPTkUgKi8sIHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlciA9IHJlc3BvbnNlLnBob25lSW5mbztcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU2VydmVyUmVzcG9uc2UoX2F1dGgsIGVucm9sbG1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaG9uZU11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XG4gICAgfVxufVxuY2xhc3MgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwgZXh0ZW5kcyBNdWx0aUZhY3RvckluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovLCByZXNwb25zZSk7XG4gICAgfVxuICAgIHN0YXRpYyBfZnJvbVNlcnZlclJlc3BvbnNlKF9hdXRoLCBlbnJvbGxtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgVG90cE11bHRpRmFjdG9ySW5mb0ltcGwoZW5yb2xsbWVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX3NldEFjdGlvbkNvZGVTZXR0aW5nc09uUmVxdWVzdChhdXRoLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICB2YXIgX2E7XG4gICAgX2Fzc2VydCgoKF9hID0gYWN0aW9uQ29kZVNldHRpbmdzLnVybCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPiAwLCBhdXRoLCBcImludmFsaWQtY29udGludWUtdXJpXCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0NPTlRJTlVFX1VSSSAqLyk7XG4gICAgX2Fzc2VydCh0eXBlb2YgYWN0aW9uQ29kZVNldHRpbmdzLmR5bmFtaWNMaW5rRG9tYWluID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICBhY3Rpb25Db2RlU2V0dGluZ3MuZHluYW1pY0xpbmtEb21haW4ubGVuZ3RoID4gMCwgYXV0aCwgXCJpbnZhbGlkLWR5bmFtaWMtbGluay1kb21haW5cIiAvKiBBdXRoRXJyb3JDb2RlLklOVkFMSURfRFlOQU1JQ19MSU5LX0RPTUFJTiAqLyk7XG4gICAgcmVxdWVzdC5jb250aW51ZVVybCA9IGFjdGlvbkNvZGVTZXR0aW5ncy51cmw7XG4gICAgcmVxdWVzdC5keW5hbWljTGlua0RvbWFpbiA9IGFjdGlvbkNvZGVTZXR0aW5ncy5keW5hbWljTGlua0RvbWFpbjtcbiAgICByZXF1ZXN0LmNhbkhhbmRsZUNvZGVJbkFwcCA9IGFjdGlvbkNvZGVTZXR0aW5ncy5oYW5kbGVDb2RlSW5BcHA7XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncy5pT1MpIHtcbiAgICAgICAgX2Fzc2VydChhY3Rpb25Db2RlU2V0dGluZ3MuaU9TLmJ1bmRsZUlkLmxlbmd0aCA+IDAsIGF1dGgsIFwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCIgLyogQXV0aEVycm9yQ29kZS5NSVNTSU5HX0lPU19CVU5ETEVfSUQgKi8pO1xuICAgICAgICByZXF1ZXN0LmlPU0J1bmRsZUlkID0gYWN0aW9uQ29kZVNldHRpbmdzLmlPUy5idW5kbGVJZDtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkKSB7XG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQucGFja2FnZU5hbWUubGVuZ3RoID4gMCwgYXV0aCwgXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIiAvKiBBdXRoRXJyb3JDb2RlLk1JU1NJTkdfQU5EUk9JRF9QQUNLQUdFX05BTUUgKi8pO1xuICAgICAgICByZXF1ZXN0LmFuZHJvaWRJbnN0YWxsQXBwID0gYWN0aW9uQ29kZVNldHRpbmdzLmFuZHJvaWQuaW5zdGFsbEFwcDtcbiAgICAgICAgcmVxdWVzdC5hbmRyb2lkTWluaW11bVZlcnNpb25Db2RlID1cbiAgICAgICAgICAgIGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLm1pbmltdW1WZXJzaW9uO1xuICAgICAgICByZXF1ZXN0LmFuZHJvaWRQYWNrYWdlTmFtZSA9IGFjdGlvbkNvZGVTZXR0aW5ncy5hbmRyb2lkLnBhY2thZ2VOYW1lO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVXBkYXRlcyB0aGUgcGFzc3dvcmQgcG9saWN5IGNhY2hlZCBpbiB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIGlmIGEgcG9saWN5IGlzIGFscmVhZHlcbiAqIGNhY2hlZCBmb3IgdGhlIHByb2plY3Qgb3IgdGVuYW50LlxuICpcbiAqIEByZW1hcmtzXG4gKiBXZSBvbmx5IGZldGNoIHRoZSBwYXNzd29yZCBwb2xpY3kgaWYgdGhlIHBhc3N3b3JkIGRpZCBub3QgbWVldCBwb2xpY3kgcmVxdWlyZW1lbnRzIGFuZFxuICogdGhlcmUgaXMgYW4gZXhpc3RpbmcgcG9saWN5IGNhY2hlZC4gQSBkZXZlbG9wZXIgbXVzdCBjYWxsIHZhbGlkYXRlUGFzc3dvcmQgYXQgbGVhc3RcbiAqIG9uY2UgZm9yIHRoZSBjYWNoZSB0byBiZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGlmIChhdXRoSW50ZXJuYWwuX2dldFBhc3N3b3JkUG9saWN5SW50ZXJuYWwoKSkge1xuICAgICAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZVBhc3N3b3JkUG9saWN5KCk7XG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhIHBhc3N3b3JkIHJlc2V0IGVtYWlsIHRvIHRoZSBnaXZlbiBlbWFpbCBhZGRyZXNzLiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuXG4gKiB0aGVyZSdzIG5vIHVzZXIgYWNjb3VudCB3aXRoIHRoZSBnaXZlbiBlbWFpbCBhZGRyZXNzIGFuZFxuICoge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS9pZGVudGl0eS1wbGF0Zm9ybS9kb2NzL2FkbWluL2VtYWlsLWVudW1lcmF0aW9uLXByb3RlY3Rpb24gfCBFbWFpbCBFbnVtZXJhdGlvbiBQcm90ZWN0aW9ufVxuICogaXMgZW5hYmxlZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVG8gY29tcGxldGUgdGhlIHBhc3N3b3JkIHJlc2V0LCBjYWxsIHtAbGluayBjb25maXJtUGFzc3dvcmRSZXNldH0gd2l0aCB0aGUgY29kZSBzdXBwbGllZCBpblxuICogdGhlIGVtYWlsIHNlbnQgdG8gdGhlIHVzZXIsIGFsb25nIHdpdGggdGhlIG5ldyBwYXNzd29yZCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZFBhc3N3b3JkUmVzZXRFbWFpbChhdXRoLCAndXNlckBleGFtcGxlLmNvbScsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gKiAvLyBPYnRhaW4gY29kZSBmcm9tIHVzZXIuXG4gKiBhd2FpdCBjb25maXJtUGFzc3dvcmRSZXNldCgndXNlckBleGFtcGxlLmNvbScsIGNvZGUpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRQYXNzd29yZFJlc2V0RW1haWwoYXV0aCwgZW1haWwsIGFjdGlvbkNvZGVTZXR0aW5ncykge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICByZXF1ZXN0VHlwZTogXCJQQVNTV09SRF9SRVNFVFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uUEFTU1dPUkRfUkVTRVQgKi8sXG4gICAgICAgIGVtYWlsLFxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgfTtcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoYXV0aEludGVybmFsLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIH1cbiAgICBhd2FpdCBoYW5kbGVSZWNhcHRjaGFGbG93KGF1dGhJbnRlcm5hbCwgcmVxdWVzdCwgXCJnZXRPb2JDb2RlXCIgLyogUmVjYXB0Y2hhQWN0aW9uTmFtZS5HRVRfT09CX0NPREUgKi8sIHNlbmRQYXNzd29yZFJlc2V0RW1haWwkMSwgXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLyk7XG59XG4vKipcbiAqIENvbXBsZXRlcyB0aGUgcGFzc3dvcmQgcmVzZXQgcHJvY2VzcywgZ2l2ZW4gYSBjb25maXJtYXRpb24gY29kZSBhbmQgbmV3IHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSBjb25maXJtYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICogQHBhcmFtIG5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbmZpcm1QYXNzd29yZFJlc2V0KGF1dGgsIG9vYkNvZGUsIG5ld1Bhc3N3b3JkKSB7XG4gICAgYXdhaXQgcmVzZXRQYXNzd29yZChnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHtcbiAgICAgICAgb29iQ29kZSxcbiAgICAgICAgbmV3UGFzc3dvcmRcbiAgICB9KVxuICAgICAgICAuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PVxuICAgICAgICAgICAgYGF1dGgvJHtcInBhc3N3b3JkLWRvZXMtbm90LW1lZXQtcmVxdWlyZW1lbnRzXCIgLyogQXV0aEVycm9yQ29kZS5QQVNTV09SRF9ET0VTX05PVF9NRUVUX1JFUVVJUkVNRU5UUyAqL31gKSB7XG4gICAgICAgICAgICB2b2lkIHJlY2FjaGVQYXNzd29yZFBvbGljeShhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICAvLyBEbyBub3QgcmV0dXJuIHRoZSBlbWFpbC5cbn1cbi8qKlxuICogQXBwbGllcyBhIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIgYnkgZW1haWwgb3Igb3RoZXIgb3V0LW9mLWJhbmQgbWVjaGFuaXNtLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvb2JDb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXBwbHlBY3Rpb25Db2RlKGF1dGgsIG9vYkNvZGUpIHtcbiAgICBhd2FpdCBhcHBseUFjdGlvbkNvZGUkMShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHsgb29iQ29kZSB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGEgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXG4gKlxuICogQHJldHVybnMgbWV0YWRhdGEgYWJvdXQgdGhlIGNvZGUuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG9vYkNvZGUgLSBBIHZlcmlmaWNhdGlvbiBjb2RlIHNlbnQgdG8gdGhlIHVzZXIuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBjaGVja0FjdGlvbkNvZGUoYXV0aCwgb29iQ29kZSkge1xuICAgIGNvbnN0IGF1dGhNb2R1bGFyID0gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzZXRQYXNzd29yZChhdXRoTW9kdWxhciwgeyBvb2JDb2RlIH0pO1xuICAgIC8vIEVtYWlsIGNvdWxkIGJlIGVtcHR5IG9ubHkgaWYgdGhlIHJlcXVlc3QgdHlwZSBpcyBFTUFJTF9TSUdOSU4gb3JcbiAgICAvLyBWRVJJRllfQU5EX0NIQU5HRV9FTUFJTC5cbiAgICAvLyBOZXcgZW1haWwgc2hvdWxkIG5vdCBiZSBlbXB0eSBpZiB0aGUgcmVxdWVzdCB0eXBlIGlzXG4gICAgLy8gVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwuXG4gICAgLy8gTXVsdGktZmFjdG9yIGluZm8gY291bGQgbm90IGJlIGVtcHR5IGlmIHRoZSByZXF1ZXN0IHR5cGUgaXNcbiAgICAvLyBSRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTi5cbiAgICBjb25zdCBvcGVyYXRpb24gPSByZXNwb25zZS5yZXF1ZXN0VHlwZTtcbiAgICBfYXNzZXJ0KG9wZXJhdGlvbiwgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgICBjYXNlIFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi86XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqLzpcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UubmV3RW1haWwsIGF1dGhNb2R1bGFyLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJFVkVSVF9TRUNPTkRfRkFDVE9SX0FERElUSU9OXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5SRVZFUlRfU0VDT05EX0ZBQ1RPUl9BRERJVElPTiAqLzpcbiAgICAgICAgICAgIF9hc3NlcnQocmVzcG9uc2UubWZhSW5mbywgYXV0aE1vZHVsYXIsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBfYXNzZXJ0KHJlc3BvbnNlLmVtYWlsLCBhdXRoTW9kdWxhciwgXCJpbnRlcm5hbC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuSU5URVJOQUxfRVJST1IgKi8pO1xuICAgIH1cbiAgICAvLyBUaGUgbXVsdGktZmFjdG9yIGluZm8gZm9yIHJldmVydCBzZWNvbmQgZmFjdG9yIGFkZGl0aW9uXG4gICAgbGV0IG11bHRpRmFjdG9ySW5mbyA9IG51bGw7XG4gICAgaWYgKHJlc3BvbnNlLm1mYUluZm8pIHtcbiAgICAgICAgbXVsdGlGYWN0b3JJbmZvID0gTXVsdGlGYWN0b3JJbmZvSW1wbC5fZnJvbVNlcnZlclJlc3BvbnNlKF9jYXN0QXV0aChhdXRoTW9kdWxhciksIHJlc3BvbnNlLm1mYUluZm8pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBlbWFpbDogKHJlc3BvbnNlLnJlcXVlc3RUeXBlID09PSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqL1xuICAgICAgICAgICAgICAgID8gcmVzcG9uc2UubmV3RW1haWxcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmVtYWlsKSB8fCBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNFbWFpbDogKHJlc3BvbnNlLnJlcXVlc3RUeXBlID09PSBcIlZFUklGWV9BTkRfQ0hBTkdFX0VNQUlMXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5WRVJJRllfQU5EX0NIQU5HRV9FTUFJTCAqL1xuICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuZW1haWxcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLm5ld0VtYWlsKSB8fCBudWxsLFxuICAgICAgICAgICAgbXVsdGlGYWN0b3JJbmZvXG4gICAgICAgIH0sXG4gICAgICAgIG9wZXJhdGlvblxuICAgIH07XG59XG4vKipcbiAqIENoZWNrcyBhIHBhc3N3b3JkIHJlc2V0IGNvZGUgc2VudCB0byB0aGUgdXNlciBieSBlbWFpbCBvciBvdGhlciBvdXQtb2YtYmFuZCBtZWNoYW5pc20uXG4gKlxuICogQHJldHVybnMgdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzIGlmIHZhbGlkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBjb2RlIC0gQSB2ZXJpZmljYXRpb24gY29kZSBzZW50IHRvIHRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UGFzc3dvcmRSZXNldENvZGUoYXV0aCwgY29kZSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgY2hlY2tBY3Rpb25Db2RlKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgY29kZSk7XG4gICAgLy8gRW1haWwgc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IHNpbmNlIGEgY29kZSB3YXMgc2VudCB0byBpdFxuICAgIHJldHVybiBkYXRhLmVtYWlsO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHVzZXIgYWNjb3VudCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZC5cbiAqXG4gKiBAcmVtYXJrc1xuICogT24gc3VjY2Vzc2Z1bCBjcmVhdGlvbiBvZiB0aGUgdXNlciBhY2NvdW50LCB0aGlzIHVzZXIgd2lsbCBhbHNvIGJlIHNpZ25lZCBpbiB0byB5b3VyIGFwcGxpY2F0aW9uLlxuICpcbiAqIFVzZXIgYWNjb3VudCBjcmVhdGlvbiBjYW4gZmFpbCBpZiB0aGUgYWNjb3VudCBhbHJlYWR5IGV4aXN0cyBvciB0aGUgcGFzc3dvcmQgaXMgaW52YWxpZC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIG9uIHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBOb3RlOiBUaGUgZW1haWwgYWRkcmVzcyBhY3RzIGFzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSB1c2VyIGFuZCBlbmFibGVzIGFuIGVtYWlsLWJhc2VkXG4gKiBwYXNzd29yZCByZXNldC4gVGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBhIG5ldyB1c2VyIGFjY291bnQgYW5kIHNldCB0aGUgaW5pdGlhbCB1c2VyIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgY2hvc2VuIHBhc3N3b3JkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlcldpdGhFbWFpbEFuZFBhc3N3b3JkKGF1dGgsIGVtYWlsLCBwYXNzd29yZCkge1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlLFxuICAgICAgICBlbWFpbCxcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIGNsaWVudFR5cGU6IFwiQ0xJRU5UX1RZUEVfV0VCXCIgLyogUmVjYXB0Y2hhQ2xpZW50VHlwZS5XRUIgKi9cbiAgICB9O1xuICAgIGNvbnN0IHNpZ25VcFJlc3BvbnNlID0gaGFuZGxlUmVjYXB0Y2hhRmxvdyhhdXRoSW50ZXJuYWwsIHJlcXVlc3QsIFwic2lnblVwUGFzc3dvcmRcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLlNJR05fVVBfUEFTU1dPUkQgKi8sIHNpZ25VcCwgXCJFTUFJTF9QQVNTV09SRF9QUk9WSURFUlwiIC8qIFJlY2FwdGNoYUF1dGhQcm92aWRlci5FTUFJTF9QQVNTV09SRF9QUk9WSURFUiAqLyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzaWduVXBSZXNwb25zZS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBgYXV0aC8ke1wicGFzc3dvcmQtZG9lcy1ub3QtbWVldC1yZXF1aXJlbWVudHNcIiAvKiBBdXRoRXJyb3JDb2RlLlBBU1NXT1JEX0RPRVNfTk9UX01FRVRfUkVRVUlSRU1FTlRTICovfWApIHtcbiAgICAgICAgICAgIHZvaWQgcmVjYWNoZVBhc3N3b3JkUG9saWN5KGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGhJbnRlcm5hbCwgXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi8sIHJlc3BvbnNlKTtcbiAgICBhd2FpdCBhdXRoSW50ZXJuYWwuX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICAgIHJldHVybiB1c2VyQ3JlZGVudGlhbDtcbn1cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgc2lnbnMgaW4gdXNpbmcgYW4gZW1haWwgYW5kIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSBlbWFpbCBhZGRyZXNzIGFuZCBwYXNzd29yZCBkbyBub3QgbWF0Y2guIFdoZW5cbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn1cbiAqIGlzIGVuYWJsZWQsIHRoaXMgbWV0aG9kIGZhaWxzIHdpdGggXCJhdXRoL2ludmFsaWQtY3JlZGVudGlhbFwiIGluIGNhc2Ugb2YgYW4gaW52YWxpZFxuICogZW1haWwvcGFzc3dvcmQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogTm90ZTogVGhlIHVzZXIncyBwYXNzd29yZCBpcyBOT1QgdGhlIHBhc3N3b3JkIHVzZWQgdG8gYWNjZXNzIHRoZSB1c2VyJ3MgZW1haWwgYWNjb3VudC4gVGhlXG4gKiBlbWFpbCBhZGRyZXNzIHNlcnZlcyBhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgdXNlciwgYW5kIHRoZSBwYXNzd29yZCBpcyB1c2VkIHRvIGFjY2Vzc1xuICogdGhlIHVzZXIncyBhY2NvdW50IGluIHlvdXIgRmlyZWJhc2UgcHJvamVjdC4gU2VlIGFsc286IHtAbGluayBjcmVhdGVVc2VyV2l0aEVtYWlsQW5kUGFzc3dvcmR9LlxuICpcbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcnMgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSB1c2VycyBwYXNzd29yZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbEFuZFBhc3N3b3JkKGF1dGgsIGVtYWlsLCBwYXNzd29yZCkge1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25JbldpdGhDcmVkZW50aWFsKGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKSwgRW1haWxBdXRoUHJvdmlkZXIuY3JlZGVudGlhbChlbWFpbCwgcGFzc3dvcmQpKS5jYXRjaChhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGBhdXRoLyR7XCJwYXNzd29yZC1kb2VzLW5vdC1tZWV0LXJlcXVpcmVtZW50c1wiIC8qIEF1dGhFcnJvckNvZGUuUEFTU1dPUkRfRE9FU19OT1RfTUVFVF9SRVFVSVJFTUVOVFMgKi99YCkge1xuICAgICAgICAgICAgdm9pZCByZWNhY2hlUGFzc3dvcmRQb2xpY3koYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFNlbmRzIGEgc2lnbi1pbiBlbWFpbCBsaW5rIHRvIHRoZSB1c2VyIHdpdGggdGhlIHNwZWNpZmllZCBlbWFpbC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNpZ24taW4gb3BlcmF0aW9uIGhhcyB0byBhbHdheXMgYmUgY29tcGxldGVkIGluIHRoZSBhcHAgdW5saWtlIG90aGVyIG91dCBvZiBiYW5kIGVtYWlsXG4gKiBhY3Rpb25zIChwYXNzd29yZCByZXNldCBhbmQgZW1haWwgdmVyaWZpY2F0aW9ucykuIFRoaXMgaXMgYmVjYXVzZSwgYXQgdGhlIGVuZCBvZiB0aGUgZmxvdyxcbiAqIHRoZSB1c2VyIGlzIGV4cGVjdGVkIHRvIGJlIHNpZ25lZCBpbiBhbmQgdGhlaXIgQXV0aCBzdGF0ZSBwZXJzaXN0ZWQgd2l0aGluIHRoZSBhcHAuXG4gKlxuICogVG8gY29tcGxldGUgc2lnbiBpbiB3aXRoIHRoZSBlbWFpbCBsaW5rLCBjYWxsIHtAbGluayBzaWduSW5XaXRoRW1haWxMaW5rfSB3aXRoIHRoZSBlbWFpbFxuICogYWRkcmVzcyBhbmQgdGhlIGVtYWlsIGxpbmsgc3VwcGxpZWQgaW4gdGhlIGVtYWlsIHNlbnQgdG8gdGhlIHVzZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB0aGUgdXNlci5cbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XG4gKiAgIGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBlbWFpbExpbmspO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhJbnRlcm5hbCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gZW1haWwgLSBUaGUgdXNlcidzIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0gYWN0aW9uQ29kZVNldHRpbmdzIC0gVGhlIHtAbGluayBBY3Rpb25Db2RlU2V0dGluZ3N9LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsIGVtYWlsLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCBhdXRoSW50ZXJuYWwgPSBfY2FzdEF1dGgoYXV0aCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi8sXG4gICAgICAgIGVtYWlsLFxuICAgICAgICBjbGllbnRUeXBlOiBcIkNMSUVOVF9UWVBFX1dFQlwiIC8qIFJlY2FwdGNoYUNsaWVudFR5cGUuV0VCICovXG4gICAgfTtcbiAgICBmdW5jdGlvbiBzZXRBY3Rpb25Db2RlU2V0dGluZ3MocmVxdWVzdCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgIF9hc3NlcnQoYWN0aW9uQ29kZVNldHRpbmdzLmhhbmRsZUNvZGVJbkFwcCwgYXV0aEludGVybmFsLCBcImFyZ3VtZW50LWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5BUkdVTUVOVF9FUlJPUiAqLyk7XG4gICAgICAgIGlmIChhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QoYXV0aEludGVybmFsLCByZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEFjdGlvbkNvZGVTZXR0aW5ncyhyZXF1ZXN0LCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICAgIGF3YWl0IGhhbmRsZVJlY2FwdGNoYUZsb3coYXV0aEludGVybmFsLCByZXF1ZXN0LCBcImdldE9vYkNvZGVcIiAvKiBSZWNhcHRjaGFBY3Rpb25OYW1lLkdFVF9PT0JfQ09ERSAqLywgc2VuZFNpZ25JbkxpbmtUb0VtYWlsJDEsIFwiRU1BSUxfUEFTU1dPUkRfUFJPVklERVJcIiAvKiBSZWNhcHRjaGFBdXRoUHJvdmlkZXIuRU1BSUxfUEFTU1dPUkRfUFJPVklERVIgKi8pO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYW4gaW5jb21pbmcgbGluayBpcyBhIHNpZ24taW4gd2l0aCBlbWFpbCBsaW5rIHN1aXRhYmxlIGZvciB7QGxpbmsgc2lnbkluV2l0aEVtYWlsTGlua30uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsTGluayAtIFRoZSBsaW5rIHNlbnQgdG8gdGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNTaWduSW5XaXRoRW1haWxMaW5rKGF1dGgsIGVtYWlsTGluaykge1xuICAgIGNvbnN0IGFjdGlvbkNvZGVVcmwgPSBBY3Rpb25Db2RlVVJMLnBhcnNlTGluayhlbWFpbExpbmspO1xuICAgIHJldHVybiAoYWN0aW9uQ29kZVVybCA9PT0gbnVsbCB8fCBhY3Rpb25Db2RlVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3Rpb25Db2RlVXJsLm9wZXJhdGlvbikgPT09IFwiRU1BSUxfU0lHTklOXCIgLyogQWN0aW9uQ29kZU9wZXJhdGlvbi5FTUFJTF9TSUdOSU4gKi87XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNpZ25zIGluIHVzaW5nIGFuIGVtYWlsIGFuZCBzaWduLWluIGVtYWlsIGxpbmsuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIG5vIGxpbmsgaXMgcGFzc2VkLCB0aGUgbGluayBpcyBpbmZlcnJlZCBmcm9tIHRoZSBjdXJyZW50IFVSTC5cbiAqXG4gKiBGYWlscyB3aXRoIGFuIGVycm9yIGlmIHRoZSBlbWFpbCBhZGRyZXNzIGlzIGludmFsaWQgb3IgT1RQIGluIGVtYWlsIGxpbmsgZXhwaXJlcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHtAbGluayBBdXRofSBpbnN0YW5jZXMgY3JlYXRlZCB3aXRoIGFcbiAqIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlU2VydmVyQXBwfS5cbiAqXG4gKiBOb3RlOiBDb25maXJtIHRoZSBsaW5rIGlzIGEgc2lnbi1pbiBlbWFpbCBsaW5rIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kIGZpcmViYXNlLmF1dGguQXV0aC5pc1NpZ25JbldpdGhFbWFpbExpbmsuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IGFjdGlvbkNvZGVTZXR0aW5ncyA9IHtcbiAqICAgdXJsOiAnaHR0cHM6Ly93d3cuZXhhbXBsZS5jb20vP2VtYWlsPXVzZXJAZXhhbXBsZS5jb20nLFxuICogICBpT1M6IHtcbiAqICAgICAgYnVuZGxlSWQ6ICdjb20uZXhhbXBsZS5pb3MnXG4gKiAgIH0sXG4gKiAgIGFuZHJvaWQ6IHtcbiAqICAgICBwYWNrYWdlTmFtZTogJ2NvbS5leGFtcGxlLmFuZHJvaWQnLFxuICogICAgIGluc3RhbGxBcHA6IHRydWUsXG4gKiAgICAgbWluaW11bVZlcnNpb246ICcxMidcbiAqICAgfSxcbiAqICAgaGFuZGxlQ29kZUluQXBwOiB0cnVlXG4gKiB9O1xuICogYXdhaXQgc2VuZFNpZ25JbkxpbmtUb0VtYWlsKGF1dGgsICd1c2VyQGV4YW1wbGUuY29tJywgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBlbWFpbExpbmsgZnJvbSB0aGUgdXNlci5cbiAqIGlmKGlzU2lnbkluV2l0aEVtYWlsTGluayhhdXRoLCBlbWFpbExpbmspKSB7XG4gKiAgIGF3YWl0IHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgJ3VzZXJAZXhhbXBsZS5jb20nLCBlbWFpbExpbmspO1xuICogfVxuICogYGBgXG4gKlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlbWFpbCAtIFRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqIEBwYXJhbSBlbWFpbExpbmsgLSBUaGUgbGluayBzZW50IHRvIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNpZ25JbldpdGhFbWFpbExpbmsoYXV0aCwgZW1haWwsIGVtYWlsTGluaykge1xuICAgIGlmIChfaXNGaXJlYmFzZVNlcnZlckFwcChhdXRoLmFwcCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KF9zZXJ2ZXJBcHBDdXJyZW50VXNlck9wZXJhdGlvbk5vdFN1cHBvcnRlZEVycm9yKGF1dGgpKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG4gICAgY29uc3QgY3JlZGVudGlhbCA9IEVtYWlsQXV0aFByb3ZpZGVyLmNyZWRlbnRpYWxXaXRoTGluayhlbWFpbCwgZW1haWxMaW5rIHx8IF9nZXRDdXJyZW50VXJsKCkpO1xuICAgIC8vIENoZWNrIGlmIHRoZSB0ZW5hbnQgSUQgaW4gdGhlIGVtYWlsIGxpbmsgbWF0Y2hlcyB0aGUgdGVuYW50IElEIG9uIEF1dGhcbiAgICAvLyBpbnN0YW5jZS5cbiAgICBfYXNzZXJ0KGNyZWRlbnRpYWwuX3RlbmFudElkID09PSAoYXV0aE1vZHVsYXIudGVuYW50SWQgfHwgbnVsbCksIGF1dGhNb2R1bGFyLCBcInRlbmFudC1pZC1taXNtYXRjaFwiIC8qIEF1dGhFcnJvckNvZGUuVEVOQU5UX0lEX01JU01BVENIICovKTtcbiAgICByZXR1cm4gc2lnbkluV2l0aENyZWRlbnRpYWwoYXV0aE1vZHVsYXIsIGNyZWRlbnRpYWwpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXV0aFVyaShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YxL2FjY291bnRzOmNyZWF0ZUF1dGhVcmlcIiAvKiBFbmRwb2ludC5DUkVBVEVfQVVUSF9VUkkgKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEdldHMgdGhlIGxpc3Qgb2YgcG9zc2libGUgc2lnbiBpbiBtZXRob2RzIGZvciB0aGUgZ2l2ZW4gZW1haWwgYWRkcmVzcy4gVGhpcyBtZXRob2QgcmV0dXJucyBhblxuICogZW1wdHkgbGlzdCB3aGVuXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XG4gKiBpcyBlbmFibGVkLCBpcnJlc3BlY3RpdmUgb2YgdGhlIG51bWJlciBvZiBhdXRoZW50aWNhdGlvbiBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIGVtYWlsLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBkaWZmZXJlbnRpYXRlIG1ldGhvZHMgb2Ygc2lnbi1pbiBmb3IgdGhlIHNhbWUgcHJvdmlkZXIsIGVnLlxuICoge0BsaW5rIEVtYWlsQXV0aFByb3ZpZGVyfSB3aGljaCBoYXMgMiBtZXRob2RzIG9mIHNpZ24taW4sXG4gKiB7QGxpbmsgU2lnbkluTWV0aG9kfS5FTUFJTF9QQVNTV09SRCBhbmRcbiAqIHtAbGluayBTaWduSW5NZXRob2R9LkVNQUlMX0xJTksuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGVtYWlsIC0gVGhlIHVzZXIncyBlbWFpbCBhZGRyZXNzLlxuICpcbiAqIERlcHJlY2F0ZWQuIE1pZ3JhdGluZyBvZmYgb2YgdGhpcyBtZXRob2QgaXMgcmVjb21tZW5kZWQgYXMgYSBzZWN1cml0eSBiZXN0LXByYWN0aWNlLlxuICogTGVhcm4gbW9yZSBpbiB0aGUgSWRlbnRpdHkgUGxhdGZvcm0gZG9jdW1lbnRhdGlvbiBmb3JcbiAqIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vaWRlbnRpdHktcGxhdGZvcm0vZG9jcy9hZG1pbi9lbWFpbC1lbnVtZXJhdGlvbi1wcm90ZWN0aW9uIHwgRW1haWwgRW51bWVyYXRpb24gUHJvdGVjdGlvbn0uXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoU2lnbkluTWV0aG9kc0ZvckVtYWlsKGF1dGgsIGVtYWlsKSB7XG4gICAgLy8gY3JlYXRlQXV0aFVyaSByZXR1cm5zIGFuIGVycm9yIGlmIGNvbnRpbnVlIFVSSSBpcyBub3QgaHR0cCBvciBodHRwcy5cbiAgICAvLyBGb3IgZW52aXJvbm1lbnRzIGxpa2UgQ29yZG92YSwgQ2hyb21lIGV4dGVuc2lvbnMsIG5hdGl2ZSBmcmFtZXdvcmtzLCBmaWxlXG4gICAgLy8gc3lzdGVtcywgZXRjLCB1c2UgaHR0cDovL2xvY2FsaG9zdCBhcyBjb250aW51ZSBVUkwuXG4gICAgY29uc3QgY29udGludWVVcmkgPSBfaXNIdHRwT3JIdHRwcygpID8gX2dldEN1cnJlbnRVcmwoKSA6ICdodHRwOi8vbG9jYWxob3N0JztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBpZGVudGlmaWVyOiBlbWFpbCxcbiAgICAgICAgY29udGludWVVcmlcbiAgICB9O1xuICAgIGNvbnN0IHsgc2lnbmluTWV0aG9kcyB9ID0gYXdhaXQgY3JlYXRlQXV0aFVyaShnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCksIHJlcXVlc3QpO1xuICAgIHJldHVybiBzaWduaW5NZXRob2RzIHx8IFtdO1xufVxuLyoqXG4gKiBTZW5kcyBhIHZlcmlmaWNhdGlvbiBlbWFpbCB0byBhIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBpcyBjb21wbGV0ZWQgYnkgY2FsbGluZyB7QGxpbmsgYXBwbHlBY3Rpb25Db2RlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCBzZW5kRW1haWxWZXJpZmljYXRpb24odXNlciwgYWN0aW9uQ29kZVNldHRpbmdzKTtcbiAqIC8vIE9idGFpbiBjb2RlIGZyb20gdGhlIHVzZXIuXG4gKiBhd2FpdCBhcHBseUFjdGlvbkNvZGUoYXV0aCwgY29kZSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICogQHBhcmFtIGFjdGlvbkNvZGVTZXR0aW5ncyAtIFRoZSB7QGxpbmsgQWN0aW9uQ29kZVNldHRpbmdzfS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlbmRFbWFpbFZlcmlmaWNhdGlvbih1c2VyLCBhY3Rpb25Db2RlU2V0dGluZ3MpIHtcbiAgICBjb25zdCB1c2VySW50ZXJuYWwgPSBnZXRNb2R1bGFySW5zdGFuY2UodXNlcik7XG4gICAgY29uc3QgaWRUb2tlbiA9IGF3YWl0IHVzZXIuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIHJlcXVlc3RUeXBlOiBcIlZFUklGWV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0VNQUlMICovLFxuICAgICAgICBpZFRva2VuXG4gICAgfTtcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZW1haWwgfSA9IGF3YWl0IHNlbmRFbWFpbFZlcmlmaWNhdGlvbiQxKHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0KTtcbiAgICBpZiAoZW1haWwgIT09IHVzZXIuZW1haWwpIHtcbiAgICAgICAgYXdhaXQgdXNlci5yZWxvYWQoKTtcbiAgICB9XG59XG4vKipcbiAqIFNlbmRzIGEgdmVyaWZpY2F0aW9uIGVtYWlsIHRvIGEgbmV3IGVtYWlsIGFkZHJlc3MuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSB1c2VyJ3MgZW1haWwgd2lsbCBiZSB1cGRhdGVkIHRvIHRoZSBuZXcgb25lIGFmdGVyIGJlaW5nIHZlcmlmaWVkLlxuICpcbiAqIElmIHlvdSBoYXZlIGEgY3VzdG9tIGVtYWlsIGFjdGlvbiBoYW5kbGVyLCB5b3UgY2FuIGNvbXBsZXRlIHRoZSB2ZXJpZmljYXRpb24gcHJvY2VzcyBieSBjYWxsaW5nXG4gKiB7QGxpbmsgYXBwbHlBY3Rpb25Db2RlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgYWN0aW9uQ29kZVNldHRpbmdzID0ge1xuICogICB1cmw6ICdodHRwczovL3d3dy5leGFtcGxlLmNvbS8/ZW1haWw9dXNlckBleGFtcGxlLmNvbScsXG4gKiAgIGlPUzoge1xuICogICAgICBidW5kbGVJZDogJ2NvbS5leGFtcGxlLmlvcydcbiAqICAgfSxcbiAqICAgYW5kcm9pZDoge1xuICogICAgIHBhY2thZ2VOYW1lOiAnY29tLmV4YW1wbGUuYW5kcm9pZCcsXG4gKiAgICAgaW5zdGFsbEFwcDogdHJ1ZSxcbiAqICAgICBtaW5pbXVtVmVyc2lvbjogJzEyJ1xuICogICB9LFxuICogICBoYW5kbGVDb2RlSW5BcHA6IHRydWVcbiAqIH07XG4gKiBhd2FpdCB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCh1c2VyLCAnbmV3ZW1haWxAZXhhbXBsZS5jb20nLCBhY3Rpb25Db2RlU2V0dGluZ3MpO1xuICogLy8gT2J0YWluIGNvZGUgZnJvbSB0aGUgdXNlci5cbiAqIGF3YWl0IGFwcGx5QWN0aW9uQ29kZShhdXRoLCBjb2RlKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MgdG8gYmUgdmVyaWZpZWQgYmVmb3JlIHVwZGF0ZS5cbiAqIEBwYXJhbSBhY3Rpb25Db2RlU2V0dGluZ3MgLSBUaGUge0BsaW5rIEFjdGlvbkNvZGVTZXR0aW5nc30uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCh1c2VyLCBuZXdFbWFpbCwgYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICByZXF1ZXN0VHlwZTogXCJWRVJJRllfQU5EX0NIQU5HRV9FTUFJTFwiIC8qIEFjdGlvbkNvZGVPcGVyYXRpb24uVkVSSUZZX0FORF9DSEFOR0VfRU1BSUwgKi8sXG4gICAgICAgIGlkVG9rZW4sXG4gICAgICAgIG5ld0VtYWlsXG4gICAgfTtcbiAgICBpZiAoYWN0aW9uQ29kZVNldHRpbmdzKSB7XG4gICAgICAgIF9zZXRBY3Rpb25Db2RlU2V0dGluZ3NPblJlcXVlc3QodXNlckludGVybmFsLmF1dGgsIHJlcXVlc3QsIGFjdGlvbkNvZGVTZXR0aW5ncyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZW1haWwgfSA9IGF3YWl0IHZlcmlmeUFuZENoYW5nZUVtYWlsKHVzZXJJbnRlcm5hbC5hdXRoLCByZXF1ZXN0KTtcbiAgICBpZiAoZW1haWwgIT09IHVzZXIuZW1haWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxvY2FsIGNvcHkgb2YgdGhlIGVtYWlsIG9uIHVzZXIgaXMgb3V0ZGF0ZWQsIHJlbG9hZCB0aGVcbiAgICAgICAgLy8gdXNlci5cbiAgICAgICAgYXdhaXQgdXNlci5yZWxvYWQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVQcm9maWxlJDEoYXV0aCwgcmVxdWVzdCkge1xuICAgIHJldHVybiBfcGVyZm9ybUFwaVJlcXVlc3QoYXV0aCwgXCJQT1NUXCIgLyogSHR0cE1ldGhvZC5QT1NUICovLCBcIi92MS9hY2NvdW50czp1cGRhdGVcIiAvKiBFbmRwb2ludC5TRVRfQUNDT1VOVF9JTkZPICovLCByZXF1ZXN0KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVXBkYXRlcyBhIHVzZXIncyBwcm9maWxlIGRhdGEuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBwcm9maWxlIC0gVGhlIHByb2ZpbGUncyBgZGlzcGxheU5hbWVgIGFuZCBgcGhvdG9VUkxgIHRvIHVwZGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGUodXNlciwgeyBkaXNwbGF5TmFtZSwgcGhvdG9VUkw6IHBob3RvVXJsIH0pIHtcbiAgICBpZiAoZGlzcGxheU5hbWUgPT09IHVuZGVmaW5lZCAmJiBwaG90b1VybCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdXNlckludGVybmFsID0gZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VySW50ZXJuYWwuZ2V0SWRUb2tlbigpO1xuICAgIGNvbnN0IHByb2ZpbGVSZXF1ZXN0ID0ge1xuICAgICAgICBpZFRva2VuLFxuICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgcGhvdG9VcmwsXG4gICAgICAgIHJldHVyblNlY3VyZVRva2VuOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHVzZXJJbnRlcm5hbCwgdXBkYXRlUHJvZmlsZSQxKHVzZXJJbnRlcm5hbC5hdXRoLCBwcm9maWxlUmVxdWVzdCkpO1xuICAgIHVzZXJJbnRlcm5hbC5kaXNwbGF5TmFtZSA9IHJlc3BvbnNlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgdXNlckludGVybmFsLnBob3RvVVJMID0gcmVzcG9uc2UucGhvdG9VcmwgfHwgbnVsbDtcbiAgICAvLyBVcGRhdGUgdGhlIHBhc3N3b3JkIHByb3ZpZGVyIGFzIHdlbGxcbiAgICBjb25zdCBwYXNzd29yZFByb3ZpZGVyID0gdXNlckludGVybmFsLnByb3ZpZGVyRGF0YS5maW5kKCh7IHByb3ZpZGVySWQgfSkgPT4gcHJvdmlkZXJJZCA9PT0gXCJwYXNzd29yZFwiIC8qIFByb3ZpZGVySWQuUEFTU1dPUkQgKi8pO1xuICAgIGlmIChwYXNzd29yZFByb3ZpZGVyKSB7XG4gICAgICAgIHBhc3N3b3JkUHJvdmlkZXIuZGlzcGxheU5hbWUgPSB1c2VySW50ZXJuYWwuZGlzcGxheU5hbWU7XG4gICAgICAgIHBhc3N3b3JkUHJvdmlkZXIucGhvdG9VUkwgPSB1c2VySW50ZXJuYWwucGhvdG9VUkw7XG4gICAgfVxuICAgIGF3YWl0IHVzZXJJbnRlcm5hbC5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkocmVzcG9uc2UpO1xufVxuLyoqXG4gKiBVcGRhdGVzIHRoZSB1c2VyJ3MgZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogQW4gZW1haWwgd2lsbCBiZSBzZW50IHRvIHRoZSBvcmlnaW5hbCBlbWFpbCBhZGRyZXNzIChpZiBpdCB3YXMgc2V0KSB0aGF0IGFsbG93cyB0byByZXZva2UgdGhlXG4gKiBlbWFpbCBhZGRyZXNzIGNoYW5nZSwgaW4gb3JkZXIgdG8gcHJvdGVjdCB0aGVtIGZyb20gYWNjb3VudCBoaWphY2tpbmcuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBvbiBhbnkge0BsaW5rIFVzZXJ9IHNpZ25lZCBpbiBieSB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzXG4gKiBjcmVhdGVkIHdpdGggYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogSW1wb3J0YW50OiB0aGlzIGlzIGEgc2VjdXJpdHkgc2Vuc2l0aXZlIG9wZXJhdGlvbiB0aGF0IHJlcXVpcmVzIHRoZSB1c2VyIHRvIGhhdmUgcmVjZW50bHkgc2lnbmVkXG4gKiBpbi4gSWYgdGhpcyByZXF1aXJlbWVudCBpc24ndCBtZXQsIGFzayB0aGUgdXNlciB0byBhdXRoZW50aWNhdGUgYWdhaW4gYW5kIHRoZW4gY2FsbFxuICoge0BsaW5rIHJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWx9LlxuICpcbiAqIEBwYXJhbSB1c2VyIC0gVGhlIHVzZXIuXG4gKiBAcGFyYW0gbmV3RW1haWwgLSBUaGUgbmV3IGVtYWlsIGFkZHJlc3MuXG4gKlxuICogVGhyb3dzIFwiYXV0aC9vcGVyYXRpb24tbm90LWFsbG93ZWRcIiBlcnJvciB3aGVuXG4gKiB7QGxpbmsgaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL2lkZW50aXR5LXBsYXRmb3JtL2RvY3MvYWRtaW4vZW1haWwtZW51bWVyYXRpb24tcHJvdGVjdGlvbiB8IEVtYWlsIEVudW1lcmF0aW9uIFByb3RlY3Rpb259XG4gKiBpcyBlbmFibGVkLlxuICogRGVwcmVjYXRlZCAtIFVzZSB7QGxpbmsgdmVyaWZ5QmVmb3JlVXBkYXRlRW1haWx9IGluc3RlYWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1cGRhdGVFbWFpbCh1c2VyLCBuZXdFbWFpbCkge1xuICAgIGNvbnN0IHVzZXJJbnRlcm5hbCA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBpZiAoX2lzRmlyZWJhc2VTZXJ2ZXJBcHAodXNlckludGVybmFsLmF1dGguYXBwKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IodXNlckludGVybmFsLmF1dGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZUVtYWlsT3JQYXNzd29yZCh1c2VySW50ZXJuYWwsIG5ld0VtYWlsLCBudWxsKTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgdXNlcidzIHBhc3N3b3JkLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJbXBvcnRhbnQ6IHRoaXMgaXMgYSBzZWN1cml0eSBzZW5zaXRpdmUgb3BlcmF0aW9uIHRoYXQgcmVxdWlyZXMgdGhlIHVzZXIgdG8gaGF2ZSByZWNlbnRseSBzaWduZWRcbiAqIGluLiBJZiB0aGlzIHJlcXVpcmVtZW50IGlzbid0IG1ldCwgYXNrIHRoZSB1c2VyIHRvIGF1dGhlbnRpY2F0ZSBhZ2FpbiBhbmQgdGhlbiBjYWxsXG4gKiB7QGxpbmsgcmVhdXRoZW50aWNhdGVXaXRoQ3JlZGVudGlhbH0uXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqIEBwYXJhbSBuZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1cGRhdGVQYXNzd29yZCh1c2VyLCBuZXdQYXNzd29yZCkge1xuICAgIHJldHVybiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQoZ2V0TW9kdWxhckluc3RhbmNlKHVzZXIpLCBudWxsLCBuZXdQYXNzd29yZCk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGRhdGVFbWFpbE9yUGFzc3dvcmQodXNlciwgZW1haWwsIHBhc3N3b3JkKSB7XG4gICAgY29uc3QgeyBhdXRoIH0gPSB1c2VyO1xuICAgIGNvbnN0IGlkVG9rZW4gPSBhd2FpdCB1c2VyLmdldElkVG9rZW4oKTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBpZFRva2VuLFxuICAgICAgICByZXR1cm5TZWN1cmVUb2tlbjogdHJ1ZVxuICAgIH07XG4gICAgaWYgKGVtYWlsKSB7XG4gICAgICAgIHJlcXVlc3QuZW1haWwgPSBlbWFpbDtcbiAgICB9XG4gICAgaWYgKHBhc3N3b3JkKSB7XG4gICAgICAgIHJlcXVlc3QucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfbG9nb3V0SWZJbnZhbGlkYXRlZCh1c2VyLCB1cGRhdGVFbWFpbFBhc3N3b3JkKGF1dGgsIHJlcXVlc3QpKTtcbiAgICBhd2FpdCB1c2VyLl91cGRhdGVUb2tlbnNJZk5lY2Vzc2FyeShyZXNwb25zZSwgLyogcmVsb2FkICovIHRydWUpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQYXJzZSB0aGUgYEFkZGl0aW9uYWxVc2VySW5mb2AgZnJvbSB0aGUgSUQgdG9rZW4gcmVzcG9uc2UuXG4gKlxuICovXG5mdW5jdGlvbiBfZnJvbUlkVG9rZW5SZXNwb25zZShpZFRva2VuUmVzcG9uc2UpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghaWRUb2tlblJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHByb3ZpZGVySWQgfSA9IGlkVG9rZW5SZXNwb25zZTtcbiAgICBjb25zdCBwcm9maWxlID0gaWRUb2tlblJlc3BvbnNlLnJhd1VzZXJJbmZvXG4gICAgICAgID8gSlNPTi5wYXJzZShpZFRva2VuUmVzcG9uc2UucmF3VXNlckluZm8pXG4gICAgICAgIDoge307XG4gICAgY29uc3QgaXNOZXdVc2VyID0gaWRUb2tlblJlc3BvbnNlLmlzTmV3VXNlciB8fFxuICAgICAgICBpZFRva2VuUmVzcG9uc2Uua2luZCA9PT0gXCJpZGVudGl0eXRvb2xraXQjU2lnbnVwTmV3VXNlclJlc3BvbnNlXCIgLyogSWRUb2tlblJlc3BvbnNlS2luZC5TaWdudXBOZXdVc2VyICovO1xuICAgIGlmICghcHJvdmlkZXJJZCAmJiAoaWRUb2tlblJlc3BvbnNlID09PSBudWxsIHx8IGlkVG9rZW5SZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaWRUb2tlblJlc3BvbnNlLmlkVG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IHNpZ25JblByb3ZpZGVyID0gKF9iID0gKF9hID0gX3BhcnNlVG9rZW4oaWRUb2tlblJlc3BvbnNlLmlkVG9rZW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlyZWJhc2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsnc2lnbl9pbl9wcm92aWRlciddO1xuICAgICAgICBpZiAoc2lnbkluUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkUHJvdmlkZXJJZCA9IHNpZ25JblByb3ZpZGVyICE9PSBcImFub255bW91c1wiIC8qIFByb3ZpZGVySWQuQU5PTllNT1VTICovICYmXG4gICAgICAgICAgICAgICAgc2lnbkluUHJvdmlkZXIgIT09IFwiY3VzdG9tXCIgLyogUHJvdmlkZXJJZC5DVVNUT00gKi9cbiAgICAgICAgICAgICAgICA/IHNpZ25JblByb3ZpZGVyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgLy8gVXNlcyBnZW5lcmljIGNsYXNzIGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgbGVnYWN5IFNESy5cbiAgICAgICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0FkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIGZpbHRlcmVkUHJvdmlkZXJJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwcm92aWRlcklkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKHByb3ZpZGVySWQpIHtcbiAgICAgICAgY2FzZSBcImZhY2Vib29rLmNvbVwiIC8qIFByb3ZpZGVySWQuRkFDRUJPT0sgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZhY2Vib29rQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSk7XG4gICAgICAgIGNhc2UgXCJnaXRodWIuY29tXCIgLyogUHJvdmlkZXJJZC5HSVRIVUIgKi86XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdpdGh1YkFkZGl0aW9uYWxVc2VySW5mbyhpc05ld1VzZXIsIHByb2ZpbGUpO1xuICAgICAgICBjYXNlIFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHb29nbGVBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm9maWxlKTtcbiAgICAgICAgY2FzZSBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUd2l0dGVyQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgcHJvZmlsZSwgaWRUb2tlblJlc3BvbnNlLnNjcmVlbk5hbWUgfHwgbnVsbCk7XG4gICAgICAgIGNhc2UgXCJjdXN0b21cIiAvKiBQcm92aWRlcklkLkNVU1RPTSAqLzpcbiAgICAgICAgY2FzZSBcImFub255bW91c1wiIC8qIFByb3ZpZGVySWQuQU5PTllNT1VTICovOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvKGlzTmV3VXNlciwgbnVsbCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8oaXNOZXdVc2VyLCBwcm92aWRlcklkLCBwcm9maWxlKTtcbiAgICB9XG59XG5jbGFzcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUgPSB7fSkge1xuICAgICAgICB0aGlzLmlzTmV3VXNlciA9IGlzTmV3VXNlcjtcbiAgICAgICAgdGhpcy5wcm92aWRlcklkID0gcHJvdmlkZXJJZDtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gcHJvZmlsZTtcbiAgICB9XG59XG5jbGFzcyBGZWRlcmF0ZWRBZGRpdGlvbmFsVXNlckluZm9XaXRoVXNlcm5hbWUgZXh0ZW5kcyBHZW5lcmljQWRkaXRpb25hbFVzZXJJbmZvIHtcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb3ZpZGVySWQsIHByb2ZpbGUsIHVzZXJuYW1lKSB7XG4gICAgICAgIHN1cGVyKGlzTmV3VXNlciwgcHJvdmlkZXJJZCwgcHJvZmlsZSk7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICB9XG59XG5jbGFzcyBGYWNlYm9va0FkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZmFjZWJvb2suY29tXCIgLyogUHJvdmlkZXJJZC5GQUNFQk9PSyAqLywgcHJvZmlsZSk7XG4gICAgfVxufVxuY2xhc3MgR2l0aHViQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUpIHtcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcImdpdGh1Yi5jb21cIiAvKiBQcm92aWRlcklkLkdJVEhVQiAqLywgcHJvZmlsZSwgdHlwZW9mIChwcm9maWxlID09PSBudWxsIHx8IHByb2ZpbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2ZpbGUubG9naW4pID09PSAnc3RyaW5nJyA/IHByb2ZpbGUgPT09IG51bGwgfHwgcHJvZmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZmlsZS5sb2dpbiA6IG51bGwpO1xuICAgIH1cbn1cbmNsYXNzIEdvb2dsZUFkZGl0aW9uYWxVc2VySW5mbyBleHRlbmRzIEdlbmVyaWNBZGRpdGlvbmFsVXNlckluZm8ge1xuICAgIGNvbnN0cnVjdG9yKGlzTmV3VXNlciwgcHJvZmlsZSkge1xuICAgICAgICBzdXBlcihpc05ld1VzZXIsIFwiZ29vZ2xlLmNvbVwiIC8qIFByb3ZpZGVySWQuR09PR0xFICovLCBwcm9maWxlKTtcbiAgICB9XG59XG5jbGFzcyBUd2l0dGVyQWRkaXRpb25hbFVzZXJJbmZvIGV4dGVuZHMgRmVkZXJhdGVkQWRkaXRpb25hbFVzZXJJbmZvV2l0aFVzZXJuYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcihpc05ld1VzZXIsIHByb2ZpbGUsIHNjcmVlbk5hbWUpIHtcbiAgICAgICAgc3VwZXIoaXNOZXdVc2VyLCBcInR3aXR0ZXIuY29tXCIgLyogUHJvdmlkZXJJZC5UV0lUVEVSICovLCBwcm9maWxlLCBzY3JlZW5OYW1lKTtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHByb3ZpZGVyIHNwZWNpZmljIHtAbGluayBBZGRpdGlvbmFsVXNlckluZm99IGZvciB0aGUgZ2l2ZW4gY3JlZGVudGlhbC5cbiAqXG4gKiBAcGFyYW0gdXNlckNyZWRlbnRpYWwgLSBUaGUgdXNlciBjcmVkZW50aWFsLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZ2V0QWRkaXRpb25hbFVzZXJJbmZvKHVzZXJDcmVkZW50aWFsKSB7XG4gICAgY29uc3QgeyB1c2VyLCBfdG9rZW5SZXNwb25zZSB9ID0gdXNlckNyZWRlbnRpYWw7XG4gICAgaWYgKHVzZXIuaXNBbm9ueW1vdXMgJiYgIV90b2tlblJlc3BvbnNlKSB7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIHNpZ25JbkFub255bW91c2x5KCkgZ2V0cyBjYWxsZWQgdHdpY2UuXG4gICAgICAgIC8vIE5vIG5ldHdvcmsgY2FsbCBpcyBtYWRlIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBhY3R1YWxseSBmaWxsIHRoaXMgaW5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3ZpZGVySWQ6IG51bGwsXG4gICAgICAgICAgICBpc05ld1VzZXI6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZmlsZTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX2Zyb21JZFRva2VuUmVzcG9uc2UoX3Rva2VuUmVzcG9uc2UpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLy8gTm9uLW9wdGlvbmFsIGF1dGggbWV0aG9kcy5cbi8qKlxuICogQ2hhbmdlcyB0aGUgdHlwZSBvZiBwZXJzaXN0ZW5jZSBvbiB0aGUge0BsaW5rIEF1dGh9IGluc3RhbmNlIGZvciB0aGUgY3VycmVudGx5IHNhdmVkXG4gKiBgQXV0aGAgc2Vzc2lvbiBhbmQgYXBwbGllcyB0aGlzIHR5cGUgb2YgcGVyc2lzdGVuY2UgZm9yIGZ1dHVyZSBzaWduLWluIHJlcXVlc3RzLCBpbmNsdWRpbmdcbiAqIHNpZ24taW4gd2l0aCByZWRpcmVjdCByZXF1ZXN0cy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBtYWtlcyBpdCBlYXN5IGZvciBhIHVzZXIgc2lnbmluZyBpbiB0byBzcGVjaWZ5IHdoZXRoZXIgdGhlaXIgc2Vzc2lvbiBzaG91bGQgYmVcbiAqIHJlbWVtYmVyZWQgb3Igbm90LiBJdCBhbHNvIG1ha2VzIGl0IGVhc2llciB0byBuZXZlciBwZXJzaXN0IHRoZSBgQXV0aGAgc3RhdGUgZm9yIGFwcGxpY2F0aW9uc1xuICogdGhhdCBhcmUgc2hhcmVkIGJ5IG90aGVyIHVzZXJzIG9yIGhhdmUgc2Vuc2l0aXZlIGRhdGEuXG4gKlxuICogVGhpcyBtZXRob2QgZG9lcyBub3Qgd29yayBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQgb3Igd2l0aCB7QGxpbmsgQXV0aH0gaW5zdGFuY2VzIGNyZWF0ZWQgd2l0aCBhXG4gKiB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZVNlcnZlckFwcH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHNldFBlcnNpc3RlbmNlKGF1dGgsIGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHBlcnNpc3RlbmNlIC0gVGhlIHtAbGluayBQZXJzaXN0ZW5jZX0gdG8gdXNlLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBwZXJzaXN0ZW5jZSBjaGFuZ2UgaGFzIGNvbXBsZXRlZFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0UGVyc2lzdGVuY2UoYXV0aCwgcGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnNldFBlcnNpc3RlbmNlKHBlcnNpc3RlbmNlKTtcbn1cbi8qKlxuICogTG9hZHMgdGhlIHJlQ0FQVENIQSBjb25maWd1cmF0aW9uIGludG8gdGhlIGBBdXRoYCBpbnN0YW5jZS5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyB3aWxsIGxvYWQgdGhlIHJlQ0FQVENIQSBjb25maWcsIHdoaWNoIGluZGljYXRlcyB3aGV0aGVyIHRoZSByZUNBUFRDSEFcbiAqIHZlcmlmaWNhdGlvbiBmbG93IHNob3VsZCBiZSB0cmlnZ2VyZWQgZm9yIGVhY2ggYXV0aCBwcm92aWRlciwgaW50byB0aGVcbiAqIGN1cnJlbnQgQXV0aCBzZXNzaW9uLlxuICpcbiAqIElmIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoKSBpcyBub3QgaW52b2tlZCwgdGhlIGF1dGggZmxvdyB3aWxsIGFsd2F5cyBzdGFydFxuICogd2l0aG91dCByZUNBUFRDSEEgdmVyaWZpY2F0aW9uLiBJZiB0aGUgcHJvdmlkZXIgaXMgY29uZmlndXJlZCB0byByZXF1aXJlIHJlQ0FQVENIQVxuICogdmVyaWZpY2F0aW9uLCB0aGUgU0RLIHdpbGwgdHJhbnNwYXJlbnRseSBsb2FkIHRoZSByZUNBUFRDSEEgY29uZmlnIGFuZCByZXN0YXJ0IHRoZVxuICogYXV0aCBmbG93cy5cbiAqXG4gKiBUaHVzLCBieSBjYWxsaW5nIHRoaXMgb3B0aW9uYWwgbWV0aG9kLCB5b3Ugd2lsbCByZWR1Y2UgdGhlIGxhdGVuY3kgb2YgZnV0dXJlIGF1dGggZmxvd3MuXG4gKiBMb2FkaW5nIHRoZSByZUNBUFRDSEEgY29uZmlnIGVhcmx5IHdpbGwgYWxzbyBlbmhhbmNlIHRoZSBzaWduYWwgY29sbGVjdGVkIGJ5IHJlQ0FQVENIQS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgamF2YXNjcmlwdFxuICogaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyhhdXRoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVSZWNhcHRjaGFDb25maWcoYXV0aCkge1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyhhdXRoKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBwYXNzd29yZCBhZ2FpbnN0IHRoZSBwYXNzd29yZCBwb2xpY3kgY29uZmlndXJlZCBmb3IgdGhlIHByb2plY3Qgb3IgdGVuYW50LlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiBubyB0ZW5hbnQgSUQgaXMgc2V0IG9uIHRoZSBgQXV0aGAgaW5zdGFuY2UsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlIHBhc3N3b3JkXG4gKiBwb2xpY3kgY29uZmlndXJlZCBmb3IgdGhlIHByb2plY3QuIE90aGVyd2lzZSwgdGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlIHBvbGljeSBjb25maWd1cmVkXG4gKiBmb3IgdGhlIHRlbmFudC4gSWYgYSBwYXNzd29yZCBwb2xpY3kgaGFzIG5vdCBiZWVuIGNvbmZpZ3VyZWQsIHRoZW4gdGhlIGRlZmF1bHQgcG9saWN5XG4gKiBjb25maWd1cmVkIGZvciBhbGwgcHJvamVjdHMgd2lsbCBiZSB1c2VkLlxuICpcbiAqIElmIGFuIGF1dGggZmxvdyBmYWlscyBiZWNhdXNlIGEgc3VibWl0dGVkIHBhc3N3b3JkIGRvZXMgbm90IG1lZXQgdGhlIHBhc3N3b3JkIHBvbGljeVxuICogcmVxdWlyZW1lbnRzIGFuZCB0aGlzIG1ldGhvZCBoYXMgcHJldmlvdXNseSBiZWVuIGNhbGxlZCwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGVcbiAqIG1vc3QgcmVjZW50IHBvbGljeSBhdmFpbGFibGUgd2hlbiBjYWxsZWQgYWdhaW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhbGlkYXRlUGFzc3dvcmQoYXV0aCwgJ3NvbWUtcGFzc3dvcmQnKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRoIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIHZhbGlkYXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVQYXNzd29yZChhdXRoLCBwYXNzd29yZCkge1xuICAgIGNvbnN0IGF1dGhJbnRlcm5hbCA9IF9jYXN0QXV0aChhdXRoKTtcbiAgICByZXR1cm4gYXV0aEludGVybmFsLnZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpO1xufVxuLyoqXG4gKiBBZGRzIGFuIG9ic2VydmVyIGZvciBjaGFuZ2VzIHRvIHRoZSBzaWduZWQtaW4gdXNlcidzIElEIHRva2VuLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIGluY2x1ZGVzIHNpZ24taW4sIHNpZ24tb3V0LCBhbmQgdG9rZW4gcmVmcmVzaCBldmVudHMuXG4gKiBUaGlzIHdpbGwgbm90IGJlIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IHVwb24gSUQgdG9rZW4gZXhwaXJhdGlvbi4gVXNlIHtAbGluayBVc2VyLmdldElkVG9rZW59IHRvIHJlZnJlc2ggdGhlIElEIHRva2VuLlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBuZXh0T3JPYnNlcnZlciAtIGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBjaGFuZ2UuXG4gKiBAcGFyYW0gZXJyb3IgLSBEZXByZWNhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5ldmVyIHRyaWdnZXJlZC4gRXJyb3JzXG4gKiBvbiBzaWduaW5nIGluL291dCBjYW4gYmUgY2F1Z2h0IGluIHByb21pc2VzIHJldHVybmVkIGZyb21cbiAqIHNpZ24taW4vc2lnbi1vdXQgZnVuY3Rpb25zLlxuICogQHBhcmFtIGNvbXBsZXRlZCAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gb25JZFRva2VuQ2hhbmdlZChhdXRoLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkub25JZFRva2VuQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG59XG4vKipcbiAqIEFkZHMgYSBibG9ja2luZyBjYWxsYmFjayB0aGF0IHJ1bnMgYmVmb3JlIGFuIGF1dGggc3RhdGUgY2hhbmdlXG4gKiBzZXRzIGEgbmV3IHVzZXIuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIGJlZm9yZSBuZXcgdXNlciB2YWx1ZSBpcyBzZXQuXG4gKiAgIElmIHRoaXMgdGhyb3dzLCBpdCBibG9ja3MgdGhlIHVzZXIgZnJvbSBiZWluZyBzZXQuXG4gKiBAcGFyYW0gb25BYm9ydCAtIGNhbGxiYWNrIHRyaWdnZXJlZCBpZiBhIGxhdGVyIGBiZWZvcmVBdXRoU3RhdGVDaGFuZ2VkKClgXG4gKiAgIGNhbGxiYWNrIHRocm93cywgYWxsb3dpbmcgeW91IHRvIHVuZG8gYW55IHNpZGUgZWZmZWN0cy5cbiAqL1xuZnVuY3Rpb24gYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChhdXRoLCBjYWxsYmFjaywgb25BYm9ydCkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZChjYWxsYmFjaywgb25BYm9ydCk7XG59XG4vKipcbiAqIEFkZHMgYW4gb2JzZXJ2ZXIgZm9yIGNoYW5nZXMgdG8gdGhlIHVzZXIncyBzaWduLWluIHN0YXRlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUbyBrZWVwIHRoZSBvbGQgYmVoYXZpb3IsIHNlZSB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0uXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIG5leHRPck9ic2VydmVyIC0gY2FsbGJhY2sgdHJpZ2dlcmVkIG9uIGNoYW5nZS5cbiAqIEBwYXJhbSBlcnJvciAtIERlcHJlY2F0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbmV2ZXIgdHJpZ2dlcmVkLiBFcnJvcnNcbiAqIG9uIHNpZ25pbmcgaW4vb3V0IGNhbiBiZSBjYXVnaHQgaW4gcHJvbWlzZXMgcmV0dXJuZWQgZnJvbVxuICogc2lnbi1pbi9zaWduLW91dCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gY29tcGxldGVkIC0gRGVwcmVjYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBuZXZlciB0cmlnZ2VyZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvbkF1dGhTdGF0ZUNoYW5nZWQoYXV0aCwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZWQpIHtcbiAgICByZXR1cm4gZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLm9uQXV0aFN0YXRlQ2hhbmdlZChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlZCk7XG59XG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UgdG8gdGhlIGRlZmF1bHQgZGV2aWNlL2Jyb3dzZXIgcHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gYXV0aCAtIFRoZSB7QGxpbmsgQXV0aH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VEZXZpY2VMYW5ndWFnZShhdXRoKSB7XG4gICAgZ2V0TW9kdWxhckluc3RhbmNlKGF1dGgpLnVzZURldmljZUxhbmd1YWdlKCk7XG59XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNldHMgdGhlIHByb3ZpZGVkIHVzZXIgYXMge0BsaW5rIEF1dGguY3VycmVudFVzZXJ9IG9uIHRoZVxuICoge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBBIG5ldyBpbnN0YW5jZSBjb3B5IG9mIHRoZSB1c2VyIHByb3ZpZGVkIHdpbGwgYmUgbWFkZSBhbmQgc2V0IGFzIGN1cnJlbnRVc2VyLlxuICpcbiAqIFRoaXMgd2lsbCB0cmlnZ2VyIHtAbGluayBvbkF1dGhTdGF0ZUNoYW5nZWR9IGFuZCB7QGxpbmsgb25JZFRva2VuQ2hhbmdlZH0gbGlzdGVuZXJzXG4gKiBsaWtlIG90aGVyIHNpZ24gaW4gbWV0aG9kcy5cbiAqXG4gKiBUaGUgb3BlcmF0aW9uIGZhaWxzIHdpdGggYW4gZXJyb3IgaWYgdGhlIHVzZXIgdG8gYmUgdXBkYXRlZCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IEZpcmViYXNlXG4gKiBwcm9qZWN0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB1c2VyIC0gVGhlIG5ldyB7QGxpbmsgVXNlcn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50VXNlcihhdXRoLCB1c2VyKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZShhdXRoKS51cGRhdGVDdXJyZW50VXNlcih1c2VyKTtcbn1cbi8qKlxuICogU2lnbnMgb3V0IHRoZSBjdXJyZW50IHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkge0BsaW5rIEF1dGh9IGluc3RhbmNlcyBjcmVhdGVkIHdpdGggYVxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VTZXJ2ZXJBcHB9LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNpZ25PdXQoYXV0aCkge1xuICAgIHJldHVybiBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCkuc2lnbk91dCgpO1xufVxuLyoqXG4gKiBSZXZva2VzIHRoZSBnaXZlbiBhY2Nlc3MgdG9rZW4uIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbnMuXG4gKlxuICogQHBhcmFtIGF1dGggLSBUaGUge0BsaW5rIEF1dGh9IGluc3RhbmNlLlxuICogQHBhcmFtIHRva2VuIC0gVGhlIEFwcGxlIE9BdXRoIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJldm9rZUFjY2Vzc1Rva2VuKGF1dGgsIHRva2VuKSB7XG4gICAgY29uc3QgYXV0aEludGVybmFsID0gX2Nhc3RBdXRoKGF1dGgpO1xuICAgIHJldHVybiBhdXRoSW50ZXJuYWwucmV2b2tlQWNjZXNzVG9rZW4odG9rZW4pO1xufVxuLyoqXG4gKiBEZWxldGVzIGFuZCBzaWducyBvdXQgdGhlIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIEltcG9ydGFudDogdGhpcyBpcyBhIHNlY3VyaXR5LXNlbnNpdGl2ZSBvcGVyYXRpb24gdGhhdCByZXF1aXJlcyB0aGUgdXNlciB0byBoYXZlIHJlY2VudGx5XG4gKiBzaWduZWQgaW4uIElmIHRoaXMgcmVxdWlyZW1lbnQgaXNuJ3QgbWV0LCBhc2sgdGhlIHVzZXIgdG8gYXV0aGVudGljYXRlIGFnYWluIGFuZCB0aGVuIGNhbGxcbiAqIHtAbGluayByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsfS5cbiAqXG4gKiBAcGFyYW0gdXNlciAtIFRoZSB1c2VyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlVXNlcih1c2VyKSB7XG4gICAgcmV0dXJuIGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKS5kZWxldGUoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNyZWRlbnRpYWwsIHVzZXIpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFsID0gY3JlZGVudGlhbDtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tSWR0b2tlbihpZFRva2VuLCB1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JTZXNzaW9uSW1wbChcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovLCBpZFRva2VuLCB1c2VyKTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tTWZhUGVuZGluZ0NyZWRlbnRpYWwobWZhUGVuZGluZ0NyZWRlbnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclNlc3Npb25JbXBsKFwic2lnbmluXCIgLyogTXVsdGlGYWN0b3JTZXNzaW9uVHlwZS5TSUdOX0lOICovLCBtZmFQZW5kaW5nQ3JlZGVudGlhbCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy50eXBlID09PSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovXG4gICAgICAgICAgICA/ICdpZFRva2VuJ1xuICAgICAgICAgICAgOiAncGVuZGluZ0NyZWRlbnRpYWwnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXVsdGlGYWN0b3JTZXNzaW9uOiB7XG4gICAgICAgICAgICAgICAgW2tleV06IHRoaXMuY3JlZGVudGlhbFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUpTT04ob2JqKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmoubXVsdGlGYWN0b3JTZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAoKF9hID0gb2JqLm11bHRpRmFjdG9yU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlbmRpbmdDcmVkZW50aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChvYmoubXVsdGlGYWN0b3JTZXNzaW9uLnBlbmRpbmdDcmVkZW50aWFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IG9iai5tdWx0aUZhY3RvclNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21JZHRva2VuKG9iai5tdWx0aUZhY3RvclNlc3Npb24uaWRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb24sIGhpbnRzLCBzaWduSW5SZXNvbHZlcikge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmhpbnRzID0gaGludHM7XG4gICAgICAgIHRoaXMuc2lnbkluUmVzb2x2ZXIgPSBzaWduSW5SZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbUVycm9yKGF1dGhFeHRlcm4sIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGF1dGggPSBfY2FzdEF1dGgoYXV0aEV4dGVybik7XG4gICAgICAgIGNvbnN0IHNlcnZlclJlc3BvbnNlID0gZXJyb3IuY3VzdG9tRGF0YS5fc2VydmVyUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IGhpbnRzID0gKHNlcnZlclJlc3BvbnNlLm1mYUluZm8gfHwgW10pLm1hcChlbnJvbGxtZW50ID0+IE11bHRpRmFjdG9ySW5mb0ltcGwuX2Zyb21TZXJ2ZXJSZXNwb25zZShhdXRoLCBlbnJvbGxtZW50KSk7XG4gICAgICAgIF9hc3NlcnQoc2VydmVyUmVzcG9uc2UubWZhUGVuZGluZ0NyZWRlbnRpYWwsIGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IE11bHRpRmFjdG9yU2Vzc2lvbkltcGwuX2Zyb21NZmFQZW5kaW5nQ3JlZGVudGlhbChzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbCk7XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlGYWN0b3JSZXNvbHZlckltcGwoc2Vzc2lvbiwgaGludHMsIGFzeW5jIChhc3NlcnRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1mYVJlc3BvbnNlID0gYXdhaXQgYXNzZXJ0aW9uLl9wcm9jZXNzKGF1dGgsIHNlc3Npb24pO1xuICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSB1bm5lZWRlZCBmaWVsZHMgZnJvbSB0aGUgb2xkIGxvZ2luIHJlc3BvbnNlXG4gICAgICAgICAgICBkZWxldGUgc2VydmVyUmVzcG9uc2UubWZhSW5mbztcbiAgICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXJSZXNwb25zZS5tZmFQZW5kaW5nQ3JlZGVudGlhbDtcbiAgICAgICAgICAgIC8vIFVzZSBpbiB0aGUgbmV3IHRva2VuICYgcmVmcmVzaCB0b2tlbiBpbiB0aGUgb2xkIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBpZFRva2VuUmVzcG9uc2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNlcnZlclJlc3BvbnNlKSwgeyBpZFRva2VuOiBtZmFSZXNwb25zZS5pZFRva2VuLCByZWZyZXNoVG9rZW46IG1mYVJlc3BvbnNlLnJlZnJlc2hUb2tlbiB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBjb2xsYXBzZSB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbiBhbmQgaGF2ZSBpdCBzdXBwb3J0IHRoZSBTSUdOX0lOIGNhc2VcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyb3Iub3BlcmF0aW9uVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzaWduSW5cIiAvKiBPcGVyYXRpb25UeXBlLlNJR05fSU4gKi86XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJDcmVkZW50aWFsID0gYXdhaXQgVXNlckNyZWRlbnRpYWxJbXBsLl9mcm9tSWRUb2tlblJlc3BvbnNlKGF1dGgsIGVycm9yLm9wZXJhdGlvblR5cGUsIGlkVG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGF1dGguX3VwZGF0ZUN1cnJlbnRVc2VyKHVzZXJDcmVkZW50aWFsLnVzZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXNlckNyZWRlbnRpYWw7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlYXV0aGVudGljYXRlXCIgLyogT3BlcmF0aW9uVHlwZS5SRUFVVEhFTlRJQ0FURSAqLzpcbiAgICAgICAgICAgICAgICAgICAgX2Fzc2VydChlcnJvci51c2VyLCBhdXRoLCBcImludGVybmFsLWVycm9yXCIgLyogQXV0aEVycm9yQ29kZS5JTlRFUk5BTF9FUlJPUiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVc2VyQ3JlZGVudGlhbEltcGwuX2Zvck9wZXJhdGlvbihlcnJvci51c2VyLCBlcnJvci5vcGVyYXRpb25UeXBlLCBpZFRva2VuUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF9mYWlsKGF1dGgsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVTaWduSW4oYXNzZXJ0aW9uRXh0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGFzc2VydGlvbiA9IGFzc2VydGlvbkV4dGVybjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkluUmVzb2x2ZXIoYXNzZXJ0aW9uKTtcbiAgICB9XG59XG4vKipcbiAqIFByb3ZpZGVzIGEge0BsaW5rIE11bHRpRmFjdG9yUmVzb2x2ZXJ9IHN1aXRhYmxlIGZvciBjb21wbGV0aW9uIG9mIGFcbiAqIG11bHRpLWZhY3RvciBmbG93LlxuICpcbiAqIEBwYXJhbSBhdXRoIC0gVGhlIHtAbGluayBBdXRofSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBlcnJvciAtIFRoZSB7QGxpbmsgTXVsdGlGYWN0b3JFcnJvcn0gcmFpc2VkIGR1cmluZyBhIHNpZ24taW4sIG9yXG4gKiByZWF1dGhlbnRpY2F0aW9uIG9wZXJhdGlvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIoYXV0aCwgZXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXV0aE1vZHVsYXIgPSBnZXRNb2R1bGFySW5zdGFuY2UoYXV0aCk7XG4gICAgY29uc3QgZXJyb3JJbnRlcm5hbCA9IGVycm9yO1xuICAgIF9hc3NlcnQoZXJyb3IuY3VzdG9tRGF0YS5vcGVyYXRpb25UeXBlLCBhdXRoTW9kdWxhciwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgIF9hc3NlcnQoKF9hID0gZXJyb3JJbnRlcm5hbC5jdXN0b21EYXRhLl9zZXJ2ZXJSZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1mYVBlbmRpbmdDcmVkZW50aWFsLCBhdXRoTW9kdWxhciwgXCJhcmd1bWVudC1lcnJvclwiIC8qIEF1dGhFcnJvckNvZGUuQVJHVU1FTlRfRVJST1IgKi8pO1xuICAgIHJldHVybiBNdWx0aUZhY3RvclJlc29sdmVySW1wbC5fZnJvbUVycm9yKGF1dGhNb2R1bGFyLCBlcnJvckludGVybmFsKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0RW5yb2xsVG90cE1mYShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6c3RhcnRcIiAvKiBFbmRwb2ludC5TVEFSVF9NRkFfRU5ST0xMTUVOVCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplRW5yb2xsVG90cE1mYShhdXRoLCByZXF1ZXN0KSB7XG4gICAgcmV0dXJuIF9wZXJmb3JtQXBpUmVxdWVzdChhdXRoLCBcIlBPU1RcIiAvKiBIdHRwTWV0aG9kLlBPU1QgKi8sIFwiL3YyL2FjY291bnRzL21mYUVucm9sbG1lbnQ6ZmluYWxpemVcIiAvKiBFbmRwb2ludC5GSU5BTElaRV9NRkFfRU5ST0xMTUVOVCAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cbmZ1bmN0aW9uIHdpdGhkcmF3TWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhRW5yb2xsbWVudDp3aXRoZHJhd1wiIC8qIEVuZHBvaW50LldJVEhEUkFXX01GQSAqLywgX2FkZFRpZElmTmVjZXNzYXJ5KGF1dGgsIHJlcXVlc3QpKTtcbn1cblxuY2xhc3MgTXVsdGlGYWN0b3JVc2VySW1wbCB7XG4gICAgY29uc3RydWN0b3IodXNlcikge1xuICAgICAgICB0aGlzLnVzZXIgPSB1c2VyO1xuICAgICAgICB0aGlzLmVucm9sbGVkRmFjdG9ycyA9IFtdO1xuICAgICAgICB1c2VyLl9vblJlbG9hZCh1c2VySW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAodXNlckluZm8ubWZhSW5mbykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5yb2xsZWRGYWN0b3JzID0gdXNlckluZm8ubWZhSW5mby5tYXAoZW5yb2xsbWVudCA9PiBNdWx0aUZhY3RvckluZm9JbXBsLl9mcm9tU2VydmVyUmVzcG9uc2UodXNlci5hdXRoLCBlbnJvbGxtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgX2Zyb21Vc2VyKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNdWx0aUZhY3RvclVzZXJJbXBsKHVzZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gTXVsdGlGYWN0b3JTZXNzaW9uSW1wbC5fZnJvbUlkdG9rZW4oYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4oKSwgdGhpcy51c2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZW5yb2xsKGFzc2VydGlvbkV4dGVybiwgZGlzcGxheU5hbWUpIHtcbiAgICAgICAgY29uc3QgYXNzZXJ0aW9uID0gYXNzZXJ0aW9uRXh0ZXJuO1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gKGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpKTtcbiAgICAgICAgY29uc3QgZmluYWxpemVNZmFSZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHRoaXMudXNlciwgYXNzZXJ0aW9uLl9wcm9jZXNzKHRoaXMudXNlci5hdXRoLCBzZXNzaW9uLCBkaXNwbGF5TmFtZSkpO1xuICAgICAgICAvLyBOZXcgdG9rZW5zIHdpbGwgYmUgaXNzdWVkIGFmdGVyIGVucm9sbG1lbnQgb2YgdGhlIG5ldyBzZWNvbmQgZmFjdG9ycy5cbiAgICAgICAgLy8gVGhleSBuZWVkIHRvIGJlIHVwZGF0ZWQgb24gdGhlIHVzZXIuXG4gICAgICAgIGF3YWl0IHRoaXMudXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoZmluYWxpemVNZmFSZXNwb25zZSk7XG4gICAgICAgIC8vIFRoZSB1c2VyIG5lZWRzIHRvIGJlIHJlbG9hZGVkIHRvIGdldCB0aGUgbmV3IG11bHRpLWZhY3RvciBpbmZvcm1hdGlvblxuICAgICAgICAvLyBmcm9tIHNlcnZlci4gVVNFUl9SRUxPQURFRCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBhbmQgYGVucm9sbGVkRmFjdG9yc2BcbiAgICAgICAgLy8gd2lsbCBiZSB1cGRhdGVkLlxuICAgICAgICByZXR1cm4gdGhpcy51c2VyLnJlbG9hZCgpO1xuICAgIH1cbiAgICBhc3luYyB1bmVucm9sbChpbmZvT3JVaWQpIHtcbiAgICAgICAgY29uc3QgbWZhRW5yb2xsbWVudElkID0gdHlwZW9mIGluZm9PclVpZCA9PT0gJ3N0cmluZycgPyBpbmZvT3JVaWQgOiBpbmZvT3JVaWQudWlkO1xuICAgICAgICBjb25zdCBpZFRva2VuID0gYXdhaXQgdGhpcy51c2VyLmdldElkVG9rZW4oKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlkVG9rZW5SZXNwb25zZSA9IGF3YWl0IF9sb2dvdXRJZkludmFsaWRhdGVkKHRoaXMudXNlciwgd2l0aGRyYXdNZmEodGhpcy51c2VyLmF1dGgsIHtcbiAgICAgICAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgICAgICAgIG1mYUVucm9sbG1lbnRJZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZWNvbmQgZmFjdG9yIGZyb20gdGhlIHVzZXIncyBsaXN0LlxuICAgICAgICAgICAgdGhpcy5lbnJvbGxlZEZhY3RvcnMgPSB0aGlzLmVucm9sbGVkRmFjdG9ycy5maWx0ZXIoKHsgdWlkIH0pID0+IHVpZCAhPT0gbWZhRW5yb2xsbWVudElkKTtcbiAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBiYWNrZW5kIGRlY2lkZWQgdG8gcmV2b2tlIHRoZSB1c2VyJ3Mgc2Vzc2lvbixcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlblJlc3BvbnNlIG1heSBiZSBlbXB0eS4gSWYgdGhlIHRva2VucyB3ZXJlIG5vdCB1cGRhdGVkIChhbmQgdGhleVxuICAgICAgICAgICAgLy8gYXJlIG5vdyBpbnZhbGlkKSwgcmVsb2FkaW5nIHRoZSB1c2VyIHdpbGwgZGlzY292ZXIgdGhpcyBhbmQgaW52YWxpZGF0ZVxuICAgICAgICAgICAgLy8gdGhlIHVzZXIncyBzdGF0ZSBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5fdXBkYXRlVG9rZW5zSWZOZWNlc3NhcnkoaWRUb2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlci5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IG11bHRpRmFjdG9yVXNlckNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogVGhlIHtAbGluayBNdWx0aUZhY3RvclVzZXJ9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVzZXIuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgdXNlZCB0byBhY2Nlc3MgYWxsIG11bHRpLWZhY3RvciBwcm9wZXJ0aWVzIGFuZCBvcGVyYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHVzZXIgLSBUaGUgdXNlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIG11bHRpRmFjdG9yKHVzZXIpIHtcbiAgICBjb25zdCB1c2VyTW9kdWxhciA9IGdldE1vZHVsYXJJbnN0YW5jZSh1c2VyKTtcbiAgICBpZiAoIW11bHRpRmFjdG9yVXNlckNhY2hlLmhhcyh1c2VyTW9kdWxhcikpIHtcbiAgICAgICAgbXVsdGlGYWN0b3JVc2VyQ2FjaGUuc2V0KHVzZXJNb2R1bGFyLCBNdWx0aUZhY3RvclVzZXJJbXBsLl9mcm9tVXNlcih1c2VyTW9kdWxhcikpO1xuICAgIH1cbiAgICByZXR1cm4gbXVsdGlGYWN0b3JVc2VyQ2FjaGUuZ2V0KHVzZXJNb2R1bGFyKTtcbn1cblxudmFyIG5hbWUgPSBcIkBmaXJlYmFzZS9hdXRoXCI7XG52YXIgdmVyc2lvbiA9IFwiMS44LjFcIjtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIEF1dGhJbnRlcm9wIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoKSB7XG4gICAgICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldFVpZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudWlkKSB8fCBudWxsO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xuICAgICAgICBhd2FpdCB0aGlzLmF1dGguX2luaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgICAgaWYgKCF0aGlzLmF1dGguY3VycmVudFVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy5hdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oZm9yY2VSZWZyZXNoKTtcbiAgICAgICAgcmV0dXJuIHsgYWNjZXNzVG9rZW4gfTtcbiAgICB9XG4gICAgYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRBdXRoQ29uZmlndXJlZCgpO1xuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbExpc3RlbmVycy5oYXMobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmF1dGgub25JZFRva2VuQ2hhbmdlZCh1c2VyID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCh1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuc3RzVG9rZW5NYW5hZ2VyLmFjY2Vzc1Rva2VuKSB8fCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCB1bnN1YnNjcmliZSk7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpO1xuICAgIH1cbiAgICByZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmFzc2VydEF1dGhDb25maWd1cmVkKCk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5pbnRlcm5hbExpc3RlbmVycy5nZXQobGlzdGVuZXIpO1xuICAgICAgICBpZiAoIXVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb2FjdGl2ZVJlZnJlc2goKTtcbiAgICB9XG4gICAgYXNzZXJ0QXV0aENvbmZpZ3VyZWQoKSB7XG4gICAgICAgIF9hc3NlcnQodGhpcy5hdXRoLl9pbml0aWFsaXphdGlvblByb21pc2UsIFwiZGVwZW5kZW50LXNkay1pbml0aWFsaXplZC1iZWZvcmUtYXV0aFwiIC8qIEF1dGhFcnJvckNvZGUuREVQRU5ERU5UX1NES19JTklUX0JFRk9SRV9BVVRIICovKTtcbiAgICB9XG4gICAgdXBkYXRlUHJvYWN0aXZlUmVmcmVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxMaXN0ZW5lcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aC5fc3RhcnRQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF1dGguX3N0b3BQcm9hY3RpdmVSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBnZXRWZXJzaW9uRm9yUGxhdGZvcm0oY2xpZW50UGxhdGZvcm0pIHtcbiAgICBzd2l0Y2ggKGNsaWVudFBsYXRmb3JtKSB7XG4gICAgICAgIGNhc2UgXCJOb2RlXCIgLyogQ2xpZW50UGxhdGZvcm0uTk9ERSAqLzpcbiAgICAgICAgICAgIHJldHVybiAnbm9kZSc7XG4gICAgICAgIGNhc2UgXCJSZWFjdE5hdGl2ZVwiIC8qIENsaWVudFBsYXRmb3JtLlJFQUNUX05BVElWRSAqLzpcbiAgICAgICAgICAgIHJldHVybiAncm4nO1xuICAgICAgICBjYXNlIFwiV29ya2VyXCIgLyogQ2xpZW50UGxhdGZvcm0uV09SS0VSICovOlxuICAgICAgICAgICAgcmV0dXJuICd3ZWJ3b3JrZXInO1xuICAgICAgICBjYXNlIFwiQ29yZG92YVwiIC8qIENsaWVudFBsYXRmb3JtLkNPUkRPVkEgKi86XG4gICAgICAgICAgICByZXR1cm4gJ2NvcmRvdmEnO1xuICAgICAgICBjYXNlIFwiV2ViRXh0ZW5zaW9uXCIgLyogQ2xpZW50UGxhdGZvcm0uV0VCX0VYVEVOU0lPTiAqLzpcbiAgICAgICAgICAgIHJldHVybiAnd2ViLWV4dGVuc2lvbic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQXV0aChjbGllbnRQbGF0Zm9ybSkge1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KFwiYXV0aFwiIC8qIF9Db21wb25lbnROYW1lLkFVVEggKi8sIChjb250YWluZXIsIHsgb3B0aW9uczogZGVwcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignaGVhcnRiZWF0Jyk7XG4gICAgICAgIGNvbnN0IGFwcENoZWNrU2VydmljZVByb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcbiAgICAgICAgY29uc3QgeyBhcGlLZXksIGF1dGhEb21haW4gfSA9IGFwcC5vcHRpb25zO1xuICAgICAgICBfYXNzZXJ0KGFwaUtleSAmJiAhYXBpS2V5LmluY2x1ZGVzKCc6JyksIFwiaW52YWxpZC1hcGkta2V5XCIgLyogQXV0aEVycm9yQ29kZS5JTlZBTElEX0FQSV9LRVkgKi8sIHsgYXBwTmFtZTogYXBwLm5hbWUgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgIGF1dGhEb21haW4sXG4gICAgICAgICAgICBjbGllbnRQbGF0Zm9ybSxcbiAgICAgICAgICAgIGFwaUhvc3Q6IFwiaWRlbnRpdHl0b29sa2l0Lmdvb2dsZWFwaXMuY29tXCIgLyogRGVmYXVsdENvbmZpZy5BUElfSE9TVCAqLyxcbiAgICAgICAgICAgIHRva2VuQXBpSG9zdDogXCJzZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbVwiIC8qIERlZmF1bHRDb25maWcuVE9LRU5fQVBJX0hPU1QgKi8sXG4gICAgICAgICAgICBhcGlTY2hlbWU6IFwiaHR0cHNcIiAvKiBEZWZhdWx0Q29uZmlnLkFQSV9TQ0hFTUUgKi8sXG4gICAgICAgICAgICBzZGtDbGllbnRWZXJzaW9uOiBfZ2V0Q2xpZW50VmVyc2lvbihjbGllbnRQbGF0Zm9ybSlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXV0aEluc3RhbmNlID0gbmV3IEF1dGhJbXBsKGFwcCwgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLCBhcHBDaGVja1NlcnZpY2VQcm92aWRlciwgY29uZmlnKTtcbiAgICAgICAgX2luaXRpYWxpemVBdXRoSW5zdGFuY2UoYXV0aEluc3RhbmNlLCBkZXBzKTtcbiAgICAgICAgcmV0dXJuIGF1dGhJbnN0YW5jZTtcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKVxuICAgICAgICAvKipcbiAgICAgICAgICogQXV0aCBjYW4gb25seSBiZSBpbml0aWFsaXplZCBieSBleHBsaWNpdGx5IGNhbGxpbmcgZ2V0QXV0aCgpIG9yIGluaXRpYWxpemVBdXRoKClcbiAgICAgICAgICogRm9yIHdoeSB3ZSBkbyB0aGlzLCBTZWUgZ28vZmlyZWJhc2UtbmV4dC1hdXRoLWluaXRcbiAgICAgICAgICovXG4gICAgICAgIC5zZXRJbnN0YW50aWF0aW9uTW9kZShcIkVYUExJQ0lUXCIgLyogSW5zdGFudGlhdGlvbk1vZGUuRVhQTElDSVQgKi8pXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCZWNhdXNlIGFsbCBmaXJlYmFzZSBwcm9kdWN0cyB0aGF0IGRlcGVuZCBvbiBhdXRoIGRlcGVuZCBvbiBhdXRoLWludGVybmFsIGRpcmVjdGx5LFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGluaXRpYWxpemUgYXV0aC1pbnRlcm5hbCBhZnRlciBhdXRoIGlzIGluaXRpYWxpemVkIHRvIG1ha2UgaXQgYXZhaWxhYmxlIHRvIG90aGVyIGZpcmViYXNlIHByb2R1Y3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgLnNldEluc3RhbmNlQ3JlYXRlZENhbGxiYWNrKChjb250YWluZXIsIF9pbnN0YW5jZUlkZW50aWZpZXIsIF9pbnN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBhdXRoSW50ZXJuYWxQcm92aWRlciA9IGNvbnRhaW5lci5nZXRQcm92aWRlcihcImF1dGgtaW50ZXJuYWxcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIX0lOVEVSTkFMICovKTtcbiAgICAgICAgYXV0aEludGVybmFsUHJvdmlkZXIuaW5pdGlhbGl6ZSgpO1xuICAgIH0pKTtcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudChcImF1dGgtaW50ZXJuYWxcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIX0lOVEVSTkFMICovLCBjb250YWluZXIgPT4ge1xuICAgICAgICBjb25zdCBhdXRoID0gX2Nhc3RBdXRoKGNvbnRhaW5lci5nZXRQcm92aWRlcihcImF1dGhcIiAvKiBfQ29tcG9uZW50TmFtZS5BVVRIICovKS5nZXRJbW1lZGlhdGUoKSk7XG4gICAgICAgIHJldHVybiAoYXV0aCA9PiBuZXcgQXV0aEludGVyb3AoYXV0aCkpKGF1dGgpO1xuICAgIH0sIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykuc2V0SW5zdGFudGlhdGlvbk1vZGUoXCJFWFBMSUNJVFwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVYUExJQ0lUICovKSk7XG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sIGdldFZlcnNpb25Gb3JQbGF0Zm9ybShjbGllbnRQbGF0Zm9ybSkpO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTIwMTcsIGNqczIwMTcsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBJbml0aWFsaXplIHRoZSBmZXRjaCBwb2x5ZmlsbCwgdGhlIHR5cGVzIGFyZSBzbGlnaHRseSBvZmYgc28ganVzdCBjYXN0IGFuZCBob3BlIGZvciB0aGUgYmVzdFxuRmV0Y2hQcm92aWRlci5pbml0aWFsaXplKGZldGNoLCBIZWFkZXJzLCBSZXNwb25zZSk7XG4vLyBGaXJzdCwgd2Ugc2V0IHVwIHRoZSB2YXJpb3VzIHBsYXRmb3JtLXNwZWNpZmljIGZlYXR1cmVzIGZvciBOb2RlIChyZWdpc3RlclxuLy8gdGhlIHZlcnNpb24gYW5kIGRlY2xhcmUgdGhlIE5vZGUgZ2V0QXV0aCBmdW5jdGlvbilcbmZ1bmN0aW9uIGdldEF1dGgoYXBwID0gZ2V0QXBwKCkpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsICdhdXRoJyk7XG4gICAgaWYgKHByb3ZpZGVyLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0SW1tZWRpYXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IGF1dGggPSBpbml0aWFsaXplQXV0aChhcHApO1xuICAgIGNvbnN0IGF1dGhFbXVsYXRvckhvc3QgPSBnZXREZWZhdWx0RW11bGF0b3JIb3N0KCdhdXRoJyk7XG4gICAgaWYgKGF1dGhFbXVsYXRvckhvc3QpIHtcbiAgICAgICAgY29ubmVjdEF1dGhFbXVsYXRvcihhdXRoLCBgaHR0cDovLyR7YXV0aEVtdWxhdG9ySG9zdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dGg7XG59XG5yZWdpc3RlckF1dGgoXCJOb2RlXCIgLyogQ2xpZW50UGxhdGZvcm0uTk9ERSAqLyk7XG4vLyBUaGUgcmVzdCBvZiB0aGlzIGZpbGUgY29udGFpbnMgbm8tb3BzIGFuZCBlcnJvcnMgZm9yIGJyb3dzZXItc3BlY2lmaWNcbi8vIG1ldGhvZHMuIFdlIGtlZXAgdGhlIGJyb3dzZXIgYW5kIE5vZGUgZW50cnkgcG9pbnRzIHRoZSBzYW1lLCBidXQgZmVhdHVyZXNcbi8vIHRoYXQgb25seSB3b3JrIGluIGJyb3dzZXJzIGFyZSBzZXQgdG8gZWl0aGVyIGRvIG5vdGhpbmcgKHNldFBlcnNpc3RlbmNlKSBvclxuLy8gdG8gcmVqZWN0IHdpdGggYW4gYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50IGVycm9yLlxuLy8gVGhlIGJlbG93IGV4cG9ydHMgYXJlIHB1bGxlZCBpbnRvIHRoZSBtYWluIGVudHJ5IHBvaW50IGJ5IGEgcm9sbHVwIGFsaWFzXG4vLyBwbHVnaW4gKG92ZXJ3cml0aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgaW1wb3J0cykuXG4vKiogYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50ICovXG5jb25zdCBOT1RfQVZBSUxBQkxFX0VSUk9SID0gX2NyZWF0ZUVycm9yKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiIC8qIEF1dGhFcnJvckNvZGUuT1BFUkFUSU9OX05PVF9TVVBQT1JURUQgKi8pO1xuLyoqIFJlamVjdCB3aXRoIGF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudCAqL1xuYXN5bmMgZnVuY3Rpb24gZmFpbCgpIHtcbiAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xufVxuLyoqXG4gKiBBIGNsYXNzIHdoaWNoIHdpbGwgdGhyb3cgd2l0aFxuICogYXV0aC9vcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50IGlmIGluc3RhbnRpYXRlZFxuICovXG5jbGFzcyBGYWlsQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xuICAgIH1cbn1cbmNvbnN0IGJyb3dzZXJMb2NhbFBlcnNpc3RlbmNlID0gaW5NZW1vcnlQZXJzaXN0ZW5jZTtcbmNvbnN0IGJyb3dzZXJTZXNzaW9uUGVyc2lzdGVuY2UgPSBpbk1lbW9yeVBlcnNpc3RlbmNlO1xuY29uc3QgaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZSA9IGluTWVtb3J5UGVyc2lzdGVuY2U7XG5jb25zdCBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyID0gTk9UX0FWQUlMQUJMRV9FUlJPUjtcbmNvbnN0IFBob25lQXV0aFByb3ZpZGVyID0gRmFpbENsYXNzO1xuY29uc3Qgc2lnbkluV2l0aFBob25lTnVtYmVyID0gZmFpbDtcbmNvbnN0IGxpbmtXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3QgdXBkYXRlUGhvbmVOdW1iZXIgPSBmYWlsO1xuY29uc3Qgc2lnbkluV2l0aFBvcHVwID0gZmFpbDtcbmNvbnN0IGxpbmtXaXRoUG9wdXAgPSBmYWlsO1xuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUG9wdXAgPSBmYWlsO1xuY29uc3Qgc2lnbkluV2l0aFJlZGlyZWN0ID0gZmFpbDtcbmNvbnN0IGxpbmtXaXRoUmVkaXJlY3QgPSBmYWlsO1xuY29uc3QgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QgPSBmYWlsO1xuY29uc3QgZ2V0UmVkaXJlY3RSZXN1bHQgPSBmYWlsO1xuY29uc3QgUmVjYXB0Y2hhVmVyaWZpZXIgPSBGYWlsQ2xhc3M7XG5jbGFzcyBQaG9uZU11bHRpRmFjdG9yR2VuZXJhdG9yIHtcbiAgICBzdGF0aWMgYXNzZXJ0aW9uKCkge1xuICAgICAgICB0aHJvdyBOT1RfQVZBSUxBQkxFX0VSUk9SO1xuICAgIH1cbn1cbi8vIFNldCBwZXJzaXN0ZW5jZSBzaG91bGQgbm8tb3AgaW5zdGVhZCBvZiBmYWlsLiBDaGFuZ2luZyB0aGUgcHJvdG90eXBlIHdpbGxcbi8vIG1ha2Ugc3VyZSBib3RoIHNldFBlcnNpc3RlbmNlKGF1dGgsIHBlcnNpc3RlbmNlKSBhbmRcbi8vIGF1dGguc2V0UGVyc2lzdGVuY2UocGVyc2lzdGVuY2UpIGFyZSBjb3ZlcmVkLlxuQXV0aEltcGwucHJvdG90eXBlLnNldFBlcnNpc3RlbmNlID0gYXN5bmMgKCkgPT4geyB9O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZmluYWxpemVTaWduSW5Ub3RwTWZhKGF1dGgsIHJlcXVlc3QpIHtcbiAgICByZXR1cm4gX3BlcmZvcm1BcGlSZXF1ZXN0KGF1dGgsIFwiUE9TVFwiIC8qIEh0dHBNZXRob2QuUE9TVCAqLywgXCIvdjIvYWNjb3VudHMvbWZhU2lnbkluOmZpbmFsaXplXCIgLyogRW5kcG9pbnQuRklOQUxJWkVfTUZBX1NJR05fSU4gKi8sIF9hZGRUaWRJZk5lY2Vzc2FyeShhdXRoLCByZXF1ZXN0KSk7XG59XG5cbmNsYXNzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9ySWQpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JJZCA9IGZhY3RvcklkO1xuICAgIH1cbiAgICBfcHJvY2VzcyhhdXRoLCBzZXNzaW9uLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICBzd2l0Y2ggKHNlc3Npb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImVucm9sbFwiIC8qIE11bHRpRmFjdG9yU2Vzc2lvblR5cGUuRU5ST0xMICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZUVucm9sbChhdXRoLCBzZXNzaW9uLmNyZWRlbnRpYWwsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzaWduaW5cIiAvKiBNdWx0aUZhY3RvclNlc3Npb25UeXBlLlNJR05fSU4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplU2lnbkluKGF1dGgsIHNlc3Npb24uY3JlZGVudGlhbCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1Z0ZhaWwoJ3VuZXhwZWN0ZWQgTXVsdGlGYWN0b3JTZXNzaW9uVHlwZScpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGVyIGZvciBnZW5lcmF0aW5nIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0uXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3Ige1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gdG8gY29uZmlybSBvd25lcnNoaXAgb2ZcbiAgICAgKiB0aGUgVE9UUCAodGltZS1iYXNlZCBvbmUtdGltZSBwYXNzd29yZCkgc2Vjb25kIGZhY3Rvci5cbiAgICAgKiBUaGlzIGFzc2VydGlvbiBpcyB1c2VkIHRvIGNvbXBsZXRlIGVucm9sbG1lbnQgaW4gVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlY3JldCBBIHtAbGluayBUb3RwU2VjcmV0fSBjb250YWluaW5nIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgb3RoZXIgVE9UUCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBvbmVUaW1lUGFzc3dvcmQgT25lLXRpbWUgcGFzc3dvcmQgZnJvbSBUT1RQIEFwcC5cbiAgICAgKiBAcmV0dXJucyBBIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHdoaWNoIGNhbiBiZSB1c2VkIHdpdGhcbiAgICAgKiB7QGxpbmsgTXVsdGlGYWN0b3JVc2VyLmVucm9sbH0uXG4gICAgICovXG4gICAgc3RhdGljIGFzc2VydGlvbkZvckVucm9sbG1lbnQoc2VjcmV0LCBvbmVUaW1lUGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21TZWNyZXQoc2VjcmV0LCBvbmVUaW1lUGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259IHRvIGNvbmZpcm0gb3duZXJzaGlwIG9mIHRoZSBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICogVGhpcyBhc3NlcnRpb24gaXMgdXNlZCB0byBjb21wbGV0ZSBzaWduSW4gd2l0aCBUT1RQIGFzIHRoZSBzZWNvbmQgZmFjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVucm9sbG1lbnRJZCBpZGVudGlmaWVzIHRoZSBlbnJvbGxlZCBUT1RQIHNlY29uZCBmYWN0b3IuXG4gICAgICogQHBhcmFtIG9uZVRpbWVQYXNzd29yZCBPbmUtdGltZSBwYXNzd29yZCBmcm9tIFRPVFAgQXBwLlxuICAgICAqIEByZXR1cm5zIEEge0BsaW5rIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbn0gd2hpY2ggY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIHtAbGluayBNdWx0aUZhY3RvclJlc29sdmVyLnJlc29sdmVTaWduSW59LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3NlcnRpb25Gb3JTaWduSW4oZW5yb2xsbWVudElkLCBvbmVUaW1lUGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwuX2Zyb21FbnJvbGxtZW50SWQoZW5yb2xsbWVudElkLCBvbmVUaW1lUGFzc3dvcmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0byB7QGxpbmsgVG90cFNlY3JldH0gd2hpY2ggY29udGFpbnMgdGhlIFRPVFAgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMuXG4gICAgICogQ3JlYXRlcyBhIFRPVFAgc2VjcmV0IGFzIHBhcnQgb2YgZW5yb2xsaW5nIGEgVE9UUCBzZWNvbmQgZmFjdG9yLlxuICAgICAqIFVzZWQgZm9yIGdlbmVyYXRpbmcgYSBRUiBjb2RlIFVSTCBvciBpbnB1dHRpbmcgaW50byBhIFRPVFAgYXBwLlxuICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGF1dGggaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byB0aGUgdXNlciBpbiB0aGUgbXVsdGlGYWN0b3JTZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlc3Npb24gVGhlIHtAbGluayBNdWx0aUZhY3RvclNlc3Npb259IHRoYXQgdGhlIHVzZXIgaXMgcGFydCBvZi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdG8ge0BsaW5rIFRvdHBTZWNyZXR9LlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZVNlY3JldChzZXNzaW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWZhU2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIF9hc3NlcnQodHlwZW9mICgoX2EgPSBtZmFTZXNzaW9uLnVzZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRoKSAhPT0gJ3VuZGVmaW5lZCcsIFwiaW50ZXJuYWwtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLklOVEVSTkFMX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdGFydEVucm9sbFRvdHBNZmEobWZhU2Vzc2lvbi51c2VyLmF1dGgsIHtcbiAgICAgICAgICAgIGlkVG9rZW46IG1mYVNlc3Npb24uY3JlZGVudGlhbCxcbiAgICAgICAgICAgIHRvdHBFbnJvbGxtZW50SW5mbzoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBUb3RwU2VjcmV0Ll9mcm9tU3RhcnRUb3RwTWZhRW5yb2xsbWVudFJlc3BvbnNlKHJlc3BvbnNlLCBtZmFTZXNzaW9uLnVzZXIuYXV0aCk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgaWRlbnRpZmllciBvZiB0aGUgVE9UUCBzZWNvbmQgZmFjdG9yOiBgdG90cGAuXG4gKi9cblRvdHBNdWx0aUZhY3RvckdlbmVyYXRvci5GQUNUT1JfSUQgPSBcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovO1xuY2xhc3MgVG90cE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCBleHRlbmRzIE11bHRpRmFjdG9yQXNzZXJ0aW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3RwLCBlbnJvbGxtZW50SWQsIHNlY3JldCkge1xuICAgICAgICBzdXBlcihcInRvdHBcIiAvKiBGYWN0b3JJZC5UT1RQICovKTtcbiAgICAgICAgdGhpcy5vdHAgPSBvdHA7XG4gICAgICAgIHRoaXMuZW5yb2xsbWVudElkID0gZW5yb2xsbWVudElkO1xuICAgICAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbVNlY3JldChzZWNyZXQsIG90cCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBNdWx0aUZhY3RvckFzc2VydGlvbkltcGwob3RwLCB1bmRlZmluZWQsIHNlY3JldCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgX2Zyb21FbnJvbGxtZW50SWQoZW5yb2xsbWVudElkLCBvdHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb25JbXBsKG90cCwgZW5yb2xsbWVudElkKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGFzeW5jIF9maW5hbGl6ZUVucm9sbChhdXRoLCBpZFRva2VuLCBkaXNwbGF5TmFtZSkge1xuICAgICAgICBfYXNzZXJ0KHR5cGVvZiB0aGlzLnNlY3JldCAhPT0gJ3VuZGVmaW5lZCcsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplRW5yb2xsVG90cE1mYShhdXRoLCB7XG4gICAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgICB0b3RwVmVyaWZpY2F0aW9uSW5mbzogdGhpcy5zZWNyZXQuX21ha2VUb3RwVmVyaWZpY2F0aW9uSW5mbyh0aGlzLm90cClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfZmluYWxpemVTaWduSW4oYXV0aCwgbWZhUGVuZGluZ0NyZWRlbnRpYWwpIHtcbiAgICAgICAgX2Fzc2VydCh0aGlzLmVucm9sbG1lbnRJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3RwICE9PSB1bmRlZmluZWQsIGF1dGgsIFwiYXJndW1lbnQtZXJyb3JcIiAvKiBBdXRoRXJyb3JDb2RlLkFSR1VNRU5UX0VSUk9SICovKTtcbiAgICAgICAgY29uc3QgdG90cFZlcmlmaWNhdGlvbkluZm8gPSB7IHZlcmlmaWNhdGlvbkNvZGU6IHRoaXMub3RwIH07XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNpZ25JblRvdHBNZmEoYXV0aCwge1xuICAgICAgICAgICAgbWZhUGVuZGluZ0NyZWRlbnRpYWwsXG4gICAgICAgICAgICBtZmFFbnJvbGxtZW50SWQ6IHRoaXMuZW5yb2xsbWVudElkLFxuICAgICAgICAgICAgdG90cFZlcmlmaWNhdGlvbkluZm9cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm92aWRlciBmb3IgZ2VuZXJhdGluZyBhIHtAbGluayBUb3RwTXVsdGlGYWN0b3JBc3NlcnRpb259LlxuICpcbiAqIFN0b3JlcyB0aGUgc2hhcmVkIHNlY3JldCBrZXkgYW5kIG90aGVyIHBhcmFtZXRlcnMgdG8gZ2VuZXJhdGUgdGltZS1iYXNlZCBPVFBzLlxuICogSW1wbGVtZW50cyBtZXRob2RzIHRvIHJldHJpZXZlIHRoZSBzaGFyZWQgc2VjcmV0IGtleSBhbmQgZ2VuZXJhdGUgYSBRUiBjb2RlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVG90cFNlY3JldCB7XG4gICAgLy8gVGhlIHB1YmxpYyBtZW1iZXJzIGFyZSBkZWNsYXJlZCBvdXRzaWRlIHRoZSBjb25zdHJ1Y3RvciBzbyB0aGUgZG9jcyBjYW4gYmUgZ2VuZXJhdGVkLlxuICAgIGNvbnN0cnVjdG9yKHNlY3JldEtleSwgaGFzaGluZ0FsZ29yaXRobSwgY29kZUxlbmd0aCwgY29kZUludGVydmFsU2Vjb25kcywgZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZSwgc2Vzc2lvbkluZm8sIGF1dGgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uSW5mbyA9IHNlc3Npb25JbmZvO1xuICAgICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICB0aGlzLnNlY3JldEtleSA9IHNlY3JldEtleTtcbiAgICAgICAgdGhpcy5oYXNoaW5nQWxnb3JpdGhtID0gaGFzaGluZ0FsZ29yaXRobTtcbiAgICAgICAgdGhpcy5jb2RlTGVuZ3RoID0gY29kZUxlbmd0aDtcbiAgICAgICAgdGhpcy5jb2RlSW50ZXJ2YWxTZWNvbmRzID0gY29kZUludGVydmFsU2Vjb25kcztcbiAgICAgICAgdGhpcy5lbnJvbGxtZW50Q29tcGxldGlvbkRlYWRsaW5lID0gZW5yb2xsbWVudENvbXBsZXRpb25EZWFkbGluZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBfZnJvbVN0YXJ0VG90cE1mYUVucm9sbG1lbnRSZXNwb25zZShyZXNwb25zZSwgYXV0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFRvdHBTZWNyZXQocmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnNoYXJlZFNlY3JldEtleSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLmhhc2hpbmdBbGdvcml0aG0sIHJlc3BvbnNlLnRvdHBTZXNzaW9uSW5mby52ZXJpZmljYXRpb25Db2RlTGVuZ3RoLCByZXNwb25zZS50b3RwU2Vzc2lvbkluZm8ucGVyaW9kU2VjLCBuZXcgRGF0ZShyZXNwb25zZS50b3RwU2Vzc2lvbkluZm8uZmluYWxpemVFbnJvbGxtZW50VGltZSkudG9VVENTdHJpbmcoKSwgcmVzcG9uc2UudG90cFNlc3Npb25JbmZvLnNlc3Npb25JbmZvLCBhdXRoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tYWtlVG90cFZlcmlmaWNhdGlvbkluZm8ob3RwKSB7XG4gICAgICAgIHJldHVybiB7IHNlc3Npb25JbmZvOiB0aGlzLnNlc3Npb25JbmZvLCB2ZXJpZmljYXRpb25Db2RlOiBvdHAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFFSIGNvZGUgVVJMIGFzIGRlc2NyaWJlZCBpblxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvZ29vZ2xlLWF1dGhlbnRpY2F0b3Ivd2lraS9LZXktVXJpLUZvcm1hdFxuICAgICAqIFRoaXMgY2FuIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhcyBhIFFSIGNvZGUgdG8gYmUgc2Nhbm5lZCBpbnRvIGEgVE9UUCBhcHAgbGlrZSBHb29nbGUgQXV0aGVudGljYXRvci5cbiAgICAgKiBJZiB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgdW5zcGVjaWZpZWQsIGFuIGFjY291bnROYW1lIG9mIDx1c2VyRW1haWw+IGFuZCBpc3N1ZXIgb2YgPGZpcmViYXNlQXBwTmFtZT4gYXJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWNjb3VudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGFjY291bnQvYXBwIGFsb25nIHdpdGggYSB1c2VyIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgb2YgdGhlIFRPVFAgKGxpa2VseSB0aGUgYXBwIG5hbWUpLlxuICAgICAqIEByZXR1cm5zIEEgUVIgY29kZSBVUkwgc3RyaW5nLlxuICAgICAqL1xuICAgIGdlbmVyYXRlUXJDb2RlVXJsKGFjY291bnROYW1lLCBpc3N1ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgdXNlRGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgICAgaWYgKF9pc0VtcHR5U3RyaW5nKGFjY291bnROYW1lKSB8fCBfaXNFbXB0eVN0cmluZyhpc3N1ZXIpKSB7XG4gICAgICAgICAgICB1c2VEZWZhdWx0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZURlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoYWNjb3VudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudE5hbWUgPSAoKF9hID0gdGhpcy5hdXRoLmN1cnJlbnRVc2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1haWwpIHx8ICd1bmtub3dudXNlcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2lzRW1wdHlTdHJpbmcoaXNzdWVyKSkge1xuICAgICAgICAgICAgICAgIGlzc3VlciA9IHRoaXMuYXV0aC5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgb3RwYXV0aDovL3RvdHAvJHtpc3N1ZXJ9OiR7YWNjb3VudE5hbWV9P3NlY3JldD0ke3RoaXMuc2VjcmV0S2V5fSZpc3N1ZXI9JHtpc3N1ZXJ9JmFsZ29yaXRobT0ke3RoaXMuaGFzaGluZ0FsZ29yaXRobX0mZGlnaXRzPSR7dGhpcy5jb2RlTGVuZ3RofWA7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gX2lzRW1wdHlTdHJpbmcoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJyB8fCAoaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0Lmxlbmd0aCkgPT09IDA7XG59XG5cbmV4cG9ydCB7IFR3aXR0ZXJBdXRoUHJvdmlkZXIgYXMgJCwgQWN0aW9uQ29kZU9wZXJhdGlvbiBhcyBBLCB1cGRhdGVDdXJyZW50VXNlciBhcyBCLCBzaWduT3V0IGFzIEMsIHJldm9rZUFjY2Vzc1Rva2VuIGFzIEQsIGRlbGV0ZVVzZXIgYXMgRSwgRmFjdG9ySWQgYXMgRiwgZGVidWdFcnJvck1hcCBhcyBHLCBwcm9kRXJyb3JNYXAgYXMgSCwgQVVUSF9FUlJPUl9DT0RFU19NQVBfRE9fTk9UX1VTRV9JTlRFUk5BTExZIGFzIEksIGluaXRpYWxpemVBdXRoIGFzIEosIGNvbm5lY3RBdXRoRW11bGF0b3IgYXMgSywgQXV0aENyZWRlbnRpYWwgYXMgTCwgRW1haWxBdXRoQ3JlZGVudGlhbCBhcyBNLCBPQXV0aENyZWRlbnRpYWwgYXMgTiwgT3BlcmF0aW9uVHlwZSBhcyBPLCBQaG9uZUF1dGhQcm92aWRlciBhcyBQLCBQaG9uZUF1dGhDcmVkZW50aWFsIGFzIFEsIFJlY2FwdGNoYVZlcmlmaWVyIGFzIFIsIFNpZ25Jbk1ldGhvZCBhcyBTLCBUb3RwTXVsdGlGYWN0b3JHZW5lcmF0b3IgYXMgVCwgaW5NZW1vcnlQZXJzaXN0ZW5jZSBhcyBVLCBFbWFpbEF1dGhQcm92aWRlciBhcyBWLCBGYWNlYm9va0F1dGhQcm92aWRlciBhcyBXLCBHb29nbGVBdXRoUHJvdmlkZXIgYXMgWCwgR2l0aHViQXV0aFByb3ZpZGVyIGFzIFksIE9BdXRoUHJvdmlkZXIgYXMgWiwgU0FNTEF1dGhQcm92aWRlciBhcyBfLCBicm93c2VyU2Vzc2lvblBlcnNpc3RlbmNlIGFzIGEsIHNpZ25JbkFub255bW91c2x5IGFzIGEwLCBzaWduSW5XaXRoQ3JlZGVudGlhbCBhcyBhMSwgbGlua1dpdGhDcmVkZW50aWFsIGFzIGEyLCByZWF1dGhlbnRpY2F0ZVdpdGhDcmVkZW50aWFsIGFzIGEzLCBzaWduSW5XaXRoQ3VzdG9tVG9rZW4gYXMgYTQsIHNlbmRQYXNzd29yZFJlc2V0RW1haWwgYXMgYTUsIGNvbmZpcm1QYXNzd29yZFJlc2V0IGFzIGE2LCBhcHBseUFjdGlvbkNvZGUgYXMgYTcsIGNoZWNrQWN0aW9uQ29kZSBhcyBhOCwgdmVyaWZ5UGFzc3dvcmRSZXNldENvZGUgYXMgYTksIF9mYWlsIGFzIGFBLCBkZWJ1Z0Fzc2VydCBhcyBhQiwgX3BlcnNpc3RlbmNlS2V5TmFtZSBhcyBhQywgX3NlcnZlckFwcEN1cnJlbnRVc2VyT3BlcmF0aW9uTm90U3VwcG9ydGVkRXJyb3IgYXMgYUQsIF9jYXN0QXV0aCBhcyBhRSwgRmVkZXJhdGVkQXV0aFByb3ZpZGVyIGFzIGFGLCBCYXNlT0F1dGhQcm92aWRlciBhcyBhRywgX2VtdWxhdG9yVXJsIGFzIGFILCBfcGVyZm9ybUFwaVJlcXVlc3QgYXMgYUksIF9pc0lPUyBhcyBhSiwgX2lzQW5kcm9pZCBhcyBhSywgX2lzSU9TN09yOCBhcyBhTCwgX2NyZWF0ZUVycm9yIGFzIGFNLCBfaXNNb2JpbGVCcm93c2VyIGFzIGFOLCBfaXNJRTEwIGFzIGFPLCBVc2VySW1wbCBhcyBhUCwgQXV0aEltcGwgYXMgYVEsIF9nZXRDbGllbnRWZXJzaW9uIGFzIGFSLCBGZXRjaFByb3ZpZGVyIGFzIGFTLCBTQU1MQXV0aENyZWRlbnRpYWwgYXMgYVQsIGNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZCBhcyBhYSwgc2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmQgYXMgYWIsIHNlbmRTaWduSW5MaW5rVG9FbWFpbCBhcyBhYywgaXNTaWduSW5XaXRoRW1haWxMaW5rIGFzIGFkLCBzaWduSW5XaXRoRW1haWxMaW5rIGFzIGFlLCBmZXRjaFNpZ25Jbk1ldGhvZHNGb3JFbWFpbCBhcyBhZiwgc2VuZEVtYWlsVmVyaWZpY2F0aW9uIGFzIGFnLCB2ZXJpZnlCZWZvcmVVcGRhdGVFbWFpbCBhcyBhaCwgQWN0aW9uQ29kZVVSTCBhcyBhaSwgcGFyc2VBY3Rpb25Db2RlVVJMIGFzIGFqLCB1cGRhdGVQcm9maWxlIGFzIGFrLCB1cGRhdGVFbWFpbCBhcyBhbCwgdXBkYXRlUGFzc3dvcmQgYXMgYW0sIGdldElkVG9rZW4gYXMgYW4sIGdldElkVG9rZW5SZXN1bHQgYXMgYW8sIHVubGluayBhcyBhcCwgZ2V0QWRkaXRpb25hbFVzZXJJbmZvIGFzIGFxLCByZWxvYWQgYXMgYXIsIGdldE11bHRpRmFjdG9yUmVzb2x2ZXIgYXMgYXMsIG11bHRpRmFjdG9yIGFzIGF0LCBfZ2V0SW5zdGFuY2UgYXMgYXUsIF9hc3NlcnQgYXMgYXYsIF9zaWduSW5XaXRoQ3JlZGVudGlhbCBhcyBhdywgX3JlYXV0aGVudGljYXRlIGFzIGF4LCBfbGluayBhcyBheSwgc2lnbkluV2l0aElkcCBhcyBheiwgYnJvd3NlckxvY2FsUGVyc2lzdGVuY2UgYXMgYiwgc2lnbkluV2l0aFBvcHVwIGFzIGMsIGxpbmtXaXRoUG9wdXAgYXMgZCwgcmVhdXRoZW50aWNhdGVXaXRoUG9wdXAgYXMgZSwgc2lnbkluV2l0aFJlZGlyZWN0IGFzIGYsIGxpbmtXaXRoUmVkaXJlY3QgYXMgZywgcmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3QgYXMgaCwgaW5kZXhlZERCTG9jYWxQZXJzaXN0ZW5jZSBhcyBpLCBnZXRSZWRpcmVjdFJlc3VsdCBhcyBqLCBicm93c2VyUG9wdXBSZWRpcmVjdFJlc29sdmVyIGFzIGssIGxpbmtXaXRoUGhvbmVOdW1iZXIgYXMgbCwgUGhvbmVNdWx0aUZhY3RvckdlbmVyYXRvciBhcyBtLCBUb3RwU2VjcmV0IGFzIG4sIGdldEF1dGggYXMgbywgUHJvdmlkZXJJZCBhcyBwLCBzZXRQZXJzaXN0ZW5jZSBhcyBxLCByZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlciBhcyByLCBzaWduSW5XaXRoUGhvbmVOdW1iZXIgYXMgcywgaW5pdGlhbGl6ZVJlY2FwdGNoYUNvbmZpZyBhcyB0LCB1cGRhdGVQaG9uZU51bWJlciBhcyB1LCB2YWxpZGF0ZVBhc3N3b3JkIGFzIHYsIG9uSWRUb2tlbkNoYW5nZWQgYXMgdywgYmVmb3JlQXV0aFN0YXRlQ2hhbmdlZCBhcyB4LCBvbkF1dGhTdGF0ZUNoYW5nZWQgYXMgeSwgdXNlRGV2aWNlTGFuZ3VhZ2UgYXMgeiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG90cC0zZGYyZjVmOS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/auth/dist/node-esm/totp-3df2f5f9.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/component/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component),\n/* harmony export */   ComponentContainer: () => (/* binding */ ComponentContainer),\n/* harmony export */   Provider: () => (/* binding */ Provider)\n/* harmony export */ });\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/util */ \"(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\");\n\n\n/**\n * Component for service name T, e.g. `auth`, `auth-internal`\n */\nclass Component {\n    /**\n     *\n     * @param name The public service name, e.g. app, auth, firestore, database\n     * @param instanceFactory Service factory responsible for creating the public interface\n     * @param type whether the service provided by the component is public or private\n     */\n    constructor(name, instanceFactory, type) {\n        this.name = name;\n        this.instanceFactory = instanceFactory;\n        this.type = type;\n        this.multipleInstances = false;\n        /**\n         * Properties to be added to the service namespace\n         */\n        this.serviceProps = {};\n        this.instantiationMode = \"LAZY\" /* InstantiationMode.LAZY */;\n        this.onInstanceCreated = null;\n    }\n    setInstantiationMode(mode) {\n        this.instantiationMode = mode;\n        return this;\n    }\n    setMultipleInstances(multipleInstances) {\n        this.multipleInstances = multipleInstances;\n        return this;\n    }\n    setServiceProps(props) {\n        this.serviceProps = props;\n        return this;\n    }\n    setInstanceCreatedCallback(callback) {\n        this.onInstanceCreated = callback;\n        return this;\n    }\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\n * NameServiceMapping[T] is an alias for the type of the instance\n */\nclass Provider {\n    constructor(name, container) {\n        this.name = name;\n        this.container = container;\n        this.component = null;\n        this.instances = new Map();\n        this.instancesDeferred = new Map();\n        this.instancesOptions = new Map();\n        this.onInitCallbacks = new Map();\n    }\n    /**\n     * @param identifier A provider can provide multiple instances of a service\n     * if this.component.multipleInstances is true.\n     */\n    get(identifier) {\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\n            const deferred = new _firebase_util__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\n            if (this.isInitialized(normalizedIdentifier) ||\n                this.shouldAutoInitialize()) {\n                // initialize the service if it can be auto-initialized\n                try {\n                    const instance = this.getOrInitializeService({\n                        instanceIdentifier: normalizedIdentifier\n                    });\n                    if (instance) {\n                        deferred.resolve(instance);\n                    }\n                }\n                catch (e) {\n                    // when the instance factory throws an exception during get(), it should not cause\n                    // a fatal error. We just return the unresolved promise in this case.\n                }\n            }\n        }\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\n    }\n    getImmediate(options) {\n        var _a;\n        // if multipleInstances is not supported, use the default name\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n        if (this.isInitialized(normalizedIdentifier) ||\n            this.shouldAutoInitialize()) {\n            try {\n                return this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n            }\n            catch (e) {\n                if (optional) {\n                    return null;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        else {\n            // In case a component is not initialized and should/cannot be auto-initialized at the moment, return null if the optional flag is set, or throw\n            if (optional) {\n                return null;\n            }\n            else {\n                throw Error(`Service ${this.name} is not available`);\n            }\n        }\n    }\n    getComponent() {\n        return this.component;\n    }\n    setComponent(component) {\n        if (component.name !== this.name) {\n            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);\n        }\n        if (this.component) {\n            throw Error(`Component for ${this.name} has already been provided`);\n        }\n        this.component = component;\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n        if (!this.shouldAutoInitialize()) {\n            return;\n        }\n        // if the service is eager, initialize the default instance\n        if (isComponentEager(component)) {\n            try {\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\n            }\n            catch (e) {\n                // when the instance factory for an eager Component throws an exception during the eager\n                // initialization, it should not cause a fatal error.\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\n                // a fatal error in this case?\n            }\n        }\n        // Create service instances for the pending promises and resolve them\n        // NOTE: if this.multipleInstances is false, only the default instance will be created\n        // and all promises with resolve with it regardless of the identifier.\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            try {\n                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n                const instance = this.getOrInitializeService({\n                    instanceIdentifier: normalizedIdentifier\n                });\n                instanceDeferred.resolve(instance);\n            }\n            catch (e) {\n                // when the instance factory throws an exception, it should not cause\n                // a fatal error. We just leave the promise unresolved.\n            }\n        }\n    }\n    clearInstance(identifier = DEFAULT_ENTRY_NAME) {\n        this.instancesDeferred.delete(identifier);\n        this.instancesOptions.delete(identifier);\n        this.instances.delete(identifier);\n    }\n    // app.delete() will call this method on every provider to delete the services\n    // TODO: should we mark the provider as deleted?\n    async delete() {\n        const services = Array.from(this.instances.values());\n        await Promise.all([\n            ...services\n                .filter(service => 'INTERNAL' in service) // legacy services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service.INTERNAL.delete()),\n            ...services\n                .filter(service => '_delete' in service) // modularized services\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .map(service => service._delete())\n        ]);\n    }\n    isComponentSet() {\n        return this.component != null;\n    }\n    isInitialized(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instances.has(identifier);\n    }\n    getOptions(identifier = DEFAULT_ENTRY_NAME) {\n        return this.instancesOptions.get(identifier) || {};\n    }\n    initialize(opts = {}) {\n        const { options = {} } = opts;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n        if (this.isInitialized(normalizedIdentifier)) {\n            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);\n        }\n        if (!this.isComponentSet()) {\n            throw Error(`Component ${this.name} has not been registered yet`);\n        }\n        const instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier,\n            options\n        });\n        // resolve any pending promise waiting for the service instance\n        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {\n            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n            if (normalizedIdentifier === normalizedDeferredIdentifier) {\n                instanceDeferred.resolve(instance);\n            }\n        }\n        return instance;\n    }\n    /**\n     *\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\n     *\n     * @param identifier An optional instance identifier\n     * @returns a function to unregister the callback\n     */\n    onInit(callback, identifier) {\n        var _a;\n        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n        existingCallbacks.add(callback);\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n        const existingInstance = this.instances.get(normalizedIdentifier);\n        if (existingInstance) {\n            callback(existingInstance, normalizedIdentifier);\n        }\n        return () => {\n            existingCallbacks.delete(callback);\n        };\n    }\n    /**\n     * Invoke onInit callbacks synchronously\n     * @param instance the service instance`\n     */\n    invokeOnInitCallbacks(instance, identifier) {\n        const callbacks = this.onInitCallbacks.get(identifier);\n        if (!callbacks) {\n            return;\n        }\n        for (const callback of callbacks) {\n            try {\n                callback(instance, identifier);\n            }\n            catch (_a) {\n                // ignore errors in the onInit callback\n            }\n        }\n    }\n    getOrInitializeService({ instanceIdentifier, options = {} }) {\n        let instance = this.instances.get(instanceIdentifier);\n        if (!instance && this.component) {\n            instance = this.component.instanceFactory(this.container, {\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n                options\n            });\n            this.instances.set(instanceIdentifier, instance);\n            this.instancesOptions.set(instanceIdentifier, options);\n            /**\n             * Invoke onInit listeners.\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\n             * while onInit listeners are registered by consumers of the provider.\n             */\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\n            /**\n             * Order is important\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\n             * makes `isInitialized()` return true.\n             */\n            if (this.component.onInstanceCreated) {\n                try {\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n                }\n                catch (_a) {\n                    // ignore errors in the onInstanceCreatedCallback\n                }\n            }\n        }\n        return instance || null;\n    }\n    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {\n        if (this.component) {\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n        }\n        else {\n            return identifier; // assume multiple instances are supported before the component is provided.\n        }\n    }\n    shouldAutoInitialize() {\n        return (!!this.component &&\n            this.component.instantiationMode !== \"EXPLICIT\" /* InstantiationMode.EXPLICIT */);\n    }\n}\n// undefined should be passed to the service factory for the default instance\nfunction normalizeIdentifierForFactory(identifier) {\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\nfunction isComponentEager(component) {\n    return component.instantiationMode === \"EAGER\" /* InstantiationMode.EAGER */;\n}\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\n */\nclass ComponentContainer {\n    constructor(name) {\n        this.name = name;\n        this.providers = new Map();\n    }\n    /**\n     *\n     * @param component Component being added\n     * @param overwrite When a component with the same name has already been registered,\n     * if overwrite is true: overwrite the existing component with the new component and create a new\n     * provider with the new component. It can be useful in tests where you want to use different mocks\n     * for different tests.\n     * if overwrite is false: throw an exception\n     */\n    addComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);\n        }\n        provider.setComponent(component);\n    }\n    addOrOverwriteComponent(component) {\n        const provider = this.getProvider(component.name);\n        if (provider.isComponentSet()) {\n            // delete the existing provider from the container, so we can register the new component\n            this.providers.delete(component.name);\n        }\n        this.addComponent(component);\n    }\n    /**\n     * getProvider provides a type safe interface where it can only be called with a field name\n     * present in NameServiceMapping interface.\n     *\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\n     * themselves.\n     */\n    getProvider(name) {\n        if (this.providers.has(name)) {\n            return this.providers.get(name);\n        }\n        // create a Provider for a service that hasn't registered with Firebase\n        const provider = new Provider(name, this);\n        this.providers.set(name, provider);\n        return provider;\n    }\n    getProviders() {\n        return Array.from(this.providers.values());\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2NvbXBvbmVudC9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQixlQUFlLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsR0FBRyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0IsbUNBQW1DLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1EO0FBQ25EIiwic291cmNlcyI6WyIvaG9tZS9yZ3RlY2gwMDgvYWNhZGVtaWMtY29ubmVjdC1wcm9qZWN0L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVmZXJyZWQgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5cbi8qKlxuICogQ29tcG9uZW50IGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxuICovXG5jbGFzcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHB1YmxpYyBzZXJ2aWNlIG5hbWUsIGUuZy4gYXBwLCBhdXRoLCBmaXJlc3RvcmUsIGRhdGFiYXNlXG4gICAgICogQHBhcmFtIGluc3RhbmNlRmFjdG9yeSBTZXJ2aWNlIGZhY3RvcnkgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBwdWJsaWMgaW50ZXJmYWNlXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgaW5zdGFuY2VGYWN0b3J5LCB0eXBlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VGYWN0b3J5ID0gaW5zdGFuY2VGYWN0b3J5O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIHRvIGJlIGFkZGVkIHRvIHRoZSBzZXJ2aWNlIG5hbWVzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJ2aWNlUHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5pbnN0YW50aWF0aW9uTW9kZSA9IFwiTEFaWVwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkxBWlkgKi87XG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRJbnN0YW50aWF0aW9uTW9kZShtb2RlKSB7XG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyA9IG11bHRpcGxlSW5zdGFuY2VzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0U2VydmljZVByb3BzKHByb3BzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZVByb3BzID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRJbnN0YW5jZUNyZWF0ZWRDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IERFRkFVTFRfRU5UUllfTkFNRSA9ICdbREVGQVVMVF0nO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXG4gKiBOYW1lU2VydmljZU1hcHBpbmdbVF0gaXMgYW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZVxuICovXG5jbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBIHByb3ZpZGVyIGNhbiBwcm92aWRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiBhIHNlcnZpY2VcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxuICAgICAqL1xuICAgIGdldChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGlmICghdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5oYXMobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGRlZmVycmVkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc2VydmljZSBpZiBpdCBjYW4gYmUgYXV0by1pbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgaW5zdGFuY2UgZmFjdG9yeSB0aHJvd3MgYW4gZXhjZXB0aW9uIGR1cmluZyBnZXQoKSwgaXQgc2hvdWxkIG5vdCBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKS5wcm9taXNlO1xuICAgIH1cbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvcHRpb25hbCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vcHRpb25hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIGEgY29tcG9uZW50IGlzIG5vdCBpbml0aWFsaXplZCBhbmQgc2hvdWxkL2Nhbm5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcbiAgICAgICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNlcnZpY2UgJHt0aGlzLm5hbWV9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcbiAgICB9XG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc21hdGNoaW5nIENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmb3IgUHJvdmlkZXIgJHt0aGlzLm5hbWV9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvbXBvbmVudCBmb3IgJHt0aGlzLm5hbWV9IGhhcyBhbHJlYWR5IGJlZW4gcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IHdpdGhvdXQgYXR0ZW1wdGluZyB0byBpbml0aWFsaXplIHRoZSBjb21wb25lbnQgaWYgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBleHBsaWNpdCBpbml0aWFsaXphdGlvbiAoY2FsbGluZyBgUHJvdmlkZXIuaW5pdGlhbGl6ZSgpYClcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxuICAgICAgICBpZiAoaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6YXRpb24sIGl0IHNob3VsZCBub3QgY2F1c2UgYSBmYXRhbCBlcnJvci5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB3ZSBuZWVkIHRvIG1ha2UgaXQgY29uZmlndXJhYmxlLCBiZWNhdXNlIHNvbWUgY29tcG9uZW50IG1heSB3YW50IHRvIGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXG4gICAgICAgIC8vIE5PVEU6IGlmIHRoaXMubXVsdGlwbGVJbnN0YW5jZXMgaXMgZmFsc2UsIG9ubHkgdGhlIGRlZmF1bHQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkXG4gICAgICAgIC8vIGFuZCBhbGwgcHJvbWlzZXMgd2l0aCByZXNvbHZlIHdpdGggaXQgcmVnYXJkbGVzcyBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IHRocm93cyBhbiBleGNlcHRpb24sIGl0IHNob3VsZCBub3QgY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IGxlYXZlIHRoZSBwcm9taXNlIHVucmVzb2x2ZWQuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuZGVsZXRlKGlkZW50aWZpZXIpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIC8vIGFwcC5kZWxldGUoKSB3aWxsIGNhbGwgdGhpcyBtZXRob2Qgb24gZXZlcnkgcHJvdmlkZXIgdG8gZGVsZXRlIHRoZSBzZXJ2aWNlc1xuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSBBcnJheS5mcm9tKHRoaXMuaW5zdGFuY2VzLnZhbHVlcygpKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgLi4uc2VydmljZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlcnZpY2UgPT4gJ0lOVEVSTkFMJyBpbiBzZXJ2aWNlKSAvLyBsZWdhY3kgc2VydmljZXNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLklOVEVSTkFMLmRlbGV0ZSgpKSxcbiAgICAgICAgICAgIC4uLnNlcnZpY2VzXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuX2RlbGV0ZSgpKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnRTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xuICAgIH1cbiAgICBpc0luaXRpYWxpemVkKGlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucyhpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihvcHRzLmluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQobm9ybWFsaXplZElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50U2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZERlZmVycmVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZURlZmVycmVkLnJlc29sdmUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkICBhZnRlciB0aGUgcHJvdmlkZXIgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgYnkgY2FsbGluZyBwcm92aWRlci5pbml0aWFsaXplKCkuXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWRlbnRpZmllciBBbiBvcHRpb25hbCBpbnN0YW5jZSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uSW5pdChjYWxsYmFjaywgaWRlbnRpZmllcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FsbGJhY2tzID0gKF9hID0gdGhpcy5vbkluaXRDYWxsYmFja3MuZ2V0KG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcy5zZXQobm9ybWFsaXplZElkZW50aWZpZXIsIGV4aXN0aW5nQ2FsbGJhY2tzKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VzLmdldChub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhleGlzdGluZ0luc3RhbmNlLCBub3JtYWxpemVkSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGV4aXN0aW5nQ2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZSBvbkluaXQgY2FsbGJhY2tzIHN5bmNocm9ub3VzbHlcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXG4gICAgICovXG4gICAgaW52b2tlT25Jbml0Q2FsbGJhY2tzKGluc3RhbmNlLCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPckluaXRpYWxpemVTZXJ2aWNlKHsgaW5zdGFuY2VJZGVudGlmaWVyLCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQoaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZUZhY3RvcnkodGhpcy5jb250YWluZXIsIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGluc3RhbmNlSWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlcy5zZXQoaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEludm9rZSBvbkluaXQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxuICAgICAgICAgICAgICogd2hpbGUgb25Jbml0IGxpc3RlbmVycyBhcmUgcmVnaXN0ZXJlZCBieSBjb25zdW1lcnMgb2YgdGhlIHByb3ZpZGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3JkZXIgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxuICAgICAgICAgICAgICogbWFrZXMgYGlzSW5pdGlhbGl6ZWQoKWAgcmV0dXJuIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50Lm9uSW5zdGFuY2VDcmVhdGVkKHRoaXMuY29udGFpbmVyLCBpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvcnMgaW4gdGhlIG9uSW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2tcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lm11bHRpcGxlSW5zdGFuY2VzID8gaWRlbnRpZmllciA6IERFRkFVTFRfRU5UUllfTkFNRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyOyAvLyBhc3N1bWUgbXVsdGlwbGUgaW5zdGFuY2VzIGFyZSBzdXBwb3J0ZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQXV0b0luaXRpYWxpemUoKSB7XG4gICAgICAgIHJldHVybiAoISF0aGlzLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XG4gICAgfVxufVxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXJGb3JGYWN0b3J5KGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllciA9PT0gREVGQVVMVF9FTlRSWV9OQU1FID8gdW5kZWZpbmVkIDogaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIGlzQ29tcG9uZW50RWFnZXIoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5pbnN0YW50aWF0aW9uTW9kZSA9PT0gXCJFQUdFUlwiIC8qIEluc3RhbnRpYXRpb25Nb2RlLkVBR0VSICovO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBDb21wb25lbnRDb250YWluZXIgdGhhdCBwcm92aWRlcyBQcm92aWRlcnMgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuIGBhdXRoYCwgYGF1dGgtaW50ZXJuYWxgXG4gKi9cbmNsYXNzIENvbXBvbmVudENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBiZWluZyBhZGRlZFxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyB0cnVlOiBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgY29tcG9uZW50IGFuZCBjcmVhdGUgYSBuZXdcbiAgICAgKiBwcm92aWRlciB3aXRoIHRoZSBuZXcgY29tcG9uZW50LiBJdCBjYW4gYmUgdXNlZnVsIGluIHRlc3RzIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgbW9ja3NcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxuICAgICAqIGlmIG92ZXJ3cml0ZSBpcyBmYWxzZTogdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICovXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvdmlkZXIuc2V0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgfVxuICAgIGFkZE9yT3ZlcndyaXRlQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoY29tcG9uZW50Lm5hbWUpO1xuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xuICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSBleGlzdGluZyBwcm92aWRlciBmcm9tIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiByZWdpc3RlciB0aGUgbmV3IGNvbXBvbmVudFxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuZGVsZXRlKGNvbXBvbmVudC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZXRQcm92aWRlciBwcm92aWRlcyBhIHR5cGUgc2FmZSBpbnRlcmZhY2Ugd2hlcmUgaXQgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBmaWVsZCBuYW1lXG4gICAgICogcHJlc2VudCBpbiBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogRmlyZWJhc2UgU0RLcyBwcm92aWRpbmcgc2VydmljZXMgc2hvdWxkIGV4dGVuZCBOYW1lU2VydmljZU1hcHBpbmcgaW50ZXJmYWNlIHRvIHJlZ2lzdGVyXG4gICAgICogdGhlbXNlbHZlcy5cbiAgICAgKi9cbiAgICBnZXRQcm92aWRlcihuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIGEgUHJvdmlkZXIgZm9yIGEgc2VydmljZSB0aGF0IGhhc24ndCByZWdpc3RlcmVkIHdpdGggRmlyZWJhc2VcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuYW1lLCBwcm92aWRlcik7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgZ2V0UHJvdmlkZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnByb3ZpZGVycy52YWx1ZXMoKSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21wb25lbnQsIENvbXBvbmVudENvbnRhaW5lciwgUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@firebase/logger/dist/esm/index.esm2017.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   setUserLogHandler: () => (/* binding */ setUserLogHandler)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nconst instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nconst levelStringToEnum = {\n    'debug': LogLevel.DEBUG,\n    'verbose': LogLevel.VERBOSE,\n    'info': LogLevel.INFO,\n    'warn': LogLevel.WARN,\n    'error': LogLevel.ERROR,\n    'silent': LogLevel.SILENT\n};\n/**\n * The default log level\n */\nconst defaultLogLevel = LogLevel.INFO;\n/**\n * By default, `console.debug` is not displayed in the developer console (in\n * chrome). To avoid forcing users to have to opt-in to these logs twice\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n * logs to the `console.log` function.\n */\nconst ConsoleMethod = {\n    [LogLevel.DEBUG]: 'log',\n    [LogLevel.VERBOSE]: 'log',\n    [LogLevel.INFO]: 'info',\n    [LogLevel.WARN]: 'warn',\n    [LogLevel.ERROR]: 'error'\n};\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nconst defaultLogHandler = (instance, logType, ...args) => {\n    if (logType < instance.logLevel) {\n        return;\n    }\n    const now = new Date().toISOString();\n    const method = ConsoleMethod[logType];\n    if (method) {\n        console[method](`[${now}]  ${instance.name}:`, ...args);\n    }\n    else {\n        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);\n    }\n};\nclass Logger {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    constructor(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The main (internal) log handler for the Logger instance.\n         * Can be set to a new function in internal package code but not by user.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * The optional, additional, user-defined log handler for the Logger instance.\n         */\n        this._userLogHandler = null;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(val) {\n        if (!(val in LogLevel)) {\n            throw new TypeError(`Invalid value \"${val}\" assigned to \\`logLevel\\``);\n        }\n        this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n    setLogLevel(val) {\n        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n    get logHandler() {\n        return this._logHandler;\n    }\n    set logHandler(val) {\n        if (typeof val !== 'function') {\n            throw new TypeError('Value assigned to `logHandler` must be a function');\n        }\n        this._logHandler = val;\n    }\n    get userLogHandler() {\n        return this._userLogHandler;\n    }\n    set userLogHandler(val) {\n        this._userLogHandler = val;\n    }\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    debug(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);\n        this._logHandler(this, LogLevel.DEBUG, ...args);\n    }\n    log(...args) {\n        this._userLogHandler &&\n            this._userLogHandler(this, LogLevel.VERBOSE, ...args);\n        this._logHandler(this, LogLevel.VERBOSE, ...args);\n    }\n    info(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);\n        this._logHandler(this, LogLevel.INFO, ...args);\n    }\n    warn(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);\n        this._logHandler(this, LogLevel.WARN, ...args);\n    }\n    error(...args) {\n        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);\n        this._logHandler(this, LogLevel.ERROR, ...args);\n    }\n}\nfunction setLogLevel(level) {\n    instances.forEach(inst => {\n        inst.setLogLevel(level);\n    });\n}\nfunction setUserLogHandler(logCallback, options) {\n    for (const instance of instances) {\n        let customLogLevel = null;\n        if (options && options.level) {\n            customLogLevel = levelStringToEnum[options.level];\n        }\n        if (logCallback === null) {\n            instance.userLogHandler = null;\n        }\n        else {\n            instance.userLogHandler = (instance, level, ...args) => {\n                const message = args\n                    .map(arg => {\n                    if (arg == null) {\n                        return null;\n                    }\n                    else if (typeof arg === 'string') {\n                        return arg;\n                    }\n                    else if (typeof arg === 'number' || typeof arg === 'boolean') {\n                        return arg.toString();\n                    }\n                    else if (arg instanceof Error) {\n                        return arg.message;\n                    }\n                    else {\n                        try {\n                            return JSON.stringify(arg);\n                        }\n                        catch (ignored) {\n                            return null;\n                        }\n                    }\n                })\n                    .filter(arg => arg)\n                    .join(' ');\n                if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n                    logCallback({\n                        level: LogLevel[level].toLowerCase(),\n                        message,\n                        args,\n                        type: instance.name\n                    });\n                }\n            };\n        }\n    }\n}\n\n\n//# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLEtBQUssY0FBYztBQUNuRDtBQUNBO0FBQ0Esc0ZBQXNGLFFBQVE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEQ7QUFDNUQiLCJzb3VyY2VzIjpbIi9ob21lL3JndGVjaDAwOC9hY2FkZW1pYy1jb25uZWN0LXByb2plY3Qvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9sb2dnZXIvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXG4gKi9cbmNvbnN0IGluc3RhbmNlcyA9IFtdO1xuLyoqXG4gKiBUaGUgSlMgU0RLIHN1cHBvcnRzIDUgbG9nIGxldmVscyBhbmQgYWxzbyBhbGxvd3MgYSB1c2VyIHRoZSBhYmlsaXR5IHRvXG4gKiBzaWxlbmNlIHRoZSBsb2dzIGFsdG9nZXRoZXIuXG4gKlxuICogVGhlIG9yZGVyIGlzIGEgZm9sbG93czpcbiAqIERFQlVHIDwgVkVSQk9TRSA8IElORk8gPCBXQVJOIDwgRVJST1JcbiAqXG4gKiBBbGwgb2YgdGhlIGxvZyB0eXBlcyBhYm92ZSB0aGUgY3VycmVudCBsb2cgbGV2ZWwgd2lsbCBiZSBjYXB0dXJlZCAoaS5lLiBpZlxuICogeW91IHNldCB0aGUgbG9nIGxldmVsIHRvIGBJTkZPYCwgZXJyb3JzIHdpbGwgc3RpbGwgYmUgbG9nZ2VkLCBidXQgYERFQlVHYCBhbmRcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiVkVSQk9TRVwiXSA9IDFdID0gXCJWRVJCT1NFXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldBUk5cIl0gPSAzXSA9IFwiV0FSTlwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRVJST1JcIl0gPSA0XSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5jb25zdCBsZXZlbFN0cmluZ1RvRW51bSA9IHtcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAndmVyYm9zZSc6IExvZ0xldmVsLlZFUkJPU0UsXG4gICAgJ2luZm8nOiBMb2dMZXZlbC5JTkZPLFxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcbiAgICAnZXJyb3InOiBMb2dMZXZlbC5FUlJPUixcbiAgICAnc2lsZW50JzogTG9nTGV2ZWwuU0lMRU5UXG59O1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBsb2cgbGV2ZWxcbiAqL1xuY29uc3QgZGVmYXVsdExvZ0xldmVsID0gTG9nTGV2ZWwuSU5GTztcbi8qKlxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxuICogY2hyb21lKS4gVG8gYXZvaWQgZm9yY2luZyB1c2VycyB0byBoYXZlIHRvIG9wdC1pbiB0byB0aGVzZSBsb2dzIHR3aWNlXG4gKiAoaS5lLiBvbmNlIGZvciBmaXJlYmFzZSwgYW5kIG9uY2UgaW4gdGhlIGNvbnNvbGUpLCB3ZSBhcmUgc2VuZGluZyBgREVCVUdgXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxuICovXG5jb25zdCBDb25zb2xlTWV0aG9kID0ge1xuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxuICAgIFtMb2dMZXZlbC5WRVJCT1NFXTogJ2xvZycsXG4gICAgW0xvZ0xldmVsLklORk9dOiAnaW5mbycsXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXG4gICAgW0xvZ0xldmVsLkVSUk9SXTogJ2Vycm9yJ1xufTtcbi8qKlxuICogVGhlIGRlZmF1bHQgbG9nIGhhbmRsZXIgd2lsbCBmb3J3YXJkIERFQlVHLCBWRVJCT1NFLCBJTkZPLCBXQVJOLCBhbmQgRVJST1JcbiAqIG1lc3NhZ2VzIG9uIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcgY29uc29sZSBjb3VudGVycGFydHMgKGlmIHRoZSBsb2cgbWV0aG9kXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxuICovXG5jb25zdCBkZWZhdWx0TG9nSGFuZGxlciA9IChpbnN0YW5jZSwgbG9nVHlwZSwgLi4uYXJncykgPT4ge1xuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgbWV0aG9kID0gQ29uc29sZU1ldGhvZFtsb2dUeXBlXTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcbiAgICB9XG59O1xuY2xhc3MgTG9nZ2VyIHtcbiAgICAvKipcbiAgICAgKiBHaXZlcyB5b3UgYW4gaW5zdGFuY2Ugb2YgYSBMb2dnZXIgdG8gY2FwdHVyZSBtZXNzYWdlcyBhY2NvcmRpbmcgdG9cbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgdGhhdCB0aGUgbG9ncyB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsb2cgbGV2ZWwgb2YgdGhlIGdpdmVuIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1haW4gKGludGVybmFsKSBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IGRlZmF1bHRMb2dIYW5kbGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wdGlvbmFsLCBhZGRpdGlvbmFsLCB1c2VyLWRlZmluZWQgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXB0dXJlIHRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBsYXRlciB1c2VcbiAgICAgICAgICovXG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbG9nTGV2ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICB9XG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xuICAgICAgICBpZiAoISh2YWwgaW4gTG9nTGV2ZWwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIFwiJHt2YWx9XCIgYXNzaWduZWQgdG8gXFxgbG9nTGV2ZWxcXGBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbDtcbiAgICB9XG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cbiAgICBzZXRMb2dMZXZlbCh2YWwpIHtcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IGxldmVsU3RyaW5nVG9FbnVtW3ZhbF0gOiB2YWw7XG4gICAgfVxuICAgIGdldCBsb2dIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nSGFuZGxlcjtcbiAgICB9XG4gICAgc2V0IGxvZ0hhbmRsZXIodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlciA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IHVzZXJMb2dIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlckxvZ0hhbmRsZXI7XG4gICAgfVxuICAgIHNldCB1c2VyTG9nSGFuZGxlcih2YWwpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGFsbCBiYXNlZCBvbiB0aGUgYGNvbnNvbGVgIGludGVyZmFjZVxuICAgICAqL1xuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuREVCVUcsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcbiAgICAgICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLlZFUkJPU0UsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiYgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgZXJyb3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5FUlJPUiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuRVJST1IsIC4uLmFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsKSB7XG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XG4gICAgICAgIGluc3Quc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VXNlckxvZ0hhbmRsZXIobG9nQ2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmxldmVsKSB7XG4gICAgICAgICAgICBjdXN0b21Mb2dMZXZlbCA9IGxldmVsU3RyaW5nVG9FbnVtW29wdGlvbnMubGV2ZWxdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dDYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UudXNlckxvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxldmVsLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcbiAgICAgICAgICAgICAgICAgICAgLm1hcChhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYXJnID0+IGFyZylcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPj0gKGN1c3RvbUxvZ0xldmVsICE9PSBudWxsICYmIGN1c3RvbUxvZ0xldmVsICE9PSB2b2lkIDAgPyBjdXN0b21Mb2dMZXZlbCA6IGluc3RhbmNlLmxvZ0xldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dDYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@firebase/util/dist/node-esm/index.node.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANTS: () => (/* binding */ CONSTANTS),\n/* harmony export */   DecodeBase64StringError: () => (/* binding */ DecodeBase64StringError),\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   ErrorFactory: () => (/* binding */ ErrorFactory),\n/* harmony export */   FirebaseError: () => (/* binding */ FirebaseError),\n/* harmony export */   MAX_VALUE_MILLIS: () => (/* binding */ MAX_VALUE_MILLIS),\n/* harmony export */   RANDOM_FACTOR: () => (/* binding */ RANDOM_FACTOR),\n/* harmony export */   Sha1: () => (/* binding */ Sha1),\n/* harmony export */   areCookiesEnabled: () => (/* binding */ areCookiesEnabled),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assertionError: () => (/* binding */ assertionError),\n/* harmony export */   async: () => (/* binding */ async),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64Decode: () => (/* binding */ base64Decode),\n/* harmony export */   base64Encode: () => (/* binding */ base64Encode),\n/* harmony export */   base64urlEncodeWithoutPadding: () => (/* binding */ base64urlEncodeWithoutPadding),\n/* harmony export */   calculateBackoffMillis: () => (/* binding */ calculateBackoffMillis),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createMockUserToken: () => (/* binding */ createMockUserToken),\n/* harmony export */   createSubscribe: () => (/* binding */ createSubscribe),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   deepCopy: () => (/* binding */ deepCopy),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   deepExtend: () => (/* binding */ deepExtend),\n/* harmony export */   errorPrefix: () => (/* binding */ errorPrefix),\n/* harmony export */   extractQuerystring: () => (/* binding */ extractQuerystring),\n/* harmony export */   getDefaultAppConfig: () => (/* binding */ getDefaultAppConfig),\n/* harmony export */   getDefaultEmulatorHost: () => (/* binding */ getDefaultEmulatorHost),\n/* harmony export */   getDefaultEmulatorHostnameAndPort: () => (/* binding */ getDefaultEmulatorHostnameAndPort),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getExperimentalSetting: () => (/* binding */ getExperimentalSetting),\n/* harmony export */   getGlobal: () => (/* binding */ getGlobal),\n/* harmony export */   getModularInstance: () => (/* binding */ getModularInstance),\n/* harmony export */   getUA: () => (/* binding */ getUA),\n/* harmony export */   isAdmin: () => (/* binding */ isAdmin),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isBrowserExtension: () => (/* binding */ isBrowserExtension),\n/* harmony export */   isCloudflareWorker: () => (/* binding */ isCloudflareWorker),\n/* harmony export */   isElectron: () => (/* binding */ isElectron),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isIE: () => (/* binding */ isIE),\n/* harmony export */   isIndexedDBAvailable: () => (/* binding */ isIndexedDBAvailable),\n/* harmony export */   isMobileCordova: () => (/* binding */ isMobileCordova),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isNodeSdk: () => (/* binding */ isNodeSdk),\n/* harmony export */   isReactNative: () => (/* binding */ isReactNative),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isUWP: () => (/* binding */ isUWP),\n/* harmony export */   isValidFormat: () => (/* binding */ isValidFormat),\n/* harmony export */   isValidTimestamp: () => (/* binding */ isValidTimestamp),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   issuedAtTime: () => (/* binding */ issuedAtTime),\n/* harmony export */   jsonEval: () => (/* binding */ jsonEval),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   ordinal: () => (/* binding */ ordinal),\n/* harmony export */   promiseWithTimeout: () => (/* binding */ promiseWithTimeout),\n/* harmony export */   querystring: () => (/* binding */ querystring),\n/* harmony export */   querystringDecode: () => (/* binding */ querystringDecode),\n/* harmony export */   safeGet: () => (/* binding */ safeGet),\n/* harmony export */   stringLength: () => (/* binding */ stringLength),\n/* harmony export */   stringToByteArray: () => (/* binding */ stringToByteArray),\n/* harmony export */   stringify: () => (/* binding */ stringify),\n/* harmony export */   uuidv4: () => (/* binding */ uuidv4),\n/* harmony export */   validateArgCount: () => (/* binding */ validateArgCount),\n/* harmony export */   validateCallback: () => (/* binding */ validateCallback),\n/* harmony export */   validateContextObject: () => (/* binding */ validateContextObject),\n/* harmony export */   validateIndexedDBOpenable: () => (/* binding */ validateIndexedDBOpenable),\n/* harmony export */   validateNamespace: () => (/* binding */ validateNamespace)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.\n */\nconst CONSTANTS = {\n    /**\n     * @define {boolean} Whether this is the client Node.js SDK.\n     */\n    NODE_CLIENT: false,\n    /**\n     * @define {boolean} Whether this is the Admin Node.js SDK.\n     */\n    NODE_ADMIN: false,\n    /**\n     * Firebase SDK Version\n     */\n    SDK_VERSION: '${JSCORE_VERSION}'\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Throws an error if the provided assertion is falsy\n */\nconst assert = function (assertion, message) {\n    if (!assertion) {\n        throw assertionError(message);\n    }\n};\n/**\n * Returns an Error object suitable for throwing.\n */\nconst assertionError = function (message) {\n    return new Error('Firebase Database (' +\n        CONSTANTS.SDK_VERSION +\n        ') INTERNAL ASSERT FAILED: ' +\n        message);\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst stringToByteArray$1 = function (str) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if ((c & 0xfc00) === 0xd800 &&\n            i + 1 < str.length &&\n            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {\n            // Surrogate Pair\n            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Turns an array of numbers into the string given by the concatenation of the\n * characters to which the numbers correspond.\n * @param bytes Array of numbers representing characters.\n * @return Stringification of the array.\n */\nconst byteArrayToString = function (bytes) {\n    // TODO(user): Use native implementations if/when available\n    const out = [];\n    let pos = 0, c = 0;\n    while (pos < bytes.length) {\n        const c1 = bytes[pos++];\n        if (c1 < 128) {\n            out[c++] = String.fromCharCode(c1);\n        }\n        else if (c1 > 191 && c1 < 224) {\n            const c2 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));\n        }\n        else if (c1 > 239 && c1 < 365) {\n            // Surrogate Pair\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            const c4 = bytes[pos++];\n            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -\n                0x10000;\n            out[c++] = String.fromCharCode(0xd800 + (u >> 10));\n            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));\n        }\n        else {\n            const c2 = bytes[pos++];\n            const c3 = bytes[pos++];\n            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n        }\n    }\n    return out.join('');\n};\n// We define it as an object literal instead of a class because a class compiled down to es5 can't\n// be treeshaked. https://github.com/rollup/rollup/issues/1691\n// Static lookup maps, lazily populated by init_()\n// TODO(dlarocque): Define this as a class, since we no longer target ES5.\nconst base64 = {\n    /**\n     * Maps bytes to characters.\n     */\n    byteToCharMap_: null,\n    /**\n     * Maps characters to bytes.\n     */\n    charToByteMap_: null,\n    /**\n     * Maps bytes to websafe characters.\n     * @private\n     */\n    byteToCharMapWebSafe_: null,\n    /**\n     * Maps websafe characters to bytes.\n     * @private\n     */\n    charToByteMapWebSafe_: null,\n    /**\n     * Our default alphabet, shared between\n     * ENCODED_VALS and ENCODED_VALS_WEBSAFE\n     */\n    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',\n    /**\n     * Our default alphabet. Value 64 (=) is special; it means \"nothing.\"\n     */\n    get ENCODED_VALS() {\n        return this.ENCODED_VALS_BASE + '+/=';\n    },\n    /**\n     * Our websafe alphabet.\n     */\n    get ENCODED_VALS_WEBSAFE() {\n        return this.ENCODED_VALS_BASE + '-_.';\n    },\n    /**\n     * Whether this browser supports the atob and btoa functions. This extension\n     * started at Mozilla but is now implemented by many browsers. We use the\n     * ASSUME_* variables to avoid pulling in the full useragent detection library\n     * but still allowing the standard per-browser compilations.\n     *\n     */\n    HAS_NATIVE_SUPPORT: typeof atob === 'function',\n    /**\n     * Base64-encode an array of bytes.\n     *\n     * @param input An array of bytes (numbers with\n     *     value in [0, 255]) to encode.\n     * @param webSafe Boolean indicating we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeByteArray(input, webSafe) {\n        if (!Array.isArray(input)) {\n            throw Error('encodeByteArray takes an array as a parameter');\n        }\n        this.init_();\n        const byteToCharMap = webSafe\n            ? this.byteToCharMapWebSafe_\n            : this.byteToCharMap_;\n        const output = [];\n        for (let i = 0; i < input.length; i += 3) {\n            const byte1 = input[i];\n            const haveByte2 = i + 1 < input.length;\n            const byte2 = haveByte2 ? input[i + 1] : 0;\n            const haveByte3 = i + 2 < input.length;\n            const byte3 = haveByte3 ? input[i + 2] : 0;\n            const outByte1 = byte1 >> 2;\n            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n            let outByte4 = byte3 & 0x3f;\n            if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                    outByte3 = 64;\n                }\n            }\n            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);\n        }\n        return output.join('');\n    },\n    /**\n     * Base64-encode a string.\n     *\n     * @param input A string to encode.\n     * @param webSafe If true, we should use the\n     *     alternative alphabet.\n     * @return The base64 encoded string.\n     */\n    encodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return btoa(input);\n        }\n        return this.encodeByteArray(stringToByteArray$1(input), webSafe);\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * @param input to decode.\n     * @param webSafe True if we should use the\n     *     alternative alphabet.\n     * @return string representing the decoded value.\n     */\n    decodeString(input, webSafe) {\n        // Shortcut for Mozilla browsers that implement\n        // a native base64 encoder in the form of \"btoa/atob\"\n        if (this.HAS_NATIVE_SUPPORT && !webSafe) {\n            return atob(input);\n        }\n        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));\n    },\n    /**\n     * Base64-decode a string.\n     *\n     * In base-64 decoding, groups of four characters are converted into three\n     * bytes.  If the encoder did not apply padding, the input length may not\n     * be a multiple of 4.\n     *\n     * In this case, the last group will have fewer than 4 characters, and\n     * padding will be inferred.  If the group has one or two characters, it decodes\n     * to one byte.  If the group has three characters, it decodes to two bytes.\n     *\n     * @param input Input to decode.\n     * @param webSafe True if we should use the web-safe alphabet.\n     * @return bytes representing the decoded value.\n     */\n    decodeStringToByteArray(input, webSafe) {\n        this.init_();\n        const charToByteMap = webSafe\n            ? this.charToByteMapWebSafe_\n            : this.charToByteMap_;\n        const output = [];\n        for (let i = 0; i < input.length;) {\n            const byte1 = charToByteMap[input.charAt(i++)];\n            const haveByte2 = i < input.length;\n            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;\n            ++i;\n            const haveByte3 = i < input.length;\n            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            const haveByte4 = i < input.length;\n            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;\n            ++i;\n            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {\n                throw new DecodeBase64StringError();\n            }\n            const outByte1 = (byte1 << 2) | (byte2 >> 4);\n            output.push(outByte1);\n            if (byte3 !== 64) {\n                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);\n                output.push(outByte2);\n                if (byte4 !== 64) {\n                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;\n                    output.push(outByte3);\n                }\n            }\n        }\n        return output;\n    },\n    /**\n     * Lazy static initialization function. Called before\n     * accessing any of the static map variables.\n     * @private\n     */\n    init_() {\n        if (!this.byteToCharMap_) {\n            this.byteToCharMap_ = {};\n            this.charToByteMap_ = {};\n            this.byteToCharMapWebSafe_ = {};\n            this.charToByteMapWebSafe_ = {};\n            // We want quick mappings back and forth, so we precompute two maps.\n            for (let i = 0; i < this.ENCODED_VALS.length; i++) {\n                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);\n                this.charToByteMap_[this.byteToCharMap_[i]] = i;\n                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);\n                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;\n                // Be forgiving when decoding and correctly decode both encodings.\n                if (i >= this.ENCODED_VALS_BASE.length) {\n                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;\n                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;\n                }\n            }\n        }\n    }\n};\n/**\n * An error encountered while decoding base64 string.\n */\nclass DecodeBase64StringError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'DecodeBase64StringError';\n    }\n}\n/**\n * URL-safe base64 encoding\n */\nconst base64Encode = function (str) {\n    const utf8Bytes = stringToByteArray$1(str);\n    return base64.encodeByteArray(utf8Bytes, true);\n};\n/**\n * URL-safe base64 encoding (without \".\" padding in the end).\n * e.g. Used in JSON Web Token (JWT) parts.\n */\nconst base64urlEncodeWithoutPadding = function (str) {\n    // Use base64url encoding and remove padding in the end (dot characters).\n    return base64Encode(str).replace(/\\./g, '');\n};\n/**\n * URL-safe base64 decoding\n *\n * NOTE: DO NOT use the global atob() function - it does NOT support the\n * base64Url variant encoding.\n *\n * @param str To be decoded\n * @return Decoded result, if possible\n */\nconst base64Decode = function (str) {\n    try {\n        return base64.decodeString(str, true);\n    }\n    catch (e) {\n        console.error('base64Decode failed: ', e);\n    }\n    return null;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Do a deep-copy of basic JavaScript Objects or Arrays.\n */\nfunction deepCopy(value) {\n    return deepExtend(undefined, value);\n}\n/**\n * Copy properties from source to target (recursively allows extension\n * of Objects and Arrays).  Scalar values in the target are over-written.\n * If target is undefined, an object of the appropriate type will be created\n * (and returned).\n *\n * We recursively copy all child properties of plain Objects in the source- so\n * that namespace- like dictionaries are merged.\n *\n * Note that the target can be a function, in which case the properties in\n * the source Object are copied onto it as static properties of the Function.\n *\n * Note: we don't merge __proto__ to prevent prototype pollution\n */\nfunction deepExtend(target, source) {\n    if (!(source instanceof Object)) {\n        return source;\n    }\n    switch (source.constructor) {\n        case Date:\n            // Treat Dates like scalars; if the target date object had any child\n            // properties - they will be lost!\n            const dateValue = source;\n            return new Date(dateValue.getTime());\n        case Object:\n            if (target === undefined) {\n                target = {};\n            }\n            break;\n        case Array:\n            // Always copy the array source and overwrite the target.\n            target = [];\n            break;\n        default:\n            // Not a plain Object - treat it as a scalar.\n            return source;\n    }\n    for (const prop in source) {\n        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202\n        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {\n            continue;\n        }\n        target[prop] = deepExtend(target[prop], source[prop]);\n    }\n    return target;\n}\nfunction isValidKey(key) {\n    return key !== '__proto__';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Polyfill for `globalThis` object.\n * @returns the `globalThis` object for the given environment.\n * @public\n */\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('Unable to locate global object.');\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;\n/**\n * Attempt to read defaults from a JSON string provided to\n * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in\n * process(.)env(.)__FIREBASE_DEFAULTS_PATH__\n * The dots are in parens because certain compilers (Vite?) cannot\n * handle seeing that variable in comments.\n * See https://github.com/firebase/firebase-js-sdk/issues/6838\n */\nconst getDefaultsFromEnvVariable = () => {\n    if (typeof process === 'undefined' || typeof process.env === 'undefined') {\n        return;\n    }\n    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;\n    if (defaultsJsonString) {\n        return JSON.parse(defaultsJsonString);\n    }\n};\nconst getDefaultsFromCookie = () => {\n    if (typeof document === 'undefined') {\n        return;\n    }\n    let match;\n    try {\n        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);\n    }\n    catch (e) {\n        // Some environments such as Angular Universal SSR have a\n        // `document` object but error on accessing `document.cookie`.\n        return;\n    }\n    const decoded = match && base64Decode(match[1]);\n    return decoded && JSON.parse(decoded);\n};\n/**\n * Get the __FIREBASE_DEFAULTS__ object. It checks in order:\n * (1) if such an object exists as a property of `globalThis`\n * (2) if such an object was provided on a shell environment variable\n * (3) if such an object exists in a cookie\n * @public\n */\nconst getDefaults = () => {\n    try {\n        return (getDefaultsFromGlobal() ||\n            getDefaultsFromEnvVariable() ||\n            getDefaultsFromCookie());\n    }\n    catch (e) {\n        /**\n         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due\n         * to any environment case we have not accounted for. Log to\n         * info instead of swallowing so we can find these unknown cases\n         * and add paths for them if needed.\n         */\n        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);\n        return;\n    }\n};\n/**\n * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available\n * @public\n */\nconst getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };\n/**\n * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object\n * for the given product.\n * @returns a pair of hostname and port like `[\"::1\", 4000]` if available\n * @public\n */\nconst getDefaultEmulatorHostnameAndPort = (productName) => {\n    const host = getDefaultEmulatorHost(productName);\n    if (!host) {\n        return undefined;\n    }\n    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.\n    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {\n        throw new Error(`Invalid host ${host} with no separate hostname and port!`);\n    }\n    // eslint-disable-next-line no-restricted-globals\n    const port = parseInt(host.substring(separatorIndex + 1), 10);\n    if (host[0] === '[') {\n        // Bracket-quoted `[ipv6addr]:port` => return \"ipv6addr\" (without brackets).\n        return [host.substring(1, separatorIndex - 1), port];\n    }\n    else {\n        return [host.substring(0, separatorIndex), port];\n    }\n};\n/**\n * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.\n * @public\n */\nconst getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };\n/**\n * Returns an experimental setting on the __FIREBASE_DEFAULTS__ object (properties\n * prefixed by \"_\")\n * @public\n */\nconst getExperimentalSetting = (name) => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`]; };\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Deferred {\n    constructor() {\n        this.reject = () => { };\n        this.resolve = () => { };\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    /**\n     * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around\n     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback\n     * and returns a node-style callback which will resolve or reject the Deferred's promise.\n     */\n    wrapCallback(callback) {\n        return (error, value) => {\n            if (error) {\n                this.reject(error);\n            }\n            else {\n                this.resolve(value);\n            }\n            if (typeof callback === 'function') {\n                // Attaching noop handler just in case developer wasn't expecting\n                // promises\n                this.promise.catch(() => { });\n                // Some of our callbacks don't expect a value and our own tests\n                // assert that the parameter length is 1\n                if (callback.length === 1) {\n                    callback(error);\n                }\n                else {\n                    callback(error, value);\n                }\n            }\n        };\n    }\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction createMockUserToken(token, projectId) {\n    if (token.uid) {\n        throw new Error('The \"uid\" field is no longer supported by mockUserToken. Please use \"sub\" instead for Firebase Auth User ID.');\n    }\n    // Unsecured JWTs use \"none\" as the algorithm.\n    const header = {\n        alg: 'none',\n        type: 'JWT'\n    };\n    const project = projectId || 'demo-project';\n    const iat = token.iat || 0;\n    const sub = token.sub || token.user_id;\n    if (!sub) {\n        throw new Error(\"mockUserToken must contain 'sub' or 'user_id' field!\");\n    }\n    const payload = Object.assign({ \n        // Set all required fields to decent defaults\n        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {\n            sign_in_provider: 'custom',\n            identities: {}\n        } }, token);\n    // Unsecured JWTs use the empty string as a signature.\n    const signature = '';\n    return [\n        base64urlEncodeWithoutPadding(JSON.stringify(header)),\n        base64urlEncodeWithoutPadding(JSON.stringify(payload)),\n        signature\n    ].join('.');\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns navigator.userAgent string or '' if it's not defined.\n * @return user agent string\n */\nfunction getUA() {\n    if (typeof navigator !== 'undefined' &&\n        typeof navigator['userAgent'] === 'string') {\n        return navigator['userAgent'];\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.\n *\n * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap\n * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally\n * wait for a callback.\n */\nfunction isMobileCordova() {\n    return (typeof window !== 'undefined' &&\n        // @ts-ignore Setting up an broadly applicable index signature for Window\n        // just to deal with this case would probably be a bad idea.\n        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&\n        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));\n}\n/**\n * Detect Node.js.\n *\n * @return true if Node.js environment is detected or specified.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nfunction isNode() {\n    var _a;\n    const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;\n    if (forceEnvironment === 'node') {\n        return true;\n    }\n    else if (forceEnvironment === 'browser') {\n        return false;\n    }\n    try {\n        return (Object.prototype.toString.call(global.process) === '[object process]');\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * Detect Browser Environment.\n * Note: This will return true for certain test frameworks that are incompletely\n * mimicking a browser, and should not lead to assuming all browser APIs are\n * available.\n */\nfunction isBrowser() {\n    return typeof window !== 'undefined' || isWebWorker();\n}\n/**\n * Detect Web Worker context.\n */\nfunction isWebWorker() {\n    return (typeof WorkerGlobalScope !== 'undefined' &&\n        typeof self !== 'undefined' &&\n        self instanceof WorkerGlobalScope);\n}\n/**\n * Detect Cloudflare Worker context.\n */\nfunction isCloudflareWorker() {\n    return (typeof navigator !== 'undefined' &&\n        navigator.userAgent === 'Cloudflare-Workers');\n}\nfunction isBrowserExtension() {\n    const runtime = typeof chrome === 'object'\n        ? chrome.runtime\n        : typeof browser === 'object'\n            ? browser.runtime\n            : undefined;\n    return typeof runtime === 'object' && runtime.id !== undefined;\n}\n/**\n * Detect React Native.\n *\n * @return true if ReactNative environment is detected.\n */\nfunction isReactNative() {\n    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');\n}\n/** Detects Electron apps. */\nfunction isElectron() {\n    return getUA().indexOf('Electron/') >= 0;\n}\n/** Detects Internet Explorer. */\nfunction isIE() {\n    const ua = getUA();\n    return ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;\n}\n/** Detects Universal Windows Platform apps. */\nfunction isUWP() {\n    return getUA().indexOf('MSAppHost/') >= 0;\n}\n/**\n * Detect whether the current SDK build is the Node version.\n *\n * @return true if it's the Node SDK build.\n */\nfunction isNodeSdk() {\n    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;\n}\n/** Returns true if we are running in Safari. */\nfunction isSafari() {\n    return (!isNode() &&\n        !!navigator.userAgent &&\n        navigator.userAgent.includes('Safari') &&\n        !navigator.userAgent.includes('Chrome'));\n}\n/**\n * This method checks if indexedDB is supported by current browser/service worker context\n * @return true if indexedDB is supported by current browser/service worker context\n */\nfunction isIndexedDBAvailable() {\n    try {\n        return typeof indexedDB === 'object';\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject\n * if errors occur during the database open operation.\n *\n * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox\n * private browsing)\n */\nfunction validateIndexedDBOpenable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let preExist = true;\n            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';\n            const request = self.indexedDB.open(DB_CHECK_NAME);\n            request.onsuccess = () => {\n                request.result.close();\n                // delete database only when it doesn't pre-exist\n                if (!preExist) {\n                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);\n                }\n                resolve(true);\n            };\n            request.onupgradeneeded = () => {\n                preExist = false;\n            };\n            request.onerror = () => {\n                var _a;\n                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');\n            };\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n *\n * This method checks whether cookie is enabled within current browser\n * @return true if cookie is enabled within current browser\n */\nfunction areCookiesEnabled() {\n    if (typeof navigator === 'undefined' || !navigator.cookieEnabled) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview Standardized Firebase Error.\n *\n * Usage:\n *\n *   // TypeScript string literals for type-safe codes\n *   type Err =\n *     'unknown' |\n *     'object-not-found'\n *     ;\n *\n *   // Closure enum for type-safe error codes\n *   // at-enum {string}\n *   var Err = {\n *     UNKNOWN: 'unknown',\n *     OBJECT_NOT_FOUND: 'object-not-found',\n *   }\n *\n *   let errors: Map<Err, string> = {\n *     'generic-error': \"Unknown error\",\n *     'file-not-found': \"Could not find file: {$file}\",\n *   };\n *\n *   // Type-safe function - must pass a valid error code as param.\n *   let error = new ErrorFactory<Err>('service', 'Service', errors);\n *\n *   ...\n *   throw error.create(Err.GENERIC);\n *   ...\n *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});\n *   ...\n *   // Service: Could not file file: foo.txt (service/file-not-found).\n *\n *   catch (e) {\n *     assert(e.message === \"Could not find file: foo.txt.\");\n *     if ((e as FirebaseError)?.code === 'service/file-not-found') {\n *       console.log(\"Could not read file: \" + e['file']);\n *     }\n *   }\n */\nconst ERROR_NAME = 'FirebaseError';\n// Based on code from:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\nclass FirebaseError extends Error {\n    constructor(\n    /** The error code for this error. */\n    code, message, \n    /** Custom data for this error. */\n    customData) {\n        super(message);\n        this.code = code;\n        this.customData = customData;\n        /** The custom name for all FirebaseErrors. */\n        this.name = ERROR_NAME;\n        // Fix For ES5\n        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        // TODO(dlarocque): Replace this with `new.target`: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n        //                   which we can now use since we no longer target ES5.\n        Object.setPrototypeOf(this, FirebaseError.prototype);\n        // Maintains proper stack trace for where our error was thrown.\n        // Only available on V8.\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ErrorFactory.prototype.create);\n        }\n    }\n}\nclass ErrorFactory {\n    constructor(service, serviceName, errors) {\n        this.service = service;\n        this.serviceName = serviceName;\n        this.errors = errors;\n    }\n    create(code, ...data) {\n        const customData = data[0] || {};\n        const fullCode = `${this.service}/${code}`;\n        const template = this.errors[code];\n        const message = template ? replaceTemplate(template, customData) : 'Error';\n        // Service Name: Error message (service/code).\n        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;\n        const error = new FirebaseError(fullCode, fullMessage, customData);\n        return error;\n    }\n}\nfunction replaceTemplate(template, data) {\n    return template.replace(PATTERN, (_, key) => {\n        const value = data[key];\n        return value != null ? String(value) : `<${key}?>`;\n    });\n}\nconst PATTERN = /\\{\\$([^}]+)}/g;\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Evaluates a JSON string into a javascript object.\n *\n * @param {string} str A string containing JSON.\n * @return {*} The javascript object representing the specified JSON.\n */\nfunction jsonEval(str) {\n    return JSON.parse(str);\n}\n/**\n * Returns JSON representing a javascript object.\n * @param {*} data JavaScript object to be stringified.\n * @return {string} The JSON contents of the object.\n */\nfunction stringify(data) {\n    return JSON.stringify(data);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst decode = function (token) {\n    let header = {}, claims = {}, data = {}, signature = '';\n    try {\n        const parts = token.split('.');\n        header = jsonEval(base64Decode(parts[0]) || '');\n        claims = jsonEval(base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header,\n        claims,\n        data,\n        signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidTimestamp = function (token) {\n    const claims = decode(token).claims;\n    const now = Math.floor(new Date().getTime() / 1000);\n    let validSince = 0, validUntil = 0;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (!!now &&\n        !!validSince &&\n        !!validUntil &&\n        now >= validSince &&\n        now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst issuedAtTime = function (token) {\n    const claims = decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isValidFormat = function (token) {\n    const decoded = decode(token), claims = decoded.claims;\n    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n */\nconst isAdmin = function (token) {\n    const claims = decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction safeGet(obj, key) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return obj[key];\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isEmpty(obj) {\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction map(obj, fn, contextObj) {\n    const res = {};\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[key] = fn.call(contextObj, obj[key], key, obj);\n        }\n    }\n    return res;\n}\n/**\n * Deep equal two objects. Support Arrays and Objects.\n */\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    for (const k of aKeys) {\n        if (!bKeys.includes(k)) {\n            return false;\n        }\n        const aProp = a[k];\n        const bProp = b[k];\n        if (isObject(aProp) && isObject(bProp)) {\n            if (!deepEqual(aProp, bProp)) {\n                return false;\n            }\n        }\n        else if (aProp !== bProp) {\n            return false;\n        }\n    }\n    for (const k of bKeys) {\n        if (!aKeys.includes(k)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(thing) {\n    return thing !== null && typeof thing === 'object';\n}\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Rejects if the given promise doesn't resolve in timeInMS milliseconds.\n * @internal\n */\nfunction promiseWithTimeout(promise, timeInMS = 2000) {\n    const deferredPromise = new Deferred();\n    setTimeout(() => deferredPromise.reject('timeout!'), timeInMS);\n    promise.then(deferredPromise.resolve, deferredPromise.reject);\n    return deferredPromise.promise;\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a\n * params object (e.g. {arg: 'val', arg2: 'val2'})\n * Note: You must prepend it with ? when adding it to a URL.\n */\nfunction querystring(querystringParams) {\n    const params = [];\n    for (const [key, value] of Object.entries(querystringParams)) {\n        if (Array.isArray(value)) {\n            value.forEach(arrayVal => {\n                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));\n            });\n        }\n        else {\n            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        }\n    }\n    return params.length ? '&' + params.join('&') : '';\n}\n/**\n * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object\n * (e.g. {arg: 'val', arg2: 'val2'})\n */\nfunction querystringDecode(querystring) {\n    const obj = {};\n    const tokens = querystring.replace(/^\\?/, '').split('&');\n    tokens.forEach(token => {\n        if (token) {\n            const [key, value] = token.split('=');\n            obj[decodeURIComponent(key)] = decodeURIComponent(value);\n        }\n    });\n    return obj;\n}\n/**\n * Extract the query string part of a URL, including the leading question mark (if present).\n */\nfunction extractQuerystring(url) {\n    const queryStart = url.indexOf('?');\n    if (!queryStart) {\n        return '';\n    }\n    const fragmentStart = url.indexOf('#', queryStart);\n    return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : undefined);\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @fileoverview SHA-1 cryptographic hash.\n * Variable names follow the notation in FIPS PUB 180-3:\n * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.\n *\n * Usage:\n *   var sha1 = new sha1();\n *   sha1.update(bytes);\n *   var hash = sha1.digest();\n *\n * Performance:\n *   Chrome 23:   ~400 Mbit/s\n *   Firefox 16:  ~250 Mbit/s\n *\n */\n/**\n * SHA-1 cryptographic hash constructor.\n *\n * The properties declared here are discussed in the above algorithm document.\n * @constructor\n * @final\n * @struct\n */\nclass Sha1 {\n    constructor() {\n        /**\n         * Holds the previous values of accumulated variables a-e in the compress_\n         * function.\n         * @private\n         */\n        this.chain_ = [];\n        /**\n         * A buffer holding the partially computed hash result.\n         * @private\n         */\n        this.buf_ = [];\n        /**\n         * An array of 80 bytes, each a part of the message to be hashed.  Referred to\n         * as the message schedule in the docs.\n         * @private\n         */\n        this.W_ = [];\n        /**\n         * Contains data needed to pad messages less than 64 bytes.\n         * @private\n         */\n        this.pad_ = [];\n        /**\n         * @private {number}\n         */\n        this.inbuf_ = 0;\n        /**\n         * @private {number}\n         */\n        this.total_ = 0;\n        this.blockSize = 512 / 8;\n        this.pad_[0] = 128;\n        for (let i = 1; i < this.blockSize; ++i) {\n            this.pad_[i] = 0;\n        }\n        this.reset();\n    }\n    reset() {\n        this.chain_[0] = 0x67452301;\n        this.chain_[1] = 0xefcdab89;\n        this.chain_[2] = 0x98badcfe;\n        this.chain_[3] = 0x10325476;\n        this.chain_[4] = 0xc3d2e1f0;\n        this.inbuf_ = 0;\n        this.total_ = 0;\n    }\n    /**\n     * Internal compress helper function.\n     * @param buf Block to compress.\n     * @param offset Offset of the block in the buffer.\n     * @private\n     */\n    compress_(buf, offset) {\n        if (!offset) {\n            offset = 0;\n        }\n        const W = this.W_;\n        // get 16 big endian words\n        if (typeof buf === 'string') {\n            for (let i = 0; i < 16; i++) {\n                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS\n                // have a bug that turns the post-increment ++ operator into pre-increment\n                // during JIT compilation.  We have code that depends heavily on SHA-1 for\n                // correctness and which is affected by this bug, so I've removed all uses\n                // of post-increment ++ in which the result value is used.  We can revert\n                // this change once the Safari bug\n                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and\n                // most clients have been updated.\n                W[i] =\n                    (buf.charCodeAt(offset) << 24) |\n                        (buf.charCodeAt(offset + 1) << 16) |\n                        (buf.charCodeAt(offset + 2) << 8) |\n                        buf.charCodeAt(offset + 3);\n                offset += 4;\n            }\n        }\n        else {\n            for (let i = 0; i < 16; i++) {\n                W[i] =\n                    (buf[offset] << 24) |\n                        (buf[offset + 1] << 16) |\n                        (buf[offset + 2] << 8) |\n                        buf[offset + 3];\n                offset += 4;\n            }\n        }\n        // expand to 80 words\n        for (let i = 16; i < 80; i++) {\n            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;\n        }\n        let a = this.chain_[0];\n        let b = this.chain_[1];\n        let c = this.chain_[2];\n        let d = this.chain_[3];\n        let e = this.chain_[4];\n        let f, k;\n        // TODO(user): Try to unroll this loop to speed up the computation.\n        for (let i = 0; i < 80; i++) {\n            if (i < 40) {\n                if (i < 20) {\n                    f = d ^ (b & (c ^ d));\n                    k = 0x5a827999;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0x6ed9eba1;\n                }\n            }\n            else {\n                if (i < 60) {\n                    f = (b & c) | (d & (b | c));\n                    k = 0x8f1bbcdc;\n                }\n                else {\n                    f = b ^ c ^ d;\n                    k = 0xca62c1d6;\n                }\n            }\n            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;\n            e = d;\n            d = c;\n            c = ((b << 30) | (b >>> 2)) & 0xffffffff;\n            b = a;\n            a = t;\n        }\n        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;\n        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;\n        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;\n        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;\n        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;\n    }\n    update(bytes, length) {\n        // TODO(johnlenz): tighten the function signature and remove this check\n        if (bytes == null) {\n            return;\n        }\n        if (length === undefined) {\n            length = bytes.length;\n        }\n        const lengthMinusBlock = length - this.blockSize;\n        let n = 0;\n        // Using local instead of member variables gives ~5% speedup on Firefox 16.\n        const buf = this.buf_;\n        let inbuf = this.inbuf_;\n        // The outer while loop should execute at most twice.\n        while (n < length) {\n            // When we have no data in the block to top up, we can directly process the\n            // input buffer (assuming it contains sufficient data). This gives ~25%\n            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that\n            // the data is provided in large chunks (or in multiples of 64 bytes).\n            if (inbuf === 0) {\n                while (n <= lengthMinusBlock) {\n                    this.compress_(bytes, n);\n                    n += this.blockSize;\n                }\n            }\n            if (typeof bytes === 'string') {\n                while (n < length) {\n                    buf[inbuf] = bytes.charCodeAt(n);\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n            else {\n                while (n < length) {\n                    buf[inbuf] = bytes[n];\n                    ++inbuf;\n                    ++n;\n                    if (inbuf === this.blockSize) {\n                        this.compress_(buf);\n                        inbuf = 0;\n                        // Jump to the outer loop so we use the full-block optimization.\n                        break;\n                    }\n                }\n            }\n        }\n        this.inbuf_ = inbuf;\n        this.total_ += length;\n    }\n    /** @override */\n    digest() {\n        const digest = [];\n        let totalBits = this.total_ * 8;\n        // Add pad 0x80 0x00*.\n        if (this.inbuf_ < 56) {\n            this.update(this.pad_, 56 - this.inbuf_);\n        }\n        else {\n            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));\n        }\n        // Add # bits.\n        for (let i = this.blockSize - 1; i >= 56; i--) {\n            this.buf_[i] = totalBits & 255;\n            totalBits /= 256; // Don't use bit-shifting here!\n        }\n        this.compress_(this.buf_);\n        let n = 0;\n        for (let i = 0; i < 5; i++) {\n            for (let j = 24; j >= 0; j -= 8) {\n                digest[n] = (this.chain_[i] >> j) & 255;\n                ++n;\n            }\n        }\n        return digest;\n    }\n}\n\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    const proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nclass ObserverProxy {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    constructor(executor, onNoObservers) {\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(() => {\n            executor(this);\n        })\n            .catch(e => {\n            this.error(e);\n        });\n    }\n    next(value) {\n        this.forEachObserver((observer) => {\n            observer.next(value);\n        });\n    }\n    error(error) {\n        this.forEachObserver((observer) => {\n            observer.error(error);\n        });\n        this.close(error);\n    }\n    complete() {\n        this.forEachObserver((observer) => {\n            observer.complete();\n        });\n        this.close();\n    }\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber synchronously to their\n     *   call to subscribe().\n     */\n    subscribe(nextOrObserver, error, complete) {\n        let observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, [\n            'next',\n            'error',\n            'complete'\n        ])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error,\n                complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        const unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.task.then(() => {\n                try {\n                    if (this.finalError) {\n                        observer.error(this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    }\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    unsubscribeOne(i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    }\n    forEachObserver(fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (let i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    }\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    sendOne(i, fn) {\n        // Execute the callback asynchronously\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            if (this.observers !== undefined && this.observers[i] !== undefined) {\n                try {\n                    fn(this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    }\n    close(err) {\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.task.then(() => {\n            this.observers = undefined;\n            this.onNoObservers = undefined;\n        });\n    }\n}\n/** Turn synchronous function into one called asynchronously. */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction async(fn, onError) {\n    return (...args) => {\n        Promise.resolve(true)\n            .then(() => {\n            fn(...args);\n        })\n            .catch((error) => {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (const method of methods) {\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Check to make sure the appropriate number of arguments are provided for a public function.\n * Throws an error if it fails.\n *\n * @param fnName The function name\n * @param minCount The minimum number of arguments to allow for the function call\n * @param maxCount The maximum number of argument to allow for the function call\n * @param argCount The actual number of arguments provided.\n */\nconst validateArgCount = function (fnName, minCount, maxCount, argCount) {\n    let argError;\n    if (argCount < minCount) {\n        argError = 'at least ' + minCount;\n    }\n    else if (argCount > maxCount) {\n        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;\n    }\n    if (argError) {\n        const error = fnName +\n            ' failed: Was called with ' +\n            argCount +\n            (argCount === 1 ? ' argument.' : ' arguments.') +\n            ' Expects ' +\n            argError +\n            '.';\n        throw new Error(error);\n    }\n};\n/**\n * Generates a string to prefix an error message about failed argument validation\n *\n * @param fnName The function name\n * @param argName The name of the argument\n * @return The prefix to add to the error thrown for validation.\n */\nfunction errorPrefix(fnName, argName) {\n    return `${fnName} failed: ${argName} argument `;\n}\n/**\n * @param fnName\n * @param argumentNumber\n * @param namespace\n * @param optional\n */\nfunction validateNamespace(fnName, namespace, optional) {\n    if (optional && !namespace) {\n        return;\n    }\n    if (typeof namespace !== 'string') {\n        //TODO: I should do more validation here. We only allow certain chars in namespaces.\n        throw new Error(errorPrefix(fnName, 'namespace') + 'must be a valid firebase namespace.');\n    }\n}\nfunction validateCallback(fnName, argumentName, \n// eslint-disable-next-line @typescript-eslint/ban-types\ncallback, optional) {\n    if (optional && !callback) {\n        return;\n    }\n    if (typeof callback !== 'function') {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid function.');\n    }\n}\nfunction validateContextObject(fnName, argumentName, context, optional) {\n    if (optional && !context) {\n        return;\n    }\n    if (typeof context !== 'object' || context === null) {\n        throw new Error(errorPrefix(fnName, argumentName) + 'must be a valid context object.');\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they\n// automatically replaced '\\r\\n' with '\\n', and they didn't handle surrogate pairs,\n// so it's been modified.\n// Note that not all Unicode characters appear as single characters in JavaScript strings.\n// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters\n// use 2 characters in JavaScript.  All 4-byte UTF-8 characters begin with a first\n// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate\n// pair).\n// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3\n/**\n * @param {string} str\n * @return {Array}\n */\nconst stringToByteArray = function (str) {\n    const out = [];\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n        // Is this the lead surrogate in a surrogate pair?\n        if (c >= 0xd800 && c <= 0xdbff) {\n            const high = c - 0xd800; // the high 10 bits.\n            i++;\n            assert(i < str.length, 'Surrogate pair missing trail surrogate.');\n            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.\n            c = 0x10000 + (high << 10) + low;\n        }\n        if (c < 128) {\n            out[p++] = c;\n        }\n        else if (c < 2048) {\n            out[p++] = (c >> 6) | 192;\n            out[p++] = (c & 63) | 128;\n        }\n        else if (c < 65536) {\n            out[p++] = (c >> 12) | 224;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n        else {\n            out[p++] = (c >> 18) | 240;\n            out[p++] = ((c >> 12) & 63) | 128;\n            out[p++] = ((c >> 6) & 63) | 128;\n            out[p++] = (c & 63) | 128;\n        }\n    }\n    return out;\n};\n/**\n * Calculate length without actually converting; useful for doing cheaper validation.\n * @param {string} str\n * @return {number}\n */\nconst stringLength = function (str) {\n    let p = 0;\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 128) {\n            p++;\n        }\n        else if (c < 2048) {\n            p += 2;\n        }\n        else if (c >= 0xd800 && c <= 0xdbff) {\n            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.\n            p += 4;\n            i++; // skip trail surrogate.\n        }\n        else {\n            p += 3;\n        }\n    }\n    return p;\n};\n\n/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Copied from https://stackoverflow.com/a/2117523\n * Generates a new uuid.\n * @public\n */\nconst uuidv4 = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The amount of milliseconds to exponentially increase.\n */\nconst DEFAULT_INTERVAL_MILLIS = 1000;\n/**\n * The factor to backoff by.\n * Should be a number greater than 1.\n */\nconst DEFAULT_BACKOFF_FACTOR = 2;\n/**\n * The maximum milliseconds to increase to.\n *\n * <p>Visible for testing\n */\nconst MAX_VALUE_MILLIS = 4 * 60 * 60 * 1000; // Four hours, like iOS and Android.\n/**\n * The percentage of backoff time to randomize by.\n * See\n * http://go/safe-client-behavior#step-1-determine-the-appropriate-retry-interval-to-handle-spike-traffic\n * for context.\n *\n * <p>Visible for testing\n */\nconst RANDOM_FACTOR = 0.5;\n/**\n * Based on the backoff method from\n * https://github.com/google/closure-library/blob/master/closure/goog/math/exponentialbackoff.js.\n * Extracted here so we don't need to pass metadata and a stateful ExponentialBackoff object around.\n */\nfunction calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {\n    // Calculates an exponentially increasing value.\n    // Deviation: calculates value from count and a constant interval, so we only need to save value\n    // and count to restore state.\n    const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);\n    // A random \"fuzz\" to avoid waves of retries.\n    // Deviation: randomFactor is required.\n    const randomWait = Math.round(\n    // A fraction of the backoff value to add/subtract.\n    // Deviation: changes multiplication order to improve readability.\n    RANDOM_FACTOR *\n        currBaseValue *\n        // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines\n        // if we add or subtract.\n        (Math.random() - 0.5) *\n        2);\n    // Limits backoff to max to avoid effectively permanent backoff.\n    return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provide English ordinal letters after a number\n */\nfunction ordinal(i) {\n    if (!Number.isFinite(i)) {\n        return `${i}`;\n    }\n    return i + indicator(i);\n}\nfunction indicator(i) {\n    i = Math.abs(i);\n    const cent = i % 100;\n    if (cent >= 10 && cent <= 20) {\n        return 'th';\n    }\n    const dec = i % 10;\n    if (dec === 1) {\n        return 'st';\n    }\n    if (dec === 2) {\n        return 'nd';\n    }\n    if (dec === 3) {\n        return 'rd';\n    }\n    return 'th';\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getModularInstance(service) {\n    if (service && service._delegate) {\n        return service._delegate;\n    }\n    else {\n        return service;\n    }\n}\n\n/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Overriding the constant (we should be the only ones doing this)\nCONSTANTS.NODE_CLIENT = true;\n\n\n//# sourceMappingURL=index.node.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSx3RUFBd0UsS0FBSzs7QUFFaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYSxHQUFHLEtBQUs7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQixJQUFJLFNBQVMsR0FBRyxTQUFTO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUk7QUFDdkQsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLE1BQU0sSUFBSTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUSxVQUFVLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNi9CO0FBQzcvQiIsInNvdXJjZXMiOlsiL2hvbWUvcmd0ZWNoMDA4L2FjYWRlbWljLWNvbm5lY3QtcHJvamVjdC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9ub2RlLWVzbS9pbmRleC5ub2RlLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cbmNvbnN0IENPTlNUQU5UUyA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIGNsaWVudCBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0NMSUVOVDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cbiAgICAgKi9cbiAgICBOT0RFX0FETUlOOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBGaXJlYmFzZSBTREsgVmVyc2lvblxuICAgICAqL1xuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGFzc2VydGlvbiBpcyBmYWxzeVxuICovXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IobWVzc2FnZSk7XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBhbiBFcnJvciBvYmplY3Qgc3VpdGFibGUgZm9yIHRocm93aW5nLlxuICovXG5jb25zdCBhc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignRmlyZWJhc2UgRGF0YWJhc2UgKCcgK1xuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xuICAgICAgICAnKSBJTlRFUk5BTCBBU1NFUlQgRkFJTEVEOiAnICtcbiAgICAgICAgbWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3Qgc3RyaW5nVG9CeXRlQXJyYXkkMSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAvLyBUT0RPKHVzZXIpOiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9ucyBpZi93aGVuIGF2YWlsYWJsZVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGxldCBwID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuICAgICAgICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXG4gICAgICAgICAgICAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICogY2hhcmFjdGVycyB0byB3aGljaCB0aGUgbnVtYmVycyBjb3JyZXNwb25kLlxuICogQHBhcmFtIGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbmNvbnN0IGJ5dGVBcnJheVRvU3RyaW5nID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcG9zID0gMCwgYyA9IDA7XG4gICAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjMSA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMxID4gMTkxICYmIGMxIDwgMjI0KSB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjMSA+IDIzOSAmJiBjMSA8IDM2NSkge1xuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBjb25zdCBjNCA9IGJ5dGVzW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSAoKChjMSAmIDcpIDw8IDE4KSB8ICgoYzIgJiA2MykgPDwgMTIpIHwgKChjMyAmIDYzKSA8PCA2KSB8IChjNCAmIDYzKSkgLVxuICAgICAgICAgICAgICAgIDB4MTAwMDA7XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwICsgKHUgPj4gMTApKTtcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGRjMDAgKyAodSAmIDEwMjMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjMSAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xufTtcbi8vIFdlIGRlZmluZSBpdCBhcyBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY2xhc3MgYmVjYXVzZSBhIGNsYXNzIGNvbXBpbGVkIGRvd24gdG8gZXM1IGNhbid0XG4vLyBiZSB0cmVlc2hha2VkLiBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTY5MVxuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcbi8vIFRPRE8oZGxhcm9jcXVlKTogRGVmaW5lIHRoaXMgYXMgYSBjbGFzcywgc2luY2Ugd2Ugbm8gbG9uZ2VyIHRhcmdldCBFUzUuXG5jb25zdCBiYXNlNjQgPSB7XG4gICAgLyoqXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5dGVUb0NoYXJNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIHdlYnNhZmUgY2hhcmFjdGVycyB0byBieXRlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoYXJUb0J5dGVNYXBXZWJTYWZlXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cbiAgICAgKiBFTkNPREVEX1ZBTFMgYW5kIEVOQ09ERURfVkFMU19XRUJTQUZFXG4gICAgICovXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXG4gICAgICovXG4gICAgZ2V0IEVOQ09ERURfVkFMUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnKy89JztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE91ciB3ZWJzYWZlIGFscGhhYmV0LlxuICAgICAqL1xuICAgIGdldCBFTkNPREVEX1ZBTFNfV0VCU0FGRSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRU5DT0RFRF9WQUxTX0JBU0UgKyAnLV8uJztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHRoZSBhdG9iIGFuZCBidG9hIGZ1bmN0aW9ucy4gVGhpcyBleHRlbnNpb25cbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXG4gICAgICogQVNTVU1FXyogdmFyaWFibGVzIHRvIGF2b2lkIHB1bGxpbmcgaW4gdGhlIGZ1bGwgdXNlcmFnZW50IGRldGVjdGlvbiBsaWJyYXJ5XG4gICAgICogYnV0IHN0aWxsIGFsbG93aW5nIHRoZSBzdGFuZGFyZCBwZXItYnJvd3NlciBjb21waWxhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBIQVNfTkFUSVZFX1NVUFBPUlQ6IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nLFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYW4gYXJyYXkgb2YgYnl0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxuICAgICAqICAgICB2YWx1ZSBpbiBbMCwgMjU1XSkgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIEJvb2xlYW4gaW5kaWNhdGluZyB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbmNvZGVCeXRlQXJyYXkgdGFrZXMgYW4gYXJyYXkgYXMgYSBwYXJhbWV0ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRfKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVUb0NoYXJNYXAgPSB3ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlMSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgY29uc3QgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpICsgMiA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMSAmIDB4MDMpIDw8IDQpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGUzID0gKChieXRlMiAmIDB4MGYpIDw8IDIpIHwgKGJ5dGUzID4+IDYpO1xuICAgICAgICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xuICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTMpIHtcbiAgICAgICAgICAgICAgICBvdXRCeXRlNCA9IDY0O1xuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEJ5dGUzID0gNjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMV0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTJdLCBieXRlVG9DaGFyTWFwW291dEJ5dGUzXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlNF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IEEgc3RyaW5nIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlU3RyaW5nKGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICF3ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5JDEoaW5wdXQpLCB3ZWJTYWZlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1kZWNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXQgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhpbnB1dCwgd2ViU2FmZSkge1xuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxuICAgICAgICAvLyBhIG5hdGl2ZSBiYXNlNjQgZW5jb2RlciBpbiB0aGUgZm9ybSBvZiBcImJ0b2EvYXRvYlwiXG4gICAgICAgIGlmICh0aGlzLkhBU19OQVRJVkVfU1VQUE9SVCAmJiAhd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZGVjb2RlIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogSW4gYmFzZS02NCBkZWNvZGluZywgZ3JvdXBzIG9mIGZvdXIgY2hhcmFjdGVycyBhcmUgY29udmVydGVkIGludG8gdGhyZWVcbiAgICAgKiBieXRlcy4gIElmIHRoZSBlbmNvZGVyIGRpZCBub3QgYXBwbHkgcGFkZGluZywgdGhlIGlucHV0IGxlbmd0aCBtYXkgbm90XG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgbGFzdCBncm91cCB3aWxsIGhhdmUgZmV3ZXIgdGhhbiA0IGNoYXJhY3RlcnMsIGFuZFxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXG4gICAgICogdG8gb25lIGJ5dGUuICBJZiB0aGUgZ3JvdXAgaGFzIHRocmVlIGNoYXJhY3RlcnMsIGl0IGRlY29kZXMgdG8gdHdvIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBUcnVlIGlmIHdlIHNob3VsZCB1c2UgdGhlIHdlYi1zYWZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcbiAgICAgICAgICAgID8gdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV9cbiAgICAgICAgICAgIDogdGhpcy5jaGFyVG9CeXRlTWFwXztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICAgICAgY29uc3QgYnl0ZTEgPSBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKyspXTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgYnl0ZTMgPSBoYXZlQnl0ZTMgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBieXRlNCA9IGhhdmVCeXRlNCA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTEpO1xuICAgICAgICAgICAgaWYgKGJ5dGUzICE9PSA2NCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUyKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZTQgIT09IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIExhenkgc3RhdGljIGluaXRpYWxpemF0aW9uIGZ1bmN0aW9uLiBDYWxsZWQgYmVmb3JlXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0XygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBBbiBlcnJvciBlbmNvdW50ZXJlZCB3aGlsZSBkZWNvZGluZyBiYXNlNjQgc3RyaW5nLlxuICovXG5jbGFzcyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcbiAgICB9XG59XG4vKipcbiAqIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZ1xuICovXG5jb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY29uc3QgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkkMShzdHIpO1xuICAgIHJldHVybiBiYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmcgKHdpdGhvdXQgXCIuXCIgcGFkZGluZyBpbiB0aGUgZW5kKS5cbiAqIGUuZy4gVXNlZCBpbiBKU09OIFdlYiBUb2tlbiAoSldUKSBwYXJ0cy5cbiAqL1xuY29uc3QgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgLy8gVXNlIGJhc2U2NHVybCBlbmNvZGluZyBhbmQgcmVtb3ZlIHBhZGRpbmcgaW4gdGhlIGVuZCAoZG90IGNoYXJhY3RlcnMpLlxuICAgIHJldHVybiBiYXNlNjRFbmNvZGUoc3RyKS5yZXBsYWNlKC9cXC4vZywgJycpO1xufTtcbi8qKlxuICogVVJMLXNhZmUgYmFzZTY0IGRlY29kaW5nXG4gKlxuICogTk9URTogRE8gTk9UIHVzZSB0aGUgZ2xvYmFsIGF0b2IoKSBmdW5jdGlvbiAtIGl0IGRvZXMgTk9UIHN1cHBvcnQgdGhlXG4gKiBiYXNlNjRVcmwgdmFyaWFudCBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIFRvIGJlIGRlY29kZWRcbiAqIEByZXR1cm4gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXG4gKi9cbmNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYmFzZTY0LmRlY29kZVN0cmluZyhzdHIsIHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdiYXNlNjREZWNvZGUgZmFpbGVkOiAnLCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxuICovXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xufVxuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXG4gKiAoYW5kIHJldHVybmVkKS5cbiAqXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxuICpcbiAqIE5vdGU6IHdlIGRvbid0IG1lcmdlIF9fcHJvdG9fXyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cbiAqL1xuZnVuY3Rpb24gZGVlcEV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgICAgLy8gVHJlYXQgRGF0ZXMgbGlrZSBzY2FsYXJzOyBpZiB0aGUgdGFyZ2V0IGRhdGUgb2JqZWN0IGhhZCBhbnkgY2hpbGRcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIC8vIHVzZSBpc1ZhbGlkS2V5IHRvIGd1YXJkIGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvbi4gU2VlIGh0dHBzOi8vc255ay5pby92dWxuL1NOWUstSlMtTE9EQVNILTQ1MDIwMlxuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICdfX3Byb3RvX18nO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgYGdsb2JhbFRoaXNgIG9iamVjdC5cbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCkgPT4gZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xuLyoqXG4gKiBBdHRlbXB0IHRvIHJlYWQgZGVmYXVsdHMgZnJvbSBhIEpTT04gc3RyaW5nIHByb3ZpZGVkIHRvXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19fIG9yIGEgSlNPTiBmaWxlIHdob3NlIHBhdGggaXMgaW5cbiAqIHByb2Nlc3MoLillbnYoLilfX0ZJUkVCQVNFX0RFRkFVTFRTX1BBVEhfX1xuICogVGhlIGRvdHMgYXJlIGluIHBhcmVucyBiZWNhdXNlIGNlcnRhaW4gY29tcGlsZXJzIChWaXRlPykgY2Fubm90XG4gKiBoYW5kbGUgc2VlaW5nIHRoYXQgdmFyaWFibGUgaW4gY29tbWVudHMuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjgzOFxuICovXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBwcm9jZXNzLmVudiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0c0pzb25TdHJpbmcgPSBwcm9jZXNzLmVudi5fX0ZJUkVCQVNFX0RFRkFVTFRTX187XG4gICAgaWYgKGRlZmF1bHRzSnNvblN0cmluZykge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xuICAgIH1cbn07XG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxuICAgICAgICAvLyBgZG9jdW1lbnRgIG9iamVjdCBidXQgZXJyb3Igb24gYWNjZXNzaW5nIGBkb2N1bWVudC5jb29raWVgLlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWQgPSBtYXRjaCAmJiBiYXNlNjREZWNvZGUobWF0Y2hbMV0pO1xuICAgIHJldHVybiBkZWNvZGVkICYmIEpTT04ucGFyc2UoZGVjb2RlZCk7XG59O1xuLyoqXG4gKiBHZXQgdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3QuIEl0IGNoZWNrcyBpbiBvcmRlcjpcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcbiAqICgyKSBpZiBzdWNoIGFuIG9iamVjdCB3YXMgcHJvdmlkZWQgb24gYSBzaGVsbCBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICogKDMpIGlmIHN1Y2ggYW4gb2JqZWN0IGV4aXN0cyBpbiBhIGNvb2tpZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGdldERlZmF1bHRzRnJvbUdsb2JhbCgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSgpIHx8XG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXRjaC1hbGwgZm9yIGJlaW5nIHVuYWJsZSB0byBnZXQgX19GSVJFQkFTRV9ERUZBVUxUU19fIGR1ZVxuICAgICAgICAgKiB0byBhbnkgZW52aXJvbm1lbnQgY2FzZSB3ZSBoYXZlIG5vdCBhY2NvdW50ZWQgZm9yLiBMb2cgdG9cbiAgICAgICAgICogaW5mbyBpbnN0ZWFkIG9mIHN3YWxsb3dpbmcgc28gd2UgY2FuIGZpbmQgdGhlc2UgdW5rbm93biBjYXNlc1xuICAgICAgICAgKiBhbmQgYWRkIHBhdGhzIGZvciB0aGVtIGlmIG5lZWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlIHRvOiAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGVtdWxhdG9yIGhvc3Qgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0XG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXG4gKiBAcmV0dXJucyBhIFVSTCBob3N0IGZvcm1hdHRlZCBsaWtlIGAxMjcuMC4wLjE6OTk5OWAgb3IgYFs6OjFdOjQwMDBgIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0ID0gKHByb2R1Y3ROYW1lKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW11bGF0b3JIb3N0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3Byb2R1Y3ROYW1lXTsgfTtcbi8qKlxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcbiAqIGZvciB0aGUgZ2l2ZW4gcHJvZHVjdC5cbiAqIEByZXR1cm5zIGEgcGFpciBvZiBob3N0bmFtZSBhbmQgcG9ydCBsaWtlIGBbXCI6OjFcIiwgNDAwMF1gIGlmIGF2YWlsYWJsZVxuICogQHB1YmxpY1xuICovXG5jb25zdCBnZXREZWZhdWx0RW11bGF0b3JIb3N0bmFtZUFuZFBvcnQgPSAocHJvZHVjdE5hbWUpID0+IHtcbiAgICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XG4gICAgaWYgKCFob3N0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcGFyYXRvckluZGV4ID0gaG9zdC5sYXN0SW5kZXhPZignOicpOyAvLyBGaW5kaW5nIHRoZSBsYXN0IHNpbmNlIElQdjYgYWRkciBhbHNvIGhhcyBjb2xvbnMuXG4gICAgaWYgKHNlcGFyYXRvckluZGV4IDw9IDAgfHwgc2VwYXJhdG9ySW5kZXggKyAxID09PSBob3N0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9zdCAke2hvc3R9IHdpdGggbm8gc2VwYXJhdGUgaG9zdG5hbWUgYW5kIHBvcnQhYCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKSwgMTApO1xuICAgIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICAgICAgLy8gQnJhY2tldC1xdW90ZWQgYFtpcHY2YWRkcl06cG9ydGAgPT4gcmV0dXJuIFwiaXB2NmFkZHJcIiAod2l0aG91dCBicmFja2V0cykuXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KSwgcG9ydF07XG4gICAgfVxufTtcbi8qKlxuICogUmV0dXJucyBGaXJlYmFzZSBhcHAgY29uZmlnIHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdEFwcENvbmZpZyA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZzsgfTtcbi8qKlxuICogUmV0dXJucyBhbiBleHBlcmltZW50YWwgc2V0dGluZyBvbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdCAocHJvcGVydGllc1xuICogcHJlZml4ZWQgYnkgXCJfXCIpXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGdldEV4cGVyaW1lbnRhbFNldHRpbmcgPSAobmFtZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYF8ke25hbWV9YF07IH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVqZWN0ID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLnJlc29sdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzaWZpZWQgYW5kIGNhbm5vdCBiZWNhdXNlIG91ciBjYWxsYmFjayBBUElzIGhhdmUgc3VidGxlIGV4cGVjdGF0aW9ucyBhcm91bmRcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xuICAgICAqIGFuZCByZXR1cm5zIGEgbm9kZS1zdHlsZSBjYWxsYmFjayB3aGljaCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBEZWZlcnJlZCdzIHByb21pc2UuXG4gICAgICovXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoZXJyb3IsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZXNcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQgdGhhdCB0aGUgcGFyYW1ldGVyIGxlbmd0aCBpcyAxXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcbiAgICBpZiAodG9rZW4udWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwidWlkXCIgZmllbGQgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBieSBtb2NrVXNlclRva2VuLiBQbGVhc2UgdXNlIFwic3ViXCIgaW5zdGVhZCBmb3IgRmlyZWJhc2UgQXV0aCBVc2VyIElELicpO1xuICAgIH1cbiAgICAvLyBVbnNlY3VyZWQgSldUcyB1c2UgXCJub25lXCIgYXMgdGhlIGFsZ29yaXRobS5cbiAgICBjb25zdCBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzogJ25vbmUnLFxuICAgICAgICB0eXBlOiAnSldUJ1xuICAgIH07XG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcbiAgICBjb25zdCBpYXQgPSB0b2tlbi5pYXQgfHwgMDtcbiAgICBjb25zdCBzdWIgPSB0b2tlbi5zdWIgfHwgdG9rZW4udXNlcl9pZDtcbiAgICBpZiAoIXN1Yikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2NrVXNlclRva2VuIG11c3QgY29udGFpbiAnc3ViJyBvciAndXNlcl9pZCcgZmllbGQhXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxuICAgICAgICAvLyBTZXQgYWxsIHJlcXVpcmVkIGZpZWxkcyB0byBkZWNlbnQgZGVmYXVsdHNcbiAgICAgICAgaXNzOiBgaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGUuY29tLyR7cHJvamVjdH1gLCBhdWQ6IHByb2plY3QsIGlhdCwgZXhwOiBpYXQgKyAzNjAwLCBhdXRoX3RpbWU6IGlhdCwgc3ViLCB1c2VyX2lkOiBzdWIsIGZpcmViYXNlOiB7XG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IHt9XG4gICAgICAgIH0gfSwgdG9rZW4pO1xuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICcnO1xuICAgIHJldHVybiBbXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxuICAgICAgICBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSksXG4gICAgICAgIHNpZ25hdHVyZVxuICAgIF0uam9pbignLicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldFVBKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yWyd1c2VyQWdlbnQnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcbiAqIGluIHRoZSBSaXBwbGUgZW11bGF0b3IpIG5vciBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHlcbiAqIHdhaXQgZm9yIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGlzTW9iaWxlQ29yZG92YSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcbiAgICAgICAgLy8ganVzdCB0byBkZWFsIHdpdGggdGhpcyBjYXNlIHdvdWxkIHByb2JhYmx5IGJlIGEgYmFkIGlkZWEuXG4gICAgICAgICEhKHdpbmRvd1snY29yZG92YSddIHx8IHdpbmRvd1sncGhvbmVnYXAnXSB8fCB3aW5kb3dbJ1Bob25lR2FwJ10pICYmXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcbn1cbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIE5vZGUuanMgZW52aXJvbm1lbnQgaXMgZGV0ZWN0ZWQgb3Igc3BlY2lmaWVkLlxuICovXG4vLyBOb2RlIGRldGVjdGlvbiBsb2dpYyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vaWxpYWthbi9kZXRlY3Qtbm9kZS9cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZm9yY2VFbnZpcm9ubWVudCA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JjZUVudmlyb25tZW50O1xuICAgIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcmNlRW52aXJvbm1lbnQgPT09ICdicm93c2VyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRGV0ZWN0IEJyb3dzZXIgRW52aXJvbm1lbnQuXG4gKiBOb3RlOiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGNlcnRhaW4gdGVzdCBmcmFtZXdvcmtzIHRoYXQgYXJlIGluY29tcGxldGVseVxuICogbWltaWNraW5nIGEgYnJvd3NlciwgYW5kIHNob3VsZCBub3QgbGVhZCB0byBhc3N1bWluZyBhbGwgYnJvd3NlciBBUElzIGFyZVxuICogYXZhaWxhYmxlLlxuICovXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnIHx8IGlzV2ViV29ya2VyKCk7XG59XG4vKipcbiAqIERldGVjdCBXZWIgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzV2ViV29ya2VyKCkge1xuICAgIHJldHVybiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKTtcbn1cbi8qKlxuICogRGV0ZWN0IENsb3VkZmxhcmUgV29ya2VyIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvdWRmbGFyZVdvcmtlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdDbG91ZGZsYXJlLVdvcmtlcnMnKTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlckV4dGVuc2lvbigpIHtcbiAgICBjb25zdCBydW50aW1lID0gdHlwZW9mIGNocm9tZSA9PT0gJ29iamVjdCdcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxuICAgICAgICA6IHR5cGVvZiBicm93c2VyID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgPyBicm93c2VyLnJ1bnRpbWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0eXBlb2YgcnVudGltZSA9PT0gJ29iamVjdCcgJiYgcnVudGltZS5pZCAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZXRlY3QgUmVhY3QgTmF0aXZlLlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5hdGl2ZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcbn1cbi8qKiBEZXRlY3RzIEVsZWN0cm9uIGFwcHMuICovXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ0VsZWN0cm9uLycpID49IDA7XG59XG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cbmZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgY29uc3QgdWEgPSBnZXRVQSgpO1xuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xufVxuLyoqIERldGVjdHMgVW5pdmVyc2FsIFdpbmRvd3MgUGxhdGZvcm0gYXBwcy4gKi9cbmZ1bmN0aW9uIGlzVVdQKCkge1xuICAgIHJldHVybiBnZXRVQSgpLmluZGV4T2YoJ01TQXBwSG9zdC8nKSA+PSAwO1xufVxuLyoqXG4gKiBEZXRlY3Qgd2hldGhlciB0aGUgY3VycmVudCBTREsgYnVpbGQgaXMgdGhlIE5vZGUgdmVyc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZVNkaygpIHtcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xufVxuLyoqIFJldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgcnVubmluZyBpbiBTYWZhcmkuICovXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcbiAgICByZXR1cm4gKCFpc05vZGUoKSAmJlxuICAgICAgICAhIW5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcbiAgICAgICAgIW5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKTtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGlmIGluZGV4ZWREQiBpcyBzdXBwb3J0ZWQgYnkgY3VycmVudCBicm93c2VyL3NlcnZpY2Ugd29ya2VyIGNvbnRleHRcbiAqIEByZXR1cm4gdHJ1ZSBpZiBpbmRleGVkREIgaXMgc3VwcG9ydGVkIGJ5IGN1cnJlbnQgYnJvd3Nlci9zZXJ2aWNlIHdvcmtlciBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXhlZERCQXZhaWxhYmxlKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBtZXRob2QgdmFsaWRhdGVzIGJyb3dzZXIvc3cgY29udGV4dCBmb3IgaW5kZXhlZERCIGJ5IG9wZW5pbmcgYSBkdW1teSBpbmRleGVkREIgZGF0YWJhc2UgYW5kIHJlamVjdFxuICogaWYgZXJyb3JzIG9jY3VyIGR1cmluZyB0aGUgZGF0YWJhc2Ugb3BlbiBvcGVyYXRpb24uXG4gKlxuICogQHRocm93cyBleGNlcHRpb24gaWYgY3VycmVudCBicm93c2VyL3N3IGNvbnRleHQgY2FuJ3QgcnVuIGlkYi5vcGVuIChleDogU2FmYXJpIGlmcmFtZSwgRmlyZWZveFxuICogcHJpdmF0ZSBicm93c2luZylcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByZUV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IERCX0NIRUNLX05BTUUgPSAndmFsaWRhdGUtYnJvd3Nlci1jb250ZXh0LWZvci1pbmRleGVkZGItYW5hbHl0aWNzLW1vZHVsZSc7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxuICAgICAgICAgICAgICAgIGlmICghcHJlRXhpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoREJfQ0hFQ0tfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcHJlRXhpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJlamVjdCgoKF9hID0gcmVxdWVzdC5lcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICcnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXG4gKiBAcmV0dXJuIHRydWUgaWYgY29va2llIGlzIGVuYWJsZWQgd2l0aGluIGN1cnJlbnQgYnJvd3NlclxuICovXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5jb29raWVFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgU3RhbmRhcmRpemVkIEZpcmViYXNlIEVycm9yLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgLy8gVHlwZVNjcmlwdCBzdHJpbmcgbGl0ZXJhbHMgZm9yIHR5cGUtc2FmZSBjb2Rlc1xuICogICB0eXBlIEVyciA9XG4gKiAgICAgJ3Vua25vd24nIHxcbiAqICAgICAnb2JqZWN0LW5vdC1mb3VuZCdcbiAqICAgICA7XG4gKlxuICogICAvLyBDbG9zdXJlIGVudW0gZm9yIHR5cGUtc2FmZSBlcnJvciBjb2Rlc1xuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XG4gKiAgIHZhciBFcnIgPSB7XG4gKiAgICAgVU5LTk9XTjogJ3Vua25vd24nLFxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcbiAqICAgfVxuICpcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcbiAqICAgICAnZ2VuZXJpYy1lcnJvcic6IFwiVW5rbm93biBlcnJvclwiLFxuICogICAgICdmaWxlLW5vdC1mb3VuZCc6IFwiQ291bGQgbm90IGZpbmQgZmlsZTogeyRmaWxlfVwiLFxuICogICB9O1xuICpcbiAqICAgLy8gVHlwZS1zYWZlIGZ1bmN0aW9uIC0gbXVzdCBwYXNzIGEgdmFsaWQgZXJyb3IgY29kZSBhcyBwYXJhbS5cbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xuICpcbiAqICAgLi4uXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XG4gKiAgIC4uLlxuICogICB0aHJvdyBlcnJvci5jcmVhdGUoRXJyLkZJTEVfTk9UX0ZPVU5ELCB7J2ZpbGUnOiBmaWxlTmFtZX0pO1xuICogICAuLi5cbiAqICAgLy8gU2VydmljZTogQ291bGQgbm90IGZpbGUgZmlsZTogZm9vLnR4dCAoc2VydmljZS9maWxlLW5vdC1mb3VuZCkuXG4gKlxuICogICBjYXRjaCAoZSkge1xuICogICAgIGFzc2VydChlLm1lc3NhZ2UgPT09IFwiQ291bGQgbm90IGZpbmQgZmlsZTogZm9vLnR4dC5cIik7XG4gKiAgICAgaWYgKChlIGFzIEZpcmViYXNlRXJyb3IpPy5jb2RlID09PSAnc2VydmljZS9maWxlLW5vdC1mb3VuZCcpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xuICogICAgIH1cbiAqICAgfVxuICovXG5jb25zdCBFUlJPUl9OQU1FID0gJ0ZpcmViYXNlRXJyb3InO1xuLy8gQmFzZWQgb24gY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXG5jbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cbiAgICBjb2RlLCBtZXNzYWdlLCBcbiAgICAvKiogQ3VzdG9tIGRhdGEgZm9yIHRoaXMgZXJyb3IuICovXG4gICAgY3VzdG9tRGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgICAgLyoqIFRoZSBjdXN0b20gbmFtZSBmb3IgYWxsIEZpcmViYXNlRXJyb3JzLiAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBFUlJPUl9OQU1FO1xuICAgICAgICAvLyBGaXggRm9yIEVTNVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQtd2lraS9ibG9iL21hc3Rlci9CcmVha2luZy1DaGFuZ2VzLm1kI2V4dGVuZGluZy1idWlsdC1pbnMtbGlrZS1lcnJvci1hcnJheS1hbmQtbWFwLW1heS1uby1sb25nZXItd29ya1xuICAgICAgICAvLyBUT0RPKGRsYXJvY3F1ZSk6IFJlcGxhY2UgdGhpcyB3aXRoIGBuZXcudGFyZ2V0YDogaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItMi5odG1sI3N1cHBvcnQtZm9yLW5ld3RhcmdldFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICB3aGljaCB3ZSBjYW4gbm93IHVzZSBzaW5jZSB3ZSBubyBsb25nZXIgdGFyZ2V0IEVTNS5cbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24uXG4gICAgICAgIC8vIE9ubHkgYXZhaWxhYmxlIG9uIFY4LlxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVycm9yRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVycm9yRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICBjcmVhdGUoY29kZSwgLi4uZGF0YSkge1xuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZnVsbENvZGUgPSBgJHt0aGlzLnNlcnZpY2V9LyR7Y29kZX1gO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuZXJyb3JzW2NvZGVdO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcbiAgICAgICAgLy8gU2VydmljZSBOYW1lOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxuICAgICAgICBjb25zdCBmdWxsTWVzc2FnZSA9IGAke3RoaXMuc2VydmljZU5hbWV9OiAke21lc3NhZ2V9ICgke2Z1bGxDb2RlfSkuYDtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVRlbXBsYXRlKHRlbXBsYXRlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoUEFUVEVSTiwgKF8sIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyBTdHJpbmcodmFsdWUpIDogYDwke2tleX0/PmA7XG4gICAgfSk7XG59XG5jb25zdCBQQVRURVJOID0gL1xce1xcJChbXn1dKyl9L2c7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGNvbnRhaW5pbmcgSlNPTi5cbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxuICovXG5mdW5jdGlvbiBqc29uRXZhbChzdHIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xufVxuLyoqXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IGRhdGEgSmF2YVNjcmlwdCBvYmplY3QgdG8gYmUgc3RyaW5naWZpZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBKU09OIGNvbnRlbnRzIG9mIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gaW50byBjb25zdGl0dWVudCBwYXJ0cy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiB3aXRoIGludmFsaWQgLyBpbmNvbXBsZXRlIGNsYWltcyBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGRlY29kZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0b2tlbi5zcGxpdCgnLicpO1xuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcbiAgICAgICAgY2xhaW1zID0ganNvbkV2YWwoYmFzZTY0RGVjb2RlKHBhcnRzWzFdKSB8fCAnJyk7XG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcnRzWzJdO1xuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XG4gICAgICAgIGRlbGV0ZSBjbGFpbXNbJ2QnXTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcixcbiAgICAgICAgY2xhaW1zLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzaWduYXR1cmVcbiAgICB9O1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAqIHRva2VuIGlzIHdpdGhpbiB0aGUgdGltZSB3aW5kb3cgYXV0aG9yaXplZCBieSB0aGUgJ25iZicgKG5vdC1iZWZvcmUpIGFuZCAnaWF0JyAoaXNzdWVkLWF0KSBjbGFpbXMuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKi9cbmNvbnN0IGlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgbGV0IHZhbGlkU2luY2UgPSAwLCB2YWxpZFVudGlsID0gMDtcbiAgICBpZiAodHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ25iZiddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgICAgIHZhbGlkU2luY2UgPSBjbGFpbXNbJ2lhdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gY2xhaW1zWydleHAnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRva2VuIHdpbGwgZXhwaXJlIGFmdGVyIDI0aCBieSBkZWZhdWx0XG4gICAgICAgICAgICB2YWxpZFVudGlsID0gdmFsaWRTaW5jZSArIDg2NDAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoISFub3cgJiZcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXG4gICAgICAgICEhdmFsaWRVbnRpbCAmJlxuICAgICAgICBub3cgPj0gdmFsaWRTaW5jZSAmJlxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqL1xuY29uc3QgaXNWYWxpZEZvcm1hdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcbiAgICByZXR1cm4gISFjbGFpbXMgJiYgdHlwZW9mIGNsYWltcyA9PT0gJ29iamVjdCcgJiYgY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICovXG5jb25zdCBpc0FkbWluID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBjb250YWlucyhvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuZnVuY3Rpb24gc2FmZUdldChvYmosIGtleSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGZuLmNhbGwoY29udGV4dE9iaiwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBEZWVwIGVxdWFsIHR3byBvYmplY3RzLiBTdXBwb3J0IEFycmF5cyBhbmQgT2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xuICAgICAgICBpZiAoIWJLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYVByb3AgPSBhW2tdO1xuICAgICAgICBjb25zdCBiUHJvcCA9IGJba107XG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbChhUHJvcCwgYlByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFQcm9wICE9PSBiUHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xuICAgICAgICBpZiAoIWFLZXlzLmluY2x1ZGVzKGspKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc09iamVjdCh0aGluZykge1xuICAgIHJldHVybiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZWplY3RzIGlmIHRoZSBnaXZlbiBwcm9taXNlIGRvZXNuJ3QgcmVzb2x2ZSBpbiB0aW1lSW5NUyBtaWxsaXNlY29uZHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvbWlzZVdpdGhUaW1lb3V0KHByb21pc2UsIHRpbWVJbk1TID0gMjAwMCkge1xuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gZGVmZXJyZWRQcm9taXNlLnJlamVjdCgndGltZW91dCEnKSwgdGltZUluTVMpO1xuICAgIHByb21pc2UudGhlbihkZWZlcnJlZFByb21pc2UucmVzb2x2ZSwgZGVmZXJyZWRQcm9taXNlLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxuICogcGFyYW1zIG9iamVjdCAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqIE5vdGU6IFlvdSBtdXN0IHByZXBlbmQgaXQgd2l0aCA/IHdoZW4gYWRkaW5nIGl0IHRvIGEgVVJMLlxuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeXN0cmluZ1BhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goYXJyYXlWYWwgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5sZW5ndGggPyAnJicgKyBwYXJhbXMuam9pbignJicpIDogJyc7XG59XG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0XG4gKiAoZS5nLiB7YXJnOiAndmFsJywgYXJnMjogJ3ZhbDInfSlcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdEZWNvZGUocXVlcnlzdHJpbmcpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KGtleSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59XG4vKipcbiAqIEV4dHJhY3QgdGhlIHF1ZXJ5IHN0cmluZyBwYXJ0IG9mIGEgVVJMLCBpbmNsdWRpbmcgdGhlIGxlYWRpbmcgcXVlc3Rpb24gbWFyayAoaWYgcHJlc2VudCkuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcbiAgICBjb25zdCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICBpZiAoIXF1ZXJ5U3RhcnQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBmcmFnbWVudFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnLCBxdWVyeVN0YXJ0KTtcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cbiAqIFZhcmlhYmxlIG5hbWVzIGZvbGxvdyB0aGUgbm90YXRpb24gaW4gRklQUyBQVUIgMTgwLTM6XG4gKiBodHRwOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZmlwcy9maXBzMTgwLTMvZmlwczE4MC0zX2ZpbmFsLnBkZi5cbiAqXG4gKiBVc2FnZTpcbiAqICAgdmFyIHNoYTEgPSBuZXcgc2hhMSgpO1xuICogICBzaGExLnVwZGF0ZShieXRlcyk7XG4gKiAgIHZhciBoYXNoID0gc2hhMS5kaWdlc3QoKTtcbiAqXG4gKiBQZXJmb3JtYW5jZTpcbiAqICAgQ2hyb21lIDIzOiAgIH40MDAgTWJpdC9zXG4gKiAgIEZpcmVmb3ggMTY6ICB+MjUwIE1iaXQvc1xuICpcbiAqL1xuLyoqXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHByb3BlcnRpZXMgZGVjbGFyZWQgaGVyZSBhcmUgZGlzY3Vzc2VkIGluIHRoZSBhYm92ZSBhbGdvcml0aG0gZG9jdW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICovXG5jbGFzcyBTaGExIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBwcmV2aW91cyB2YWx1ZXMgb2YgYWNjdW11bGF0ZWQgdmFyaWFibGVzIGEtZSBpbiB0aGUgY29tcHJlc3NfXG4gICAgICAgICAqIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFpbl8gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgYnVmZmVyIGhvbGRpbmcgdGhlIHBhcnRpYWxseSBjb21wdXRlZCBoYXNoIHJlc3VsdC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYnVmXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXG4gICAgICAgICAqIGFzIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGluIHRoZSBkb2NzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5XXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcbiAgICAgICAgdGhpcy5wYWRfWzBdID0gMTI4O1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuYmxvY2tTaXplOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAweDY3NDUyMzAxO1xuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XG4gICAgICAgIHRoaXMuY2hhaW5fWzJdID0gMHg5OGJhZGNmZTtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAweDEwMzI1NDc2O1xuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XG4gICAgICAgIHRoaXMuaW5idWZfID0gMDtcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiB0aGUgYmxvY2sgaW4gdGhlIGJ1ZmZlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzXyhidWYsIG9mZnNldCkge1xuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gdGhpcy5XXztcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBXW2ldID1cbiAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZltvZmZzZXQgKyAzXTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleHBhbmQgdG8gODAgd29yZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdCA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgICAgICBXW2ldID0gKCh0IDw8IDEpIHwgKHQgPj4+IDMxKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gdGhpcy5jaGFpbl9bMF07XG4gICAgICAgIGxldCBiID0gdGhpcy5jaGFpbl9bMV07XG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XG4gICAgICAgIGxldCBkID0gdGhpcy5jaGFpbl9bM107XG4gICAgICAgIGxldCBlID0gdGhpcy5jaGFpbl9bNF07XG4gICAgICAgIGxldCBmLCBrO1xuICAgICAgICAvLyBUT0RPKHVzZXIpOiBUcnkgdG8gdW5yb2xsIHRoaXMgbG9vcCB0byBzcGVlZCB1cCB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGQgXiAoYiAmIChjIF4gZCkpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xuICAgICAgICAgICAgICAgICAgICBrID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweGNhNjJjMWQ2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xuICAgIH1cbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xuICAgICAgICAvLyBUT0RPKGpvaG5sZW56KTogdGlnaHRlbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIGFuZCByZW1vdmUgdGhpcyBjaGVja1xuICAgICAgICBpZiAoYnl0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aE1pbnVzQmxvY2sgPSBsZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5idWZfO1xuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcbiAgICAgICAgLy8gVGhlIG91dGVyIHdoaWxlIGxvb3Agc2hvdWxkIGV4ZWN1dGUgYXQgbW9zdCB0d2ljZS5cbiAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxuICAgICAgICAgICAgLy8gaW5wdXQgYnVmZmVyIChhc3N1bWluZyBpdCBjb250YWlucyBzdWZmaWNpZW50IGRhdGEpLiBUaGlzIGdpdmVzIH4yNSVcbiAgICAgICAgICAgIC8vIHNwZWVkdXAgb24gQ2hyb21lIDIzIGFuZCB+MTUlIHNwZWVkdXAgb24gRmlyZWZveCAxNiwgYnV0IHJlcXVpcmVzIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cbiAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDw9IGxlbmd0aE1pbnVzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xuICAgICAgICAgICAgICAgICAgICBuICs9IHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluYnVmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzW25dO1xuICAgICAgICAgICAgICAgICAgICArK2luYnVmO1xuICAgICAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmJ1ZiA9PT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluYnVmXyA9IGluYnVmO1xuICAgICAgICB0aGlzLnRvdGFsXyArPSBsZW5ndGg7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xuICAgICAgICBsZXQgdG90YWxCaXRzID0gdGhpcy50b3RhbF8gKiA4O1xuICAgICAgICAvLyBBZGQgcGFkIDB4ODAgMHgwMCouXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIDU2IC0gdGhpcy5pbmJ1Zl8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCB0aGlzLmJsb2NrU2l6ZSAtICh0aGlzLmluYnVmXyAtIDU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICMgYml0cy5cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuYmxvY2tTaXplIC0gMTsgaSA+PSA1NjsgaS0tKSB7XG4gICAgICAgICAgICB0aGlzLmJ1Zl9baV0gPSB0b3RhbEJpdHMgJiAyNTU7XG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzc18odGhpcy5idWZfKTtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDI0OyBqID49IDA7IGogLT0gOCkge1xuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcbiAgICAgICAgICAgICAgICArK247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2VzdDtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIG1ha2UgYSBTdWJzY3JpYmUgZnVuY3Rpb24gKGp1c3QgbGlrZSBQcm9taXNlIGhlbHBzIG1ha2UgYVxuICogVGhlbmFibGUpLlxuICpcbiAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICogICAgIGFzIGEgcHJveHkuXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN1YnNjcmliZShleGVjdXRvciwgb25Ob09ic2VydmVycykge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG4vKipcbiAqIEltcGxlbWVudCBmYW4tb3V0IGZvciBhbnkgbnVtYmVyIG9mIE9ic2VydmVycyBhdHRhY2hlZCB2aWEgYSBzdWJzY3JpYmVcbiAqIGZ1bmN0aW9uLlxuICovXG5jbGFzcyBPYnNlcnZlclByb3h5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcbiAgICAgKiAgICAgYXMgYSBwcm94eS5cbiAgICAgKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50ID0gMDtcbiAgICAgICAgLy8gTWljcm8tdGFzayBzY2hlZHVsaW5nIGJ5IGNhbGxpbmcgdGFzay50aGVuKCkuXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTm9PYnNlcnZlcnMgPSBvbk5vT2JzZXJ2ZXJzO1xuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcbiAgICAgICAgLy8gc3luY2hyb25vdXNseSBhZnRlciB0aGUgY3JlYXRpb24gb2YgdGhlIHN1YnNjcmliZSBmdW5jdGlvblxuICAgICAgICAvLyBjYW4gc3RpbGwgcmVjZWl2ZSB0aGUgdmVyeSBmaXJzdCB2YWx1ZSBnZW5lcmF0ZWQgaW4gdGhlIGV4ZWN1dG9yLlxuICAgICAgICB0aGlzLnRhc2tcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGV4ZWN1dG9yKHRoaXMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBhbiBPYnNlcnZlciB0byB0aGUgZmFuLW91dCBsaXN0LlxuICAgICAqXG4gICAgICogLSBXZSByZXF1aXJlIHRoYXQgbm8gZXZlbnQgaXMgc2VudCB0byBhIHN1YnNjcmliZXIgc3luY2hyb25vdXNseSB0byB0aGVpclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBsZXQgb2JzZXJ2ZXI7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBlcnJvciA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgT2JzZXJ2ZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAgICAgICAgaWYgKGltcGxlbWVudHNBbnlNZXRob2RzKG5leHRPck9ic2VydmVyLCBbXG4gICAgICAgICAgICAnbmV4dCcsXG4gICAgICAgICAgICAnZXJyb3InLFxuICAgICAgICAgICAgJ2NvbXBsZXRlJ1xuICAgICAgICBdKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRPck9ic2VydmVyLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvciA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHN1YnNjcmliZSB0byBhIHRlcm1pbmF0ZWQgT2JzZXJ2YWJsZSAtIHdlXG4gICAgICAgIC8vIGp1c3QgcmVzcG9uZCB0byB0aGUgT2JzZXJ2ZXIgd2l0aCB0aGUgZmluYWwgZXJyb3Igb3IgY29tcGxldGVcbiAgICAgICAgLy8gZXZlbnQuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB1bnN1YjtcbiAgICB9XG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cbiAgICAvLyBhbnkgdW5zdWJzY3JpYmVkIE9ic2VydmVyLlxuICAgIHVuc3Vic2NyaWJlT25lKGkpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcbiAgICAgICAgdGhpcy5vYnNlcnZlckNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVyQ291bnQgPT09IDAgJiYgdGhpcy5vbk5vT2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWxsIHRoZSBPYnNlcnZlciB2aWEgb25lIG9mIGl0J3MgY2FsbGJhY2sgZnVuY3Rpb24uIFdlIGFyZSBjYXJlZnVsIHRvXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcbiAgICAvLyBmdW5jdGlvbiBoYWQgYmVlbiBxdWV1ZWQuXG4gICAgc2VuZE9uZShpLCBmbikge1xuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmbih0aGlzLm9ic2VydmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBleGNlcHRpb25zIHJhaXNlZCBpbiBPYnNlcnZlcnMgb3IgbWlzc2luZyBtZXRob2RzIG9mIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgdG8gY29uc29sZS4gYi8zMTQwNDgwNlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFR1cm4gc3luY2hyb25vdXMgZnVuY3Rpb24gaW50byBvbmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5LiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZm4oLi4uYXJncyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgb2JqZWN0IHBhc3NlZCBpbiBpbXBsZW1lbnRzIGFueSBvZiB0aGUgbmFtZWQgbWV0aG9kcy5cbiAqL1xuZnVuY3Rpb24gaW1wbGVtZW50c0FueU1ldGhvZHMob2JqLCBtZXRob2RzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQ2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgYXJndW1lbnRzIGFyZSBwcm92aWRlZCBmb3IgYSBwdWJsaWMgZnVuY3Rpb24uXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxuICogQHBhcmFtIGFyZ0NvdW50IFRoZSBhY3R1YWwgbnVtYmVyIG9mIGFyZ3VtZW50cyBwcm92aWRlZC5cbiAqL1xuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcbiAgICBsZXQgYXJnRXJyb3I7XG4gICAgaWYgKGFyZ0NvdW50IDwgbWluQ291bnQpIHtcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdDb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcbiAgICB9XG4gICAgaWYgKGFyZ0Vycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcbiAgICAgICAgICAgICcgZmFpbGVkOiBXYXMgY2FsbGVkIHdpdGggJyArXG4gICAgICAgICAgICBhcmdDb3VudCArXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXG4gICAgICAgICAgICAnIEV4cGVjdHMgJyArXG4gICAgICAgICAgICBhcmdFcnJvciArXG4gICAgICAgICAgICAnLic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgfVxufTtcbi8qKlxuICogR2VuZXJhdGVzIGEgc3RyaW5nIHRvIHByZWZpeCBhbiBlcnJvciBtZXNzYWdlIGFib3V0IGZhaWxlZCBhcmd1bWVudCB2YWxpZGF0aW9uXG4gKlxuICogQHBhcmFtIGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIGFyZ05hbWUgVGhlIG5hbWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGVycm9yUHJlZml4KGZuTmFtZSwgYXJnTmFtZSkge1xuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xufVxuLyoqXG4gKiBAcGFyYW0gZm5OYW1lXG4gKiBAcGFyYW0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSBuYW1lc3BhY2VcbiAqIEBwYXJhbSBvcHRpb25hbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWVzcGFjZShmbk5hbWUsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgJ25hbWVzcGFjZScpICsgJ211c3QgYmUgYSB2YWxpZCBmaXJlYmFzZSBuYW1lc3BhY2UuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDYWxsYmFjayhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuY2FsbGJhY2ssIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE5hbWUpICsgJ211c3QgYmUgYSB2YWxpZCBjb250ZXh0IG9iamVjdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBDb2RlIG9yaWdpbmFsbHkgY2FtZSBmcm9tIGdvb2cuY3J5cHQuc3RyaW5nVG9VdGY4Qnl0ZUFycmF5LCBidXQgZm9yIHNvbWUgcmVhc29uIHRoZXlcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXG4vLyBzbyBpdCdzIGJlZW4gbW9kaWZpZWQuXG4vLyBOb3RlIHRoYXQgbm90IGFsbCBVbmljb2RlIGNoYXJhY3RlcnMgYXBwZWFyIGFzIHNpbmdsZSBjaGFyYWN0ZXJzIGluIEphdmFTY3JpcHQgc3RyaW5ncy5cbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xuLy8gdXNlIDIgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0LiAgQWxsIDQtYnl0ZSBVVEYtOCBjaGFyYWN0ZXJzIGJlZ2luIHdpdGggYSBmaXJzdFxuLy8gY2hhcmFjdGVyIGluIHRoZSByYW5nZSAweEQ4MDAgLSAweERCRkYgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzby1jYWxsZWQgc3Vycm9nYXRlXG4vLyBwYWlyKS5cbi8vIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTUuMS4zXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBsZXQgcCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gSXMgdGhpcyB0aGUgbGVhZCBzdXJyb2dhdGUgaW4gYSBzdXJyb2dhdGUgcGFpcj9cbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xuICAgICAgICAgICAgY29uc3QgbG93ID0gc3RyLmNoYXJDb2RlQXQoaSkgLSAweGRjMDA7IC8vIHRoZSBsb3cgMTAgYml0cy5cbiAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKGhpZ2ggPDwgMTApICsgbG93O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCA2NTUzNikge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICogQ2FsY3VsYXRlIGxlbmd0aCB3aXRob3V0IGFjdHVhbGx5IGNvbnZlcnRpbmc7IHVzZWZ1bCBmb3IgZG9pbmcgY2hlYXBlciB2YWxpZGF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgbGV0IHAgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICAgIHArKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgICAgcCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XG4gICAgICAgICAgICAvLyBMZWFkIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLiAgVGhlIHBhaXIgdG9nZXRoZXIgd2lsbCB0YWtlIDQgYnl0ZXMgdG8gcmVwcmVzZW50LlxuICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgaSsrOyAvLyBza2lwIHRyYWlsIHN1cnJvZ2F0ZS5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gMztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXG4gKiBHZW5lcmF0ZXMgYSBuZXcgdXVpZC5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgdXVpZHY0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cbiAqL1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xuLyoqXG4gKiBUaGUgZmFjdG9yIHRvIGJhY2tvZmYgYnkuXG4gKiBTaG91bGQgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDEuXG4gKi9cbmNvbnN0IERFRkFVTFRfQkFDS09GRl9GQUNUT1IgPSAyO1xuLyoqXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xuICovXG5jb25zdCBNQVhfVkFMVUVfTUlMTElTID0gNCAqIDYwICogNjAgKiAxMDAwOyAvLyBGb3VyIGhvdXJzLCBsaWtlIGlPUyBhbmQgQW5kcm9pZC5cbi8qKlxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cbiAqIFNlZVxuICogaHR0cDovL2dvL3NhZmUtY2xpZW50LWJlaGF2aW9yI3N0ZXAtMS1kZXRlcm1pbmUtdGhlLWFwcHJvcHJpYXRlLXJldHJ5LWludGVydmFsLXRvLWhhbmRsZS1zcGlrZS10cmFmZmljXG4gKiBmb3IgY29udGV4dC5cbiAqXG4gKiA8cD5WaXNpYmxlIGZvciB0ZXN0aW5nXG4gKi9cbmNvbnN0IFJBTkRPTV9GQUNUT1IgPSAwLjU7XG4vKipcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9leHBvbmVudGlhbGJhY2tvZmYuanMuXG4gKiBFeHRyYWN0ZWQgaGVyZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHBhc3MgbWV0YWRhdGEgYW5kIGEgc3RhdGVmdWwgRXhwb25lbnRpYWxCYWNrb2ZmIG9iamVjdCBhcm91bmQuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCBpbnRlcnZhbE1pbGxpcyA9IERFRkFVTFRfSU5URVJWQUxfTUlMTElTLCBiYWNrb2ZmRmFjdG9yID0gREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUikge1xuICAgIC8vIENhbGN1bGF0ZXMgYW4gZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIHZhbHVlLlxuICAgIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxuICAgIC8vIGFuZCBjb3VudCB0byByZXN0b3JlIHN0YXRlLlxuICAgIGNvbnN0IGN1cnJCYXNlVmFsdWUgPSBpbnRlcnZhbE1pbGxpcyAqIE1hdGgucG93KGJhY2tvZmZGYWN0b3IsIGJhY2tvZmZDb3VudCk7XG4gICAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cbiAgICAvLyBEZXZpYXRpb246IHJhbmRvbUZhY3RvciBpcyByZXF1aXJlZC5cbiAgICBjb25zdCByYW5kb21XYWl0ID0gTWF0aC5yb3VuZChcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cbiAgICAvLyBEZXZpYXRpb246IGNoYW5nZXMgbXVsdGlwbGljYXRpb24gb3JkZXIgdG8gaW1wcm92ZSByZWFkYWJpbGl0eS5cbiAgICBSQU5ET01fRkFDVE9SICpcbiAgICAgICAgY3VyckJhc2VWYWx1ZSAqXG4gICAgICAgIC8vIEEgcmFuZG9tIGZsb2F0IChyb3VuZGVkIHRvIGludCBieSBNYXRoLnJvdW5kIGFib3ZlKSBpbiB0aGUgcmFuZ2UgWy0xLCAxXS4gRGV0ZXJtaW5lc1xuICAgICAgICAvLyBpZiB3ZSBhZGQgb3Igc3VidHJhY3QuXG4gICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXG4gICAgICAgIDIpO1xuICAgIC8vIExpbWl0cyBiYWNrb2ZmIHRvIG1heCB0byBhdm9pZCBlZmZlY3RpdmVseSBwZXJtYW5lbnQgYmFja29mZi5cbiAgICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXG4gKi9cbmZ1bmN0aW9uIG9yZGluYWwoaSkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XG4gICAgICAgIHJldHVybiBgJHtpfWA7XG4gICAgfVxuICAgIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xufVxuZnVuY3Rpb24gaW5kaWNhdG9yKGkpIHtcbiAgICBpID0gTWF0aC5hYnMoaSk7XG4gICAgY29uc3QgY2VudCA9IGkgJSAxMDA7XG4gICAgaWYgKGNlbnQgPj0gMTAgJiYgY2VudCA8PSAyMCkge1xuICAgICAgICByZXR1cm4gJ3RoJztcbiAgICB9XG4gICAgY29uc3QgZGVjID0gaSAlIDEwO1xuICAgIGlmIChkZWMgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdzdCc7XG4gICAgfVxuICAgIGlmIChkZWMgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICduZCc7XG4gICAgfVxuICAgIGlmIChkZWMgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdyZCc7XG4gICAgfVxuICAgIHJldHVybiAndGgnO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kdWxhckluc3RhbmNlKHNlcnZpY2UpIHtcbiAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLl9kZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gc2VydmljZS5fZGVsZWdhdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VydmljZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBPdmVycmlkaW5nIHRoZSBjb25zdGFudCAod2Ugc2hvdWxkIGJlIHRoZSBvbmx5IG9uZXMgZG9pbmcgdGhpcylcbkNPTlNUQU5UUy5OT0RFX0NMSUVOVCA9IHRydWU7XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNDbG91ZGZsYXJlV29ya2VyLCBpc0VsZWN0cm9uLCBpc0VtcHR5LCBpc0lFLCBpc0luZGV4ZWREQkF2YWlsYWJsZSwgaXNNb2JpbGVDb3Jkb3ZhLCBpc05vZGUsIGlzTm9kZVNkaywgaXNSZWFjdE5hdGl2ZSwgaXNTYWZhcmksIGlzVVdQLCBpc1ZhbGlkRm9ybWF0LCBpc1ZhbGlkVGltZXN0YW1wLCBpc1dlYldvcmtlciwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@firebase/util/dist/node-esm/index.node.esm.js\n");

/***/ })

};
;